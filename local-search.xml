<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>为什么LOL比赛越来越“假了”.md</title>
    <link href="/2024/09/06/mdstorage/project/%E5%86%99%E4%BD%9C/%E4%B8%BA%E4%BB%80%E4%B9%88LOL%E6%AF%94%E8%B5%9B%E8%B6%8A%E6%9D%A5%E8%B6%8A%E2%80%9C%E5%81%87%E4%BA%86%E2%80%9D/"/>
    <url>/2024/09/06/mdstorage/project/%E5%86%99%E4%BD%9C/%E4%B8%BA%E4%BB%80%E4%B9%88LOL%E6%AF%94%E8%B5%9B%E8%B6%8A%E6%9D%A5%E8%B6%8A%E2%80%9C%E5%81%87%E4%BA%86%E2%80%9D/</url>
    
    <content type="html"><![CDATA[<p>今日话题：为什么LOL比赛越来越“假了”？</p><p>评论一：咱们这LOL比赛啊，现在越来越像电视剧了，剧本都能提前猜到一半。有人说，这不仅仅是一场游戏的竞技，更像是利益角逐的战场。听说有些比赛，背后都被某些利益集团操控了。打假赛？这事儿在电竞圈也不是新鲜事，但每次听到还是让人觉得心里不是滋味。原本纯粹的竞技精神，现在被这些利益玷污了。</p><p>评论二：再说说咱们的选手们，有的实力挺强，但为了迎合团队的战术风格，不得不改变自己的打法。这就像是把老虎的爪子剪了，变成了家猫。有时候看他们在比赛里束手束脚的，真是让人心疼。原本可以大放异彩的个人技术，现在只能被团队战术所局限，这不仅让选手们失去了状态，也让观众们看得不过瘾。</p><p>评论三：而且，这心理素质啊，真是个大问题。有的选手情绪起伏太大，一会儿天上，一会儿地下。比赛中一个小失误就可能导致整个人崩溃。这不只是技术问题，更是心理问题。电竞选手也是人，压力大了，心理上难免会有波动。但这也影响了比赛的质量和观赏性，有时候看着都替他们捏把汗。</p><p>最后，我想说的是，LOL比赛虽然越来越“假”，但这也从侧面反映了电竞行业的种种问题。从利益操控到选手心理素质，这些都是电竞行业需要正视和解决的问题。只有真正解决了这些问题，我们才能看到更纯粹、更高质量的电竞比赛。毕竟，大家都希望看到的是真刀真枪的较量，而不是事先排练好的戏码。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Golang项目管理组员管理.md</title>
    <link href="/2024/09/06/mdstorage/project/sr/Golang%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%BB%84%E5%91%98%E7%AE%A1%E7%90%86/"/>
    <url>/2024/09/06/mdstorage/project/sr/Golang%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%BB%84%E5%91%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>必要性： 所有参与者得到明确的目标，确保所有相关者都对预期结果有共同的理解，提高效率。</p><p>任务、拆分与评估:</p><p>组员的所有任务必须告知组长，由组长或老板授权下发，不然组长不承认其合规。</p><p>小组长向下面管理组员，组长一般只跟小组长沟通</p><p>所有执行的任务必须细分到可以在一个短时间周期（例如，3天内）完成。</p><p>任务的评估应当是一个团队活动（任务相关人员和组长共同评估），确保任何时间随时沟通，每周将在周会中复盘。</p><p>每到一个大型提测时，在拆分任务时预留一个处理bug的子任务并评估时间，以保证交付日期更接近真实，防止紧急任务插入过于频繁</p><p>优先级应该基于业务价值和依赖关系。高业务价值和多依赖的任务应该有较高的优先级。</p><p>优先级需要考虑不同任务间的关系，有前后有联动的应该安排好优先级，有前后依赖需要提前安排时间，尽量做到前置先做，后置后做，避免后置任务组员不好测试，最好是时间重叠，这样方便调试，而且评估工期时应该同时联系其他相关的人员，尽量多维评估工期。</p><p>任务不填开始时间和结束时间，填工时，8小时为一天，因为前期 BUG 和紧急任务都比较多，一旦插入一个则会大量调整排期的时间。</p><p>如有bug优先级高，则通知组长可以暂停已开始的任务来开始处理bug。</p><p>任务执行时必须在禅道维护状态，开始执行了就点击开始任务。</p><p>延期的任务会记录下来，放到周会时讨论。</p><h3 id="组员的流程"><a href="#组员的流程" class="headerlink" title="组员的流程:"></a>组员的流程:</h3><h4 id="需求阶段"><a href="#需求阶段" class="headerlink" title="需求阶段"></a>需求阶段</h4><h5 id="需求接收"><a href="#需求接收" class="headerlink" title="需求接收"></a>需求接收</h5><p>从组长那里接收模块需求，描述需求背景和目标</p><h5 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h5><p>分析流程、功能点、技术实现方案、风险等细节</p><h5 id="需求评审"><a href="#需求评审" class="headerlink" title="需求评审"></a>需求评审</h5><p>对产品经理的需求文档持续分析</p><p>参与产品经理需求评审会议并以技术角度提出、确认问题以免流程中遗漏、冲突等问题和人力、时间等资源问题。</p><h4 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h4><p>任务评估与拆分: <strong>将模块进一步拆分为小任务，进行时间和优先级的评估。</strong></p><p>持续沟通: 在日报会中分享进展和遇到的问题（即使已经解决的问题）。</p><p>任务执行: 根据任务优先级开始执行任务，随时向组长汇报问题。</p><p>紧急任务的处理: 根据组长的通知，调整任务的优先级或延期任务。</p><p>反馈: 在项目的关键时点或结束时，参与回顾会议。</p><h3 id="组长的流程"><a href="#组长的流程" class="headerlink" title="组长的流程:"></a>组长的流程:</h3><p>需求分解与分配: 将项目需求拆分为模块，并分配给小组。</p><p>组长审查: 汇总组员的评估，再次审核。</p><p>任务录入管理工具: 将经过审核的任务录入到禅道。</p><p>组织持续沟通: 确保组员间的沟通，并组织日报和周会，提供稳定时间给组员沟通渠道。</p><p>固定的评审时点: 周会设定评审会议，跟踪项目进度，调整任务优先级。</p><p>处理紧急任务: 在禅道中插入紧急任务，并通知受影响的组员。</p><p>持续监督任务的完整性: 对于预估时间过长的任务，与相关组员沟通拆分。</p><p>组织反馈循环: 在项目结束时，组织回顾会议。</p><h3 id="组员任务主流程图"><a href="#组员任务主流程图" class="headerlink" title="组员任务主流程图"></a>组员任务主流程图</h3><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/image-20231211114518347.png" alt="image-20231211114518347"></p><p>延期：紧急任务、技术难题、人力风险等等造成。</p><p>&gt; 任务下发流程</p><p>1. 项目经理或大组长下发模块任务到禅道</p><p>2. 大组长会通知小组长接任务</p><p>3. 小组长接任务后进行任务分配, 由分配到的人进行任务拆分和工时评估后汇报结果给大组长</p><p>4. 大组长将上面的录入到禅道(可能会重新评估出新任务或工时不一致的情况, 所以组员开始任务时要确认工时)</p><p>5. 组员去 开始任务 完成任务 结束任务</p><h3 id="任务拆分参考"><a href="#任务拆分参考" class="headerlink" title="任务拆分参考"></a>任务拆分参考</h3><p>&gt;&gt; 需求</p><p>构想到需求, 形成需求</p><p>需求评估</p><p>需求评审</p><p>需求开发设计文档</p><p>需求开发</p><p>开发自测</p><p>测试用例评审</p><h2 id="风险项参考"><a href="#风险项参考" class="headerlink" title="风险项参考"></a>风险项参考</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>识别记录风险的目的是为了评估和规避风险，不是要追责，请大家踊跃提出风险。</p><h4 id="需求风险"><a href="#需求风险" class="headerlink" title="需求风险"></a>需求风险</h4><p>需求的频繁变更导致的工作重复。</p><p>不明确或模糊的需求。</p><p>错误或遗漏的需求。</p><h4 id="沟通与协作风险"><a href="#沟通与协作风险" class="headerlink" title="沟通与协作风险:"></a>沟通与协作风险:</h4><p>团队成员间、团队与其他团队、团队与利益相关者之间的沟通障碍。</p><p>对外部团队或组织的依赖导致的沟通障碍。</p><h4 id="技术风险"><a href="#技术风险" class="headerlink" title="技术风险"></a>技术风险</h4><p>采用新技术或工具可能导致的问题。</p><p>与现有系统的集成问题。</p><p>性能、安全性和可靠性问题。</p><h4 id="人员风险"><a href="#人员风险" class="headerlink" title="人员风险:"></a>人员风险:</h4><p>关键人员的离职或长期（&gt;2天）缺席。</p><p>团队成员技能或经验不足。</p><h4 id="时间与资源风险"><a href="#时间与资源风险" class="headerlink" title="时间与资源风险:"></a>时间与资源风险:</h4><p>评估不准确，导致时间不足。</p><p>资源（如开发者或设备）不足或不可用。</p><p>对其他团队或外部组织的依赖导致的延迟。</p><h4 id="质量风险"><a href="#质量风险" class="headerlink" title="质量风险:"></a><del>质量风险:</del></h4><p><del>代码或产品中的缺陷。</del></p><p><del>不足的测试或不恰当的测试策略。</del></p><p><del>缺乏合适的质量保证措施。</del></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>发现问题，根据来源评估优先级，建立任务到禅道</p><h2 id="风险管理-组长关注"><a href="#风险管理-组长关注" class="headerlink" title="风险管理(组长关注)"></a>风险管理(组长关注)</h2><p>&gt;&gt; 识别收集风险</p><p>&gt;&gt; 记录分类风险</p><p>&gt;&gt; 设定优先级|指派处理人</p><p>&gt;&gt; 跟踪进度</p><h2 id="周会"><a href="#周会" class="headerlink" title="周会"></a>周会</h2><h3 id="复盘项"><a href="#复盘项" class="headerlink" title="复盘项"></a>复盘项</h3><p>任务评估回顾，降低延期风险，规整结算目标</p><p>变动的评估项，提高评估能力</p><p>延期任务回顾</p><p>风险项回顾</p><h1 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h1><p>大量任务同时进行，调整排期特别痛苦？作为风险汇报上去</p><p>一个需求版本的周期大概预算？ 作为风险提上去</p><p>模块需求拆分由组长和组员拆分？ 是</p><p>有依赖项的任务怎么办？ 汇报风险</p><h1 id="培训"><a href="#培训" class="headerlink" title="培训"></a>培训</h1><p>禅道使用培训</p>]]></content>
    
    
    
    <tags>
      
      <tag>pm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TLS单向认证和双向认证问题.md</title>
    <link href="/2024/09/06/mdstorage/project/sr/TLS%E5%8D%95%E5%90%91%E8%AE%A4%E8%AF%81%E5%92%8C%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E9%97%AE%E9%A2%98%E8%AE%A8%E8%AE%BA/"/>
    <url>/2024/09/06/mdstorage/project/sr/TLS%E5%8D%95%E5%90%91%E8%AE%A4%E8%AF%81%E5%92%8C%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E9%97%AE%E9%A2%98%E8%AE%A8%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p><strong>2023&#x2F;11&#x2F;20 与技术部王林对话</strong></p><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>商城和总控之间有授权同步等 API 访问，通信机制上使用什么协议实现，https 单向认证还是双向认证？</p><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><ul><li>技术部认为自建 CA 维护成本高</li><li>双向 TLS 认证过重，安全性不需要那么强，因为里面的信息对黑客来说价值并不大</li><li>使用软件的算法进行身份认证等协商工作，而不是证书</li><li>技术部认为在总控软件下面的硬件是受信的</li><li>（有单向认证到双向认证会面临兼容性问题）</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>后续采用 TLS 单向认证即可，商城这边需要总控方面提供什么信息，后面通过软件算法协商即可。</p><h2 id="可能的争议点"><a href="#可能的争议点" class="headerlink" title="可能的争议点"></a>可能的争议点</h2><p>下面结合石犀软件部署场景进行分析。目前总控部署模式为客户本地部署，客户拥有机器 root 权限，并且有绝对的网络优势位置，威胁场景：客户知道如何采用中间人攻击，并想要获取商城与总控通信时的信息。</p><h3 id="问题点"><a href="#问题点" class="headerlink" title="问题点"></a>问题点</h3><ul><li><p>商城提供给总控的 API 是否涉密？</p></li><li><p>商城提供给总控的 API 泄露后是否会导致严重后果？</p></li></ul><h3 id="论点"><a href="#论点" class="headerlink" title="论点"></a>论点</h3><p>TLS 单向认证在石犀软件部署场景下不能抵抗住中间人攻击。而 TLS 双向认证是可以抵抗的。</p><p>TLS 双向认证降级为单向认证实现简单，而单向认证想要升级双向认证不好做兼容。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ol><li><p><strong>TLS 双向认证</strong>：</p><ul><li><p><strong>优势</strong>：</p><ul><li><strong>增强的安全性</strong>：不仅服务器需要提供有效的证书来证明其身份，客户端也需要做同样的事情，从而增加了安全性。</li><li><strong>减少中间人攻击的风险</strong>：因为双方都需要验证身份，这大大降低了中间人攻击的可能性。</li><li><strong>身份确认</strong>：可以确保与预期的客户端进行通信，对于高安全要求的应用尤其重要。</li></ul></li><li><p><strong>劣势</strong>：</p><ul><li><strong>部署复杂</strong>：需要为每个客户端生成和管理证书，这可能会导致部署和维护上的复杂性。</li><li><strong>性能开销</strong>：双向认证可能会带来额外的性能开销，尤其是在高并发环境中。</li><li><strong>管理成本</strong>：证书的续期、撤销和更新可能导致额外的管理成本。</li></ul></li></ul></li><li><p><strong>TLS 单向认证</strong>：</p><ul><li><p><strong>优势</strong>：</p><ul><li><strong>简单易部署</strong>：只需要服务器有证书，客户端不需要，简化了部署过程。</li><li><strong>安全</strong>：客户端可以验证服务器的身份，确保与预期的服务器通信。</li></ul></li><li><p><strong>劣势</strong>：</p><ul><li><strong>安全性较低</strong>：只能验证服务器的身份，无法验证客户端的身份，可能会面临其他安全风险。</li></ul></li></ul></li><li><p><strong>基于 API 密钥的认证</strong>：</p><ul><li><p><strong>优势</strong>：</p><ul><li><strong>部署简单</strong>：通常只需生成一个 API 密钥并在请求中发送。</li><li><strong>跨平台</strong>：API 密钥可以在多种平台和语言中使用，不受特定的协议或库的限制。</li></ul></li><li><p><strong>劣势</strong>：</p><ul><li><strong>较低的安全性</strong>：如果密钥被泄露，任何人都可以使用该密钥。</li><li><strong>无状态验证</strong>：无法验证请求来源的身份，只能验证请求是否包含有效的 API 密钥。</li></ul></li></ul></li><li><p><strong>基于 token 的认证（如 JWT）</strong>：</p><ul><li><p><strong>优势</strong>：</p><ul><li><strong>状态无关</strong>：服务器不需要存储任何关于客户端的会话信息。</li><li><strong>灵活性</strong>：Token 可以包含多种信息，并且可以轻松地跨多个服务进行验证。</li></ul></li><li><p><strong>劣势</strong>：</p><ul><li><strong>安全风险</strong>：如果 Token 被截获，攻击者可以冒充用户。</li><li><strong>生命周期管理</strong>：需要一个机制来撤销或刷新 Token。</li></ul></li></ul></li></ol><h3 id="TLS-单向认证威胁模型"><a href="#TLS-单向认证威胁模型" class="headerlink" title="TLS 单向认证威胁模型"></a>TLS 单向认证威胁模型</h3><h4 id="重点-1"><a href="#重点-1" class="headerlink" title="重点"></a>重点</h4><p>TLS 单向认证主要威胁来自于一个假设，客户拿到了其中一台总控，并试图采用中间人攻击思路来对 商城给总控提供的 API。</p><h4 id="攻击步骤"><a href="#攻击步骤" class="headerlink" title="攻击步骤"></a>攻击步骤</h4><ol><li><p>在拥有客户端主机的 root 权限的情况下，黑客可以部署特定的应用程序来拦截客户端和服务器之间的通信，并伪装成服务端与客户端建立连接。</p><h3 id="步骤-1-拦截网络流量"><a href="#步骤-1-拦截网络流量" class="headerlink" title="步骤 1: 拦截网络流量"></a>步骤 1: 拦截网络流量</h3><ol><li><strong>安装网络监控工具</strong>：使用像 Wireshark Tcpdump 这样的网络监控工具来捕获和分析经过该主机的网络流量。</li><li><strong>配置端口镜像</strong>：如果可能，配置网络设备进行端口镜像（也称为 SPAN），将目标服务器的流量复制到监控的端口。</li></ol><h3 id="步骤-2-伪装成服务器"><a href="#步骤-2-伪装成服务器" class="headerlink" title="步骤 2: 伪装成服务器"></a>步骤 2: 伪装成服务器</h3><ol><li><strong>DNS 欺骗</strong>：通过修改本地 DNS 设置或使用像 DNSChef 这样的工具，将目标服务器的域名解析到一个由黑客控制的 IP 地址上。</li><li><strong>建立伪造服务器</strong>：使用像 Apache、Nginx 或自定义服务器软件，在黑客控制的机器上设置一个伪造的服务器。</li></ol><h3 id="步骤-3-中间人攻击"><a href="#步骤-3-中间人攻击" class="headerlink" title="步骤 3: 中间人攻击"></a>步骤 3: 中间人攻击</h3><ol><li><strong>TLS 拦截代理</strong>：设置一个 TLS 拦截代理（如 mitmproxy），用于解密和重新加密传输的数据。</li><li><strong>生成和使用证书</strong>：使用自签名证书或通过某种方式获取的合法证书来伪装成目标服务器。</li><li><strong>转发请求</strong>：接收来自客户端的请求，解密数据，可以选择性地修改，然后将其加密并转发到真正的服务器。</li></ol><h3 id="步骤-4-伪装和响应客户端"><a href="#步骤-4-伪装和响应客户端" class="headerlink" title="步骤 4: 伪装和响应客户端"></a>步骤 4: 伪装和响应客户端</h3><ol><li><strong>接收服务器响应</strong>：接收来自服务器的响应，解密数据。</li><li><strong>响应客户端</strong>：将响应数据加密并发送回客户端。客户端会认为数据是直接来自目标服务器。</li></ol><h3 id="步骤-5-维护连接"><a href="#步骤-5-维护连接" class="headerlink" title="步骤 5: 维护连接"></a>步骤 5: 维护连接</h3><ol><li><strong>会话管理</strong>：维护与客户端和服务器的会话状态，确保持续的通信。</li><li><strong>数据记录</strong>：可选地记录经过的数据，以供后续分析。</li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>security</tag>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TLS双向认证.md</title>
    <link href="/2024/09/06/mdstorage/domain/network/%E5%8D%8F%E8%AE%AE/TLS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/"/>
    <url>/2024/09/06/mdstorage/domain/network/%E5%8D%8F%E8%AE%AE/TLS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h2 id="基于-HTTP-认证机制"><a href="#基于-HTTP-认证机制" class="headerlink" title="基于 HTTP 认证机制"></a>基于 HTTP 认证机制</h2><ol><li><p><strong>TLS 双向认证</strong>：</p><ul><li><p><strong>优势</strong>：</p><ul><li><strong>增强的安全性</strong>：不仅服务器需要提供有效的证书来证明其身份，客户端也需要做同样的事情，从而增加了安全性。</li><li><strong>减少中间人攻击的风险</strong>：因为双方都需要验证身份，这大大降低了中间人攻击的可能性。</li><li><strong>身份确认</strong>：可以确保与预期的客户端进行通信，对于高安全要求的应用尤其重要。</li></ul></li><li><p><strong>劣势</strong>：</p><ul><li><strong>部署复杂</strong>：需要为每个客户端生成和管理证书，这可能会导致部署和维护上的复杂性。</li><li><strong>性能开销</strong>：双向认证可能会带来额外的性能开销，尤其是在高并发环境中。</li><li><strong>管理成本</strong>：证书的续期、撤销和更新可能导致额外的管理成本。</li></ul></li></ul></li><li><p><strong>TLS 单向认证</strong>：</p><ul><li><p><strong>优势</strong>：</p><ul><li><strong>简单易部署</strong>：只需要服务器有证书，客户端不需要，简化了部署过程。</li><li><strong>安全</strong>：客户端可以验证服务器的身份，确保与预期的服务器通信。</li></ul></li><li><p><strong>劣势</strong>：</p><ul><li><strong>安全性较低</strong>：只能验证服务器的身份，无法验证客户端的身份，可能会面临其他安全风险。</li></ul></li></ul></li><li><p><strong>基于 API 密钥的认证</strong>：</p><ul><li><p><strong>优势</strong>：</p><ul><li><strong>部署简单</strong>：通常只需生成一个 API 密钥并在请求中发送。</li><li><strong>跨平台</strong>：API 密钥可以在多种平台和语言中使用，不受特定的协议或库的限制。</li></ul></li><li><p><strong>劣势</strong>：</p><ul><li><strong>较低的安全性</strong>：如果密钥被泄露，任何人都可以使用该密钥。</li><li><strong>无状态验证</strong>：无法验证请求来源的身份，只能验证请求是否包含有效的 API 密钥。</li></ul></li></ul></li><li><p><strong>基于 token 的认证（如 JWT）</strong>：</p><ul><li><p><strong>优势</strong>：</p><ul><li><strong>状态无关</strong>：服务器不需要存储任何关于客户端的会话信息。</li><li><strong>灵活性</strong>：Token 可以包含多种信息，并且可以轻松地跨多个服务进行验证。</li></ul></li><li><p><strong>劣势</strong>：</p><ul><li><strong>安全风险</strong>：如果 Token 被截获，攻击者可以冒充用户。</li><li><strong>生命周期管理</strong>：需要一个机制来撤销或刷新 Token。</li></ul></li></ul></li></ol><h2 id="TLS-单向认证威胁场景"><a href="#TLS-单向认证威胁场景" class="headerlink" title="TLS 单向认证威胁场景"></a>TLS 单向认证威胁场景</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>黑客已经攻破操作系统或本身拥有系统的高权限，并拥有网络优势位置，可以拦截客户端的出入网络。这种情况可以进行中间人攻击破解单向认证加密的信息。</p><h3 id="攻击步骤"><a href="#攻击步骤" class="headerlink" title="攻击步骤"></a>攻击步骤</h3><p>在拥有客户端主机的 root 权限的情况下，黑客可以部署特定的应用程序来拦截客户端和服务器之间的通信，并伪装成服务端与客户端建立连接。</p><h4 id="步骤-1-拦截网络流量"><a href="#步骤-1-拦截网络流量" class="headerlink" title="步骤 1: 拦截网络流量"></a>步骤 1: 拦截网络流量</h4><ol><li><strong>安装网络监控工具</strong>：使用像 Wireshark Tcpdump 这样的网络监控工具来捕获和分析经过该主机的网络流量。</li><li><strong>配置端口镜像</strong>：如果可能，配置网络设备进行端口镜像（也称为 SPAN），将目标服务器的流量复制到监控的端口。</li></ol><h4 id="步骤-2-伪装成服务器"><a href="#步骤-2-伪装成服务器" class="headerlink" title="步骤 2: 伪装成服务器"></a>步骤 2: 伪装成服务器</h4><ol><li><strong>DNS 欺骗</strong>：通过修改本地 DNS 设置或使用像 DNSChef 这样的工具，将目标服务器的域名解析到一个由黑客控制的 IP 地址上。</li><li><strong>建立伪造服务器</strong>：使用像 Apache、Nginx 或自定义服务器软件，在黑客控制的机器上设置一个伪造的服务器。</li></ol><h4 id="步骤-3-中间人攻击"><a href="#步骤-3-中间人攻击" class="headerlink" title="步骤 3: 中间人攻击"></a>步骤 3: 中间人攻击</h4><ol><li><strong>TLS 拦截代理</strong>：设置一个 TLS 拦截代理（如 mitmproxy），用于解密和重新加密传输的数据。</li><li><strong>生成和使用证书</strong>：使用自签名证书或通过某种方式获取的合法证书来伪装成目标服务器。</li><li><strong>转发请求</strong>：接收来自客户端的请求，解密数据，可以选择性地修改，然后将其加密并转发到真正的服务器。</li></ol><h4 id="步骤-4-伪装和响应客户端"><a href="#步骤-4-伪装和响应客户端" class="headerlink" title="步骤 4: 伪装和响应客户端"></a>步骤 4: 伪装和响应客户端</h4><ol><li><strong>接收服务器响应</strong>：接收来自服务器的响应，解密数据。</li><li><strong>响应客户端</strong>：将响应数据加密并发送回客户端。客户端会认为数据是直接来自目标服务器。</li></ol><h4 id="步骤-5-维护连接"><a href="#步骤-5-维护连接" class="headerlink" title="步骤 5: 维护连接"></a>步骤 5: 维护连接</h4><ol><li><strong>会话管理</strong>：维护与客户端和服务器的会话状态，确保持续的通信。</li><li><strong>数据记录</strong>：可选地记录经过的数据，以供后续分析。</li></ol><h2 id="双向认证对比单向认证的优势"><a href="#双向认证对比单向认证的优势" class="headerlink" title="双向认证对比单向认证的优势"></a>双向认证对比单向认证的优势</h2><p>双向TLS认证（也称为双向SSL或客户端认证）与单向TLS认证相比具有明显的优势，特别是在防御中间人攻击和减轻应用层面认证负担方面。以下是这两个方面的详细分析：</p><h3 id="1-防御中间人攻击"><a href="#1-防御中间人攻击" class="headerlink" title="1. 防御中间人攻击"></a>1. 防御中间人攻击</h3><h4 id="单向认证的局限性"><a href="#单向认证的局限性" class="headerlink" title="单向认证的局限性"></a>单向认证的局限性</h4><ul><li>在单向TLS认证中，只有服务器呈现证书并被客户端验证。客户端本身不提供证书，因此服务器无法验证客户端的身份。</li><li>这种情况下，一个中间人（MITM）可以在客户端和服务器之间建立两个单独的TLS连接。中间人可以与服务器建立一个合法的TLS连接，同时与客户端建立另一个TLS连接，客户端并不知道它实际上是在与中间人通信。</li></ul><h4 id="双向认证的优势"><a href="#双向认证的优势" class="headerlink" title="双向认证的优势"></a>双向认证的优势</h4><ul><li>在双向TLS认证中，客户端也需要提供证书，服务器会验证这个证书。这意味着服务器可以确认它正在直接与合法的客户端通信。</li><li>由于中间人不太可能同时拥有合法的服务器证书和客户端证书，因此双向认证可以有效防止中间人攻击。任何试图插入的中间人都会在认证过程中被发现，因为他们无法同时提供有效的服务器和客户端证书。</li></ul><h3 id="2-减少应用层面认证负担"><a href="#2-减少应用层面认证负担" class="headerlink" title="2. 减少应用层面认证负担"></a>2. 减少应用层面认证负担</h3><h4 id="单向认证的应用层负担"><a href="#单向认证的应用层负担" class="headerlink" title="单向认证的应用层负担"></a>单向认证的应用层负担</h4><ul><li>在只有单向TLS认证的情况下，服务器必须依赖于应用层面的认证机制（如用户名和密码、令牌等）来验证客户端的身份。</li><li>这不仅增加了开发和维护的复杂性，还可能导致安全风险，尤其是在处理凭据管理和存储时。</li></ul><h4 id="双向认证的减负优势"><a href="#双向认证的减负优势" class="headerlink" title="双向认证的减负优势"></a>双向认证的减负优势</h4><ul><li>双向TLS认证通过在传输层提供严格的认证机制，减轻了应用层的认证负担。一旦TLS层确认了客户端的身份，应用层就可以对这一事实有信心，不需要额外的身份验证步骤。</li><li>这种方法减少了在应用层处理和存储敏感认证信息的需要，降低了由于应用层漏洞导致的身份验证信息泄露的风险。</li><li>双向认证提供了更细粒度的访问控制，因为每个客户端证书都可以单独管理和审计。这对于高安全性要求的环境（如金融服务、政府通信等）尤为重要。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>双向TLS认证相比于单向认证，在防御中间人攻击和减轻应用层认证负担方面提供了显著优势。它通过在传输层提供更严格的认证机制，增强了整体通信的安全性，同时降低了应用层面对复杂和潜在不安全的认证机制的依赖。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>network</category>
      
      <category>协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>security</tag>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bash变量处理.md</title>
    <link href="/2024/09/06/mdstorage/domain/linux/bash%E5%8F%98%E9%87%8F%E5%A4%84%E7%90%86/"/>
    <url>/2024/09/06/mdstorage/domain/linux/bash%E5%8F%98%E9%87%8F%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Bash-变量分割处理成数组"><a href="#Bash-变量分割处理成数组" class="headerlink" title="Bash 变量分割处理成数组"></a>Bash 变量分割处理成数组</h2><p>在这篇文章中，我们将探讨在 Bash 中使用数组、<code>IFS</code> 变量的作用以及如何通过 <code>read</code> 命令来分割字符串并存入数组。这些知识对于处理复杂的字符串输入和数组操作非常有用。</p><h3 id="1-IFS（Internal-Field-Separator）"><a href="#1-IFS（Internal-Field-Separator）" class="headerlink" title="1. IFS（Internal Field Separator）"></a>1. <code>IFS</code>（Internal Field Separator）</h3><p><code>IFS</code> 是 Bash 中的内部字段分隔符，它决定了在处理字符串时，如何将字符串拆分成字段。默认情况下，<code>IFS</code> 包含空格、制表符和换行符。</p><h4 id="修改-IFS"><a href="#修改-IFS" class="headerlink" title="修改 IFS"></a>修改 <code>IFS</code></h4><p>我们可以通过更改 <code>IFS</code> 来自定义分隔符。比如我们希望使用逗号（<code>,</code>）作为分隔符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">IFS=<span class="hljs-string">&#x27;,&#x27;</span><br></code></pre></td></tr></table></figure><p>这告诉 Bash 在处理输入时，使用逗号作为字段分隔符。</p><h3 id="2-使用-read-读取并分割字符串"><a href="#2-使用-read-读取并分割字符串" class="headerlink" title="2. 使用 read 读取并分割字符串"></a>2. 使用 <code>read</code> 读取并分割字符串</h3><p><code>read</code> 命令用于从标准输入读取数据。在与 <code>IFS</code> 结合时，它可以根据指定的分隔符将字符串拆分为多个字段并存储在变量中。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">IFS=<span class="hljs-string">&#x27;,&#x27;</span> <span class="hljs-built_in">read</span> -r -a my_array &lt;&lt;&lt; <span class="hljs-string">&quot;192.168.1.1,192.168.1.2,192.168.1.3&quot;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，字符串 <code>&quot;192.168.1.1,192.168.1.2,192.168.1.3&quot;</code> 被 <code>IFS=&#39;,&#39;</code> 分割为三个部分，并存储在数组 <code>my_array</code> 中。</p><h4 id="read-命令的选项"><a href="#read-命令的选项" class="headerlink" title="read 命令的选项"></a><code>read</code> 命令的选项</h4><ul><li><code>-r</code>：表示禁止反斜杠转义。如果不加 <code>-r</code>，反斜杠会被解释为转义字符。</li><li><code>-a</code>：表示将读取的数据作为数组存储。</li></ul><h3 id="3-数组的引用"><a href="#3-数组的引用" class="headerlink" title="3. 数组的引用"></a>3. 数组的引用</h3><p>在 Bash 中，数组的元素通过 <code>$&#123;array_name[index]&#125;</code> 进行访问。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;my_array[0]&#125;</span>  <span class="hljs-comment"># 输出: 192.168.1.1</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;my_array[1]&#125;</span>  <span class="hljs-comment"># 输出: 192.168.1.2</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;my_array[2]&#125;</span>  <span class="hljs-comment"># 输出: 192.168.1.3</span><br></code></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>当你直接使用 <code>echo $array_name</code> 来引用数组时，Bash 只会输出数组的第一个元素。这是因为 Bash 默认情况下只处理单个标量变量。如果你想要打印整个数组，应该使用 <code>$&#123;array_name[@]&#125;</code> 或 <code>$&#123;array_name[*]&#125;</code>。</p><h4 id="打印整个数组"><a href="#打印整个数组" class="headerlink" title="打印整个数组"></a>打印整个数组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;my_array[@]&#125;</span>  <span class="hljs-comment"># 输出: 192.168.1.1 192.168.1.2 192.168.1.3</span><br></code></pre></td></tr></table></figure><p>你还可以使用 <code>for</code> 循环来遍历数组并逐个输出元素：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> ip <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;my_array[@]&#125;</span>&quot;</span>; <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$ip</span>&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h3 id="4-Here-String-重定向"><a href="#4-Here-String-重定向" class="headerlink" title="4. Here String 重定向"></a>4. <code>Here String</code> 重定向</h3><p><code>&lt;&lt;&lt;</code> 是 Bash 中的 <strong>Here String</strong> 重定向符号，它可以将字符串作为标准输入传递给命令。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> &lt;&lt;&lt; <span class="hljs-string">&quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure><p>相当于将 <code>&quot;Hello World&quot;</code> 作为输入传递给 <code>cat</code>，然后 <code>cat</code> 将其输出。</p><p>在我们的数组操作中，使用 <code>&lt;&lt;&lt;</code> 来将 <code>ClusterMasterIPLs</code> 变量的值传递给 <code>read</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">IFS=<span class="hljs-string">&#x27;,&#x27;</span> <span class="hljs-built_in">read</span> -r -a cluster_master_ip &lt;&lt;&lt; <span class="hljs-variable">$&#123;ClusterMasterIPLs&#125;</span><br></code></pre></td></tr></table></figure><h3 id="5-实例：通过-IFS-和-read-处理-IP-列表"><a href="#5-实例：通过-IFS-和-read-处理-IP-列表" class="headerlink" title="5. 实例：通过 IFS 和 read 处理 IP 列表"></a>5. 实例：通过 <code>IFS</code> 和 <code>read</code> 处理 IP 列表</h3><p>假设我们有一个包含多个 IP 地址的字符串，这些 IP 地址由逗号分隔。我们想要将这些 IP 地址存入一个数组并逐个处理。可以通过以下代码实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">ClusterMasterIPLs=<span class="hljs-string">&quot;192.168.1.1,192.168.1.2,192.168.1.3&quot;</span><br>IFS=<span class="hljs-string">&#x27;,&#x27;</span> <span class="hljs-built_in">read</span> -r -a cluster_master_ip &lt;&lt;&lt; <span class="hljs-variable">$&#123;ClusterMasterIPLs&#125;</span><br><br><span class="hljs-comment"># 打印第一个元素</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;cluster_master_ip[0]&#125;</span>  <span class="hljs-comment"># 输出: 192.168.1.1</span><br><br><span class="hljs-comment"># 打印整个数组</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;cluster_master_ip[@]&#125;</span>  <span class="hljs-comment"># 输出: 192.168.1.1 192.168.1.2 192.168.1.3</span><br><br><span class="hljs-comment"># 遍历数组</span><br><span class="hljs-keyword">for</span> ip <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;cluster_master_ip[@]&#125;</span>&quot;</span>; <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$ip</span>&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h4 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h4><ul><li>**<code>IFS</code>**：内部字段分隔符，用于定义如何分割字符串。</li><li>**<code>read -a</code>**：将输入拆分为数组。</li><li>**<code>&lt;&lt;&lt;</code>**：将字符串传递给命令的 Here String 重定向。</li><li><strong>数组引用</strong>：<code>$&#123;array[@]&#125;</code> 用于引用整个数组，而 <code>$&#123;array[index]&#125;</code> 引用特定的数组元素。</li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>管道和重定向.md</title>
    <link href="/2024/09/06/mdstorage/domain/linux/%E7%AE%A1%E9%81%93%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <url>/2024/09/06/mdstorage/domain/linux/%E7%AE%A1%E9%81%93%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    
    <content type="html"><![CDATA[<h1 id="使用"><a href="#使用" class="headerlink" title="使用 &lt;&lt;&lt;（Here String）重定向的条件解析"></a>使用 <code>&lt;&lt;&lt;</code>（Here String）重定向的条件解析</h1><p>在 Bash 中，<code>&lt;&lt;&lt;</code> 是一种 <strong>Here String</strong> 重定向操作符，用于将字符串作为标准输入传递给命令。在某些情况下，<code>&lt;&lt;&lt;</code> 是处理字符串数据时的简洁方式，但并非所有命令都支持这种用法。本篇文章将详细解析哪些命令能够接受 <code>&lt;&lt;&lt;</code> 形式的重定向以及它的适用场景。</p><h2 id="1"><a href="#1" class="headerlink" title="1. &lt;&lt;&lt;（Here String）的简介"></a>1. <code>&lt;&lt;&lt;</code>（Here String）的简介</h2><p><code>&lt;&lt;&lt;</code> 是 Bash 中的一种重定向符号，用来将一个字符串作为标准输入传递给命令。它的基本语法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span> &lt;&lt;&lt; <span class="hljs-string">&quot;your string&quot;</span><br></code></pre></td></tr></table></figure><p>与 <code>&lt;&lt;</code>（Here Document）不同，<code>&lt;&lt;&lt;</code> 只传递单行字符串作为标准输入，而 <code>&lt;&lt;</code> 通常用于传递多行输入。</p><h2 id="2-什么样的命令可以使用"><a href="#2-什么样的命令可以使用" class="headerlink" title="2. 什么样的命令可以使用 &lt;&lt;&lt;"></a>2. 什么样的命令可以使用 <code>&lt;&lt;&lt;</code></h2><p>只有那些<strong>支持从标准输入读取数据</strong>的命令才能使用 <code>&lt;&lt;&lt;</code> 来传递输入。这些命令通常能够处理管道 (<code>|</code>) 或直接读取标准输入 (<code>stdin</code>) 的数据。</p><h3 id="常见支持"><a href="#常见支持" class="headerlink" title="常见支持 &lt;&lt;&lt; 的命令"></a>常见支持 <code>&lt;&lt;&lt;</code> 的命令</h3><ul><li><p>**<code>cat</code>**：读取并显示标准输入的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> &lt;&lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">Hello,</span> World!<br></code></pre></td></tr></table></figure></li><li><p>**<code>grep</code>**：从标准输入中搜索特定的模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep <span class="hljs-string">&quot;test&quot;</span> &lt;&lt;&lt; <span class="hljs-string">&quot;This is a test&quot;</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">This <span class="hljs-keyword">is</span> a test<br></code></pre></td></tr></table></figure></li><li><p>**<code>awk</code>**：文本处理工具，可以从标准输入中读取数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> &lt;&lt;&lt; <span class="hljs-string">&quot;Hello Bash&quot;</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Hello</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>sed</code>**：流编辑器，可以从标准输入中进行文本替换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed <span class="hljs-string">&#x27;s/Bash/World/&#x27;</span> &lt;&lt;&lt; <span class="hljs-string">&quot;Hello Bash&quot;</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Hello World</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>sort</code>**：对标准输入的内容进行排序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sort</span> &lt;&lt;&lt; <span class="hljs-string">&quot;banana apple orange&quot;</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">apple</span><br><span class="hljs-attribute">banana</span><br><span class="hljs-attribute">orange</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>read</code>**：从标准输入中读取内容并赋值给变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">read</span> var &lt;&lt;&lt; <span class="hljs-string">&quot;Hello World&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$var</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Hello World</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="3-什么样的命令不支持"><a href="#3-什么样的命令不支持" class="headerlink" title="3. 什么样的命令不支持 &lt;&lt;&lt;"></a>3. 什么样的命令不支持 <code>&lt;&lt;&lt;</code></h2><p>并非所有命令都能够处理 <code>&lt;&lt;&lt;</code> 形式的重定向。以下是一些不能使用 <code>&lt;&lt;&lt;</code> 重定向的场景。</p><h3 id="1-只能处理文件的命令"><a href="#1-只能处理文件的命令" class="headerlink" title="1. 只能处理文件的命令"></a>1. 只能处理文件的命令</h3><p>某些命令只能操作文件，它们不接受标准输入，因此无法使用 <code>&lt;&lt;&lt;</code>。</p><ul><li><p>**<code>cp</code>**：只能复制文件，不能从标准输入中读取数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> &lt;&lt;&lt; <span class="hljs-string">&quot;data&quot;</span> /some/destination  <span class="hljs-comment"># 会导致错误</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>mv</code>**：只能移动文件，不支持从标准输入获取输入。</p></li><li><p>**<code>rm</code>**：只能删除文件，无法处理标准输入。</p></li></ul><h3 id="2-需要交互式输入的命令"><a href="#2-需要交互式输入的命令" class="headerlink" title="2. 需要交互式输入的命令"></a>2. 需要交互式输入的命令</h3><p>交互式命令（如文本编辑器）不能使用 <code>&lt;&lt;&lt;</code>，因为它们依赖用户输入进行操作。</p><ul><li><p><strong><code>vim</code></strong> 或 **<code>nano</code>**：这些编辑器需要用户手动操作，而不能通过标准输入提供数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim &lt;&lt;&lt; <span class="hljs-string">&quot;Hello&quot;</span>  <span class="hljs-comment"># 不会工作</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-强制要求文件路径作为输入的命令"><a href="#3-强制要求文件路径作为输入的命令" class="headerlink" title="3. 强制要求文件路径作为输入的命令"></a>3. 强制要求文件路径作为输入的命令</h3><p>一些命令强制要求文件路径作为参数，不能通过标准输入传递信息。</p><ul><li>**<code>ls</code>**：用于列出目录内容，不能从标准输入读取目录名称。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> &lt;&lt;&lt; <span class="hljs-string">&quot;some_directory&quot;</span>  <span class="hljs-comment"># 会导致错误</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="4-管道-vs"><a href="#4-管道-vs" class="headerlink" title="4. 管道 vs. &lt;&lt;&lt; 重定向"></a>4. 管道 vs. <code>&lt;&lt;&lt;</code> 重定向</h2><p><code>&lt;&lt;&lt;</code> 通常适用于传递单行字符串作为标准输入，而管道 (<code>|</code>) 则用于将一个命令的输出作为另一个命令的输入。如果你需要处理更复杂的输入或者是多行输出，管道更为合适。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is a test&quot;</span> | grep <span class="hljs-string">&quot;test&quot;</span><br></code></pre></td></tr></table></figure><p>与：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep <span class="hljs-string">&quot;test&quot;</span> &lt;&lt;&lt; <span class="hljs-string">&quot;This is a test&quot;</span><br></code></pre></td></tr></table></figure><p>结果是相同的，但使用场景不同。</p><h2 id="5"><a href="#5" class="headerlink" title="5. &lt;&lt;&lt; 的适用场景"></a>5. <code>&lt;&lt;&lt;</code> 的适用场景</h2><ul><li><strong>简化单行输入</strong>：当你有一个简单的单行字符串需要作为输入时，使用 <code>&lt;&lt;&lt;</code> 非常方便。</li><li><strong>快速调试</strong>：<code>&lt;&lt;&lt;</code> 可以快速将字符串传递给命令，便于调试和测试脚本。</li><li>**结合 <code>read</code>**：特别适合与 <code>read</code> 一起使用，轻松将字符串内容赋值给变量。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">IFS=<span class="hljs-string">&#x27;,&#x27;</span> <span class="hljs-built_in">read</span> -r -a array &lt;&lt;&lt; <span class="hljs-string">&quot;one,two,three&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array[@]&#125;</span><br><span class="hljs-comment"># 输出: one two three</span><br></code></pre></td></tr></table></figure><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>能够接受 <code>&lt;&lt;&lt;</code>（Here String）形式重定向的命令需要具备以下条件：</p><ol><li><strong>支持从标准输入读取数据</strong>：工具必须允许从 <code>stdin</code> 中读取数据，而不是只能接受文件路径作为参数。</li><li><strong>不是交互式工具</strong>：诸如 <code>vim</code>、<code>nano</code> 这类交互式工具无法使用 <code>&lt;&lt;&lt;</code> 来进行输入。</li><li><strong>适合单行输入的场景</strong>：<code>&lt;&lt;&lt;</code> 最适合单行字符串传递给命令，而对于多行数据或文件流，管道或文件重定向更合适。</li></ol>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NAS访问.md</title>
    <link href="/2024/09/06/mdstorage/resource/asset/NAS%E8%AE%BF%E9%97%AE/"/>
    <url>/2024/09/06/mdstorage/resource/asset/NAS%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="ssh访问"><a href="#ssh访问" class="headerlink" title="ssh访问"></a>ssh访问</h2><h3 id="先用普通账户登陆"><a href="#先用普通账户登陆" class="headerlink" title="先用普通账户登陆"></a>先用普通账户登陆</h3><p><code>xiaoy/$faker.</code></p><h3 id="切换root"><a href="#切换root" class="headerlink" title="切换root"></a>切换root</h3><p><code>root/$faker.</code></p>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>asset</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>API未授权风险自动化检测思路.md</title>
    <link href="/2024/09/04/mdstorage/API%E6%9C%AA%E6%8E%88%E6%9D%83%E9%A3%8E%E9%99%A9%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A3%80%E6%B5%8B%E6%80%9D%E8%B7%AF/"/>
    <url>/2024/09/04/mdstorage/API%E6%9C%AA%E6%8E%88%E6%9D%83%E9%A3%8E%E9%99%A9%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A3%80%E6%B5%8B%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>readme</title>
    <link href="/2024/09/04/mdstorage/readme/"/>
    <url>/2024/09/04/mdstorage/readme/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>mdstorage 储存了一系列以 markdown 格式为主的文档, 想要用于分享知识和方便查阅</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>make gp-deploy 完成对 hexo-test 的部署</p>]]></content>
    
    
    
    <tags>
      
      <tag>readme</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>proto-store项目概述.md</title>
    <link href="/2024/09/04/mdstorage/proto-store%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/09/04/mdstorage/proto-store%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>此仓库是总控、引擎、插件系统中多个组件共同使用的中央协议定义库，在<code>proto-store</code>项目中，我们组织软件模块、包和子系统，以促进高效的开发流程和代码的可维护性。项目主要使用Go语言开发，采用清晰、模块化的方式组织代码，以支持多组件间的 gRPC 通信。</p><h3 id="主要职能"><a href="#主要职能" class="headerlink" title="主要职能"></a>主要职能</h3><p>项目分为几个主要模块，包括gRPC接口定义、服务实现和工具类。</p><h2 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h2><p>项目包含一个<code>README.md</code>文件，其中详细描述了如何设置开发环境，包括安装Go语言环境、gRPC 工具和其他依赖项。</p><p>包含 <code>Makefile </code> 文件，帮助开发人员迅速搭建开发环境、生成所需代码等。</p><h2 id="开发模型"><a href="#开发模型" class="headerlink" title="开发模型"></a>开发模型</h2><h2 id="分层逻辑"><a href="#分层逻辑" class="headerlink" title="分层逻辑"></a>分层逻辑</h2><ol><li><strong>清晰的逻辑分层</strong>：核心逻辑（<code>core</code>）分离出来，突出其稳定性和重要性；<code>api</code>用于常规业务逻辑，而<code>extension</code>用于易变或实验性质的特性。</li><li><strong>便于维护和扩展</strong>：通过这种分层，维护者可以快速识别代码的稳定性和变化频率，从而更有效地进行维护和更新。</li><li><strong>降低风险</strong>：将核心逻辑与易变逻辑分离，减少了核心功能因频繁更改而出现问题的风险。</li><li><strong>灵活性提升</strong>：为新特性提供了灵活的试验空间（在<code>extension</code>），不影响核心和常规逻辑。</li><li><strong>通用代码灵活使用</strong>: common 按需使用，可以跨版本使用，也可跨功能使用</li><li><strong>服务分层</strong>: service 描述服务层面的接口定义，用于控制和管理该功能中的行为，例如获取信息、配置更新等。</li></ol><h2 id="版本概念"><a href="#版本概念" class="headerlink" title="版本概念"></a>版本概念</h2><ol><li><strong>向后兼容性</strong>：新版本并不会立即替换旧版本，使得客户端可以平滑过渡。</li><li><strong>清晰的版本管理</strong>：每个版本的更改和特性都清晰可追溯。</li></ol><h2 id="proto-store-目录结构"><a href="#proto-store-目录结构" class="headerlink" title="proto-store 目录结构"></a>proto-store 目录结构</h2><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">proto-store/<br>├── Makefile<br>├── pkg                          # pb.go 代码<br>│   ├── auth                     # 按功能分类，不要按组件分类<br>│   │   ├── api<br>│   │   │   ├── common<br>│   │   │   │   └── common.pb.go  # 公共API的Go代码<br>│   │   │   └── v1<br>│   │   │       └── auth_api_v1.pb.go  # auth API v1版本的Go代码<br>│   │   ├── core<br>│   │   │   └── v1<br>│   │   │       └── auth_core_v1.pb.go  # auth核心v1版本的Go代码<br>│   │   ├── extension<br>│   │   │   └── v1<br>│   │   │       └── auth_extension_v1.pb.go  # auth扩展v1版本的Go代码<br>│   │   └── service<br>│   │       └── v1<br>│   │           └── auth_service_v1.pb.go  # auth服务v1版本的Go代码<br>│   ├── common<br>│   │   └── v1<br>│   │       └── common_v1.pb.go  # 通用类型v1版本的Go代码<br>│   └── type<br>│       └── v1<br>│           └── types_v1.pb.go  # 数据类型v1版本的Go代码<br>├── proto<br>│   ├── auth<br>│   │   ├── api<br>│   │   │   ├── common<br>│   │   │   │   └── common.proto  # 公共API的proto定义<br>│   │   │   └── v1<br>│   │   │       └── auth_api_v1.proto  # auth API v1版本的proto定义<br>│   │   ├── core<br>│   │   │   └── v1<br>│   │   │       └── auth_core_v1.proto  # auth核心v1版本的proto定义<br>│   │   ├── extension<br>│   │   │   └── v1<br>│   │   │       └── auth_extension_v1.proto  # auth扩展v1版本的proto定义<br>│   │   └── service<br>│   │       └── v1<br>│   │           └── auth_service_v1.proto  # auth服务v1版本的proto定义<br>│   ├── common<br>│   │   └── v1<br>│   │       └── common_v1.proto  # 通用类型v1版本的proto定义<br>│   └── type<br>│       └── v1<br>│           └── types_v1.proto  # 数据类型v1版本的proto定义<br>└── README.md<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>proto-buffer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何学习一门编程语言.md</title>
    <link href="/2024/09/04/mdstorage/arch/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%97%A8%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    <url>/2024/09/04/mdstorage/arch/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%97%A8%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="学习一门编程语言"><a href="#学习一门编程语言" class="headerlink" title="学习一门编程语言"></a>学习一门编程语言</h1><p>参考链接: <a href="https://www.cnblogs.com/qiaogaojian/p/6781908.html">学习方法</a></p><h2 id="初步了解"><a href="#初步了解" class="headerlink" title="初步了解"></a>初步了解</h2><ul><li>如何运行一个简单的该语言程序</li><li>了解该语言的基本要素:<ul><li>基本数据类型</li><li>基本语法和流程控制（判断&#x2F;分支&#x2F;循环等）</li><li>主要数学运算符</li><li><code>print</code>函数的使用</li></ul></li></ul><h2 id="进阶学习"><a href="#进阶学习" class="headerlink" title="进阶学习"></a>进阶学习</h2><ul><li>掌握数组和其他集合类的使用</li><li>理解泛型（如果有基础的话，否则可以后补）</li><li>简单字符串处理，包括查找替换、截断去字串等（不涉及Regex和Parser）</li><li>字符编码问题（如果理解困难，可跳过）</li></ul><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><ul><li>基本面向对象或函数式编程的特征<ul><li>继承</li><li>多态</li><li>Lambda函数等</li></ul></li><li>异常、错误处理、断言、日志和调试</li><li>支持单元测试（不必须用TDD，但应掌握基本技能）</li></ul><h2 id="代码组织与运行"><a href="#代码组织与运行" class="headerlink" title="代码组织与运行"></a>代码组织与运行</h2><ul><li>程序代码和可执行代码的组织机制</li><li>运行时模块加载和符号查找机制</li><li>基本输入输出和文件处理</li></ul><h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><ul><li>Callback方法调用和事件驱动编程模型</li><li>序列化和反序列化</li><li>动态编程、反射、元数据编程</li><li>运行时编译和执行的机制</li></ul><h2 id="可选深化方向"><a href="#可选深化方向" class="headerlink" title="可选深化方向"></a>可选深化方向</h2><ol><li>线程、并发和异步调用机制（读懂别人代码或专门学习）</li><li>研究Regex和XML处理（如无必要可跳过）</li><li>泛型的支持（使用现成的泛型集合和函数即可，深入学习需谨慎）</li><li>咨询经验丰富的人了解该语言常用的特色features（如Ruby的block iterator, Java的dynamic proxy, C# 3的LINQ和extension method）</li></ol><h2 id="长期发展"><a href="#长期发展" class="headerlink" title="长期发展"></a>长期发展</h2><ul><li>在工作的闲暇时间，重点考察：<ul><li>该语言的惯用法和模式</li><li>编译&#x2F;解释执行机制</li></ul></li><li>之后可根据需求学习数据库、网络或图形，找成熟框架或库，边做边学。</li></ul>]]></content>
    
    
    <categories>
      
      <category>arch</category>
      
      <category>如何学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fmt和println.md</title>
    <link href="/2024/09/04/mdstorage/domain/golang/fmt%E5%92%8Cprintln/"/>
    <url>/2024/09/04/mdstorage/domain/golang/fmt%E5%92%8Cprintln/</url>
    
    <content type="html"><![CDATA[<h3 id="fmt-Print-和-println-区别"><a href="#fmt-Print-和-println-区别" class="headerlink" title="fmt.Print 和 println 区别"></a>fmt.Print 和 println 区别</h3><p><a href="https://gfw.go101.org/article/unofficial-faq.html#print-builtin-fmt-log">https://gfw.go101.org/article/unofficial-faq.html#print-builtin-fmt-log</a></p><h3 id="标准输出-stdout"><a href="#标准输出-stdout" class="headerlink" title="标准输出 (stdout)"></a>标准输出 (stdout)</h3><p><code>stdout</code> 通常用于输出程序的主要结果或期望的数据。这些信息通常是：</p><ol><li><strong>正常的数据输出</strong>：程序正常运行的结果，如计算输出、查询结果等。</li><li><strong>信息性消息</strong>：提供程序运行状态的信息，如进程指示、状态报告等。</li><li><strong>日志消息</strong>：在某些情况下，常规日志消息（非错误或警告）也可以输出到 <code>stdout</code>。</li><li><strong>用户交互</strong>：在命令行工具中，与用户的正常交互（如输入提示）通常使用 <code>stdout</code>。</li></ol><h3 id="标准错误-stderr"><a href="#标准错误-stderr" class="headerlink" title="标准错误 (stderr)"></a>标准错误 (stderr)</h3><p><code>stderr</code> 用于输出错误消息和警告。这些信息通常包括：</p><ol><li><strong>错误消息</strong>：指示程序执行中出现的问题，如异常、错误条件、处理失败等。</li><li><strong>警告信息</strong>：虽然程序可以继续运行，但需要引起注意的情况，如配置问题、推荐的用法提醒等。</li><li><strong>调试信息</strong>：在调试程序时输出的额外信息，如变量状态、错误的详细信息等。</li></ol><h3 id="为什么这种区分很重要？"><a href="#为什么这种区分很重要？" class="headerlink" title="为什么这种区分很重要？"></a>为什么这种区分很重要？</h3><ul><li><strong>自动化和脚本处理</strong>：脚本和自动化工具通常依赖于 <code>stdout</code> 来获取所需数据，同时监控 <code>stderr</code> 来捕获和响应错误条件。</li><li><strong>日志管理</strong>：系统和应用日志管理工具可以分别处理 <code>stdout</code> 和 <code>stderr</code>，使得日志更有组织，易于分析和故障排查。</li><li><strong>用户体验</strong>：在命令行界面，用户通常期望看到错误和警告信息与正常输出分开显示，以便于快速识别问题。</li><li><strong>符合预期行为</strong>：符合 <code>stdout</code> 和 <code>stderr</code> 的标准用途，可以使你的程序更容易被其他开发者理解和使用。</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>从 <code>fmt.Print</code> 和 <code>println</code> 的区别可以得出以下结论：</p><ul><li><strong>专业程度和用途</strong>：对于正式的、需要格式化输出的场景，应优先使用 <code>fmt.Print</code> 或其他 <code>fmt</code> 包中的函数。而 <code>println</code> 更适合于快速的、临时的调试用途。</li><li><strong>标准输出 vs. 标准错误</strong>：在 Go 语言中，无论是 <code>fmt.Print</code> 还是 <code>println</code>，默认都是输出到 <code>stdout</code>。如果需要输出错误信息或警告到 <code>stderr</code>，可以使用 <code>log</code> 包或 <code>fmt.Fprintf(os.Stderr, ...)</code> 的方式。</li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue项目初学.md</title>
    <link href="/2024/09/04/mdstorage/domain/js/vue%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%AD%A6/"/>
    <url>/2024/09/04/mdstorage/domain/js/vue%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>作为初学这, 学习 vue </p><h2 id="搭建-vue-项目"><a href="#搭建-vue-项目" class="headerlink" title="搭建 vue 项目"></a>搭建 vue 项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">npm create vite@latest <span class="hljs-variable">$&#123;DIR_PATH&#125;</span> --template vue  <span class="hljs-comment"># 会自动下载 create-vite 工具</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu_wifi连不上.md</title>
    <link href="/2024/09/04/mdstorage/domain/linux/Ubuntu_wifi%E8%BF%9E%E4%B8%8D%E4%B8%8A/"/>
    <url>/2024/09/04/mdstorage/domain/linux/Ubuntu_wifi%E8%BF%9E%E4%B8%8D%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="reset-systemd-resolved"><a href="#reset-systemd-resolved" class="headerlink" title="reset systemd-resolved"></a>reset systemd-resolved</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 尝试修改 dns 配置，解决问题</span><br><span class="hljs-built_in">sudo</span> nano /etc/systemd/resolved.conf<br>systemctl restart systemd-resolved<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>export.md</title>
    <link href="/2024/09/04/mdstorage/domain/linux/export/"/>
    <url>/2024/09/04/mdstorage/domain/linux/export/</url>
    
    <content type="html"><![CDATA[<h3 id="export-f-的作用"><a href="#export-f-的作用" class="headerlink" title="export -f 的作用"></a><code>export -f</code> 的作用</h3><p>在 Bash 中，<code>export -f</code> 用于将当前 shell 中定义的函数导出到子 shell 中，使子 shell 也能够访问和执行该函数。通常，<code>export</code> 命令用于导出环境变量，而 <code>export -f</code> 则专门用于导出函数。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> -f function_name<br></code></pre></td></tr></table></figure><ul><li><code>function_name</code>：要导出的函数名称。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设我们在当前 shell 中定义了一个名为 <code>my_function</code> 的函数，并希望在一个子 shell 中也能够调用它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 定义一个函数</span><br><span class="hljs-function"><span class="hljs-title">my_function</span></span>() &#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello from my_function&quot;</span><br>&#125;<br><br><span class="hljs-comment"># 导出该函数</span><br><span class="hljs-built_in">export</span> -f my_function<br><br><span class="hljs-comment"># 启动一个子 shell 并在其中调用这个函数</span><br>bash -c <span class="hljs-string">&quot;my_function&quot;</span><br></code></pre></td></tr></table></figure><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol><li><strong>定义函数</strong>：<code>my_function</code> 是在当前 shell 中定义的一个函数。</li><li>**<code>export -f</code>**：将 <code>my_function</code> 函数导出到子 shell，使得子 shell 能够访问它。</li><li><strong>子 shell</strong>：<code>bash -c &quot;my_function&quot;</code> 启动了一个子 shell，并在子 shell 中执行 <code>my_function</code>。</li></ol><p>在没有使用 <code>export -f</code> 时，子 shell 将无法识别父 shell 中定义的函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 定义一个函数</span><br><span class="hljs-function"><span class="hljs-title">my_function</span></span>() &#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello from my_function&quot;</span><br>&#125;<br><br><span class="hljs-comment"># 不导出函数，直接调用子 shell</span><br>bash -c <span class="hljs-string">&quot;my_function&quot;</span><br></code></pre></td></tr></table></figure><p>这会导致以下错误：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">bash:</span> my_function: command not found<br></code></pre></td></tr></table></figure><p>因为子 shell 中没有定义 <code>my_function</code> 函数，除非通过 <code>export -f</code> 将其导出。</p><h3 id="函数作用域问题"><a href="#函数作用域问题" class="headerlink" title="函数作用域问题"></a>函数作用域问题</h3><h4 id="1-函数的默认作用域"><a href="#1-函数的默认作用域" class="headerlink" title="1. 函数的默认作用域"></a>1. <strong>函数的默认作用域</strong></h4><p>在 Bash 中，函数的默认作用域是当前 shell，即它只能在定义它的 shell 环境中可用。函数的作用域不会自动扩展到子 shell 或其他终端会话。</p><h4 id="2-子-shell-中的函数"><a href="#2-子-shell-中的函数" class="headerlink" title="2. 子 shell 中的函数"></a>2. <strong>子 shell 中的函数</strong></h4><p>当你在当前 shell 中启动一个子 shell（如通过 <code>bash -c</code> 或 <code>bash</code> 命令），子 shell 默认不会继承父 shell 中定义的函数。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-function"><span class="hljs-title">my_function</span></span>() &#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello from my_function&quot;</span><br>&#125;<br><br><span class="hljs-comment"># 启动子 shell</span><br>bash<br></code></pre></td></tr></table></figure><p>在子 shell 中，<code>my_function</code> 将不可用，除非通过 <code>export -f</code> 将其导出。</p><h4 id="3-export-f-的作用域"><a href="#3-export-f-的作用域" class="headerlink" title="3. export -f 的作用域"></a>3. <strong><code>export -f</code> 的作用域</strong></h4><p>当你使用 <code>export -f</code> 导出函数后，导出的函数只在当前的子 shell 中有效，且仅在该次子 shell 会话中可用。一旦子 shell 结束，该函数在子 shell 中的作用域也随之结束。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-function"><span class="hljs-title">my_function</span></span>() &#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello from my_function&quot;</span><br>&#125;<br><br><span class="hljs-built_in">export</span> -f my_function<br><br><span class="hljs-comment"># 启动子 shell 1</span><br>bash -c <span class="hljs-string">&quot;my_function&quot;</span>  <span class="hljs-comment"># 输出: Hello from my_function</span><br><br><span class="hljs-comment"># 启动子 shell 2</span><br>bash -c <span class="hljs-string">&quot;my_function&quot;</span>  <span class="hljs-comment"># 输出: Hello from my_function</span><br><br><span class="hljs-comment"># 子 shell 结束后，函数的作用域也结束</span><br></code></pre></td></tr></table></figure><p>在每次启动子 shell 时，<code>my_function</code> 都会被继承并在子 shell 中可用。但是，如果你在一个不同的终端中启动新的 shell 会话，函数将不可用，除非在新的会话中再次定义并导出该函数。</p><h4 id="4-函数的生命周期"><a href="#4-函数的生命周期" class="headerlink" title="4. 函数的生命周期"></a>4. <strong>函数的生命周期</strong></h4><ul><li><strong>父 shell</strong>：函数在定义它的父 shell 中存在，父 shell 退出后，函数也会消失。</li><li><strong>子 shell</strong>：如果通过 <code>export -f</code> 将函数导出到子 shell，子 shell 可以访问和使用该函数。但子 shell 退出时，函数的作用域也随之结束。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong><code>export -f</code> 的作用</strong>：将当前 shell 中定义的函数导出到子 shell，使子 shell 可以调用该函数。</li><li><strong>作用域问题</strong>：函数默认只能在定义它的 shell 中使用。通过 <code>export -f</code>，可以将函数的作用域扩展到子 shell，但不会影响新的 shell 会话或父 shell 以外的环境。</li><li><strong>函数的生命周期</strong>：函数只在定义它的 shell 及其导出的子 shell 中有效，子 shell 结束后，函数的作用域也结束。</li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>僵尸进程.md</title>
    <link href="/2024/09/04/mdstorage/domain/linux/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
    <url>/2024/09/04/mdstorage/domain/linux/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><pre><code class="hljs">僵尸进程：在 Unix/Linux 系统中，当一个进程终止时，它的父进程还没有通过调用 wait() 系统调用读取其退出状态，那么这个进程就会成为僵尸进程。僵尸进程本身已经停止运行，但仍然在进程表中占据一个条目，以便父进程能够读取其退出状态。&lt;defunct&gt;：在 ps 的输出中，&lt;defunct&gt; 表示该进程已经终止，但是它的父进程还没有读取并处理它的退出状态。此时，这个进程处于僵尸状态。[$program_name]：这表示这个僵尸进程的原始程序名称。[$program_name] 的方括号显示形式通常是系统为了提醒用户这是一个特殊状态（僵尸进程），而不是一个正常的可执行进程。</code></pre><h2 id="如何处理僵尸进程"><a href="#如何处理僵尸进程" class="headerlink" title="如何处理僵尸进程"></a>如何处理僵尸进程</h2><pre><code class="hljs">自动清理：一般情况下，僵尸进程会在父进程通过 wait() 函数获取它的退出状态后被清理掉。如果父进程在不久后结束，僵尸进程也会随之被清理。手动处理：    终止父进程：如果父进程没有正确处理僵尸进程，你可以尝试终止父进程。这样，init 进程（PID 1）会继承这些僵尸进程，并会立即清理它们。    检查父进程是否卡住：如果有大量僵尸进程，可能意味着其父进程卡住或陷入了某种错误状态。你可能需要调查和解决父进程的问题。</code></pre>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>授权方案.md</title>
    <link href="/2024/09/04/mdstorage/domain/%E5%AE%89%E5%85%A8/%E6%8E%88%E6%9D%83%E6%96%B9%E6%A1%88/"/>
    <url>/2024/09/04/mdstorage/domain/%E5%AE%89%E5%85%A8/%E6%8E%88%E6%9D%83%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="授权方案-定义威胁模型"><a href="#授权方案-定义威胁模型" class="headerlink" title="授权方案(定义威胁模型)"></a>授权方案(定义威胁模型)</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>方案一 二 覆盖用户使用石犀系统时 可连广域网和不可连广域网 的情况, 一 二 都有各自的优缺点, 二者结合起来可以</p><pre><code class="hljs">SAC 石犀授权中心, 根据网络授权机制实现的授权服务,目前用于, 实现总控引擎插件的授权SAC_DATA 石犀授权中心数据, SAC_DATA 包含此用户帐户下网络授权方面的资产数据(总控 引擎 插件过期时间,绑定关系等),当 SC 需要授权数据,将从 SAC 下取数据.SHD 静态授权设备, 可以是USB, 里面包括静态授权数据, 或者产生静态授权数据的工具SHD_DATA 静态授权设备数据, SHD 中包含的静态授权方面的资产数据(总控 引擎 插件国企时间,绑定时间等), 当 SC 需要授权数据, 将从本地设备中获取数据.</code></pre><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><pre><code class="hljs">使用网络授权方案作为可连广域网情况下的授权方式.</code></pre><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><pre><code class="hljs">优点:    更灵活, 如果客户更新商品属性如续费, 可以通过 SAC 直接同步到总控    成本低, 除需要的节点机器外不需要额外的成本缺点:    不能解决完全不能连接广域网的情况</code></pre><h5 id="总控节点直接访问广域网"><a href="#总控节点直接访问广域网" class="headerlink" title="总控节点直接访问广域网"></a>总控节点直接访问广域网</h5><pre><code class="hljs">总控访问跟 SAC 同一台机器, 总控与 SAC 通过 127.0.0.1 通信</code></pre><h5 id="总控节点间接访问广域网"><a href="#总控节点间接访问广域网" class="headerlink" title="总控节点间接访问广域网"></a>总控节点间接访问广域网</h5><pre><code class="hljs">SAC 部署到可连广域网的节点, 总控与 SAC 通过网络进行通信</code></pre><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><pre><code class="hljs">使用静态授权设备方案作为不可连广域网情况下的授权方式.</code></pre><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><pre><code class="hljs">优点:    不要求用户节点连广域网缺点:    成本高, 每次修改商品属性都需要让商城发一个 静态授权设备(USB)    静态授权设备需要保证本身的安全性, 不可复制性等</code></pre><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs Text">&gt; 总控软件加密<br>&gt;&gt; 概述<br>在没有硬件安全的情况下, 稳定性 易用性 安全性 三者几乎无法共同存在, 不考虑软件安全的情况下, 代码会较为整洁, 稳定易用;如果要保证易用和安全, 在某些特殊场景下, 一定会导致系统的不稳定;如果保证稳定性和安全性, 则将会采用处处有校验的方式, 使用体验会受到影响;<br>作为一款商品来说, 我们只能在保证安全性的前提下, 尽量平衡稳定性和易用性的关系.<br><br>需要达成的共识: 石犀系统(总控+引擎)以什么形式存在于客户网络中?<br>1. 总控只是有我们提供的软件, 硬件和root帐号由客户掌握<br>2. 总控是部署于我们提供的硬件平台上, 客户拿不到root帐号, 只能通过我们的api访问<br><br>不管怎么说, 破解软件只是时间问题, 尽量提高整个系统任一种被破解的难度是 研发的目标之一.<br>如果是第1点, 我们系统整体被破解的风险很大, 客户拥有root权限, 首先破解数据库是破解系统的第一步也是最简单的一步(难度为10), 如果数据库被破解, cracker 拥有读写数据库的能力, 在此情形下,将采用更多的冗余校验去保证数据库中数据的完整性(破解的难度为60), 那么有人会问, 数据库不保存重要数据?数据库不保存重要数据的情况下, 如过期时间, 将数据保存于商城, 由网络去请求后保存于内存中, 这样也会有问题, 保存于内存中的数据将在软件重启后失效, 也就是说, 依赖于这个机制, 当总控与商城网络不通的情况下, 只要重启总控(比如高可用时节点漂移重启), 则总控不可用.基于以上, 可以推导, 重要数据也需要保存于此机器中, 保存于数据库反而是提高被破解难度的手段.综述, 第1种情况下, 系统被破解的总难度为70.<br>第2种情况下, 我们系统整体被破解的风险较小, 在root账户不被拿到的情况, 只能通过接口去攻击系统, 通过接口能做到的攻击有限, 造成的影响面也有限, 易防.<br><br>&gt;&gt;&gt; 网络环境<br>1. 第1种情况下, 几乎不需要关心网络环境, 总控是否和商城联通与否, 只影响消息的传达, 不需要担心过期时间等数据被修改, 或者机器的时间被修改的情况<br>2. 第2种情况下<br>商城与总控一直联通<br>这就是说, 总控依赖总控与商城的网络联通性, 一旦不能访问商城, 则禁用所有总控接口.这种情况下,安全性和易用性都可以保证, 但是客户是否能接受这种情况?(稳定性受损)<br>商城与总控一直不联通<br>不联通的情况下, 重要数据保存在哪里是一个问题, 1. license 2. 外部设备 3. 局域网网络授权<br>不联通也有两种情况:<br>总控连接的所有主机均不可以连接商城<br>此时, 可以选择的只有 1. license 2. 外部设备<br>总控连接的部分主机可以连接商城<br>此时, 可以选择 1. 2. 3 局域网网络授权<br>商城与总控半联通<br>半联通指大部分情况是联通, 但是允许商城与总控一段时间内网络不同.这种情况下, 其实还是更类似一直不联通的情况, 涉及到重要数据保存在哪的问题?<br><br>&gt;&gt; mysql<br>&gt;&gt;&gt; mysql 需不需要阻止用户破解登录?<br>mysql 几乎可以确定可以通过特殊手段破解密码, 因为客户拥有root权限<br>https://developer.aliyun.com/article/792438<br>&gt;&gt;&gt;&gt; 后面总控将把 root 隐藏(封装在小盒子), <br>&gt;&gt;&gt; mysql 如何防止用户破解后修改数据?或者修改数据<br>&gt;&gt; 软件授权机制<br>&gt;&gt;&gt; 概述<br>license 文件<br>通过算法保证的授权方式, license文件的加密方式决定了被破解的难度, 从密码学的角度来说, 非常难通过穷举来破解(几乎不可能), 但是通过查汇编代码的情况, 是可能直接被破解算法的(难度为60).<br>PS: 如果 license 文件不跟 二进制文件 1对1绑定, 在没有网络的前提下, cracker 可以直接将一个 license 传递给其他的软件, 那么用户可以无限使用.<br>优点: 本身是没有额外成本, 实现简单<br>缺点: 1. 但是如果将 license 文件和 二进制文件绑定, 则发版和存储时, 按照每个用户的包都不同的算法, 将耗费大量磁盘存储. 2. 被破解风险高<br>USB 或 光盘<br>本质上是通过将部分重要数据保存于外部设备, 来进行授权行为.但需要保证 USB 本身具有不可复制性<br>优点: 被破解风险较低<br>缺点: 需要花费一定成本买硬件, 而且每次续费或修改商品属性都需要发一个新的USB设备<br>网络授权<br> 网络授权分为两类：局域网授权；广域网授权。但是，本质上是一样的。就是程序向远程的服务器查询，看看自己的机器是否被授权。授权lib会给当前PC设备生成一个ID，利用网卡MAC、CPU、GPU等等硬件附带的信息来生成此ID。一般很难伪造ID(虚拟机平台可以通过完全克隆主机, MAC CPU GPU等硬件信息是可能被克隆出来, 难度??(福林))。也因此，这些PC上的硬件可能无法随意更换，否则会导致新的ID，PC无法通过授权。把ID提交给授权服务器并记录，这样，就能够对一个PC做授权了。<br> 优点: 1. 破解风险低. 2. 除了开发成本不需要额外的成本 <br> 缺点: 1. 需要开发额外一套授权系统 2. 客户每次更新硬件时, 可能需要重新授权. 2. 总控需要依赖 总控和局域网授权客户端的联通性<br>&gt;&gt;&gt; 总控<br>&gt;&gt;&gt; 引擎<br>&gt;&gt;&gt; 插件<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Golang研发工程师JD.md</title>
    <link href="/2024/09/04/mdstorage/domain/%E6%8B%9B%E8%81%98/Golang%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88JD/"/>
    <url>/2024/09/04/mdstorage/domain/%E6%8B%9B%E8%81%98/Golang%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88JD/</url>
    
    <content type="html"><![CDATA[<h2 id="研发JD"><a href="#研发JD" class="headerlink" title="研发JD"></a>研发JD</h2><p><strong>职位：Golang资深研发工程师</strong></p><p><strong>主要职责：</strong></p><ol><li>使用Go语言进行高效、可靠的软件开发。</li><li>设计、开发并维护复杂的软件系统和架构。</li><li>与团队成员合作，共同解决复杂的技术问题。</li><li>对数据库的使用和维护负责，确保性能和稳定性。</li><li>参与代码审查，确保代码质量和遵守最佳实践。</li><li>持续优化应用程序的性能，提高系统的可扩展性和可靠性。</li><li>编写清晰、可维护的代码，并对软件进行全面测试。</li></ol><p><strong>必备技能和资格：</strong></p><ol><li>具有4年以上使用Go语言的开发经验。</li><li>熟悉数据库的设计、优化和维护，包括但不限于MySQL、PostgreSQL或NoSQL数据库。</li><li>良好的团队合作能力和沟通技巧。</li><li>对新技术充满好奇心，并愿意不断学习和进步。</li><li>熟悉软件开发的最佳实践和敏捷开发方法。</li></ol><p><strong>加分项：</strong></p><ul><li>有网络安全领域系统开发经验。</li><li>熟悉 Devops 领域。</li><li>熟悉信创平台、有相关研发经历。</li></ul><p><strong>职位：Golang中级研发工程师</strong></p><p><strong>主要职责：</strong></p><ol><li>使用Go语言进行有效、可靠的软件开发。</li><li>参与设计和开发大型复杂度的软件系统和架构。</li><li>与团队成员合作，解决技术难题。</li><li>协助数据库的使用和维护工作，确保性能和稳定性。</li><li>参与代码审查，确保代码质量。</li><li>协助优化应用程序性能，提升系统的可扩展性和可靠性。</li><li>编写清晰的代码和相关自测。</li></ol><p><strong>必备技能和资格：</strong></p><ol><li>具有2年以上使用Go语言的开发经验。</li><li>对数据库的基本使用和维护有一定了解，熟悉MySQL、PostgreSQL或NoSQL数据库。</li><li>具备良好的团队合作和沟通能力。</li><li>对技术保持好奇心，并愿意学习新知识。</li><li>了解软件开发的基本实践和敏捷开发流程。</li></ol><p><strong>加分项：</strong></p><ul><li>有网络安全领域系统开发经验。</li><li>熟悉 Devops 领域。</li><li>熟悉信创平台、有相关研发经历。</li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>招聘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>jd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简历参考.md</title>
    <link href="/2024/09/04/mdstorage/domain/%E6%8B%9B%E8%81%98/%E7%AE%80%E5%8E%86%E5%8F%82%E8%80%83/"/>
    <url>/2024/09/04/mdstorage/domain/%E6%8B%9B%E8%81%98/%E7%AE%80%E5%8E%86%E5%8F%82%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>xxx<br>⼀、基本信息 &amp; 求职意向<br>电话 &#x2F; 微信: xxxxxxxxx 邮箱: xxxxxxx 年龄: xx 岁<br>⼯作年限: 6年 毕业院校: xxxx⼤学（2013.09 - 2017.06）<br>意向职位: 开发⼯程师 到岗时间: 可随时到岗<br>⼆、⼯作经验<br>1、深圳市xxx科技有限公司（⾹港上市公司：00909.HK）<br> xxx是国内地产数字化解决⽅案服务商的⻰头企业，深耕 SAAS 和 ERP 两⼤块业务。本⼈在明源云的前⼀<br>年半担任核⼼开发⼯程师，后⾯的两年半时间⾥相继担任两个敏捷团队的负责⼈。相关经历如下：<br>2021.02 - 2023.11 数字营销BG-业务中台-组件中⼼组 | SM （即团队负责⼈）<br> 团队负责通⽤业务组件产品的研发与维护⼯作，为其它团队提供通⽤业务解决⽅案，帮公司降本增效。本⼈担<br>任团队第⼀任负责⼈，职责包括团队规划、组织建设、技术领导、任务管理四⼤⽅⾯，其中主要的⼯作为团队各阶<br>段的⽬标与实现规划、⼈才梯队建设、成员成⻓指导、成员招聘、⼈才盘点与绩效沟通、技术实现与质量把控、敏<br>捷流程实践等。<br> 任职期间对团队所负责的业务进⾏了微服务化的改造；孵化了⽂件盒⼦（对象存储多云、多租户⽀持）、第三<br>⽅授权平台、开发者中⼼（开放平台）等项⽬；进⾏了四层 DDD 架构实践、代码⼯程化实践、质量⻛险管控、可<br>观测性改进等技术创新；成员⽇常 PDP 跟进，指导 2 名成员完成了职级的认证提升，培养了 1 名成员为后备 SM<br>。<br>2023.03 - 2023.11 数字营销BG-业务中台-ERP数据组 | SM （即团队负责⼈）<br> 团队负责 ERP 业务与 SAAS 业务的业务数据打通，为客户实现业务互通的商业价值。本⼈ 23 年 3 ⽉加⼊团队<br>担任负责⼈，职责与⼯作内容与在组件团队相似（可看上⽂，此处不再赘述）。<br> 任职期间主要梳理了团队遗留的历史债务，不影响价值交付的前提下<strong>探索渐进式重构⽅案</strong>与安排债务修复任<br>务，逐步进⾏了与业务解耦的⼯作；成员⽇常 PDP 跟进，培养了 1 名团队成员为后备 SM 。<br>2019.11 - 2021.02 数字营销BG-业务中台-公共组 | ⾼级后端开发⼯程师（Golang、PHP）<br> 团队负责基础业务的研发与维护⼯作。本⼈担任⾼级后端开发⼯程师，主要职责包括业务分析与实现、项⽬负<br>责⼈等，其中主要的⼯作项为需求分析、⽅案设计与实现、项⽬协调跟进、主持后端专业线学习⼩组等。<br> 任职期间完成了租户平台数据库模块的重构、项⽬中⼼微服务化重构、打印中⼼微服务化重构、⽤户中⼼⽇常<br>迭代维护等⼯作；每周主持专业线学习⼩组的技术分享活动，推⼴ C4 Model 的架构设计⽅法论；引⼊ Sonar 来<br>进⾏团队代码质量分析。<br>2、深圳市xxx科技发展有限公司<br>2018.04 - 2019.11 技术部 | PHP开发⼯程师<br> 担任 PHP 开发⼯程师，参与公司的逗来购、积分商城、来逗编辑器、爱兑分等多个项⽬中，职责包括需求分<br>析、技术⽅案设计、代码编写、团队 Code Review、维护等。⾃发编写提效⼩⼯具、进⾏代码⼯程化的初步探<br>索。负责部分需求主责研发⼯作，合理安排相关协作者（前后端、测试、运维等）按质按量交付需求。<br>3222970dbd8e006c0nNz09u_F1NSxY62V_yCQOyjnPLVMA~~<br>3222970dbd8e006c0nNz09u_F1NSxY62V_yCQOyjnPLVMA~~<br>3、⼴州xxxx科技有限公司（A股上市公司：300616.SZ）<br>2017.07 - 2018.04 技术部 | PHP开发⼯程师<br> 担任 PHP 开发⼯程师，负责公众号建设、ToC 节⽇活动研发、HOMKOO 后台研发等⼯作；负责部分<br>HOMKOO 后台的前端研发⼯作。<br>三、项⽬<br>1、⽂件盒⼦<br> 简介：公司级对象存储组件，⽀持多云、多租户的业务场景。该项⽬包括控制台模块、API服务端模块、多语<br>⾔SDK、图像处理转换⼯具、⾮结构数据迁移服务等。<br> 贡献：1、本⼈是该项⽬的发起⽅，完整的负责了项⽬的孵化、推⼴⼯作。⽬前基本所有事业部都接⼊到⽂件<br>盒⼦来进⾏对象存储，且提供了内部数据交互、外部数据交互等业务场景的最佳实践；<br> 2、负责该项⽬完整架构设计⼯作，结合了C&#x2F;S、SDK的设计模式，使⽤依赖倒置解耦了对各云⼚商的直接依<br>赖，保证了项⽬的性能和可扩展性；<br> 3、在鲁棒性建设上，对数据库、缓存等资源进⾏了隔离；使⽤hystrix-go做熔断措施；使⽤singleflight保护<br>缓存；其中对于资源的上传直接⾛SDK的⽅式，防⽌对服务端的强依赖，避免因服务端出问题⽽出现关联问题，且<br>减轻了服务端的带宽压⼒；使⽤Prometheus采集相关metrics，配置规则实现异常监控告警；服务端配置HPA；<br> 4、充分利⽤ go 的并发优势，通过扇⼊扇出的模式来提⾼数据迁移的效率；<br>2、开发者中⼼<br> 简介：作为各业务间交互的身份凭证，其能⼒包括：1、身份合法性认证；2、功能权限控制；3、数据权限控<br>制；4、请求频率限制；等。该项⽬包括控制台模块、API服务端模块、多语⾔SDK等。<br> 贡献：1、本⼈是该项⽬的发起⽅，负责项⽬的⽅案设计与技术选型。⽬前业务中台⼤部分服务已接⼊使⽤，<br>提升服务安全；<br> 2、使⽤ JWT 来作为身份认证机制，通过有效期、防重发等设计，降低身份伪造攻击⻛险；<br> 3、使⽤令牌桶算法来实现 QPS 限流；<br> 4、提供 SDK 帮助使⽤⽅通过切⾯的⽅式进⾏ token ⽣成、token 认证鉴权等实践，避免对业务代码的侵⼊，<br>且 SDK 的⽅式能提升可以性；<br>3、打印中⼼<br> 简介：负责将业务团队的打印任务下发⾄客户打印机进⾏业务⽂档打印。主要包括API服务端模块、WS服务<br>端、WS客户端等。<br> 贡献：1、原本是⽐较⽼旧的项⽬，其中API服务端是PHP⼤单体仓库实现，WS服务端是NodeJs实现，本着进<br>⾏业务解耦（要从⼤单体服务拆出来）、解决服务不稳定的问题，进⾏了微服务化重构；<br> 2、为保持 WebSocket 稳定的连接，实现了⼼跳检测机制；连接出问题进⾏重连时，使⽤指数退避算法来避<br>免频繁连接加重服务器负担；<br> 3、将服务端和客户端的交互由推模式改为拉模式，解决旧项⽬交互延迟、消息堆积的问题；采⽤ redis 的有<br>序集合来避免拉模式下频繁对数据库的请求，保护资源，加快响应；<br>3222970dbd8e006c0nNz09u_F1NSxY62V_yCQOyjnPLVMA~~<br>4、代码⼯程化建设<br> 简介：将规律性的、标准化的代码通过 SDK 包共⽤、或者代码⾃动⽣成的⽅式来提升研发效率。<br> 贡献：1、开发了错误处理 SDK 包。避免频繁<code>if err != null</code>，让代码更优雅；通过 proto 定义错误码及信<br>息，⾃动⽣成代码，提升效率，同时 proto 定义⽂件作为服务交互的枢纽，达到代码即⽂档的效果；⽀持将各⽅法<br>运⾏时参数实际值记录到错误对象，关联对应的堆栈信息，在响应时通过拦截器将堆栈信息和参数值进⾏⽇志记<br>录，并输出要可视化⼯具，进⾏问题现场还原，⽅便排查；使⽤ reflect ⽀持对要记录的数据使⽤定义好的处理器<br>进⾏加⼯处理；<br> 2、⽀持通过 proto 来定义⼊参数据的合法性检测规则，⽣成规则检测代码，切⾯⽅式来进⾏⼊参校验；<br> 3、读取业务数据库的表结构，⽣成 DAO 层代码；基于 proto 定义的接⼝，⽣成 GRPC 调⽤的通⽤代码；<br> 4、开箱即⽤的各种外部资源使⽤的监控实现，如 mysql、redis、http请求 等；<br>5、逗来购微商城<br> 简介：基于微信公众号体系开发的SAAS模式商城，包含商品、营销、下订单、购物⻋、⽀付、商家等系统。<br> 贡献：1、营销系统的开发及维护⼯作，使⽤ redis 来应对⾼并发场景，避免优惠券超领超卖；<br> 2、优惠券叠加使⽤的最优组合算法实现，达到优惠价格最优、券使⽤条件最优的组合；<br> 3、各系统间 sso 单点登录的实现与维护，扩展第三⽅登录的⽅式；<br>6、Scrumban流程建设<br> 简介：为了使团队更拥抱敏捷软件开发，打造⾼效团队。<br> 贡献：1、结合 scrum 和 kanban 两种敏捷框架，制定更适合团队价值交付的流程；<br> 2、将流程与 DevOps 结合，提升研发交付质量和效率；<br> 3、培养团队⽂化，形成使命必达、技术创新的团队⽂化；<br>四、技能<br>专业技能：1、熟练使⽤ Golang 、 PHP 作为开发语⾔，对 js 也有了解；<br> 2、熟练使⽤ MySQL、Redis、Mongo 等数据库，有良好的数据库设计和优化经验；<br> 3、架构设计能站在战略层⾯和战术层⾯思考，有过DDD的探索经验；了解微服务、GOF设计模式，并有在⼯<br>作中使⽤；<br> 4、追求代码质量，对团队有单元测试、代码评审相关要求；了解常⻅的 web 安全知识；<br> 5、了解容器化运维和部署⽅⾯的知识，如对k8s的了解和使⽤；<br> 6、有带领团队、任务管理的能⼒及经验，从 0 到 1 建⽴过⼀⽀敏捷⼩组；<br>通⽤技能：有结构化思维、逻辑清晰，表达能⼒好，擅⻓与他⼈协助；学习能⼒好，对技术知识敏感，理解能⼒<br>强；<br>职业素养：重守承诺、尽职尽责，所负责的事项会⼀跟到底；<br>3222970dbd8e006c0nNz09u_F1NSxY62V_yCQOyjnPLVMA~~</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>招聘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>简历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo.md</title>
    <link href="/2024/09/04/mdstorage/domain/%E6%96%87%E6%A1%A3/hexo/"/>
    <url>/2024/09/04/mdstorage/domain/%E6%96%87%E6%A1%A3/hexo/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo-使用攻略"><a href="#hexo-使用攻略" class="headerlink" title="hexo 使用攻略"></a>hexo 使用攻略</h2><p><a href="https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/">hexo使用攻略介绍-添加分类和标签</a></p><h2 id="写作风格"><a href="#写作风格" class="headerlink" title="写作风格"></a>写作风格</h2><p>categories:<br>尽量使用英文的小驼峰或蛇形写法</p><p>如果不想曝光的文章, 不加入 categories 中</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周报模板.md</title>
    <link href="/2024/09/04/mdstorage/project/sr/%E5%91%A8%E6%8A%A5%E6%A8%A1%E6%9D%BF/"/>
    <url>/2024/09/04/mdstorage/project/sr/%E5%91%A8%E6%8A%A5%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h3 id="周报模板"><a href="#周报模板" class="headerlink" title="周报模板"></a>周报模板</h3><p>引擎组&#x2F;石犀&#x2F;总控组&#x2F;HA&#x2F;引擎&amp;插件&amp;总控</p><p><strong>报告周期</strong><br>2023年12月11日 - 2023年12月15日</p><hr><h4 id="组员周报摘要"><a href="#组员周报摘要" class="headerlink" title="组员周报摘要"></a>组员周报摘要</h4><hr><h5 id="组员-xxxx"><a href="#组员-xxxx" class="headerlink" title="组员: xxxx"></a>组员: xxxx</h5><ul><li><strong>本周完成工作</strong>:<ul><li>镜像自测: 自测文档已写，等待测试有空转测即可。</li><li>慢速拒绝: 表面上完成，可能还需技术部反馈调整界面。</li><li>边车: 自测通过，流程需完善，已交由项目经理跟进。</li></ul></li><li><strong>本周总结</strong>:<ul><li>临近发版小问题不断，需求加，慢速拒绝需求草率，建议减少此类情况。</li></ul></li><li><strong>下周计划</strong>:<ul><li>梳理引擎组各成员任务。</li><li>检阅引擎相关技术文档。</li><li>镜像交付技术分享培训（可能）。</li></ul></li></ul><hr><h5 id="组员-xx"><a href="#组员-xx" class="headerlink" title="组员: xx"></a>组员: xx</h5><ul><li><strong>本周完成工作</strong>:<ul><li>弱密码可视化功能相关性能优化及代码重写，完成联调。</li><li>MongoDB技术研究文档编写。</li></ul></li><li><strong>本周总结</strong>:<ul><li>代码分支弱密码可视化功能优化和前端联调完成，MongoDB技术文档编写完成。</li></ul></li><li><strong>下周计划</strong>:<ul><li>加强弱密码可视化测试，解决bug。</li><li>研究配置下发流程。</li></ul></li></ul><hr><h5 id="组员-xxx"><a href="#组员-xxx" class="headerlink" title="组员: xxx"></a>组员: xxx</h5><ul><li><strong>本周完成工作</strong>:<ul><li>每日任务设计文档编写，自测平台部署。</li><li>生产环境时间问题处理，学习测试工具并形成文档。</li><li>219升级220邮箱帮助文档404bug修复。</li></ul></li><li><strong>本周总结</strong>:<ul><li>[无特别总结，可能因为内容重复。]</li></ul></li><li><strong>下周计划</strong>:<ul><li>完成文档补充并开始补充总控的单元测试。</li></ul></li></ul><hr><h5 id="组员-xxxx-1"><a href="#组员-xxxx-1" class="headerlink" title="组员: xxxx"></a>组员: xxxx</h5><ul><li><strong>本周完成工作</strong>:<ul><li>协助完成20亿级别数据，协助定位etcd升级失败问题。</li><li>HA适配ARM平台，可以编译，联调待确定。</li></ul></li><li><strong>本周总结</strong>:<ul><li>定位问题和准备压测数据，下周完成压测数据录入，增加TDengine适配访问日志压测代码。</li></ul></li></ul><hr><h5 id="组员-xxx-1"><a href="#组员-xxx-1" class="headerlink" title="组员: xxx"></a>组员: xxx</h5><ul><li><strong>本周完成工作</strong>:<ul><li>完成镜像安装测试，镜像中bug修复，自测文档编写。</li><li>API-GOV编译ARM64架构软件包。</li></ul></li><li><strong>本周总结</strong>:<ul><li>主要完成镜像测试与文档编写，bug修复。</li></ul></li><li><strong>下周计划</strong>:<ul><li>Aarch64平台cpuid获取调研与编码，适配授权功能。</li><li>YQ合并配置文件脚本研究。</li></ul></li></ul><hr><h5 id="组员-xxx-2"><a href="#组员-xxx-2" class="headerlink" title="组员: xxx"></a>组员: xxx</h5><ul><li><strong>本周完成工作</strong>:<ul><li>项目管理相关事务处理，Nginx配置转换过滤。</li><li>1.3.X版本问题处理，1.4.0 Nginx模块设计文档编写60%。</li></ul></li><li><strong>本周总结</strong>:<ul><li>[无特别总结。]</li></ul></li><li><strong>下周计划</strong>:<ul><li>完成1.4.0</li></ul></li></ul><p> Nginx模块设计文档。</p><ul><li>跟进信创与单测任务。</li></ul><hr><h5 id="组员-xxx-3"><a href="#组员-xxx-3" class="headerlink" title="组员: xxx"></a>组员: xxx</h5><ul><li><strong>本周完成工作</strong>:<ul><li>慢速拒绝需求对接，设计文档输出，代码合并及自测。</li><li>路由部署提示优化，静态路由设计文档补充。</li><li>WAF插件问题处理，总控时间设置需求开发。</li><li>协助排查引擎失联问题，分析WAF访问频率需求。</li></ul></li><li><strong>本周总结</strong>:<ul><li>WAF插件发现问题，数据结构变化导致，已重组数据。</li></ul></li><li><strong>下周计划</strong>:<ul><li>Webserver文档完成，ARM结构编译测试。</li></ul></li></ul><hr><h5 id="组员-xxxx-2"><a href="#组员-xxxx-2" class="headerlink" title="组员: xxxx"></a>组员: xxxx</h5><ul><li><strong>本周完成工作</strong>:<ul><li>总控热升级时间延长，总控时间设置需求变更。</li><li>总控安装升级设计文档完善，调研总控部署适配信创平台。</li></ul></li><li><strong>本周总结</strong>:<ul><li>临时需求多，打包效率低。</li></ul></li><li><strong>下周计划</strong>:<ul><li>继续调研总控部署适配信创平台，引擎集成测试。</li></ul></li></ul><hr><h5 id="组员-xxx-4"><a href="#组员-xxx-4" class="headerlink" title="组员: xxx"></a>组员: xxx</h5><ul><li><p>本周完成工作</p><ul><li>完成对ddos攻击源追踪和防御功能设计和原型规划。</li><li>深入研究了流量清洗机制，编写了详细的设计文档。</li><li>完成了app1.3版本的安全性升级和app1.4版本的需求分析。</li></ul></li><li><p>问题</p><ul><li>在流量清洗机制中存在一些理论上的问题，需要进一步的实验和测试。</li></ul></li><li><p>下周计划</p><ul><li>继续对ddos攻击源追踪和防御功能进行详细设计。</li><li>开始实施app1.3版本的安全性升级。</li><li>对app1.4版本进行详细的需求分析和设计。</li></ul></li></ul><hr><h4 id="总结备注"><a href="#总结备注" class="headerlink" title="总结备注"></a>总结备注</h4><ul><li><strong>本周整体进度</strong>:<ul><li>各组员积极推进项目任务，完成本周计划工作，同时准备下周工作计划。</li></ul></li><li><strong>团队整体问题</strong>:<ul><li>部分需求变更及紧急任务导致计划外工作量增加，需合理安排时间和资源。</li></ul></li><li><strong>下周关注点</strong>:<ul><li>优化工作流程，减少临时需求对项目进度的影响，保证关键任务的完成。</li></ul></li></ul><hr><h5 id="其他备注"><a href="#其他备注" class="headerlink" title="其他备注:"></a>其他备注:</h5><hr><p><strong>编制人</strong>: xx<br><strong>日期</strong>: 2023年12月15日</p>]]></content>
    
    
    
    <tags>
      
      <tag>周报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>端口规划文档.md</title>
    <link href="/2024/09/04/mdstorage/project/sr/%E7%AB%AF%E5%8F%A3%E8%A7%84%E5%88%92/"/>
    <url>/2024/09/04/mdstorage/project/sr/%E7%AB%AF%E5%8F%A3%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs Text">端口规划文档<br><br>&gt;&gt; 概述<br><br>总控引擎的任务因为是在客户提供的环境下运行, 所以端口需要规划, 避免出现与客户部署的服务端口冲突的情况<br><br>同时, 也需要告知客户有哪些端口需要放开, 避免防火墙<br><br>每个端口只会分配一个固定的组件, 组件如果废弃掉, 端口再分配给另一个组件, 这样避免多个版本组件端口冲突的情况<br><br>目前待规划的端口池 [22000-29000)<br><br>&gt;&gt; 蓝图<br><br>&gt;&gt;&gt; 总控<br><br>总控和总控组件    [29000-29100)<br><br>可视化和可视化组件  [29100-29200)<br><br>全流量组件 [29200-29300] <br><br>API 组件  [29300-29400)<br><br>第三方组件      [29900-30000)<br><br><br>&gt;&gt;&gt; 引擎<br><br>&gt;&gt;&gt;&gt; HA 组件<br><br>管理面 HA 组件   [20100-20133)<br><br>调度节点 HA 组件  [20133-20166)<br><br>&gt;&gt;&gt;&gt; 引擎安装组件<br><br>自研组件      [20000, 20100)<br><br>&gt;&gt;&gt;&gt; 管理面组件<br><br>自研组件      [20200-20300)<br><br>第三方组件     [20300-20400)<br><br>&gt;&gt;&gt;&gt; 调度节点组件<br><br>自研组件      [28900-28950)<br><br>&gt;&gt;&gt;&gt; 数据面组件<br><br>自研组件      [28950-29000)<br><br>&gt;&gt; 总控使用的端口<br><br>&gt;&gt;&gt; 概述<br><br>总控使用端口思路不用太严格, 因为总控是与引擎分开部署的, 理论上这台机器没有引擎运行<br><br>总控除了80 443外使用 [29000-30000) (包括29000, 不包括 30000)<br><br>sc 和 sc的组件使用 [29000-29100)<br><br>sv 和 sv的组件使用 [29100-29200)<br><br>全流量和全流量组件 [29200-29300)<br><br>API 组件  [29300-29400)<br><br>总控的第三方组件使用 [29900-30000)<br><br>sc(80 443 8080)   -&gt; 29000<br><br>installer(8098)   -&gt; 29001<br><br>meta(29010)   -&gt; 29010<br><br>sv(20522)      -&gt; 29100<br><br>mongodb(27017)   -&gt; 29900<br><br>redis(6379)     -&gt; 29901<br><br>mysql(3306)     -&gt; 29902<br><br>etcd(2379 2380)   -&gt; 29903 29904<br><br>AgentServer(29201,29202)    # 2024/4/7<br><br>&gt;&gt; 引擎<br><br>&gt;&gt;&gt; 概述<br><br>引擎使用端口思路是必须要严格而且要整齐, 因为引擎要负责服务转发, 需要与客户共享端口资源<br><br>引擎拆分后有 SE-M SE-S SE-W , 三个组件 都可以部署一台节点上, 也可以分开部署, 直接视为部署到一台节点的情况.<br><br>引擎使用 [20000-29000) 的端口, 其中管理面使用 [20200-28900), 调度节点使用 [28900-28950), 数据面使用 [28950-29000), 这样安排的理由是, 管理面可能开较多的插件服务, 端口是为插件服务提供的.<br><br>安装引擎的服务统一规划, 安装引擎目前不管是什么组件, 都是通过 agent 统一安装的, 所以 agent 端口都是 20000, 引擎安装使用 [20000, 20100)<br><br>引擎HA在引擎端口下统一规划, 每个引擎节点不管是什么组件, 都有 nexus 服务, 端口都是 20100, nexus 属于 HA 相关组件, HA 相关的服务使用 [20100, 20200)<br><br><br><br>&gt;&gt;&gt; 引擎组件和对应的端口<br><br>&gt;&gt;&gt;&gt; SE-M 管理面组件<br><br>&gt;&gt;&gt;&gt;&gt; 管理面节点安装的服务使用 [20000-20010) 端口, 管理面自研应用使用 [20200-20300), 管理面第三方组件 [20300-20400), 管理面插件应用使用 [21000-22000), 管理面 HA 组件 [20100-20133), admin_dam 和 data_dam 比较特殊, 其中端口做到了复用, admin_dam和data_dam共用了 28952 端口, 一个绑定 127.0.0.1, 一个绑定 VIP, 所以不会冲突<br><br><br><br>agent(8099)      -&gt; 20000<br><br>nexus(8000)   -&gt; 20100<br><br>admin_ha(6898)     -&gt; 20101<br><br>webserver(8299 8298)  -&gt; 20200 20201<br><br>etcd(2379 2380)    -&gt; 20300 20301<br><br>apiserver(6443)    -&gt; 20302<br><br>全局限速(7676)     -&gt; 21000<br><br>admin_dam($VIP:7000 8899 8443) -&gt; $VIP:28952 20202 20203<br><br>&gt;&gt;&gt;&gt; SE-S 调度节点组件<br><br>&gt;&gt;&gt;&gt;&gt; 调度节点 HA 使用 [20133-20166)<br><br><br><br>agent(8099)      -&gt; 20000<br><br>data_ha grpc(6899)   -&gt; 20133<br><br>* nexus(8000)      -&gt; 20100<br><br>&gt;&gt;&gt;&gt; SE-W 数据面组件<br><br>&gt;&gt;&gt;&gt;&gt; 数据面 HA使用 [20166-20199), 数据面自研应用使用 [28950-29000)<br><br>agent(8099)    -&gt; 20000<br><br>nexus(8000)      -&gt; 20100<br><br>envoy(9902)      -&gt; 28950<br><br>data_dam(9977 127.0.0.1:7000)     -&gt; 28951 127.0.0.1:28952<br><br>polycube(9000)     -&gt; 28953<br><br>super_glue        28954    内部组件使用端口, envoy 相关<br><br>dataWorker(6879)<br><br>边车模式     -&gt; 28960-28965<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>机器资源.md</title>
    <link href="/2024/09/04/mdstorage/resource/asset/%E6%9C%BA%E5%99%A8%E8%B5%84%E6%BA%90/"/>
    <url>/2024/09/04/mdstorage/resource/asset/%E6%9C%BA%E5%99%A8%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h2 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">lenovo debian11 xiaoy/<span class="hljs-variable">$faker</span>  192.168.31.239/24   负责 192.168.31.0/24 的转发<br><br><br>tencentcloud debian10 xiaoy/<span class="hljs-variable">$faker</span> 119.91.145.27 <br></code></pre></td></tr></table></figure><h2 id="QEMU-KVM"><a href="#QEMU-KVM" class="headerlink" title="QEMU&#x2F;KVM"></a>QEMU&#x2F;KVM</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ub-1 192.168.122.203 root@<span class="hljs-variable">$faker</span>. <br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>asset</category>
      
    </categories>
    
    
    <tags>
      
      <tag>asset</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件源网站.md</title>
    <link href="/2024/09/04/mdstorage/resource/asset/%E8%BD%AF%E4%BB%B6%E6%BA%90%E7%BD%91%E7%AB%99/"/>
    <url>/2024/09/04/mdstorage/resource/asset/%E8%BD%AF%E4%BB%B6%E6%BA%90%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><ul><li><a href="http://ftp.gnu.org/gnu/glibc/">gnu</a></li><li><a href="https://developer.aliyun.com/mirror/?serviceType=&tag=">阿里镜像</a></li><li><a href="https://mirrors.163.com/">网易云镜像</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>asset</category>
      
    </categories>
    
    
    <tags>
      
      <tag>asset</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>白描使用.md</title>
    <link href="/2024/09/04/mdstorage/resource/%E5%9B%BE%E7%89%87/%E7%99%BD%E6%8F%8F%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/09/04/mdstorage/resource/%E5%9B%BE%E7%89%87/%E7%99%BD%E6%8F%8F%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>图片转文字 </p><p>提取图片的文字信息</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>windows</p><p>安卓&#x2F;IOS</p><p>mac</p><p><a href="https://web.baimiaoapp.com/">网页</a></p>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>图片</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tool</tag>
      
      <tag>白描 ocr 图片转文字</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>噩梦年记事大纲.md</title>
    <link href="/2024/09/04/mdstorage/project/fountain/%E5%99%A9%E6%A2%A6%E5%B9%B4%E8%AE%B0%E4%BA%8B/%E5%A4%A7%E7%BA%B2/"/>
    <url>/2024/09/04/mdstorage/project/fountain/%E5%99%A9%E6%A2%A6%E5%B9%B4%E8%AE%B0%E4%BA%8B/%E5%A4%A7%E7%BA%B2/</url>
    
    <content type="html"><![CDATA[<ul><li><strong>构思主题与情节</strong>：<ul><li>确定您想要探讨的中心主题。</li><li>构思大致的情节框架，包括故事的开端、发展、高潮、和结局。</li></ul></li><li><strong>人物创造与发展</strong>：<ul><li>设计主要和次要人物，为他们制定背景故事、性格特点和动机。</li><li>考虑人物之间的关系以及这些关系如何推动故事发展。</li></ul></li><li><strong>世界建构</strong>：<ul><li>如果故事背景非现实世界，需要详细描绘故事的设定，包括地理、政治、经济、文化等方面。</li><li>即使故事设定在现实世界，也要研究相关的背景信息，让故事环境真实可信。</li></ul></li><li><strong>研究与灵感搜集</strong>：<ul><li>阅读相关书籍、文章，了解您的题材和背景。</li><li>搜集灵感，可能来自电影、音乐、艺术作品等。</li></ul></li><li><strong>情节细化</strong>：<ul><li>将大致情节拆分为章节和场景，规划每一部分要发生的事情。</li><li>可以通过故事梗概、时间线、情节图等工具帮助组织情节。</li></ul></li><li><strong>写作计划</strong>：<ul><li>制定写作计划和时间表，确定每天或每周的写作目标。</li><li>保持纪律，按计划写作，同时也要允许灵感的自然涌现。</li></ul></li><li><strong>文体和语言风格</strong>：<ul><li>确定小说的叙述视角和时态（例如第一人称过去时、第三人称全知视角等）。</li><li>础定语言风格和语调，比如正式、幽默、沉重或轻松等。</li></ul></li><li><strong>回顾与修订</strong>：<ul><li>准备好在初稿完成后进行大量的修订和润色。</li><li>可能需要多次重写某些章节，甚至整个情节。</li></ul></li><li><strong>反馈与改进</strong>：<ul><li>考虑在某个阶段将您的草稿或想法分享给信任的朋友或同行，获取反馈。</li><li>保持开放的态度，对建设性的批评持接受心态，并据此改进。</li></ul></li><li><strong>备份与记录</strong>：<ul><li>经常备份您的工作，以防丢失。</li><li>记录下写作过程中的想法和修改，这有助于未来的审稿和修订。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>project</category>
      
      <category>fountain</category>
      
      <category>噩梦年记事</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小说</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>噩梦年记事草稿.md</title>
    <link href="/2024/09/04/mdstorage/project/fountain/%E5%99%A9%E6%A2%A6%E5%B9%B4%E8%AE%B0%E4%BA%8B/%E8%8D%89%E7%A8%BF/"/>
    <url>/2024/09/04/mdstorage/project/fountain/%E5%99%A9%E6%A2%A6%E5%B9%B4%E8%AE%B0%E4%BA%8B/%E8%8D%89%E7%A8%BF/</url>
    
    <content type="html"><![CDATA[<p>第一章 小镇的夕阳<br>    “吉尔伯特，开门！”<br>　　在日光的偏移中，老旧的铁门随着访客拍门的动作而发出有节奏的声响。<br>　　在亚楠镇居民的眼里，这样的行为往往是不受欢迎的，毫无礼节的敲门配合着大声的呼喊往往会让人们想起那些糟糕的夜晚。<br>　　但是，当路过的人们看到那访客身上的衣服时，便又将满嘴的埋怨与不满吞回了肚子里，更何况他正在直呼吉尔伯特的名字。<br>　　“大概是教会里的猎人吧。”<br>　　人们这么想着，随后便纷纷朝着自己家的方向赶去，天色已经不早了。<br>　　门内传来了脚步声，随后，一个有着棕色卷发的中年人打开了房门，将自己疲惫的面孔暴露在了夕阳的余晖里。<br>　　在看到访客的脸后，吉尔伯特的面容立即抖动了一下，他让开了身子，示意对方进屋说话。<br>　　“怎么回事？现在应该并不是你执勤的时间。”，吉尔伯特关上门，疑惑地询问这位不速之客：“还是说，咱们的卡尔先生打算从工房里出来透透风？”<br>　　被称为卡尔的男子从头上摘下了制式的猎人三角帽，露出了那张苍白而瘦削的脸，他瘦得有些不成样子了，长时间对学识的钻研使得他不得不依靠一些手段来维持身体对营养的需求，不过近期，这种补充方法也被他自己戒掉了，这就让他看上去更加地不堪。<br>　　“瘦得和木杆子差不多了。”<br>　　吉尔伯特腹诽着，然而卡尔却没有回应他的玩笑，而是用急促而阴冷的语气说道：“提前了。”<br>　　吉尔伯特没反应过来：“什么？”<br>　　卡尔盯着他，无神的眼睛看上去就像是两个黑洞：“狩猎之夜提前了。”<br>　　吉尔伯特的表情僵住了，他惊疑不定地看着卡尔，随后试探性地问道：“提前了多少？”<br>　　“今晚。”<br>　　这个答案像是从火枪里射出的子弹一样命中了吉尔伯特，他对自己朋友的回答没有丝毫怀疑，卡尔或许并不讨人喜欢，但却不会有人想去质疑他的话的真实度。<br>　　吉尔伯特看向了墙壁，在那里正挂着一把造型狰狞的武器，乍一看像是弧形的巨大砍刀，为了便于放置，它的把柄与刀刃折叠在了一起，这就使得砍刀锯齿上的一些血渍沾染到了刀柄的白布上。<br>　　血渍还未彻底干涸，那些兽化病患者的血液比正常人的鲜血要粘稠得多，这就使得武器在使用后容易沾染上无法去除的污浊。<br>　　吉尔伯特算是知道卡尔为什么如此紧张了，他现在甚至能够感觉自己的呼吸变得无比困难。<br>　　狩猎之夜才刚结束，就又要开始了。<br>　　……<br>　　将信息带到之后，卡尔便离开了吉尔伯特家，朝着自己来时的方向走去。<br>　　在大街上能够看到不少猎人装束的亚楠居民，这些亚楠猎人在看到卡尔后，便纷纷朝他行礼，尽管卡尔看上去弱不禁风，但是他背后那治愈教会的披风却是做不得假的。<br>　　人们对治愈教会充满了尊敬，毕竟现在，小镇的治安与生存环境全靠教会的猎人与圣职者们维持着，而那些被招募的亚楠居民则更是如此，他们中的不少人都目睹过教会的精英们猎杀野兽时的场景，也因此，治愈教会的成员在小镇上拥有了惊人的地位和声望。<br>　　卡尔伸手拦住了一名行色匆匆的小伙，对方在看见卡尔的装束后便收起了自己一脸的不满，小心翼翼地问道：“先生，有什么事吗？”<br>　　“你们在紧急集合？”<br>　　卡尔用手杖指了指街道的另一头，几个朝着小镇中心赶去的亚楠猎人，如是问道。<br>　　“是的先生！”，小伙子迅速地回答道，他顺手整理了一下自己的腰带，因为高速的奔跑，上面的猎人手枪偏到了一边，看上去非常的滑稽。<br>　　在整理完腰带后，他又说道：“是路德维希大人的命令，日落之前在小镇中心集合。”<br>　　在提到路德维希这个名字的时候，小伙的脸上闪过了崇敬的神情。<br>　　卡尔抬手拍了拍对方的肩膀，顺手帮他整理了一下同样歪斜的肩带：“去吧，别迟到了。”<br>　　“谢谢您！先生！”<br>　　目送这个年轻的猎人顺着街道一路跑去，卡尔的脸色变得更加难看，这些集结的亚楠猎人的数量已经完全超出了常规配置，几乎是把所有能够招募的猎人全部集合了起来，这种情况是从来没有出现过的。<br>　　卡尔走到街道的边上，扶着护栏向下看去。<br>　　亚楠一直是一个有着独特结构的城镇，顺着山势修建的建筑带来的是一种奇妙的层叠感，而在亚楠的正上方，则有着另外一个小镇，即独属于治愈教会的辖区。<br>　　当猎杀之夜开始，人们将被要求锁死房门藏在家中，除了身具猎杀任务的猎人们，将不会有人在街道之上行走。<br>　　卡尔的手指在护栏上摩擦了一下，他摸到了一道狭长的凹痕，那是兽爪留下的痕迹。<br>　　这些平日里或沉默，或卑微，或遵纪守法的居民们一旦陷入兽化，便拥有了给这座城市留下伤痕的能力，这些痕迹是细微而不足道的，但就今日的情况来看，这些积累的伤痕似乎已经为整个城镇带来了威胁。<br>　　毫无疑问，猎杀之夜要提前了，而且接下来的这个夜晚的恶劣程度将会远超以往，可以看出，教会已经没有心思和精力去隐瞒这一点了，这从大量集结的猎人们就能看出。<br>　　最后看了一眼亚楠镇底层街道上奔走的居民，卡尔转身离去，他还要去一趟猎人工坊，每当这个时候，水银子弹与汽油弹之类的基础物资总是极为紧缺。<br>　　他朝着教会镇的入口走去，太阳的余晖维持不了多久，他必须赶在大门封锁前离开亚楠。<br>　　街道是寂静的，但是却又弥漫着一种难以言明的紧张和恐慌，人们或许已经意识到了什么，但是常识所给予他们的信心和勇气使得他们仍然能够待在屋内，向着神明祷告。<br>　　一股饭菜的味道传入卡尔的鼻子，居然难得地勾起了他对食物的渴望，但是很快，一股夹杂在食物中的血腥气使得卡尔打了一个寒颤。<br>　　这并不是正常的血疗中所用的血液的味道，它闻起来腐臭而粘稠，虽然还不够浓郁，但却足以证明，一次兽化正在附近发生。<br>　　他捏了捏手杖，拇指压在了手杖铁柄的机括上，顺着那股味道的源头走去。<br>　　兽化往往不会在白日里发生，兽化病的患者们在意识清醒的时候，可以利用镇静剂与教会发放的血液来安抚自己，所以兽化大都在睡眠时产生，又或者在患者们意识不清醒的时候爆发。<br>　　发生在傍晚时分的兽化案例可以说是屈指可数。<br>　　尖锐的叫声从小巷的深处传出，卡尔迅速地确定了方向，三步并作两步冲进了狭窄的巷道中，抬起一脚用力踢在了小巷尽头的木门上。<br>　　“嘭！”<br>　　颇为脆弱的门锁在暴力的踢击下损毁，房门大开的同时，一股浓重的血腥气便扑面而来。<br>　　兽化病可以是一个缓慢的过程，也可以在一瞬之间爆发，它会使得患者的身体出现皮肤破裂，关节扭曲等症状，而当病症再也无法扭转时，患者的血液将可能从身体各处的裂口中迸射而出，此时的患者仍然拥有神志，但强烈的痛楚与惊恐使得他们极容易被自身的攻击欲所控制。<br>　　此时此刻，那朝着卡尔扑来的人影便是这样一个可怜的存在。<br>　　仿佛早已排演过无数遍一般，卡尔的右手猛地抬起，拇指用力地按下把柄上的机括，原本的柱状手杖便如同散架了一般松散开来，那些金属斜着从上而下排开，形成了如同锯齿一般的存在，而这些锯齿之间，却又被金属关节所连接。<br>　　这条造型奇特的锯齿长鞭就这么展开了，随着卡尔的动作向上荡起，而后，又挟带着风声朝着前方抽下。<br>　　锋利的锯齿在滑过木质墙壁时发出了刺耳难听的声响，但随后，这声音便被血肉的撕裂声所取代。<br>　　这种诡异的伸缩手杖是猎人们执勤时常用的武器，尖锐的底部以及坚硬的主体使得它可以被当做短剑来使用，必要时也能够将其展开成致命的金属长鞭。<br>　　将武器藏于手杖，并选择用鞭子抽打自己的敌人，这本身便是一种慈悲，也是为了证明猎杀时的血液与痛楚永远无法侵蚀猎人高尚的灵魂。<br>　　腥臭的血液随着卡尔的动作在房屋之内泼洒开去，但仅仅是这样的鞭挞并无法阻止一个兽化的患者。<br>　　猎杀对他来说并不陌生，就算不是以猎杀为主要任务的教会猎人，卡尔一样能够熟练地应对这一切。<br>　　那两只已经被黑色的粗糙毛发所覆盖的手臂朝着两边展开，患者的双手已经朝着野兽的利爪靠拢，然而就在这尖爪即将碰到卡尔的身体时，那展开的金属长鞭迅速地扭转起来，伴随着这位瘦弱的猎人前刺的动作，长鞭再次化作手杖，其尖锐的底部轻松地贯入了对方的胸膛。</p>]]></content>
    
    
    <categories>
      
      <category>project</category>
      
      <category>fountain</category>
      
      <category>噩梦年记事</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小说</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>grpc-Tutorial.md</title>
    <link href="/2024/09/04/mdstorage/project/sr/golang%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/grpc-Tutorial/"/>
    <url>/2024/09/04/mdstorage/project/sr/golang%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/grpc-Tutorial/</url>
    
    <content type="html"><![CDATA[<h1 id="gRPC-教程"><a href="#gRPC-教程" class="headerlink" title="gRPC 教程"></a>gRPC 教程</h1><p>本教程针对希望学习如何使用 gRPC 构建和部署高效、可扩展的微服务的开发者。通过阅读本教程，了解 gRPC 的基本概念、如何在 Go 语言中实现 gRPC 服务，以及如何进行客户端和服务器之间的通信。寻找一个高性能、跨语言、开放源代码的远程过程调用 (RPC) 框架，gRPC 是一个理想的选择。</p><h2 id="教程概览"><a href="#教程概览" class="headerlink" title="教程概览"></a>教程概览</h2><p>在本教程中，学习如何：</p><ul><li>设计和定义 gRPC 服务</li><li>在 Go 语言中实现 gRPC 服务器和客户端</li><li>使用 Protocol Buffers 进行数据序列化</li></ul><h2 id="在开始之前"><a href="#在开始之前" class="headerlink" title="在开始之前"></a>在开始之前</h2><p>确保安装了以下必备软件和工具：</p><ul><li>Go 语言环境（至少 Go 1.15）</li><li>Protocol Buffers 编译器 (<code>protoc</code>)</li><li>gRPC Go 语言库</li></ul><p>以下知识或经验：</p><ul><li>基本的 Go 语言编程知识</li><li>对 RPC 和客户端-服务器架构有基本的了解</li></ul><h2 id="第一部分：定义和实现-gRPC-服务-id-”grpc-1”"><a href="#第一部分：定义和实现-gRPC-服务-id-”grpc-1”" class="headerlink" title="第一部分：定义和实现 gRPC 服务 {id&#x3D;”grpc_1”}"></a>第一部分：定义和实现 gRPC 服务 {id&#x3D;”grpc_1”}</h2><p>学习如何定义 gRPC 服务和在 Go 中实现这些服务。</p><ol><li><p>定义服务和消息格式。在 <code>service.proto</code> 文件中编写以下内容：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">package</span> tutorial;<br><br><span class="hljs-comment">// 定义 Greeter 服务</span><br><span class="hljs-keyword">service </span><span class="hljs-title class_">Greeter</span> &#123;<br>    <span class="hljs-comment">// 发送问候</span><br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> SayHello (HelloRequest) <span class="hljs-keyword">returns</span> (HelloReply) </span>&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// HelloRequest 消息定义</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloRequest</span> &#123;<br>    <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// HelloReply 消息定义</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloReply</span> &#123;<br>    <span class="hljs-type">string</span> message = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用 Protocol Buffers 编译器生成 Go 代码。在终端执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">protoc --go_out=. --go-grpc_out=. service.proto<br></code></pre></td></tr></table></figure></li><li><p>实现 gRPC 服务器。创建 <code>server.go</code> 并添加以下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>    pb <span class="hljs-string">&quot;path/to/your/service&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> server <span class="hljs-keyword">struct</span> &#123;<br>    pb.UnimplementedGreeterServer<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *server)</span></span> SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> &amp;pb.HelloReply&#123;Message: <span class="hljs-string">&quot;Hello &quot;</span> + in.Name&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:50051&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatalf(<span class="hljs-string">&quot;failed to listen: %v&quot;</span>, err)<br>    &#125;<br>    s := grpc.NewServer()<br>    pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)<br>    <span class="hljs-keyword">if</span> err := s.Serve(lis); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatalf(<span class="hljs-string">&quot;failed to serve: %v&quot;</span>, err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="第二部分：创建-gRPC-客户端"><a href="#第二部分：创建-gRPC-客户端" class="headerlink" title="第二部分：创建 gRPC 客户端"></a>第二部分：创建 gRPC 客户端</h2><p>学习如何创建 gRPC 客户端来调用服务器。</p><ol><li><p>创建 <code>client.go</code> 并添加以下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>    pb <span class="hljs-string">&quot;path/to/your/service&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    conn, err := grpc.Dial(<span class="hljs-string">&quot;localhost:50051&quot;</span>, grpc.WithInsecure(), grpc.WithBlock())<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatalf(<span class="hljs-string">&quot;did not connect: %v&quot;</span>, err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> conn.Close()<br>    c := pb.NewGreeterClient(conn)<br><br>    name := <span class="hljs-string">&quot;world&quot;</span><br>    ctx, cancel := context.WithTimeout(context.Background(), time.Second)<br>    <span class="hljs-keyword">defer</span> cancel()<br>    r, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: name&#125;)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatalf(<span class="hljs-string">&quot;could not greet: %v&quot;</span>, err)<br>    &#125;<br>    log.Printf(<span class="hljs-string">&quot;Greeting: %s&quot;</span>, r.Message)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>运行服务器和客户端，验证通信是否成功。</p></li></ol><h2 id="所学到的内容-id-”what-learned”"><a href="#所学到的内容-id-”what-learned”" class="headerlink" title="所学到的内容 {id&#x3D;”what-learned”}"></a>所学到的内容 {id&#x3D;”what-learned”}</h2><p>通过完成这个教程，已经成功地定义了一个简单的 gRPC 服务，实现了服务端和客户端，并在本地进行了测试。还学习了如何使用 Protocol Buffers 来定义数据格式和服务接口。</p><seealso><!-- 给出一些相关链接到如何文章 -->- [gRPC 官方文档](https://grpc.io/docs/)- [Go 语言官方文档](https://golang.org/doc/)</seealso>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>grpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/09/03/hello-world/"/>
    <url>/2024/09/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>清单软件设计</title>
    <link href="/2024/09/03/mdstorage/%E6%B8%85%E5%8D%95/"/>
    <url>/2024/09/03/mdstorage/%E6%B8%85%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h2 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h2><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>用户信息展示</p><h3 id="清单-1"><a href="#清单-1" class="headerlink" title="清单"></a>清单</h3><p>清单展示</p><ul><li>清单<ul><li>分组<ul><li>任务<ul><li>子任务</li></ul></li></ul></li></ul></li></ul><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ul><li>title</li><li>content</li><li>置顶</li><li>置顶时间</li><li>创建时间</li><li>更新时间</li><li>状态 0&#x2F;进度&#x2F;已完成&#x2F;已放弃</li><li>是否删除</li><li>删除时间</li></ul><h3 id="动态"><a href="#动态" class="headerlink" title="动态"></a>动态</h3><h3 id="用户用户-bind"><a href="#用户用户-bind" class="headerlink" title="用户用户 bind"></a>用户用户 bind</h3><p>联系人</p><h3 id="清单用户-bind"><a href="#清单用户-bind" class="headerlink" title="清单用户 bind"></a>清单用户 bind</h3><p>用户查看清单、共享清单</p><h3 id="任务用户-bind"><a href="#任务用户-bind" class="headerlink" title="任务用户 bind"></a>任务用户 bind</h3><p>指派任务给用户</p><h3 id="连接状态"><a href="#连接状态" class="headerlink" title="连接状态"></a>连接状态</h3><h3 id="任务动态-bind"><a href="#任务动态-bind" class="headerlink" title="任务动态 bind"></a>任务动态 bind</h3><h3 id="清单动态-bind"><a href="#清单动态-bind" class="headerlink" title="清单动态 bind"></a>清单动态 bind</h3><h2 id="维度"><a href="#维度" class="headerlink" title="维度"></a>维度</h2><h3 id="清单、任务"><a href="#清单、任务" class="headerlink" title="清单、任务"></a>清单、任务</h3><h3 id="标签-1"><a href="#标签-1" class="headerlink" title="标签"></a>标签</h3><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><h3 id="用户-1"><a href="#用户-1" class="headerlink" title="用户"></a>用户</h3><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>dashboard 、 core、 server</p><h4 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h4><p>展示层</p><h4 id="core"><a href="#core" class="headerlink" title="core"></a>core</h4><p>数据传递、数据同步</p><h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><p>数据收集、维护、提供</p>]]></content>
    
    
    
    <tags>
      
      <tag>架构</tag>
      
      <tag>清单软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>入职考试题目.md</title>
    <link href="/2024/09/03/mdstorage/domain/%E6%8B%9B%E8%81%98/%E5%85%A5%E8%81%8C%E8%80%83%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    <url>/2024/09/03/mdstorage/domain/%E6%8B%9B%E8%81%98/%E5%85%A5%E8%81%8C%E8%80%83%E8%AF%95%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol><li><strong>基础知识</strong>：<ul><li>解释 Golang 的垃圾回收机制。(3分)</li><li>在 Golang 中，<code>interface&#123;&#125;</code> 的作用是什么？(3分)</li></ul></li><li><strong>HTTP 协议与网络编程</strong>：<ul><li>列举 HTTP 状态码 200、400 和 500 分别代表什么？ (2分)</li><li>如何在 Go 中处理 HTTP 超时？ (2分)</li></ul></li><li><strong>Linux 操作系统</strong><ul><li>描述 Linux 操作系统写入文件的过程。</li></ul><ol start="2"><li>描述 Linux 操作系统处理多任务的机制。</li></ol></li><li><strong>Gin 框架</strong>：<ul><li>Gin 框架中如何实现中间件？（4分）</li><li>在 Gin 中处理 panic 的最佳实践是什么？ （4分）</li></ul></li><li><strong>GRPC</strong>：<ul><li>描述 GRPC 与传统 HTTP REST API 之间的主要区别。 （4分）</li><li>在 GRPC 中，什么是拦截器（Interceptor）？ （4分）</li></ul></li><li><strong>数据库与存储</strong>：<ul><li>如何在 Go 中使用 Redis 进行缓存操作？ （3分）</li><li>解释 Golang 中的 ORM，并举例说明如何使用。 （3分）</li></ul></li><li><strong>性能与优化</strong>：<ul><li>什么是 Goroutine 泄漏，如何避免？ （4分）</li><li>Golang 性能调优的一些常用方法是什么？ （4分）</li></ul></li><li><strong>高级题目</strong>（拉开差距的题目）：<ul><li>解释 Golang 中的反射（reflection）以及其使用场景。 （5分）</li><li>描述 Go 程序中死锁的概念，并提供一个简单的示例。 （5分）</li><li>解释 Keepalived 在 Linux 系统中的故障切换原理。 （8分）</li><li>阐述 LVS（Linux Virtual Server）的工作原理和架构。 （8分）</li><li>描述 NSQ 消息队列系统中消息的写入和读取过程。 （8分）</li><li>描述 Kubernetes 中自定义资源定义（CRD）的概念及其用途。 （8分）</li><li>概述 etcd 的主要功能和在分布式系统中的作用。 （9分）</li><li>解释 Envoy XDS 协议以及其下不同数据平面（DS）的概念和作用。 （9分）</li></ul></li></ol><h1 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h1><h2 id="试题"><a href="#试题" class="headerlink" title="试题"></a>试题</h2><p>Golang 的 GC 机制</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>考察对 Golang 垃圾回收机制的理解，包括其工作原理和对程序性能的影响。</p><h3 id="得分点"><a href="#得分点" class="headerlink" title="得分点"></a>得分点</h3><ul><li>描述垃圾回收的基本概念。</li><li>说明 Golang 中垃圾回收的工作方式（如三色标记算法）。</li><li>讨论垃圾回收对性能的影响。</li></ul><h3 id="参考答案-1"><a href="#参考答案-1" class="headerlink" title="参考答案"></a>参考答案</h3><p>Golang 使用并发的、三色标记的垃圾回收算法。在此过程中，分配器和写屏障会插入额外的代码来维护垃圾回收的数据结构。这种方法减少了程序暂停的时间，但可能会对整体性能造成轻微影响。</p><hr><h2 id="试题-1"><a href="#试题-1" class="headerlink" title="试题"></a>试题</h2><p>在 Golang 中，<code>interface&#123;&#125;</code> 的作用是什么？</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>考查对 Go 中空接口的理解及其使用场景。</p><h3 id="得分点-1"><a href="#得分点-1" class="headerlink" title="得分点"></a>得分点</h3><ul><li>解释空接口的概念。</li><li>讨论其在类型系统中的应用。</li><li>说明使用空接口的优缺点。</li></ul><h3 id="参考答案-2"><a href="#参考答案-2" class="headerlink" title="参考答案"></a>参考答案</h3><p><code>interface&#123;&#125;</code> 是 Go 中的空接口，可表示任何类型。由于 Go 是静态类型语言，空接口在需要泛型处理时非常有用，但使用时需注意类型断言或反射来处理具体类型。</p><hr><h2 id="试题-2"><a href="#试题-2" class="headerlink" title="试题"></a>试题</h2><p>列举 HTTP 状态码 200、400 和 500 分别代表什么？</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>考查对 HTTP 状态码的基本理解。</p><h3 id="得分点-2"><a href="#得分点-2" class="headerlink" title="得分点"></a>得分点</h3><ul><li>准确描述每个状态码的含义。</li><li>能够举例说明状态码的使用场景。</li></ul><h3 id="参考答案-3"><a href="#参考答案-3" class="headerlink" title="参考答案"></a>参考答案</h3><ul><li>200: 请求成功。</li><li>400: 错误的请求，客户端请求有语法错误。</li><li>500: 服务器内部错误，服务器遇到了一个意外的情况，无法完成请求。</li></ul><hr><h2 id="试题-3"><a href="#试题-3" class="headerlink" title="试题"></a>试题</h2><p>如何在 Go 中处理 HTTP 超时？</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>考查对 Go http 包使用和错误处理的理解。</p><h3 id="得分点-3"><a href="#得分点-3" class="headerlink" title="得分点"></a>得分点</h3><ul><li>说明如何设置超时。</li><li>讨论超时处理的重要性。</li></ul><h3 id="参考答案-4"><a href="#参考答案-4" class="headerlink" title="参考答案"></a>参考答案</h3><p>在 Go 中，可以通过设置 <code>http.Client</code> 的 <code>Timeout</code> 属性来处理 HTTP 请求的超时。这对于避免无限期等待响应和资源的有效管理非常重要。</p><hr><h2 id="试题-4"><a href="#试题-4" class="headerlink" title="试题"></a>试题</h2><p>描述 Linux 操作系统写入文件的过程。</p><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>考察对 Linux 文件系统和写入操作的理解，包括用户空间与内核空间的交互。</p><h3 id="得分点-4"><a href="#得分点-4" class="headerlink" title="得分点"></a>得分点</h3><ul><li>描述用户空间和内核空间的交互过程。</li><li>说明系统调用（如<code>write()</code>）的作用。</li><li>讨论缓冲区的角色和写入过程的同步&#x2F;异步特性。</li></ul><h3 id="参考答案-5"><a href="#参考答案-5" class="headerlink" title="参考答案"></a>参考答案</h3><p>在 Linux 中，写入文件通常涉及系统调用，如<code>write()</code>。应用程序在用户空间发起写入请求，通过系统调用传递给内核空间。数据首先被写入缓冲区，然后由内核管理的I&#x2F;O操作将数据写入磁盘。这个过程可以是同步的，也可以是异步的，取决于文件系统和具体的写入策略。</p><hr><h2 id="试题-5"><a href="#试题-5" class="headerlink" title="试题"></a>试题</h2><p>描述 Linux 操作系统处理多任务的机制。</p><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>考察对 Linux 多任务处理和调度机制的理解。</p><h3 id="得分点-5"><a href="#得分点-5" class="headerlink" title="得分点"></a>得分点</h3><ul><li>描述进程和线程的概念。</li><li>说明 Linux 的任务调度器如何管理多个任务。</li><li>讨论上下文切换对性能的影响。</li></ul><h3 id="参考答案-6"><a href="#参考答案-6" class="headerlink" title="参考答案"></a>参考答案</h3><p>Linux 通过进程和线程来实现多任务处理。每个进程拥有独立的地址空间，而线程则是轻量级的执行单元。Linux 的任务调度器负责分配 CPU 时间给各个任务。调度器根据任务的优先级和其他因素来决定任务的执行顺序。多任务处理涉及频繁的上下文切换，这可能对系统性能产生影响，尤其是在高负载情况下。</p><hr><h2 id="试题-6"><a href="#试题-6" class="headerlink" title="试题"></a>试题</h2><p>Gin 框架中如何实现中间件？</p><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p>考查对 Gin 框架中间件的实现和应用的理解。</p><h3 id="得分点-6"><a href="#得分点-6" class="headerlink" title="得分点"></a>得分点</h3><ul><li>描述中间件在 Gin 中的作用。</li><li>举例说明如何编写和注册中间件。</li></ul><h3 id="参考答案-7"><a href="#参考答案-7" class="headerlink" title="参考答案"></a>参考答案</h3><p>在 Gin 中，中间件是一种处理 HTTP 请求的函数，在请求到达路由处理函数之前或之后执行。可以通过使用 <code>router.Use()</code> 函数来注册中间件。中间件可以用于日志记录、用户认证等功能。</p><hr><h2 id="试题-7"><a href="#试题-7" class="headerlink" title="试题"></a>试题</h2><p>在 Gin 中处理 panic 的最佳实践是什么？</p><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><p>考查对异常处理和稳健性编程在 Gin 框架中的应用。</p><h3 id="得分点-7"><a href="#得分点-7" class="headerlink" title="得分点"></a>得分点</h3><ul><li>说明 panic 的影响。</li><li>描述如何在 Gin 中优雅地处理 panic。</li></ul><h3 id="参考答案-8"><a href="#参考答案-8" class="headerlink" title="参考答案"></a>参考答案</h3><p>在 Gin 中处理 panic 的最佳实践是使用内建的 <code>Recovery</code> 中间件，它可以捕获任何路由或中间件中的 panic，并恢复正常的 HTTP 请求处理。这样可以防止服务器因为单一的错误而崩溃。</p><hr><h2 id="试题-8"><a href="#试题-8" class="headerlink" title="试题"></a>试题</h2><p>描述 GRPC 与传统 HTTP REST API 之间的主要区别。</p><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><p>考查对 GRPC 和 HTTP REST API 技术的理解，及其优缺点。</p><h3 id="得分点-8"><a href="#得分点-8" class="headerlink" title="得分点"></a>得分点</h3><ul><li>说明两者在协议、性能和使用场景上的不同。</li><li>讨论使用场景和选择依据。</li></ul><h3 id="参考答案-9"><a href="#参考答案-9" class="headerlink" title="参考答案"></a>参考答案</h3><p>GRPC 基于 HTTP&#x2F;2, 主要用于内部服务之间的通信，支持流传输和更高效的二进制消息格式。相比之下，HTTP REST API 是基于 HTTP&#x2F;1.1, 更适用于公共 API 和不同语言之间的交互，使用 JSON 或 XML 格式进行数据传输。</p><hr><h2 id="试题-9"><a href="#试题-9" class="headerlink" title="试题"></a>试题</h2><p>在 GRPC 中，什么是拦截器（Interceptor）？</p><h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><p>探讨 GRPC 拦截器的概念及其在 GRPC 服务中的作用。</p><h3 id="得分点-9"><a href="#得分点-9" class="headerlink" title="得分点"></a>得分点</h3><ul><li>定义 GRPC 拦截器。</li><li>描述拦截器的常见用途。</li></ul><h3 id="参考答案-10"><a href="#参考答案-10" class="headerlink" title="参考答案"></a>参考答案</h3><p>拦截器在 GRPC 中用于在处理请求和响应之前或之后插入额外的逻辑。它们类似于中间件，可以用于日志记录、认证、监控等。</p><hr><h2 id="试题-10"><a href="#试题-10" class="headerlink" title="试题"></a>试题</h2><p>如何在 Go 中使用 Redis 进行缓存操作？</p><h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><p>考查对 Go 语言中使用 Redis 进行数据缓存的方法。</p><h3 id="得分点-10"><a href="#得分点-10" class="headerlink" title="得分点"></a>得分点</h3><ul><li>介绍在 Go 中连接和使用 Redis 的基本步骤。</li><li>讨论在缓存中存储和检索数据的常见模式。</li></ul><h3 id="参考答案-11"><a href="#参考答案-11" class="headerlink" title="参考答案"></a>参考答案</h3><p>在 Go 中使用 Redis，首先需要使用 Redis 客户端库，如 <code>go-redis/redis</code>。创建客户端连接后，可以使用各种命令来操作 Redis，如 <code>SET</code> 和 <code>GET</code> 来存储和检索数据。</p><hr><h2 id="试题-11"><a href="#试题-11" class="headerlink" title="试题"></a>试题</h2><p>解释 Golang 中的 ORM，并举例说明如何使用。</p><h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><p>探讨在 Go 中 ORM（对象关系映射）的概念及其应用。</p><h3 id="得分点-11"><a href="#得分点-11" class="headerlink" title="得分点"></a>得分点</h3><ul><li>定义 ORM 和其在 Go 中的作用。</li><li>举例说明如何在 Go 中使用 ORM 库。</li></ul><h3 id="参考答案-12"><a href="#参考答案-12" class="headerlink" title="参考答案"></a>参考答案</h3><p>ORM 在 Go 中是将数据库的表结构映射到 Go 的结构体。这样，可以使用 Go 的语法而非 SQL 来操作数据库。例如，使用 <code>gorm</code> 库可以通过定义结构体和调用方法来实现数据库操作。</p><hr><h2 id="试题-12"><a href="#试题-12" class="headerlink" title="试题"></a>试题</h2><p>什么是 Goroutine 泄漏，如何避免？</p><h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><p>考察对 Goroutine 泄漏的理解及预防措施。</p><h3 id="得分点-12"><a href="#得分点-12" class="headerlink" title="得分点"></a>得分点</h3><ul><li>定义 Goroutine 泄漏。</li><li>提供预防 Goroutine 泄漏的方法。</li></ul><h3 id="参考答案-13"><a href="#参考答案-13" class="headerlink" title="参考答案"></a>参考答案</h3><p>Goroutine 泄漏是指在 Go 程序中，Goroutines 由于某些原因（如阻塞的通道或无限循环）无法正常退出。避免泄漏的方法包括使用超时机制、确保所有通道能够关闭，以及避免无限循环。</p><hr><h2 id="试题-13"><a href="#试题-13" class="headerlink" title="试题"></a>试题</h2><p>Golang 性能调优的一些常用方法是什么？</p><h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><p>考察对 Go 语言中常见的性能优化技术的了解。</p><h3 id="得分点-13"><a href="#得分点-13" class="headerlink" title="得分点"></a>得分点</h3><ul><li>讨论代码优化（如避免内存分配、使用更高效的数据结构）。</li><li>描述性能分析和调试工具的使用。</li></ul><h3 id="参考答案-14"><a href="#参考答案-14" class="headerlink" title="参考答案"></a>参考答案</h3><p>Golang 性能优化的常见方法包括：优化内存使用和减少内存分配、使用高效的数据结构和算法、并发编程优化、以及使用 pprof 等工具进行性能分析。</p><hr><h2 id="试题-14"><a href="#试题-14" class="headerlink" title="试题"></a>试题</h2><p>解释 Golang 中的反射（reflection）以及其使用场景。</p><h3 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h3><p>考察对 Go 中反射的理解及其应用场景。</p><h3 id="得分点-14"><a href="#得分点-14" class="headerlink" title="得分点"></a>得分点</h3><ul><li>定义反射。</li><li>描述反射的典型应用。</li></ul><h3 id="参考答案-15"><a href="#参考答案-15" class="headerlink" title="参考答案"></a>参考答案</h3><p>反射是指在程序运行时检查、修改其变量的类型和值的能力。在 Go 中，反射常用于序列化和反序列化、实现泛型功能等。</p><hr><h2 id="试题-15"><a href="#试题-15" class="headerlink" title="试题"></a>试题</h2><p>描述 Go 程序中死锁的概念，并提供一个简单的示例。</p><h3 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h3><p>讨论 Go 中死锁的概念及其发生的条件。</p><h3 id="得分点-15"><a href="#得分点-15" class="headerlink" title="得分点"></a>得分点</h3><ul><li>解释死锁。</li><li>提供死锁的示例。</li></ul><h3 id="参考答案-16"><a href="#参考答案-16" class="headerlink" title="参考答案"></a>参考答案</h3><p>死锁是指两个或多个进程在执行过程中，因争夺资源而造成的一种僵局。在 Go 中，死锁通常发生在 Goroutines 和通道之间。一个简单的例子是两个 Goroutines 相互等待对方释放资源。</p><hr><h2 id="试题-16"><a href="#试题-16" class="headerlink" title="试题"></a>试题</h2><p>解释 Keepalived 在 Linux 系统中的故障切换原理。</p><h3 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h3><p>考察对 Keepalived 在高可用性设置中的故障切换机制的理解。</p><h3 id="得分点-16"><a href="#得分点-16" class="headerlink" title="得分点"></a>得分点</h3><ul><li>定义 Keepalived。</li><li>描述故障切换原理。</li></ul><h3 id="参考答案-17"><a href="#参考答案-17" class="headerlink" title="参考答案"></a>参考答案</h3><p>Keepalived 是一个用于 Linux 系统的高可用性解决方案，主要通过 VRRP 协议实现故障切换。它通过在多个服务器中选举一个主服务器来保证服务的可用性。当主服务器出现故障时，备份服务器接管，以此实现无缝切换。</p><hr><h2 id="试题-17"><a href="#试题-17" class="headerlink" title="试题"></a>试题</h2><p>阐述 LVS（Linux Virtual Server）的工作原理和架构。</p><h3 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h3><p>考查对 LVS 作为负载均衡解决方案的基本了解。</p><h3 id="得分点-17"><a href="#得分点-17" class="headerlink" title="得分点"></a>得分点</h3><ul><li>解释 LVS 的功能。</li><li>描述其工作原理和架构。</li></ul><h3 id="参考答案-18"><a href="#参考答案-18" class="headerlink" title="参考答案"></a>参考答案</h3><p>LVS 是一个基于 Linux 的负载均衡软件。它通过分发请求到多个服务器来提高服务的可用性和伸缩性。LVS 使用调度算法（如轮询、加权轮询）来选择后端服务器，并可以通过 NAT、IP隧道或直接路由模式来转发请求。</p><hr><h2 id="试题-18"><a href="#试题-18" class="headerlink" title="试题"></a>试题</h2><p>描述 NSQ 消息队列系统中消息的写入和读取过程。</p><h3 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h3><p>考察对 NSQ 作为消息队列系统的基本操作流程的理解。</p><h3 id="得分点-18"><a href="#得分点-18" class="headerlink" title="得分点"></a>得分点</h3><ul><li>解释消息队列的概念。</li><li>描述 NSQ 中消息的写入和读取流程。</li></ul><h3 id="参考答案-19"><a href="#参考答案-19" class="headerlink" title="参考答案"></a>参考答案</h3><p>NSQ 是一个实时分布式消息队列系统。在 NSQ 中，生产者将消息发送到主题（topic），消费者从通道（channel）读取消息。每个通道接收到主题的所有消息的副本，从而实现消息的分发和处理。</p><hr><h2 id="试题-19"><a href="#试题-19" class="headerlink" title="试题"></a>试题</h2><p>描述 Kubernetes 中自定义资源定义（CRD）的概念及其用途。</p><h3 id="解题思路-19"><a href="#解题思路-19" class="headerlink" title="解题思路"></a>解题思路</h3><p>考察对 Kubernetes 中 CRD 的理解，包括其创建和使用。</p><h3 id="得分点-19"><a href="#得分点-19" class="headerlink" title="得分点"></a>得分点</h3><ul><li>定义 CRD。</li><li>描述 CRD 如何扩展 Kubernetes API。</li></ul><h3 id="参考答案-20"><a href="#参考答案-20" class="headerlink" title="参考答案"></a>参考答案</h3><p>CRD（Custom Resource Definition）是 Kubernetes 中用于定义新的资源类型的机制。通过 CRD，用户可以创建符合自己需求的定制资源，并利用 Kubernetes API 来管理这些资源。</p><hr><h2 id="试题-20"><a href="#试题-20" class="headerlink" title="试题"></a>试题</h2><p>概述 etcd 的主要功能和在分布式系统中的作用。</p><h3 id="解题思路-20"><a href="#解题思路-20" class="headerlink" title="解题思路"></a>解题思路</h3><p>考察对 etcd 作为分布式键值存储系统的理解。</p><h3 id="得分点-20"><a href="#得分点-20" class="headerlink" title="得分点"></a>得分点</h3><ul><li>介绍 etcd 的主要功能。</li><li>讨论其在分布式系统（如 Kubernetes）中的角色。</li></ul><h3 id="参考答案-21"><a href="#参考答案-21" class="headerlink" title="参考答案"></a>参考答案</h3><p>etcd 是一个分布式键值存储系统，用于可靠地存储关键数据，并在分布式系统中保持集群状态一致。它是 Kubernetes 的核心组件之一，用于保存所有集群数据。</p><hr><h2 id="试题-21"><a href="#试题-21" class="headerlink" title="试题"></a>试题</h2><p>解释 Envoy XDS 协议以及其下不同数据平面（DS）的概念和作用。</p><h3 id="解题思路-21"><a href="#解题思路-21" class="headerlink" title="解题思路"></a>解题思路</h3><p>探讨 Envoy 代理中的 XDS 协议及其数据平面服务的作用。</p><h3 id="得分点-21"><a href="#得分点-21" class="headerlink" title="得分点"></a>得分点</h3><ul><li>描述 XDS 协议的目的。</li><li>阐述不同 DS（如 CDS、EDS、LDS、RDS）的功能。</li></ul><h3 id="参考答案-22"><a href="#参考答案-22" class="headerlink" title="参考答案"></a>参考答案</h3><p>Envoy XDS（xDS）协议用于动态配置 Envoy 代理。它包括几种不同的数据平面服务，例如 CDS（Cluster Discovery Service）、EDS（Endpoint Discovery Service）、LDS（Listener Discovery Service）、RDS（Route Discovery Service），每种服务管理 Envoy 配置的不同部分，以实现灵活的动态路由和负载均衡。</p><hr>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>招聘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo部署github-page.md</title>
    <link href="/2024/09/03/mdstorage/domain/%E6%96%87%E6%A1%A3/hexo%E9%83%A8%E7%BD%B2github-page/"/>
    <url>/2024/09/03/mdstorage/domain/%E6%96%87%E6%A1%A3/hexo%E9%83%A8%E7%BD%B2github-page/</url>
    
    <content type="html"><![CDATA[<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/cat_bayi/article/details/128725230">部署教学文档</a><br><a href="https://hexo.io/zh-cn/docs/">官方文档</a><br><a href="https://hexo.fluid-dev.com/docs/guide/#tag-%E6%8F%92%E4%BB%B6">fluid theme 用户手册</a></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="部署-hexo-test-目录"><a href="#部署-hexo-test-目录" class="headerlink" title="部署 hexo-test 目录"></a>部署 hexo-test 目录</h3><ul><li><p>初始化 hexo-test</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">npm install -g hexo-cli<br><span class="hljs-built_in">mkdir</span> hexo-test<br>hexo init hexo-test<br></code></pre></td></tr></table></figure></li><li><p>修改 _config.yml</p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Text">title<br>subtitle<br>description<br>author<br>language<br><br>url<br><br>theme<br><br>deploy:<br>  type: git<br>  repo: $&#123;github_page_url&#125;  # 这里填 ssh 的, 本机认证<br>  branch: $&#123;branch&#125;<br></code></pre></td></tr></table></figure><h3 id="部署-fluid"><a href="#部署-fluid" class="headerlink" title="部署 fluid"></a>部署 fluid</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> hexo-test/theme &amp;&amp; git <span class="hljs-built_in">clone</span> https://github.com/fluid-dev/hexo-theme-fluid/<br><span class="hljs-built_in">mv</span> hexo-theme-fluid fluid<br><span class="hljs-built_in">cp</span> fluid/_config.yml ../_config.fluid.yml <br></code></pre></td></tr></table></figure><ul><li>修改 _config.fluid.yml 内容</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Text">mermaid  修改为 true<br></code></pre></td></tr></table></figure><h3 id="拷贝-markdown-目录到-source-post-下"><a href="#拷贝-markdown-目录到-source-post-下" class="headerlink" title="拷贝 markdown 目录到 source&#x2F;_post 下"></a>拷贝 markdown 目录到 source&#x2F;_post 下</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cp</span> -r ../dairy/<br><br></code></pre></td></tr></table></figure><h3 id="github-建立-仓库-xxx-github-io"><a href="#github-建立-仓库-xxx-github-io" class="headerlink" title="github 建立 仓库 xxx.github.io"></a>github 建立 仓库 xxx.github.io</h3><ul><li>创建 repo</li><li>在 repo setting -&gt; pages -&gt; source 选择 deploy from a branch -&gt; branch main &#x2F;(root)  即可</li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cygwin.md</title>
    <link href="/2024/09/03/mdstorage/resource/windows/cygwin/"/>
    <url>/2024/09/03/mdstorage/resource/windows/cygwin/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>cygwin 可以帮助我们在 windows 系统中使用类 unix 模拟环境，安装一些工具。</p><h2 id="安装-cygwin"><a href="#安装-cygwin" class="headerlink" title="安装 cygwin"></a>安装 cygwin</h2><p><a href="https://cygwin.com/">官网</a>  下载 cygwin setup 程序， 运行则开始选择安装常用工具集， 选择完后才开始安装。</p><p>左上角，选择状态，状态为 待安装的，输入 gcc-g++ 就会出现候选列表</p><p>常用工具集： gcc-g++ ，make </p><h2 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h2><p>如果想使用工具， 可以打开 cygwin terminal 直接运行命令。</p><p>如果想在 windows cmd 中使用，将 cygwin 安装目录加入环境变量 Path 中</p><h2 id="安装额外工具"><a href="#安装额外工具" class="headerlink" title="安装额外工具"></a>安装额外工具</h2><p>如果操作完成后还想再安装额外的工具，如 rsync 等，再次运行 cygwin setup 程序， 重复步骤即可</p>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>software</tag>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows 设置浏览器切换</title>
    <link href="/2024/09/03/mdstorage/resource/windows/%E8%AE%BE%E7%BD%AE%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%87%E6%8D%A2/"/>
    <url>/2024/09/03/mdstorage/resource/windows/%E8%AE%BE%E7%BD%AE%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://blog.csdn.net/Ussim/article/details/108299370">Windows 10 修改 Alt+Tab 键 切换 新版 Microsoft Edge 单个标签页&#x2F;窗</a></p>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>edge</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mmap.md</title>
    <link href="/2024/08/29/mdstorage/domain/golang/mmap/"/>
    <url>/2024/08/29/mdstorage/domain/golang/mmap/</url>
    
    <content type="html"><![CDATA[<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><a href="https://zhuanlan.zhihu.com/p/366964820">https://zhuanlan.zhihu.com/p/366964820</a></p><h3 id="mmap-机制"><a href="#mmap-机制" class="headerlink" title="mmap 机制"></a>mmap 机制</h3><p><code>mmap</code> 通过将文件直接映射到进程的地址空间来提高文件访问的效率。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li><strong>性能</strong>：对于大文件的随机读写，<code>mmap</code> 可以提供更高的性能，因为它避免了传统的文件读写中的数据复制步骤。</li><li><strong>简易的接口</strong>：<code>mmap</code> 提供了一种将文件内容直接映射为内存的方法，这使得读写文件就像访问内存一样简单。</li><li><strong>系统优化</strong>：利用操作系统的页面缓存和虚拟内存系统，可以有效地处理大文件。</li></ol><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ol><li><strong>安全风险</strong>：直接操作内存可能导致程序崩溃和数据损坏。</li><li><strong>复杂性</strong>：需要手动管理内存映射的生命周期，错误处理更加复杂。</li><li><strong>可移植性和兼容性问题</strong>：不同操作系统对 <code>mmap</code> 的支持不同，可能需要平台特定的代码。（检测适配 鲲鹏 kylinos v10）</li></ol><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>对大型文件进行高效的随机读写。</li><li>处理有限的结构化数据，不需要复杂的查询或事务处理。</li><li>在内存和文件之间快速共享数据。</li></ul><h3 id="数据库（DB）"><a href="#数据库（DB）" class="headerlink" title="数据库（DB）"></a>数据库（DB）</h3><p>数据库是用于存储、检索、更新和管理数据的系统，它提供了数据的结构化组织、查询语言和事务处理。</p><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ol><li><strong>数据管理</strong>：提供复杂的数据查询、索引和管理能力。</li><li><strong>事务支持</strong>：支持事务处理，包括原子性、一致性、隔离性和持久性。</li><li><strong>易于使用和维护</strong>：提供了用户友好的接口和工具，简化了数据管理和维护。</li><li><strong>扩展性和灵活性</strong>：支持大量数据和多种数据类型，易于扩展和修改数据模型。</li><li><strong>安全性</strong>：提供访问控制和数据加密功能。</li></ol><h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><ol><li><strong>性能开销</strong>：对于简单的数据访问，数据库的额外功能可能带来性能开销。</li><li><strong>复杂性</strong>：数据库的安装、配置和维护相对复杂。</li><li><strong>成本</strong>：某些数据库软件可能需要购买许可证。</li></ol><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>需要复杂查询和数据分析的应用。</li><li>需要事务处理和数据完整性保证的场景。</li><li>处理大量结构化数据和关系型数据。</li><li>需要多用户并发访问和数据安全性的应用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>桌面图标.md</title>
    <link href="/2024/08/29/mdstorage/domain/linux/%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87/"/>
    <url>/2024/08/29/mdstorage/domain/linux/%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h2 id="Linux-桌面应用图标"><a href="#Linux-桌面应用图标" class="headerlink" title="Linux 桌面应用图标"></a>Linux 桌面应用图标</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># .desktop 放到 ~/.local/share/applications/your_app_name.desktop 是用户目录</span><br><span class="hljs-comment"># /usr/share/applications/your_app_name.desktop 是系统应用目录</span><br>[Desktop Entry]<br><span class="hljs-attribute">Type</span>=Application<br><span class="hljs-attribute">Name</span>=List Dashboard<br><span class="hljs-attribute">Exec</span>=/opt/mystorage/github/list_dashboard/build/linux/x64/release/bundle/list_dashboard<br><span class="hljs-attribute">Icon</span>=/opt/mystorage/github/list_dashboard/linux/icons/Icon-512.png<br><span class="hljs-attribute">Comment</span>=Your Application Description<br><span class="hljs-attribute">Terminal</span>=<span class="hljs-literal">false</span><br><span class="hljs-attribute">Categories</span>=Utility;<br><br>Type：条目的类型，对于应用程序应该是 Application。<br>Name：应用程序的名称，将在菜单和搜索中显示。<br>Exec：启动应用程序的命令或可执行文件的路径。<br>Icon：应用程序图标的路径，可以是绝对路径，或者如果图标已安装到系统图标路径，只需图标文件的名称。<br>Comment：应用程序的描述，将在鼠标悬停时显示。<br>Terminal：是否在终端中运行应用程序。对于GUI应用，通常是 <span class="hljs-literal">false</span>。<br>Categories：应用程序分类，帮助在应用菜单中归类。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>沟通.md</title>
    <link href="/2024/08/29/mdstorage/domain/pm/%E6%B2%9F%E9%80%9A/"/>
    <url>/2024/08/29/mdstorage/domain/pm/%E6%B2%9F%E9%80%9A/</url>
    
    <content type="html"><![CDATA[<h2 id="交待任务和询问进度技巧"><a href="#交待任务和询问进度技巧" class="headerlink" title="交待任务和询问进度技巧"></a>交待任务和询问进度技巧</h2><h3 id="1-明确任务目标和期望"><a href="#1-明确任务目标和期望" class="headerlink" title="1. 明确任务目标和期望"></a>1. 明确任务目标和期望</h3><ul><li><strong>具体化任务</strong>：当主管交代任务时，确保了解任务的具体目标和预期成果。询问具体的细节和预期的结果，以便你可以更好地规划和执行。</li><li><strong>阐述目标</strong>：在回应时，重申你对任务目标的理解，确保你和主管对任务的理解是一致的。</li></ul><h3 id="2-识别和聚焦关键点"><a href="#2-识别和聚焦关键点" class="headerlink" title="2. 识别和聚焦关键点"></a>2. 识别和聚焦关键点</h3><ul><li><strong>关键绩效指标（KPIs）</strong>：确定哪些指标或成果是衡量任务成功的关键。</li><li><strong>关注重点</strong>：在讨论进度时，集中讨论这些关键指标的当前状态和任何潜在的挑战。</li></ul><h3 id="3-透明的沟通"><a href="#3-透明的沟通" class="headerlink" title="3. 透明的沟通"></a>3. 透明的沟通</h3><ul><li><strong>真实情况</strong>：提供真实、直接的进度更新。如果遇到问题或延迟，请直接说明。</li><li><strong>风险和挑战</strong>：提前识别并汇报可能影响任务的风险或挑战，以及你的应对计划。</li></ul><h3 id="4-使用简明扼要的语言"><a href="#4-使用简明扼要的语言" class="headerlink" title="4. 使用简明扼要的语言"></a>4. 使用简明扼要的语言</h3><ul><li><strong>避免技术术语</strong>：尽量使用非技术性的语言，除非你的主管对相关技术有深入了解。</li><li><strong>关键信息优先</strong>：首先传达最重要的信息，然后再提供必要的背景或细节。</li></ul><h3 id="5-准备数据和证据"><a href="#5-准备数据和证据" class="headerlink" title="5. 准备数据和证据"></a>5. 准备数据和证据</h3><ul><li><strong>数据支持</strong>：使用具体数据和实例来支持你的进度报告和任何观点。</li><li><strong>可视化展示</strong>：如果可能，使用图表或其他可视化工具来展示复杂的数据或趋势。</li></ul><h3 id="6-提前准备"><a href="#6-提前准备" class="headerlink" title="6. 提前准备"></a>6. 提前准备</h3><ul><li><strong>准备汇报内容</strong>：在与主管交流之前，准备一个简明的进度摘要或任务概览。</li><li><strong>预期问题</strong>：思考主管可能会问哪些问题，并准备好回答。</li></ul><h3 id="7-主动更新"><a href="#7-主动更新" class="headerlink" title="7. 主动更新"></a>7. 主动更新</h3><ul><li><strong>定期更新</strong>：不要等到被询问时才提供信息。定期主动更新任务进度，可以建立信任并减少不必要的担忧。</li><li><strong>建议和反馈</strong>：主动提出建议或寻求反馈，展现你对项目的投入和责任感。</li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>pm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>win10端口转发.md</title>
    <link href="/2024/08/29/mdstorage/domain/windows/win10%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    <url>/2024/08/29/mdstorage/domain/windows/win10%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h2 id="win10-端口转发"><a href="#win10-端口转发" class="headerlink" title="win10 端口转发"></a>win10 <a href="https://www.cnblogs.com/sttchengfei/p/13209761.html">端口转发</a></h2><h3 id="场景用例"><a href="#场景用例" class="headerlink" title="场景用例"></a>场景用例</h3><p>主机 A (Ubuntu22.04) ，虚拟机 B (win10)，B 中连接了 VPN， 可以连接 10.9.220.87，A 通过 B 端口转发连接 10.9.220.87 22 端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">netsh interface portproxy add v4tov4 listenaddress=192.168.122.36 listenport=22 connectaddress=10.9.220.87 connectport=22<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>windows</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>信创.md</title>
    <link href="/2024/08/29/mdstorage/domain/%E4%BF%A1%E5%88%9B/%E4%BF%A1%E5%88%9B/"/>
    <url>/2024/08/29/mdstorage/domain/%E4%BF%A1%E5%88%9B/%E4%BF%A1%E5%88%9B/</url>
    
    <content type="html"><![CDATA[<h2 id="信创（飞腾）"><a href="#信创（飞腾）" class="headerlink" title="信创（飞腾）"></a>信创（飞腾）</h2><p><strong>鲲鹏920</strong>是目前业界领先的<strong>ARM-based处理器</strong>。该处理器采用<strong>7nm制造工艺</strong>，基于<strong>ARM架构授权</strong>，由华为公司自主设计完成。通过优化分支预测算法、提升运算单元数量、改进内存子系统架构<strong>等一系列微架构设计</strong>，大幅提高处理器性能。典型主频下，<strong>SPECint Benchmark评分超过930</strong>，超出业界标杆25%。同时，能效比优于业界标杆30%。鲲鹏920以更低功耗为数据中心提供更强性能¹。</p><p><strong>飞腾S2500</strong>是目前国产性能最强的多路服务器系统。作为<strong>16nm工艺CPU</strong>，性能已跟7nm的华为鲲鹏920难分伯仲。而CPU制作工艺缩小会提高CPU性能，预计明后年发布的<strong>7nmS5000</strong>、<strong>5nmS6000</strong>将会在性能上有质的飞跃³.</p><p>两者之间的性能差异值得深入思考。例如，<strong>鲲鹏920</strong>拥有<strong>64个核心</strong>，而<strong>飞腾S2500</strong>则有<strong>16个NUMA节点</strong>。较少的NUMA节点意味着访存一致性更好。此外，鲲鹏的缓存量相对较少，尽管一般来说，缓存越多性能越好，但怀疑飞腾的多核之间的通信可能不够优化，导致缓存总数较多⁴。</p><p>总之，这两款处理器在不同方面都有各自的优势，具体应用场景和需求会影响选择。⁵</p><p>源: 与必应的对话， 2024&#x2F;2&#x2F;18<br>(1) 鲲鹏920芯片 | 海思官网 - HiSilicon. <a href="https://www.hisilicon.com/cn/products/kunpeng/huawei-kunpeng/huawei-kunpeng-920">https://www.hisilicon.com/cn/products/kunpeng/huawei-kunpeng/huawei-kunpeng-920</a>.<br>(2) 如何了解鲲鹏920与飞腾S2500性能对比的概念是怎样的?. <a href="https://www.hanghangcha.com/hhcQuestion/detail/933930.html">https://www.hanghangcha.com/hhcQuestion/detail/933930.html</a>.<br>(3) 飞腾与鲲鹏性能差异的一些思考 - 济南小老虎 - 博客园. <a href="https://www.cnblogs.com/jinanxiaolaohu/p/17267168.html">https://www.cnblogs.com/jinanxiaolaohu/p/17267168.html</a>.<br>(4) 鲲鹏920与飞腾S2500性能对 - 行业研究数据 - 小牛行研. <a href="https://www.hangyan.co/charts/2532558532885087241">https://www.hangyan.co/charts/2532558532885087241</a>.<br>(5) Intel、海光、鲲鹏920、飞腾2500 CPU性能对比 | plantegg. <a href="https://bing.com/search?q=%E9%B2%B2%E9%B9%8F920+%E9%A3%9E%E8%85%BEs2500">https://bing.com/search?q=%e9%b2%b2%e9%b9%8f920+%e9%a3%9e%e8%85%bes2500</a>.</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>信创</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mkdoc.md</title>
    <link href="/2024/08/29/mdstorage/domain/%E6%96%87%E6%A1%A3/mkdocs/"/>
    <url>/2024/08/29/mdstorage/domain/%E6%96%87%E6%A1%A3/mkdocs/</url>
    
    <content type="html"><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h2 id="mkdocs"><a href="#mkdocs" class="headerlink" title="mkdocs"></a>mkdocs</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><a href="https://yangjh.gitee.io/mkdocs/">https://yangjh.gitee.io/mkdocs/</a></p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p><a href="https://squidfunk.github.io/mkdocs-material/reference/diagrams/">https://squidfunk.github.io/mkdocs-material/reference/diagrams/</a></p><p>mkdocs serve –dev-addr 172.16.1.216:12520 -f mkdocs.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">site_name:</span> <span class="hljs-string">stone-mdstorage</span><br><span class="hljs-attr">site_url:</span> <span class="hljs-string">http://172.16.1.216:12520</span><br><span class="hljs-attr">theme:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;material&#x27;</span><br>  <span class="hljs-attr">features:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">mermaid</span><br><br><span class="hljs-attr">markdown_extensions:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">pymdownx.superfences:</span><br>      <span class="hljs-attr">custom_fences:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mermaid</span><br>          <span class="hljs-attr">class:</span> <span class="hljs-string">mermaid</span><br>          <span class="hljs-attr">format:</span> <span class="hljs-type">!!python/name:pymdownx.superfences.fence_code_format</span><br><br></code></pre></td></tr></table></figure><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p><a href="https://github.com/mkdocs/mkdocs/wiki/MkDocs-Plugins">https://github.com/mkdocs/mkdocs/wiki/MkDocs-Plugins</a></p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文档</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>技术方案.md</title>
    <link href="/2024/08/29/mdstorage/domain/%E6%9E%B6%E6%9E%84/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    <url>/2024/08/29/mdstorage/domain/%E6%9E%B6%E6%9E%84/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h2 id="方案设计标准"><a href="#方案设计标准" class="headerlink" title="方案设计标准"></a>方案设计标准</h2><ol><li>设计时要做到、交付后、只剩下交付后涉及人员能搞定的事情。</li><li>systemd 的机制调研文档</li></ol>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>kvm网络.md</title>
    <link href="/2024/08/29/mdstorage/domain/%E8%99%9A%E6%8B%9F%E5%8C%96/kvm%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/08/29/mdstorage/domain/%E8%99%9A%E6%8B%9F%E5%8C%96/kvm%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="KVM-配置桥接网络"><a href="#KVM-配置桥接网络" class="headerlink" title="KVM 配置桥接网络"></a>KVM 配置桥接网络</h2><h4 id="KVM之配置桥接网卡"><a href="#KVM之配置桥接网卡" class="headerlink" title="KVM之配置桥接网卡"></a><a href="https://www.cnblogs.com/wshenjin/p/11096847.html">KVM之配置桥接网卡</a></h4>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机书籍.md</title>
    <link href="/2024/08/29/mdstorage/resource/%E4%B9%A6%E7%B1%8D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%A6%E7%B1%8D/"/>
    <url>/2024/08/29/mdstorage/resource/%E4%B9%A6%E7%B1%8D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%A6%E7%B1%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h2><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li><p>从零开始学架构</p></li><li><p>C++ primer</p></li><li><p>C++ 模板编程</p></li><li><p>数据密集型应用系统设计</p></li><li><p>正则表达式必知必会</p></li><li><p>程序员修炼之道</p></li><li><p>深入理解 linux 内核</p></li><li><p>深入理解Linux 网络内幕</p></li><li><p>大规模分布式系统</p></li></ul><h2 id="实践技术"><a href="#实践技术" class="headerlink" title="实践技术"></a>实践技术</h2><ul><li>client-go   条件锁</li><li>Raft 协议</li><li>GMP 模型</li><li>精通git</li></ul>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>书籍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机领域.md</title>
    <link href="/2024/08/29/mdstorage/resource/%E4%BA%BA%E7%89%A9/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%A2%86%E5%9F%9F/"/>
    <url>/2024/08/29/mdstorage/resource/%E4%BA%BA%E7%89%A9/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%A2%86%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>计算机领域的牛人</p><h3 id="plantegg-硬件-CPU-网络"><a href="#plantegg-硬件-CPU-网络" class="headerlink" title="plantegg 硬件 CPU 网络"></a>plantegg 硬件 CPU 网络</h3><p><a href="https://plantegg.github.io/">https://plantegg.github.io/</a> </p>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>人物</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一种软件商业模式概要.md</title>
    <link href="/2024/08/22/mdstorage/domain/%E5%95%86%E4%B8%9A/%E4%B8%80%E7%A7%8D%E8%BD%AF%E4%BB%B6%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A6%81/"/>
    <url>/2024/08/22/mdstorage/domain/%E5%95%86%E4%B8%9A/%E4%B8%80%E7%A7%8D%E8%BD%AF%E4%BB%B6%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A6%81/</url>
    
    <content type="html"><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>如果自己研发能力与市场产品差距太大的情况, 不如直接使用现成开源的软件, 通过对一个新的 web 界面进行配置下发, 来达到使用的目的. </p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>商业</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络安全-Suricata.md</title>
    <link href="/2024/08/22/mdstorage/resource/%E6%98%8E%E6%98%9F%E4%BA%A7%E5%93%81/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-Suricata/"/>
    <url>/2024/08/22/mdstorage/resource/%E6%98%8E%E6%98%9F%E4%BA%A7%E5%93%81/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-Suricata/</url>
    
    <content type="html"><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Suricata 是一个高性能的网络入侵检测和防御系统（IDS&#x2F;IPS）。它是由OISF开发，完全开源，并且可以免费使用</p><p><a href="https://www.cnblogs.com/smileleooo/p/18169413">Suricata</a></p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>仓库: </p>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>明星产品</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>条件调试.md</title>
    <link href="/2024/08/22/mdstorage/domain/ide/idea/%E6%9D%A1%E4%BB%B6%E8%B0%83%E8%AF%95/"/>
    <url>/2024/08/22/mdstorage/domain/ide/idea/%E6%9D%A1%E4%BB%B6%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>条件调试</strong>（Conditional Debugging）是一种调试技术，它允许开发者在程序执行过程中设置特定的条件，只有当这些条件满足时，程序才会中断或触发调试操作。这与传统的断点调试有所不同，传统断点是在代码的某一行设置断点，无论任何情况，只要代码执行到那一行，程序就会暂停。而条件调试则是在断点的基础上增加了条件判断，只有当某些特定的条件满足时，断点才会生效。</p><p>在<strong>多个协程运行</strong>的场景下，调试特定的协程是一个常见的挑战。特别是在并发编程中，不同协程可能以不同的顺序执行，且它们之间的交互可能导致复杂的竞态条件和难以预见的错误。<strong>条件调试</strong>在此类场景中也非常有用，尤其是当你需要捕捉满足特定条件的协程来进行调试时。</p><h3 id="多协程运行时捕捉特定条件的场景"><a href="#多协程运行时捕捉特定条件的场景" class="headerlink" title="多协程运行时捕捉特定条件的场景"></a>多协程运行时捕捉特定条件的场景</h3><h4 id="场景描述："><a href="#场景描述：" class="headerlink" title="场景描述："></a>场景描述：</h4><p>假设你有一个并发程序，多个协程（goroutine）正在同时运行。你注意到某个错误或不期望的行为发生在特定的协程上，但问题仅在满足某些条件时才会显现。你需要在这些协程中捕捉到这个特定条件并暂停程序，以便进一步分析。</p><h4 id="示例场景："><a href="#示例场景：" class="headerlink" title="示例场景："></a>示例场景：</h4><p>考虑以下简单的 Go 代码，其中多个协程并发地处理任务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(id <span class="hljs-type">int</span>, wg *sync.WaitGroup)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-comment">// 模拟某种处理</span><br>fmt.Printf(<span class="hljs-string">&quot;Worker %d processing task %d\n&quot;</span>, id, i)<br>time.Sleep(time.Millisecond * <span class="hljs-number">100</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> worker(i, &amp;wg)<br>&#125;<br><br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，有 5 个协程同时运行，每个协程都会执行一些任务。如果你发现只有当 <code>id == 3</code> 且 <code>i == 5</code> 时程序出现异常，想要捕捉这个特定的协程并进行调试，条件调试就非常有用。</p><h4 id="解决方法：条件断点配合协程调试"><a href="#解决方法：条件断点配合协程调试" class="headerlink" title="解决方法：条件断点配合协程调试"></a>解决方法：条件断点配合协程调试</h4><p>在 IDE 或调试器中，你可以执行以下步骤：</p><ol><li><p><strong>设置条件断点</strong>:<br>在 <code>fmt.Printf</code> 这一行设置断点，并添加条件，例如 <code>id == 3 &amp;&amp; i == 5</code>。这样，当且仅当该条件为 <code>true</code> 时，程序将会暂停。这允许你在多个协程中仅调试满足特定条件的协程，而不干扰其他协程的执行。</p></li><li><p><strong>使用调试器工具</strong>:<br>如果你在命令行使用调试器（如 GDB），可以使用类似的方法。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">break</span> main.go:10 <span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span> == 3 &amp;&amp; i == 5<br></code></pre></td></tr></table></figure></li><li><p><strong>协程相关信息</strong>:<br>在调试时，查看当前停止的协程（goroutine）的堆栈信息，确认它是否是你关心的那个协程。现代的 Go 调试器（如 GoLand、Delve）通常会支持查看和切换不同的协程，这样你可以进一步确认问题所在的协程。</p></li><li><p><strong>调试协程间的竞态条件</strong>:<br>在并发程序中，竞态条件是常见的问题。通过条件调试，你可以专注于调试那些特定条件下的协程，捕捉问题的根源。例如，如果你怀疑在某些特定条件下两个协程之间发生了竞态问题，你可以在某个协程运行到特定状态时暂停它，然后切换到其他协程进行检查。</p></li></ol><h2 id="具体操作步骤-Goland"><a href="#具体操作步骤-Goland" class="headerlink" title="具体操作步骤(Goland)"></a>具体操作步骤(Goland)</h2><ul><li>打断点</li><li>右键断点(在 condition 中加入符合的条件)</li></ul><h2 id="待整理"><a href="#待整理" class="headerlink" title="待整理"></a>待整理</h2><p><a href="https://www.jianshu.com/p/7d9dc09fdbe3">Goland 断点调试高级功能</a></p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>ide</category>
      
      <category>idea</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>流量引擎节点管理功能方案.md</title>
    <link href="/2024/08/19/mdstorage/project/sr/%E6%B5%81%E9%87%8F%E5%BC%95%E6%93%8E%E8%8A%82%E7%82%B9%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD%E6%96%B9%E6%A1%88/"/>
    <url>/2024/08/19/mdstorage/project/sr/%E6%B5%81%E9%87%8F%E5%BC%95%E6%93%8E%E8%8A%82%E7%82%B9%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>流量引擎是一个集群组成的具备流量转发 流量监控 的逻辑组件.<br>1.6 之前, 流量引擎分为三种逻辑组件: 管理节点 调度节点 工作节点, 管理节点 调度节点 工作节点同样由多台机器集群组成.<br>在 1.6 后, 流量引擎重新定义节点概念, 将节点定义为机器, 而管理 调度 工作 的职能定义为服务, 所以一个流量引擎集群现在的描述可能为: 该流量引擎有 3 台节点, 节点 A 中部署了管理 调度 服务, 节点 B C 中只部署了 工作 服务.</p><h2 id="产品需求"><a href="#产品需求" class="headerlink" title="产品需求"></a>产品需求</h2><p>此需求重新定义了引擎节点的概念，并对引擎节点管理进行了重新设计。</p><p>主要需求:</p><ul><li>节点列表: </li><li>节点新增: 为已有流量引擎新增节点, 可以批量添加多台, 如果失败则停止, 已经安装成功的节点不卸载</li><li>节点详情</li><li>节点编辑(???)</li><li>节点删除(暂时不做)</li><li>节点替换: 将对已有节点做替换</li><li>节点状态: 点击查看节点状态，跳转『系统管理-运行状态』页面，并将当前引擎、当前节点的数据查询出来</li></ul><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>节点新增功能实现流程图</p><pre><code class=" mermaid">graph LR    a[数据库操作]    b[发布任务]    c[返回任务 ID]    d(&quot;AddSENodes(req)&quot;)    e(&quot;AddMemberIntoCluster(newNode, clusterInfo)&quot;)    f(更新任务状态)        a---&gt;b---&gt;c    b-.-&gt;|异步任务|d--&gt;e    e --&gt;|循环| e    e --&gt; f</code></pre><p>AddSENodes 实现</p><ul><li>查询前面 cluster Info</li><li>遍历要添加的 Nodes , 为每个 Node 调用 AddMemberInfoCluster</li></ul><p>AddMemberInfoCluster 实现</p><ul><li>ssh 连接 node</li><li>组织 InstallConfigV1</li><li>上传 SE 包, 并对 SE 执行 able 安装程序 </li><li>执行成功, 则对 前面 cluster 每个节点执行 able member add newNode</li></ul><h4 id="able-install"><a href="#able-install" class="headerlink" title="able install"></a>able install</h4><p>几乎跟引擎节点安装相同, 但是需要新增 –is-cluster-exist 参数, 标记是加入引擎集群, 在安装中, 会设置 IsClusterExist 的值为 true, 对这个值敏感的程序在自己的 install 程序中可以获取到这个值, 来决定一些特别的操作</p><h4 id="able-member-add-newNode"><a href="#able-member-add-newNode" class="headerlink" title="able member add newNode"></a>able member add newNode</h4><p>执行已安装节点的 member_add action , 如果没有定义这个 action 的组件不执行.<br>在执行 member_add action 时, 会用环境变量表示 newNodeInfo ,  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基础设施类型软件的商业授权方案.md</title>
    <link href="/2024/08/16/mdstorage/domain/%E4%BA%A7%E5%93%81%E7%BB%8F%E9%AA%8C/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%B1%BB%E5%9E%8B%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%95%86%E4%B8%9A%E6%8E%88%E6%9D%83%E6%96%B9%E6%A1%88/"/>
    <url>/2024/08/16/mdstorage/domain/%E4%BA%A7%E5%93%81%E7%BB%8F%E9%AA%8C/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%B1%BB%E5%9E%8B%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%95%86%E4%B8%9A%E6%8E%88%E6%9D%83%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>基础设施即服务型产品</p><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><ul><li>商城 发放授权, 上传授权申请文件, 可下载授权文件</li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>产品经验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一个软件实现盈利的概要分析.md</title>
    <link href="/2024/08/15/mdstorage/domain/%E5%95%86%E4%B8%9A/%E4%B8%80%E4%B8%AA%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E7%9B%88%E5%88%A9%E7%9A%84%E6%A6%82%E8%A6%81%E5%88%86%E6%9E%90/"/>
    <url>/2024/08/15/mdstorage/domain/%E5%95%86%E4%B8%9A/%E4%B8%80%E4%B8%AA%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E7%9B%88%E5%88%A9%E7%9A%84%E6%A6%82%E8%A6%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一个科技公司如何才能实现盈利这个目标</p><h2 id="一个软件实现盈利的过程"><a href="#一个软件实现盈利的过程" class="headerlink" title="一个软件实现盈利的过程"></a>一个软件实现盈利的过程</h2><pre><code class=" mermaid">flowchart TDA[概念与市场调研] --&gt; B[需求分析与定义]B --&gt; C[原型设计与验证]C --&gt; D[架构设计与技术选型]D --&gt; E[开发与测试]E --&gt; F[发布与部署]F --&gt; G[市场推广与销售策略]G --&gt; H[用户获取与反馈]H --&gt; I[产品迭代与优化]I --&gt; J[用户增长与留存]J --&gt; K[收入模式与定价策略]K --&gt; L[实现盈利]</code></pre><ul><li>概念与市场调研：识别市场需求，进行市场调研，提出软件的初步概念。</li><li>需求分析与定义：明确软件功能需求和用户痛点，制定产品的核心功能和目标。</li><li>原型设计与验证：创建产品原型，与潜在用户或利益相关者进行验证和反馈。</li><li>架构设计与技术选型：制定软件的整体架构和技术方案，选择合适的技术栈。</li><li>开发与测试：进行软件开发，持续集成、测试和修复缺陷，确保产品质量。</li><li>发布与部署：将软件发布到市场上，部署到生产环境，并做好运维准备。</li><li>市场推广与销售策略：通过市场营销活动推广软件，制定销售策略，吸引用户。</li><li>用户获取与反馈：获取初期用户，通过反馈完善产品，改善用户体验。</li><li>产品迭代与优化：根据用户反馈和市场需求不断迭代和优化产品功能。</li><li>用户增长与留存：通过有效的用户增长策略和留存策略扩大用户群体，提升用户粘性。</li><li>收入模式与定价策略：确定软件的收入模式（如订阅、一次性购买、广告等）和定价策略。</li><li>实现盈利：通过稳定的收入流实现软件项目的盈利。</li></ul><h2 id="一个科技公司实现盈利的过程"><a href="#一个科技公司实现盈利的过程" class="headerlink" title="一个科技公司实现盈利的过程"></a>一个科技公司实现盈利的过程</h2><pre><code class=" mermaid">flowchart TDA[创业构思与公司成立] --&gt; B[产品开发与技术创新]B --&gt; C[市场调研与定位]C --&gt; D[融资与资金筹措]D --&gt; E[产品推出与市场进入]E --&gt; F[市场推广与用户获取]F --&gt; G[运营优化与用户留存]G --&gt; H[收入模式确定与优化]H --&gt; I[用户增长与市场扩展]I --&gt; J[成本控制与规模效应]J --&gt; K[实现盈利]</code></pre><p>详细步骤说明：</p><ol><li><p><strong>创业构思与公司成立</strong>：公司创始人根据某个市场痛点或技术创新的构思，成立科技公司，制定愿景和使命。</p></li><li><p><strong>产品开发与技术创新</strong>：公司通过研发推出具有竞争力和差异化的产品，利用技术创新来解决特定问题或创造价值。</p></li><li><p><strong>市场调研与定位</strong>：深入研究市场需求、竞争对手、目标用户等，明确公司的市场定位和战略方向。</p></li><li><p><strong>融资与资金筹措</strong>：通过天使投资、风险投资、股权融资等途径获得初创资金，支持公司的发展和扩张。</p></li><li><p><strong>产品推出与市场进入</strong>：将产品推向市场，进入目标市场领域，并进行初期的市场试探和调整。</p></li><li><p><strong>市场推广与用户获取</strong>：通过营销和推广策略，快速获取用户，建立品牌知名度和市场份额。</p></li><li><p><strong>运营优化与用户留存</strong>：不断优化产品和运营策略，提高用户体验，增强用户留存率。</p></li><li><p><strong>收入模式确定与优化</strong>：明确公司收入模式，如订阅、广告、电商、服务收费等，并不断优化以增加收入。</p></li><li><p><strong>用户增长与市场扩展</strong>：扩大用户基数，进入新的市场或领域，实现用户群体的持续增长。</p></li><li><p><strong>成本控制与规模效应</strong>：通过成本控制和优化运营流程，实现规模效应，降低边际成本，提升利润率。</p></li><li><p><strong>实现盈利</strong>：通过持续增长的收入和有效的成本控制，最终实现公司整体盈利。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>商业</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker-golang设置modcache加快编译速度.md</title>
    <link href="/2024/08/15/mdstorage/domain/%E8%99%9A%E6%8B%9F%E5%8C%96/docker-golang%E8%AE%BE%E7%BD%AEmodcache%E5%8A%A0%E5%BF%AB%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6/"/>
    <url>/2024/08/15/mdstorage/domain/%E8%99%9A%E6%8B%9F%E5%8C%96/docker-golang%E8%AE%BE%E7%BD%AEmodcache%E5%8A%A0%E5%BF%AB%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>如果每次只提供源码进行 docker build 一个 golang 项目, 那么每次都会拉取依赖仓库, 所以希望能充分利用缓存机制来减少 docker build 的时间.</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>go.Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.22</span>.<span class="hljs-number">3</span><br><br><span class="hljs-keyword">ARG</span> HTTP_PROXY<br><span class="hljs-keyword">ARG</span> HTTPS_PROXY<br><br><span class="hljs-keyword">ENV</span> PROJECT_NAME=installer<br><span class="hljs-keyword">ENV</span> GOMODCACHE=/go/pkg/mod<br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span></span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . /<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span></span><br><br><span class="hljs-comment"># 拷贝凭证文件到 Docker 容器中, 这里要确保 .git-credentials 存在</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> .git-credentials /root/.git-credentials</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> git config --global credential.helper <span class="hljs-string">&#x27;store --file=/root/.git-credentials&#x27;</span> &amp;&amp; \</span><br><span class="language-bash">    go <span class="hljs-built_in">env</span> -w GOPRIVATE=git.ouryun.cn,192.168.20.12 &amp;&amp; \</span><br><span class="language-bash">    go <span class="hljs-built_in">env</span> -w GONOSUMDB=git.ouryun.cn,192.168.20.12 &amp;&amp; \</span><br><span class="language-bash">    go <span class="hljs-built_in">env</span> -w GONOPROXY=git.ouryun.cn,192.168.20.12 &amp;&amp; \</span><br><span class="language-bash">    go <span class="hljs-built_in">env</span> -w GOINSECURE=git.ouryun.cn,192.168.20.12 &amp;&amp; \</span><br><span class="language-bash">    go <span class="hljs-built_in">env</span> -w GOPROXY=<span class="hljs-string">&quot;https://goproxy.cn|https://goproxy.io|direct&quot;</span> &amp;&amp; \</span><br><span class="language-bash">    go mod tidy -x</span><br><br><span class="hljs-comment"># 指定容器启动时执行的命令</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> go mod download</span><br><br></code></pre></td></tr></table></figure><p>构建 mod cache</p><ul><li>docker build -t cache_builder -f .&#x2F;go.Dockerfile .</li><li>docker create –name cache_extractor cache_builder</li><li>mkdir temp</li><li>docker cp cache_extractor:&#x2F;go&#x2F;pkg&#x2F;mod .&#x2F;temp&#x2F;</li></ul><p>执行完后 &#x2F;temp 下就会出现 mod, 这时的 mod 目录约 300MB+, 注意会有 open &#x2F;xxxx&#x2F;temp&#x2F;mod&#x2F;cel.dev&#x2F;<a href="mailto:&#101;&#120;&#x70;&#114;&#64;&#118;&#48;&#46;&#49;&#x35;&#x2e;&#48;">&#101;&#120;&#x70;&#114;&#64;&#118;&#48;&#46;&#49;&#x35;&#x2e;&#48;</a>&#x2F;.bazelversion: permission denied 的警告字符的目录或者文件,会报文件权限不够,如果用 sudo 执行, 则可以拷贝出来, 会发现这时的 temp 磁盘占用大很多 1GB+ .</p><p>构建Dockerfile:<br>Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> srmysql<br><br><span class="hljs-keyword">ARG</span> HTTP_PROXY<br><span class="hljs-keyword">ARG</span> HTTPS_PROXY<br><br><span class="hljs-keyword">ENV</span> PROJECT_NAME=installer<br><span class="hljs-keyword">ENV</span> SC_IP=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-keyword">ENV</span> GOMODCACHE=/go/pkg/mod<br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; apt-get -y install gettext</span><br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span></span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . /<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span></span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> temp/mod /go/pkg/mod</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go mod download</span><br><br><span class="hljs-comment"># 拷贝凭证文件到 Docker 容器中, 这里要确保 .git-credentials 存在</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> git config --global credential.helper <span class="hljs-string">&#x27;store --file=/$&#123;PROJECT_NAME&#125;/.git-credentials&#x27;</span> &amp;&amp; \</span><br><span class="language-bash">    go <span class="hljs-built_in">env</span> -w GOPRIVATE=git.ouryun.cn,192.168.20.12 &amp;&amp; \</span><br><span class="language-bash">    go <span class="hljs-built_in">env</span> -w GONOSUMDB=git.ouryun.cn,192.168.20.12 &amp;&amp; \</span><br><span class="language-bash">    go <span class="hljs-built_in">env</span> -w GONOPROXY=git.ouryun.cn,192.168.20.12 &amp;&amp; \</span><br><span class="language-bash">    go <span class="hljs-built_in">env</span> -w GOINSECURE=git.ouryun.cn,192.168.20.12 &amp;&amp; \</span><br><span class="language-bash">    go <span class="hljs-built_in">env</span> -w GOPROXY=<span class="hljs-string">&quot;https://goproxy.cn|https://goproxy.io|direct&quot;</span> &amp;&amp; \</span><br><span class="language-bash">    go install github.com/go-delve/delve/cmd/dlv@latest &amp;&amp; \</span><br><span class="language-bash">    go mod tidy -x</span><br><br><span class="hljs-comment"># 构建应用</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> make release</span><br><span class="hljs-comment"># 指定容器启动时执行的命令</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> -p /opt/public/ &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;SCIP=172.17.0.200&quot;</span> | <span class="hljs-built_in">tee</span> -a /opt/public/.env</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8098</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">2345</span><br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/lib/systemd/systemd&quot;</span>]</span><br><br></code></pre></td></tr></table></figure><p>主要起作用的两行:</p><ul><li>COPY temp&#x2F;mod &#x2F;go&#x2F;pkg&#x2F;mod</li><li>RUN go mod download</li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>strace排查异步shell执行失败问题.md</title>
    <link href="/2024/08/07/mdstorage/project/%E5%AE%9D%E8%B4%B5%E7%BB%8F%E9%AA%8C/strace%E6%8E%92%E6%9F%A5%E5%BC%82%E6%AD%A5shell%E6%89%A7%E8%A1%8C%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
    <url>/2024/08/07/mdstorage/project/%E5%AE%9D%E8%B4%B5%E7%BB%8F%E9%AA%8C/strace%E6%8E%92%E6%9F%A5%E5%BC%82%E6%AD%A5shell%E6%89%A7%E8%A1%8C%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h2><ol><li>golang 中实现 执行命令的方法</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Client)</span></span> Output(name <span class="hljs-type">string</span>, arg ...<span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>session, err := c.sshClient.NewSession()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;fail to create ssh seesion %w&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> session.Close()<br><br><span class="hljs-comment">//cmdStr := strings.Join(append([]string&#123;name&#125;, arg...), &quot; &quot;)</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//logger.Logger.Debugf(&quot;Output executing ssh command %s in %s&quot;, cmdStr, c.addr)</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//return session.Output(cmdStr)</span><br><span class="hljs-comment">// Set up output buffers for stdout and stderr</span><br><span class="hljs-keyword">var</span> stdoutBuf, stderrBuf strings.Builder<br>session.Stdout = &amp;stdoutBuf<br>session.Stderr = &amp;stderrBuf<br><br>cmdStr := strings.Join(<span class="hljs-built_in">append</span>([]<span class="hljs-type">string</span>&#123;name&#125;, arg...), <span class="hljs-string">&quot; &quot;</span>)<br><br><span class="hljs-comment">// Run the command</span><br>err = session.Run(cmdStr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// Combine stdout and stderr for detailed error message</span><br>output := stdoutBuf.String() + <span class="hljs-string">&quot;\n&quot;</span> + stderrBuf.String()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;command execution failed: %w ;Output:%s &quot;</span>, err, output)<br>&#125;<br><br><span class="hljs-comment">// Return combined output of stdout and stderr</span><br><span class="hljs-keyword">return</span> []<span class="hljs-type">byte</span>(stdoutBuf.String() + <span class="hljs-string">&quot;\n&quot;</span> + stderrBuf.String()), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在执行 xxxx &amp; 后, 父进程退出时, 此子进程会退出</p><p>后面 用 strace 跟踪, 才发现打开了一个匿名管道, 因为 golang session.Run 方法里面会为这个命令打开一个匿名管道, 然后异步命令执行后, 父进程退出, 将匿名管道退出, 子进程收到匿名管道退出的信号,结果退出了. </p>]]></content>
    
    
    <categories>
      
      <category>project</category>
      
      <category>宝贵经验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql安装.md</title>
    <link href="/2024/08/05/mdstorage/domain/db/Mysql%E5%AE%89%E8%A3%85/"/>
    <url>/2024/08/05/mdstorage/domain/db/Mysql%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://dev.mysql.com/get/Downloads/MySQL-8.3/mysql-8.3.0-linux-glibc2.28-x86_64.tar.xz">mysql 8.3 下载</a></p><h2 id="mysql-5-7-安装"><a href="#mysql-5-7-安装" class="headerlink" title="mysql 5.7 安装"></a>mysql 5.7 安装</h2><p><a href="https://developer.aliyun.com/article/1519212">阿里云下载安装</a></p><h4 id="配置-mysql-启动参数"><a href="#配置-mysql-启动参数" class="headerlink" title="配置 mysql 启动参数"></a>配置 mysql 启动参数</h4><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nsis">--<span class="hljs-literal">user</span>=root<br><br>/lib/<span class="hljs-params">system</span>d/<span class="hljs-params">system</span>/mysql.service<br></code></pre></td></tr></table></figure><h4 id="本地设置-root-密码"><a href="#本地设置-root-密码" class="headerlink" title="本地设置 root 密码"></a>本地设置 root 密码</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -uroot -<span class="hljs-selector-tag">p</span>    第一次不输入密码可以进入<br></code></pre></td></tr></table></figure><h4 id="设置远程密码"><a href="#设置远程密码" class="headerlink" title="设置远程密码"></a>设置远程密码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> privileges <span class="hljs-keyword">on</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;root&#x27;</span> @<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;$youpassword&#x27;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>db</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>installer机制.md</title>
    <link href="/2024/06/24/mdstorage/project/sr/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%9B%B8%E5%85%B3/installer%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/06/24/mdstorage/project/sr/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%9B%B8%E5%85%B3/installer%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>记录 installer 相关的机制，有的需要整理，有些需要改正的会渐渐改正</p><h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><h3 id="安装、卸载、进度条，异步任务处理机制"><a href="#安装、卸载、进度条，异步任务处理机制" class="headerlink" title="安装、卸载、进度条，异步任务处理机制"></a>安装、卸载、进度条，异步任务处理机制</h3><h3 id="使用-redis-分布式锁机制"><a href="#使用-redis-分布式锁机制" class="headerlink" title="使用 redis 分布式锁机制"></a>使用 redis 分布式锁机制</h3><h4 id="sc-侧使用-redis-逻辑"><a href="#sc-侧使用-redis-逻辑" class="headerlink" title="sc 侧使用 redis 逻辑"></a>sc 侧使用 redis 逻辑</h4><p>pkg&#x2F;empower&#x2F;redis_lock&#x2F;lock.go:26<br>外部使用的接口 TryLock UnLock ，其他的没有使用到</p><h4 id="installer-侧使用-redis-逻辑"><a href="#installer-侧使用-redis-逻辑" class="headerlink" title="installer 侧使用 redis 逻辑"></a>installer 侧使用 redis 逻辑</h4><p>manager&#x2F;task&#x2F;redis.go:26<br>新的 kvstorage 需要实现<br>使用 flock 实现 ？？？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">type</span> kvStorage <span class="hljs-keyword">interface</span> &#123;<br>NewWithTTL(key <span class="hljs-type">string</span>, ttl time.Duration) Storage<br>&#125;<br><span class="hljs-keyword">type</span> Storage <span class="hljs-keyword">interface</span> &#123;<br>Put(any) <span class="hljs-type">error</span><br>Get(any) <span class="hljs-type">error</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>installer db整理.md</title>
    <link href="/2024/06/24/mdstorage/project/sr/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%9B%B8%E5%85%B3/installer%20db%E6%95%B4%E7%90%86/"/>
    <url>/2024/06/24/mdstorage/project/sr/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%9B%B8%E5%85%B3/installer%20db%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>整理 installer-sr-server 使用的数据库逻辑</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="manager"><a href="#manager" class="headerlink" title="manager"></a>manager</h3><pre><code class=" mermaid">classDiagramdirection LRclass card_ip_mask &#123;   varchar(32) engine_serial  /* 引擎序列号 */   varchar(16) node_ip  /* 节点ip */   text ip_masks   datetime create_at   bigint id&#125;class t_agent &#123;   varchar(100) name   varchar(45) ip   bigint mirror_id   varchar(320) capture_iface   text iface   text capture_filter   varchar(10) filter_mode   tinyint(1) auto_suspend   tinyint system_cpu_overlimit   tinyint system_cpu_recover   tinyint system_mem_overlimit   tinyint system_mem_recover   tinyint agent_cpu_overlimit   tinyint agent_mem_overlimit   bigint access_time   bigint install_time   varchar(20) running_status   int reason   varchar(36) uuid&#125;class t_cert &#123;   varchar(32) name  /* 名称 */   varchar(32) key_name  /* 私钥名称 */   varchar(32) cert_name  /* 证书名称 */   text key   text cert   datetime create_at   bigint id&#125;class t_engine &#123;   install_type  /* 安装类型(1 代表在线 2 代表离线) */ tinyint   engine_type  /* 引擎类型(1 代表默认的引擎，2 代表边车引擎) */ tinyint   varchar(64) serial_number  /* 引擎序列号 */   datetime expire_time  /* 过期时间 */   varchar(64) engine_name  /* 引擎名称 */   varchar(64) engine_name_in_license  /* 授权文件中的引擎名 */   varchar(64) latest_version  /* 可升级包版本 */   varchar(64) current_version  /* 当前引擎版本 */   varchar(64) source  /* 来源 */   varchar(64) public_time  /* 发布时间 */   int major  /* 主版本号 */   int minor  /* 次版本号 */   int build  /* 内部版本号 */   tinyint delete_flag  /* 删除标记 0 未删除 1 删除 */   datetime create_at  /* 创建时间 */   datetime update_at  /* 更新时间 */   status  /* 状态(0 未定义,1 正常,2 已撤销) */ tinyint   varchar(1024) machine_code  /* 机器码 */   varchar(16) machine_ip  /* 机器ip */   bigint id&#125;class t_engine_global_param &#123;   bigint engine  /* 所属引擎 */   tinyint deploy_mode  /* 安装模式 1 默认模式 2 透明部署 3 路由模式 */   bigint process_id  /* 归属安装进程id */   int admin_virtual_router_id  /* 管理端虚拟路由id */   int data_virtual_router_id  /* 数据段虚拟路由id */   varchar(128) vip  /* 管理面浮动ip */   varchar(128) gateway_ip  /* 网关ip */   bridge_ip  /* 网桥ip(透明部署) */ varchar(128)   bridge_gateway  /* 网桥网关(透明部署) */ varchar(128)   network_device1  /* 网卡设备1(透明部署) */ varchar(128)   network_device2  /* 网卡设备2(透明部署) */ varchar(128)   varchar(128) upstream_bind_source_address  /* 上游绑定地址 */   is_transparent_deployment  /* 是否透明部署(2 否 1 是) */ tinyint   tinyint is_straight_through  /* 是否开通直通 2 否 1 是 */   tinyint mode  /* 节点模式, 0/1 单节点/三节点 */   varchar(255) cert_name  /* 证书名称 */   varchar(1024) cert_path  /* 证书路径 */   varchar(1024) cert_url  /* 证书url */   varchar(128) cert_hash  /* 证书hash */   int master_node_id  /* 安装时选定的管理面主节点，不一定永远是主节点 */   varchar(2048) token  /* 用来访问apiserver */   varchar(2048) token_csv  /* tokencsv */   varchar(4096) ca_base64  /* caBase64 */   varchar(2048) salt  /* 盐 */   varchar(2048) secret   varchar(32) sky_working_oap_addr  /* skyWorking地址 */   text bound_tls_key  /* 业务私钥 */   text bound_tls_cert  /* 业务公钥 */   varchar(32) tls_key_name  /* 私钥名称 */   varchar(32) tls_cert_name  /* 公钥名称 */   text out_bound_tls_key  /* 业务私钥 */   text out_bound_tls_cert  /* 业务公钥 */   varchar(32) out_tls_key_name  /* 私钥名称 */   varchar(32) out_tls_cert_name  /* 公钥名称 */   text cluster_info  /* 集群信息 */   tinyint version_tag   datetime create_at  /* 创建时间 */   datetime update_at  /* 更新时间 */   bigint id&#125;class t_engine_install_processes &#123;   action_type  /* 执行动作类型(1 安装 2 添加节点 3 升级 4 回退 5 卸载 6 删除节点) */ tinyint   int engine  /* 归属引擎id */   varchar(64) name  /* 安装进程名 */   tinyint status  /* 状态 0 未安装 1 安装中 2 已安装 3 安装失败 4 升级中 5 升级成功 6 升级失败 7 卸载中 8 卸载成功 ... */   varchar(64) se_version  /* 引擎版本 */   int major  /* 主版本号 */   int minor  /* 次版本号 */   int build  /* 内部版本号 */   datetime create_at  /* 创建时间 */   datetime update_at  /* 更新时间 */   bigint id&#125;class t_engine_nodes &#123;   varchar(16) ipv4  /* 节点ip */   varchar(20) ip_mask  /* ip加子网掩码 */   int engine  /* 归属引擎的id */   int ssh_port  /* ssh端口 */   varchar(255) ssh_username  /* ssh用户 */   varchar(255) ssh_password  /* ssh密码 */   is_se_m  /* 是否是管理面节点 (2 不是 1 是) */ tinyint   tinyint sem_delete_flag  /* sem删除标记 */   is_se_s  /* 是否是数据面高可用节点(2 不是 1 是) */ tinyint   tinyint ses_delete_flag  /* ses删除标记 */   is_se_w  /* 是否是工作节点(2 不是 1 是) */ tinyint   tinyint sew_delete_flag  /* sew删除标记 */   tinyint is_side_car  /* 是否是边车引擎节点 */   tinyint is_sew_route  /* 是否是路由模式工作节点 */   tinyint sew_route_delete_flag  /* sewRoute删除标记 */   varchar(128) se_m_network_card  /* 管理面节点网卡 */   varchar(128) se_m_network_card_all  /* 管里面节点网卡加ip */   varchar(128) se_s_network_card  /* 数据面节点网卡 */   varchar(128) se_s_network_card_all  /* 数据面节点网卡加ip */   varchar(128) se_w_network_card  /* 工作节点网卡 */   varchar(128) se_w_network_card_all  /* 工作节点网卡加ip */   varchar(128) sew_route_network_card  /* 路由模式工作节点网卡 */   varchar(128) sew_route_network_card_all  /* 路由模式工作节点网卡加ip */   varchar(255) sew_package_serial  /* sew包序列号 */   tinyint is_agent_installed  /* 是否已安装agent */   varchar(255) name  /* 节点名称 */   varchar(64) uuid  /* 节点UUID */   int delete_flag   text business_port   text export_traffic_port   varchar(64) os_version  /* 节点操作系统版本 */   varchar(255) package_os_version  /* 包归属操作系统版本 */   bigint package_id  /* 包id */   datetime create_at  /* 创建时间 */   datetime update_at  /* 更新时间 */   varchar(128) data_nic_ip  /* 数据面业务口ip */   bigint id&#125;class t_engine_packages &#123;   int engine_id  /* 所属引擎的id */   is_use_replication  /* 包是否可复用 (1 可复用 2 不可 3 其他) */ tinyint   int used  /* 已经使用次数 */   max_use  /* 最大使用次数(0 不限制使用次数) 默认值为1 */ int   package_type  /* 包类型(0 未知 1 SE-M 2 SE-S 3 SE-W) */ tinyint   varchar(64) serial_number  /* 序列号 */   varchar(255) name  /* 授权包名称 */   varchar(255) display_name  /* 显示名称 */   varchar(64) version  /* 版本号 */   varchar(1024) path  /* 包路径 */   varchar(1024) url  /* 包url */   varchar(128) hash  /* hash值 */   varchar(128) license_hash  /* license hash */   varchar(64) source  /* 来源 */   datetime expire_time  /* 过期时间 */   text require  /* agent.require文件内容 */   use_flag  /* (1 未使用 2 已使用 3 正在使用 4 未知) */ tinyint   process_id  /* 归属安装进程id (0 代表任何安装进程可使用) */ int   node_ip  /* 归属节点ip (0 代表任何节点可使用) */ varchar(20)   status  /* 状态(0 未定义,1 正常,2 已撤销) */ tinyint   int step_all  /* 安装总步骤 */   varchar(255) os  /* 适配操作系统 */   text support_os_version  /* 支持的操作系统版本 */   datetime create_at  /* 创建时间 */   datetime update_at  /* 更新时间 */   bigint id&#125;class t_fail_table &#123;   varchar(16) node_ip  /* 失败节点 */   int engine   tinyint package_type   tinyint status  /* 失败状态 */   tinyint action  /* 执行动作 */   text message  /* 失败描述 */   datetime create_at   bigint id&#125;class t_mirror &#123;   varchar(36) uuid   varchar(16) install_type   varchar(100) name   varchar(100) license_name   varchar(16) sn   varchar(16) version   varchar(16) installed_version   smallint agent_max_license   smallint agent_access_count   smallint agent_active_count   varchar(20) status   varchar(45) ip   varchar(20) running_status   bigint install_time   text mgnt_iface   text data_iface   varchar(300) ssh   varchar(255) os   varchar(36) task_uid   bigint component_bitmap   tinyint(1) invalid_license   text mirror_filter   int id&#125;class t_node_record &#123;   int install_process_id  /* 安装进程id */   int node_id  /* 节点id */   tinyint is_se_m  /* 是否是se-m节点 */   tinyint se_m_status  /* 状态 0 未安装 1 安装中 2 已安装 3 安装失败 4 升级中 5 升级成功 6 升级失败 7 卸载中 8 卸载成功 ... */   tinyint is_se_s  /* 是否是se-s节点 */   tinyint se_s_status  /* 状态 0 未安装 1 安装中 2 已安装 3 安装失败 4 升级中 5 升级成功 6 升级失败 7 卸载中 8 卸载成功 ... */   tinyint is_se_w  /* 是否是se-w节点 */   tinyint se_w_status  /* 状态 0 未安装 1 安装中 2 已安装 3 安装失败 4 升级中 5 升级成功 6 升级失败 7 卸载中 8 卸载成功 ... */   varchar(16) se_version  /* 引擎版本 */   datetime create_at  /* 创建时间 */   datetime update_at  /* 更新时间 */   bigint id&#125;class t_process_node &#123;   varchar(20) node_ip  /* 用于查询节点的静态信息 */   int process_id  /* 归属安装进程的id */   action_type  /* 执行动作类型(1 安装 2 添加节点 3 升级 4 回退 5 卸载 6 删除节点) */ tinyint   is_install_se_m  /* 是否是安装SE-M (0 不是 1 是) */ tinyint   int se_m_steplevel1  /* se-m已安装的步骤 */   int se_m_steplevel_all  /* se-m总的安装步骤 */   tinyint se_m_status  /* 状态 0 未安装 1 安装中 2 已安装 3 安装失败 4 升级中 5 升级成功 6 升级失败 7 卸载中 8 卸载成功 ... */   tinyint is_install_side_car  /* 是否安装边车引擎 */   is_install_se_s  /* 是否是安装SE-S (0 不是 1是) */ tinyint   int se_s_steplevel1  /* se-s已安装的步骤 */   int se_s_steplevel_all  /* se-s总的安装步骤 */   tinyint se_s_status  /* 状态 0 未安装 1 安装中 2 已安装 3 安装失败 4 升级中 5 升级成功 6 升级失败 7 卸载中 8 卸载成功 ... */   is_install_se_w  /* 是否是安装SE-W (0 不是 1 是) */ tinyint   int se_w_steplevel1  /* se-w已安装的步骤 */   int se_w_steplevel_all  /* se-w总的安装步骤 */   int se_w_status  /* 状态 0 未安装 1 安装中 2 已安装 3 安装失败 4 升级中 5 升级成功 6 升级失败 7 卸载中 8 卸载成功 ... */   int step_all  /* 引擎所有组件 */   int step_level1  /* 安装步骤 */   tinyint status  /* 状态 0 未安装 1 安装中 2 已安装 3 安装失败 4 升级中 5 升级成功 6 升级失败 7 卸载中 8 卸载成功 ... */   text message  /* 错误信息 */   datetime create_at  /* 创建时间 */   datetime update_at  /* 更新时间 */   bigint component_bitmap  /* 安装了哪些组件 */   bigint id&#125;class t_replace_record &#123;   varchar(20) engine_id  /* 引擎id */   int process_id  /* 归属安装进程的id */   varchar(16) old_ipv4  /* 被替换节点 */   varchar(16) new_ipv4  /* 替换的目标节点 */   int package_type  /* 替换类型 */   tinyint status  /* 状态 0 未安装 1 安装中 2 已安装 3 安装失败 4 升级中 5 升级成功 6 升级失败 7 卸载中 8 卸载成功 ... */   bigint id&#125;</code></pre><h3 id="表详解"><a href="#表详解" class="headerlink" title="表详解"></a>表详解</h3><p>安装进程表，安装、卸载、升级时使用。开始安装时，创建一条记录，查询安装状态时，查询此表</p><pre><code class=" mermaid">classDiagram    direction LR        class t_engine_install_processes &#123;       action_type  /* 执行动作类型(1 安装 2 添加节点 3 升级 4 回退 5 卸载 6 删除节点) */ tinyint       int engine  /* 归属引擎id */       varchar(64) name  /* 安装进程名 */       tinyint status  /* 状态 0 未安装 1 安装中 2 已安装 3 安装失败 4 升级中 5 升级成功 6 升级失败 7 卸载中 8 卸载成功 ... */       varchar(64) se_version  /* 引擎版本 */       int major  /* 主版本号 */       int minor  /* 次版本号 */       int build  /* 内部版本号 */       datetime create_at  /* 创建时间 */       datetime update_at  /* 更新时间 */       bigint id    &#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sr通信端口、链路整理.md</title>
    <link href="/2024/06/24/mdstorage/project/sr/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0/sr%E9%80%9A%E4%BF%A1%E7%AB%AF%E5%8F%A3%E3%80%81%E9%93%BE%E8%B7%AF%E6%95%B4%E7%90%86/"/>
    <url>/2024/06/24/mdstorage/project/sr/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0/sr%E9%80%9A%E4%BF%A1%E7%AB%AF%E5%8F%A3%E3%80%81%E9%93%BE%E8%B7%AF%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="服务端口"><a href="#服务端口" class="headerlink" title="服务端口"></a>服务端口</h2><h3 id="总控"><a href="#总控" class="headerlink" title="总控"></a>总控</h3><ul><li>sc  80 443</li><li>mysql   3306</li><li>redis   6379</li><li>nsq     4150 4151 4160 4161 </li><li>installer-sr-server 8098</li><li>message-manager    21032</li></ul><h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><h2 id="通信关系"><a href="#通信关系" class="headerlink" title="通信关系"></a>通信关系</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>大组件、小组件生命周期管理设想.md</title>
    <link href="/2024/06/20/mdstorage/project/sr/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%9B%B8%E5%85%B3/%E5%A4%A7%E7%BB%84%E4%BB%B6%E3%80%81%E5%B0%8F%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E8%AE%BE%E6%83%B3/"/>
    <url>/2024/06/20/mdstorage/project/sr/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%9B%B8%E5%85%B3/%E5%A4%A7%E7%BB%84%E4%BB%B6%E3%80%81%E5%B0%8F%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E8%AE%BE%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>大组件、小组件统一升级、安装、回滚、取消安装、卸载、强制卸载 逻辑</p><p>在大型软件的生命周期管理中，选择使用配置文件的方法还是约定优于配置的方法，取决于具体的需求和系统的复杂性。以下是对两种方法的比较及其适用场景的详细分析：</p><h2 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h2><h3 id="总控生命周期"><a href="#总控生命周期" class="headerlink" title="总控生命周期"></a>总控生命周期</h3><pre><code class=" mermaid">sequenceDiagram    participant User    participant UI as Command User Interface    participant Able    participant mysql as mysql    participant installer as installer    participant sc as sc    User -&gt;&gt; User: 解压总控组件包    User -&gt;&gt; UI: 执行安装脚本 install.sh，校验合法性    UI -&gt;&gt; Able: 解析依赖，开始安装总控各组件    Able -&gt;&gt; mysql: 安装组件    mysql --&gt;&gt; Able: 安装成功     Able -&gt;&gt; sc: 安装组件    alt install sc 成功        sc --&gt;&gt; Able: 升级成功    else        sc --&gt;&gt; Able: 升级失败    end                        Able -&gt;&gt; installer: 安装组件</code></pre><h3 id="组件依赖关系"><a href="#组件依赖关系" class="headerlink" title="组件依赖关系"></a>组件依赖关系</h3><h4 id="组件依赖关系说明"><a href="#组件依赖关系说明" class="headerlink" title="组件依赖关系说明"></a>组件依赖关系说明</h4><p>解释依赖关系</p><p>   dependencies: 列出当前组件所依赖的其他组件。在安装或卸载当前组件之前，先处理这些依赖组件的生命周期步骤。</p><p>Able 处理依赖关系</p><p>在 Able 中处理依赖关系时，可以按以下步骤进行：<br>安装操作</p><pre><code class="hljs">解析依赖关系：读取组件的 JSON 配置文件，获取依赖列表。递归安装依赖组件：按照依赖关系的顺序递归安装每个依赖组件。确保所有依赖组件安装成功后，再安装当前组件。执行安装步骤：安装当前组件。</code></pre><p>卸载操作</p><pre><code class="hljs">解析依赖关系：读取组件的 JSON 配置文件，获取依赖列表。递归卸载当前组件：在卸载当前组件之前，检查是否有其他组件依赖于它。卸载依赖组件：按照依赖关系的顺序递归卸载每个依赖组件。确保所有依赖组件卸载成功后，再卸载当前组件。</code></pre><h3 id="Able-处理逻辑"><a href="#Able-处理逻辑" class="headerlink" title="Able 处理逻辑"></a>Able 处理逻辑</h3><pre><code class="hljs">扫描目录：Able 程序扫描所有子目录，查找包含 able.json 文件的目录，并将其识别为组件。解析依赖关系：读取每个组件的 able.json 文件，解析其依赖关系，构建组件依赖关系图。生命周期管理：    安装：按照依赖关系的顺序，依次安装每个组件。确保依赖组件先行安装。    卸载：按照依赖关系的反向顺序，依次卸载每个组件。确保先卸载当前组件后，再卸载其依赖组件。    升级：先升级依赖组件，然后升级当前组件。    初始化：同样按依赖关系的顺序初始化每个组件。    回滚：当某步骤失败时，按依赖关系的反向顺序回滚操作。    取消安装：在安装过程中遇到问题时，执行取消安装逻辑。    强制卸载：不考虑依赖关系，直接卸载组件。    回退：用于将组件回退到之前的版本或状态。 </code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="各组件-able-json-文件结构"><a href="#各组件-able-json-文件结构" class="headerlink" title="各组件 able.json 文件结构"></a>各组件 able.json 文件结构</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sc&quot;</span><span class="hljs-punctuation">,</span>                   <span class="hljs-comment">// 组件名</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.5.9&quot;</span><span class="hljs-punctuation">,</span>             <span class="hljs-comment">// 组件版本号，版本号相同则不升级（mysql kube-apiserver etcd）</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>               <span class="hljs-comment">// 依赖</span><br>    <span class="hljs-string">&quot;mysql&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;redis&quot;</span><span class="hljs-punctuation">,</span>    <br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>              <br>  <span class="hljs-attr">&quot;lifecycle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                  <span class="hljs-comment">// 生命周期配置</span><br>    <span class="hljs-attr">&quot;install&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                  <span class="hljs-comment">// 安装</span><br>      <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./scripts/install.sh&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;previous&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Starting installation&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Installation complete&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;check&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./check_install.sh&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;retry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span>                 <span class="hljs-comment">// 重试次数， 不填就 不重试</span><br>      <span class="hljs-attr">&quot;timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">60</span><span class="hljs-punctuation">,</span>              <span class="hljs-comment">// 超时 second， 默认 3 min</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;init&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                     <span class="hljs-comment">// 初始化阶段，用于初始化配置（总控、引擎修改 IP 这种需求）、数据库、数据迁移等用途</span><br>      <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./scripts/init.sh&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;previous&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Starting initialization&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Initialization complete&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;check&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./check_init.sh&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;trigger_on_dependency_change&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>      <span class="hljs-comment">// 当依赖变化时自动初始化</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;upgrade&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                  <span class="hljs-comment">// 升级</span><br>      <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./scripts/upgrade.sh&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;previous&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Starting upgrade&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Upgrade complete&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;check&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./check_upgrade.sh&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;commit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                   <span class="hljs-comment">// 升级成功确认，说明整个软件已升级完成，将清理前版本数据备份</span><br>      <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./scripts/commit.sh&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;previous&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Starting commit&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Commit complete&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;check&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./check_commit.sh&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;rollback&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                 <span class="hljs-comment">// 回滚</span><br>      <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./scripts/rollback.sh&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;previous&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Starting rollback&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Rollback complete&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;check&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./check_rollback.sh&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;cancel_install&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>            <span class="hljs-comment">// 取消安装</span><br>      <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./scripts/cancel_install.sh&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;previous&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Starting cancel install&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Cancel install complete&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;check&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./check_cancel_install.sh&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;cancel_upgrade&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>            <span class="hljs-comment">// 取消升级</span><br>      <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./scripts/cancel_upgrade.sh&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;previous&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Starting cancel upgrade&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Cancel upgrade complete&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;check&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./check_cancel_upgrade.sh&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;uninstall&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                 <span class="hljs-comment">// 卸载，场景类似于优雅关闭</span><br>      <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./scripts/uninstall.sh&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;previous&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Starting uninstallation&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Uninstallation complete&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;check&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./check_uninstall.sh&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;force_uninstall&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>           <span class="hljs-comment">// 强制卸载, 杀死进程，清理目录</span><br>      <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./scripts/force_uninstall.sh&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;previous&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Starting force uninstallation&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Force uninstallation complete&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;check&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./check_force_uninstall.sh&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-comment">//    &quot;revert&quot;: &#123;                     // 回退 （为后面预留）</span><br><span class="hljs-comment">//      &quot;command&quot;: &quot;./scripts/revert.sh&quot;,</span><br><span class="hljs-comment">//      &quot;previous&quot;: &quot;echo &#x27;Starting revert&#x27;&quot;,</span><br><span class="hljs-comment">//      &quot;after&quot;: &quot;echo &#x27;Revert complete&#x27;&quot;,</span><br><span class="hljs-comment">//      &quot;check&quot;: &quot;./check_force_uninstall.sh&quot;</span><br><span class="hljs-comment">//    &#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;proto_version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span>     <span class="hljs-comment">// 与 able 的协议版本</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webserver&quot;</span><span class="hljs-punctuation">,</span>                   <span class="hljs-comment">// 组件名</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.1.7&quot;</span><span class="hljs-punctuation">,</span>             <span class="hljs-comment">// 组件版本号，版本号相同则不升级</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>               <span class="hljs-comment">// 依赖组件</span><br>    <span class="hljs-string">&quot;kube-apiserver&quot;</span>                       <span class="hljs-comment">// 其他组件名</span><br>    <span class="hljs-string">&quot;etcd&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;suits&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;m&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;s&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;w&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>       <span class="hljs-comment">// 目前有 m , s , w , 流量引擎的组件必须定义这个字段，最后在 able 中整合，安装套件就安装对应组件即可，根据目前调研的结果，各组件满足这种安装</span><br>  <span class="hljs-attr">&quot;lifecycle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                  <span class="hljs-comment">// 生命周期配置</span><br>    <span class="hljs-attr">&quot;install&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                  <span class="hljs-comment">// 安装</span><br>      <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./scripts/install.sh&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;previous&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Starting installation&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Installation complete&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;check&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./check_install.sh&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;retry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span>                 <span class="hljs-comment">// 重试次数</span><br>      <span class="hljs-attr">&quot;timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">60</span><span class="hljs-punctuation">,</span>              <span class="hljs-comment">// 超时 second</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;init&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                     <span class="hljs-comment">// 初始化阶段，用于初始化配置、数据库、数据迁移等用途</span><br>      <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./scripts/init.sh&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;previous&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Starting initialization&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Initialization complete&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;check&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./check_init.sh&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;trigger_on_dependency_change&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>      <span class="hljs-comment">// 当依赖变化后自动初始化</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;upgrade&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                  <span class="hljs-comment">// 升级</span><br>      <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./scripts/upgrade.sh&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;previous&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Starting upgrade&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Upgrade complete&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;check&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./check_upgrade.sh&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;rollback&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                 <span class="hljs-comment">// 回滚</span><br>      <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./scripts/rollback.sh&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;previous&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Starting rollback&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Rollback complete&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;check&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./check_rollback.sh&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;cancel_install&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>            <span class="hljs-comment">// 取消安装</span><br>      <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./scripts/cancel_install.sh&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;previous&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Starting cancel install&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Cancel install complete&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;check&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./check_cancel_install.sh&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;uninstall&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                 <span class="hljs-comment">// 卸载</span><br>      <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./scripts/uninstall.sh&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;previous&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Starting uninstallation&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Uninstallation complete&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;check&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./check_uninstall.sh&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;force_uninstall&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>           <span class="hljs-comment">// 强制卸载</span><br>      <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./scripts/force_uninstall.sh&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;previous&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Starting force uninstallation&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo &#x27;Force uninstallation complete&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;check&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./check_force_uninstall.sh&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;proto_version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span>     <span class="hljs-comment">// 与 able 的协议版本</span><br><span class="hljs-punctuation">&#125;</span><br><br><br></code></pre></td></tr></table></figure><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><pre><code class=" mermaid">sequenceDiagram    participant User    participant UI as User Interface    participant Able    participant DB as Database    participant installer as installer    participant sc as sc    participant mysql as mysql    User -&gt;&gt; UI: 导入软件包    UI -&gt;&gt; Able: 上传软件包    Able -&gt;&gt; Able: 解析包内容    Able -&gt;&gt; DB: 记录包信息到数据库    DB -&gt;&gt; Able: 记录成功    Able -&gt;&gt; UI: 显示安装、升级、卸载等选项    User -&gt;&gt; UI: 点击安装    UI -&gt;&gt; Able: 请求安装    Able -&gt;&gt; DB: 获取组件依赖信息    DB -&gt;&gt; Able: 返回依赖信息    Able -&gt;&gt; installer: 检查依赖 (sc, mysql)    alt sc 未安装        Able -&gt;&gt; sc: 安装 sc        sc -&gt;&gt; Able: 安装成功    end    alt mysql 未安装        Able -&gt;&gt; mysql: 安装 mysql        mysql -&gt;&gt; Able: 安装成功    end    Able -&gt;&gt; installer: 安装 installer    installer -&gt;&gt; Able: 安装成功    Able -&gt;&gt; installer: 初始化 installer    installer -&gt;&gt; Able: 初始化成功    Able -&gt;&gt; UI: 安装完成    User -&gt;&gt; UI: 点击升级    UI -&gt;&gt; Able: 请求升级    Able -&gt;&gt; DB: 获取组件依赖信息    DB -&gt;&gt; Able: 返回依赖信息    Able -&gt;&gt; installer: 检查依赖 (sc, mysql)    alt sc 需升级        Able -&gt;&gt; sc: 升级 sc        sc -&gt;&gt; Able: 升级成功    end    alt mysql 需升级        Able -&gt;&gt; mysql: 升级 mysql        mysql -&gt;&gt; Able: 升级成功    end    Able -&gt;&gt; installer: 升级 installer    installer -&gt;&gt; Able: 升级成功    Able -&gt;&gt; installer: 重新初始化 installer    installer -&gt;&gt; Able: 初始化成功    Able -&gt;&gt; UI: 升级完成    User -&gt;&gt; UI: 点击卸载    UI -&gt;&gt; Able: 请求卸载    Able -&gt;&gt; DB: 获取组件依赖信息    DB -&gt;&gt; Able: 返回依赖信息    Able -&gt;&gt; installer: 检查依赖 (sc, mysql)    Able -&gt;&gt; installer: 卸载 installer    installer -&gt;&gt; Able: 卸载成功    alt sc 无其他依赖        Able -&gt;&gt; sc: 卸载 sc        sc -&gt;&gt; Able: 卸载成功    end    alt mysql 无其他依赖        Able -&gt;&gt; mysql: 卸载 mysql        mysql -&gt;&gt; Able: 卸载成功    end    Able -&gt;&gt; UI: 卸载完成</code></pre><h2 id="总控安装顺序"><a href="#总控安装顺序" class="headerlink" title="总控安装顺序"></a>总控安装顺序</h2><ul><li>installer 中的安装脚本，用户输入</li><li>公共常量写入</li><li></li></ul><h2 id="内部机制"><a href="#内部机制" class="headerlink" title="内部机制"></a>内部机制</h2><h3 id="公共常量的要求"><a href="#公共常量的要求" class="headerlink" title="公共常量的要求"></a>公共常量的要求</h3><p>各个组件可能需要支持安装到同一机器，所以各组件的常量不能冲突，防止出现情况</p><ul><li>A 组件安装时，注入环境变量 a&#x3D;1 b&#x3D;2 c&#x3D;3</li><li>B 组件安装到同一节点，注入环境变量 a&#x3D;21 b&#x3D;2 c&#x3D;3 </li><li>这样最后 a 的值被覆盖了，不准确的，需要整理出，与环境无关，与 A B 组件本身有关的常量</li></ul><p>（流量引擎）节点相关常量（变量） .env 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Bash">GS_VIRD=<br>GS_Mode=<br>GS=<br>GS_EE=<br>GS_MasterIP=<br>GS_IsMaster=<br>GS_ArbiterIP=<br>GS_DaIface=<br>GS_LocalIP=<br>GS_NodeUID=<br>GS_DaIP=<br><br><span class="hljs-comment"># 可能保存下面的作为兼容</span><br>VIRD=      // 路由ID<br>Mode=      // <span class="hljs-string">&quot;代理模式&quot;</span>, <span class="hljs-string">&quot;透明部署模式&quot;</span>, <span class="hljs-string">&quot;路由模式&quot;</span>,  1 2 3<br>GS=        // token<br>GS_EE=     // 引擎SN<br>MasterIP=  // 管理IP<br></code></pre></td></tr></table></figure><h3 id="公共常量的传递"><a href="#公共常量的传递" class="headerlink" title="公共常量的传递"></a>公共常量的传递</h3><p>一些公共常量在安装时的传递过程</p><ul><li>安装组件</li><li>数据库</li><li>安装对应节点 &#x2F;opt&#x2F;public&#x2F;.env 中</li><li>各组件通过 LoadEnv GetEnv 获取这些公共常量</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="产品，是否还有其他对总控、引擎、Agent-其他的生命周期管理方法，如-重启，回退版本"><a href="#产品，是否还有其他对总控、引擎、Agent-其他的生命周期管理方法，如-重启，回退版本" class="headerlink" title="@产品，是否还有其他对总控、引擎、Agent 其他的生命周期管理方法，如 重启，回退版本"></a>@产品，是否还有其他对总控、引擎、Agent 其他的生命周期管理方法，如 重启，回退版本</h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="目前总控、引擎组件名整理"><a href="#目前总控、引擎组件名整理" class="headerlink" title="目前总控、引擎组件名整理"></a>目前总控、引擎组件名整理</h3><p>总控侧</p><ul><li>sc</li><li>manager</li><li>sc-core</li><li>mysql</li><li>nsq</li><li>redis</li><li>apione</li><li>journal</li><li>layer</li></ul><p>流量引擎</p><ul><li>webserver</li><li>adminDam</li><li>dataDam</li><li>polycube</li><li>nuclei</li><li>envoy</li><li>data_ha</li><li>data_worker</li><li>admin_ha</li><li>keepalive  (它不会启动服务)</li></ul><p>边车引擎</p><ul><li>webserver</li><li>envoy</li><li>polycube</li></ul><p>镜像引擎</p><ul><li>webserver</li><li>agent-server</li><li>st-controller</li><li>suricata</li></ul><p>流量Agent</p><ul><li>sr-agent</li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="golang-kit"><a href="#golang-kit" class="headerlink" title="golang-kit"></a>golang-kit</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// 加载 env 文件</span><br><span class="hljs-comment">// LoadEnv(publicEnv)  &quot;/opt/public/.env&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadEnv</span><span class="hljs-params">(envPath <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// Load the .env file</span><br>err := godotenv.Load(envPath)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(<span class="hljs-string">&quot;Error loading .env file: &quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 加载 env 文件</span><br>nodeId := os.Getenv(EnvNodeID)<br></code></pre></td></tr></table></figure><h3 id="总控安装逻辑"><a href="#总控安装逻辑" class="headerlink" title="总控安装逻辑"></a>总控安装逻辑</h3><ul><li>调用 installer 中的 install.sh 脚本</li><li>解析用户输入，校验值合法性，构建公共常量</li><li>解析各组件依赖关系，被依赖的组件先安装，逐步安装完所有组件</li><li>安装完后信息展示</li></ul><h3 id="调度逻辑"><a href="#调度逻辑" class="headerlink" title="调度逻辑"></a>调度逻辑</h3><p>总控、引擎安装调度逻辑</p><ul><li>able 后台开始一个异步安装任务（获取到安装进度，根据已安装组件&#x2F;总组件的数量计算进度）</li><li>拷贝组件包到对应位置</li></ul><h3 id="配置文件方法和目录约定方法的比较"><a href="#配置文件方法和目录约定方法的比较" class="headerlink" title="配置文件方法和目录约定方法的比较"></a>配置文件方法和目录约定方法的比较</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><strong>灵活性</strong>：配置文件可以根据需要灵活定义各种参数和脚本路径，适应不同的需求。</li><li><strong>可扩展性</strong>：可以很容易地添加新的配置选项或调整现有配置，而不需要改变目录结构或命名约定。</li><li><strong>明确性</strong>：配置文件可以清晰地描述组件的所有生命周期步骤和相关参数，易于阅读和维护。</li><li><strong>版本控制</strong>：配置文件可以方便地进行版本控制和管理，便于跟踪和回滚更改。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li><strong>复杂性</strong>：需要编写和维护配置文件，可能会增加一定的复杂性和工作量。</li><li><strong>标准化难度</strong>：不同团队可能会有不同的配置文件格式和习惯，需要制定和遵守统一的标准。</li></ol><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li><strong>复杂系统</strong>：当系统涉及到复杂的依赖关系和多样化的配置需求时，使用配置文件更为合适。</li><li><strong>需要高度自定义</strong>：如果每个组件的生命周期管理需要高度自定义的操作和参数，配置文件可以提供更大的灵活性。</li></ul><h3 id="约定优于配置方法"><a href="#约定优于配置方法" class="headerlink" title="约定优于配置方法"></a>约定优于配置方法</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li><strong>简单易用</strong>：通过遵循约定，减少了显式配置的需求，使得系统更简单和一致。</li><li><strong>快速上手</strong>：团队成员可以快速了解和遵循约定，不需要花费大量时间编写配置文件。</li><li><strong>减少出错</strong>：统一的目录结构和命名约定可以减少配置错误，提高可靠性。</li></ol><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol><li><strong>灵活性有限</strong>：约定通常是固定的，灵活性可能不如配置文件高。</li><li><strong>扩展性受限</strong>：在需要添加新的生命周期步骤或复杂的自定义操作时，可能需要修改约定和实现。</li></ol><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li><strong>简单系统</strong>：当系统相对简单且生命周期管理步骤较为标准化时，约定优于配置的方法更加合适。</li><li><strong>快速开发</strong>：在需要快速开发和部署的场景下，约定优于配置的方法可以提高效率。</li></ul><h3 id="综合比较"><a href="#综合比较" class="headerlink" title="综合比较"></a>综合比较</h3><p>在大型软件系统中，配置文件方法和约定优于配置的方法各有优缺点。综合考虑，<strong>配置文件方法</strong>通常更适用于大型软件的生命周期管理，主要原因包括：</p><ol><li><strong>复杂性管理</strong>：大型系统通常具有复杂的依赖关系和多样化的需求，配置文件提供了足够的灵活性来应对这些复杂性。</li><li><strong>可维护性</strong>：配置文件明确描述了每个组件的生命周期步骤和参数，便于维护和管理。</li><li><strong>可扩展性</strong>：配置文件可以方便地进行扩展和调整，适应系统不断变化的需求。</li></ol><p>然而，在一些特定的场景下，如需要快速开发、部署且系统相对简单时，<strong>约定优于配置的方法</strong>也可以作为一种高效的选择。</p><h3 id="实施建议"><a href="#实施建议" class="headerlink" title="实施建议"></a>实施建议</h3><p>为了兼顾两种方法的优点，可以考虑以下混合策略：</p><ul><li><strong>基础约定</strong>：使用约定优于配置的方法定义基础的目录结构和命名规则，确保简单、快速的生命周期管理。</li><li><strong>配置扩展</strong>：在约定的基础上，提供可选的配置文件，用于定义复杂的自定义操作和参数，以满足更高的灵活性需求。</li></ul><p>这种混合策略可以在保持系统简单性的同时，提供足够的灵活性和扩展性，适应大型软件系统的生命周期管理需求。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>总控、引擎、插件组件包定义.md</title>
    <link href="/2024/06/18/mdstorage/project/sr/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%9B%B8%E5%85%B3/%E6%80%BB%E6%8E%A7%E3%80%81%E5%BC%95%E6%93%8E%E3%80%81%E6%8F%92%E4%BB%B6%E7%BB%84%E4%BB%B6%E5%8C%85%E5%AE%9A%E4%B9%89/"/>
    <url>/2024/06/18/mdstorage/project/sr/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%9B%B8%E5%85%B3/%E6%80%BB%E6%8E%A7%E3%80%81%E5%BC%95%E6%93%8E%E3%80%81%E6%8F%92%E4%BB%B6%E7%BB%84%E4%BB%B6%E5%8C%85%E5%AE%9A%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>总控、引擎、插件包定义，构建、导入等关键流程实现方案，和接口设计</p><h2 id="组件包定义"><a href="#组件包定义" class="headerlink" title="组件包定义"></a>组件包定义</h2><p>总控、引擎、插件、Agent 等为大组件，它们的发布时按照下面协议约定构建出的文件称为组件包，导入到总控平台后，会在平台中生成对应可用组件，提供用户使用相应功能。结合平台自身环境，在导入后有不同的用户交互，如流量引擎组件包新导入总控平台时，平台会出现流量引擎安装交互接口，当之前已有可用的流量引擎组件时，平台则会出现流量引擎升级交互接口。</p><h3 id="组件包结构"><a href="#组件包结构" class="headerlink" title="组件包结构"></a>组件包结构</h3><ul><li><p><strong>基本信息：</strong></p><p>  name：组件包的名称，使用产品定义的组件英文简称。<br>  version：组件包的当前版本。<br>  description：组件包的简要描述。<br>  type：组件包的类型，包括sc（总控组件）、engine（引擎组件）、plugin（插件组件）、agent（代理组件）。</p></li><li><p><strong>依赖信息：</strong></p><p>  dependencies：组件包所依赖的其他组件包列表，包括依赖项的名称、版本范围、类型、兼容版本、不兼容版本和描述。</p></li><li><p><strong>完整性校验：</strong></p><p>  checksum：包含整个压缩包的校验和信息，用于校验包的完整性。</p></li><li><p><strong>版本更新日志：</strong></p><p>  changelog：此版本更新内容。</p></li><li><p><strong>运行相关内容：</strong></p></li></ul><h3 id="组件包生命周期"><a href="#组件包生命周期" class="headerlink" title="组件包生命周期"></a>组件包生命周期</h3><h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><p>构建顺序：</p><ul><li>运行相关内容</li><li>基本信息、依赖管理、完整性校验</li></ul><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>导入时会将组件包元信息录入到平台数据库中，以作安装、升级管理界面查看使用，在平台中生成用户可交互的组件</p><p>组件用户操作接口</p><ul><li>安装、升级、回退（插件有）、回滚、取消安装、卸载、强制卸载、备份（引擎有）、备份恢复（引擎有）</li></ul><h3 id="组件包内容"><a href="#组件包内容" class="headerlink" title="组件包内容"></a>组件包内容</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>组件包文件格式为 ${组件名}_v${version}.${os_name}-${arch}.tar.gz  SC_v1.5.6.linux-x86_64.tar.gz<br>使用 tar -zxvf 解压后为以下目录接口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs Bash">SC_v1.5.15.linux-x86_64/<br>│ ├── nsq<br>│ │ ├── bin<br>│ │ ├── hack<br>│ │ └── systemd<br>│ ├── redis<br>│ │ ├── bin<br>│ │ ├── etc<br>│ │ └── hack<br>│ ├── sc<br>│ │ ├── bin<br>│ │ ├── certificate<br>│ │ ├── config<br>│ │ ├── data<br>│ │ ├── depends<br>│ │ ├── dist<br>│ │ ├── doc<br>│ │ ├── hack<br>│ │ ├── <span class="hljs-built_in">log</span><br>│ │ ├── systemd<br>│ │ └── template<br>│ ├── sc-core<br>│ │ ├── bin<br>│ │ ├── config<br>│ │ └── hack<br>│ ├── script<br>│ │ ├── check.sh<br>│ │ ├── config<br>│ │ ├── install.sh<br>│ │ ├── os_info.env<br>│ │ ├── uninstall.sh<br>│ │ └── update_ui.sh<br>│ └── template<br>│     ├── install.sh<br>│     ├── leakScan<br>│     ├── README.md<br>│     ├── sensitive<br>│     ├── sqlInject<br>│     ├── uninstall.sh<br>│     ├── upgrade.sh<br>│     ├── waf<br>│     └── wpd<br>├── meta.json<br>├── install.sh<br>├── uninstall.sh<br><br><br><br></code></pre></td></tr></table></figure><h4 id="生命周期管理信息"><a href="#生命周期管理信息" class="headerlink" title="生命周期管理信息"></a>生命周期管理信息</h4><h4 id="发布信息"><a href="#发布信息" class="headerlink" title="发布信息"></a>发布信息</h4><h5 id="版本更新日志-changelog"><a href="#版本更新日志-changelog" class="headerlink" title="版本更新日志 changelog"></a>版本更新日志 changelog</h5><p><strong>格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Text">## [1.2.0] - 2024-06-18<br>### Added<br>- 新特性 A<br>- 新特性 B<br><br>### Fixed<br>- Bug X<br>- Bug Y<br><br>### Improved<br>- 操作体验优化 Z<br></code></pre></td></tr></table></figure><p>生命周期说明： 发布时由产品发布此文件，导入时解析此文件，并存入到数据库，安装包、升级包清理时，文件随包一起清理。有必要时，清理无用包信息，可以删除此信息</p><h5 id="依赖信息-checksum-meta-json"><a href="#依赖信息-checksum-meta-json" class="headerlink" title="依赖信息 checksum  meta.json"></a>依赖信息 checksum  meta.json</h5><p>需要最后填充此信息，因为里面包含 checksum 信息，用于包完整性校验</p><ul><li><strong>sc示例</strong></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SC&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-comment">// 产品定义的组件英文简称 https://doc.weixin.qq.com/sheet/e3_AIgA6waJABcW3JvHCTFSyGeeGr7PY?scode=ABwA9Qd2ABEu5XCNS9Ab8AhQbAADQ&amp;tab=BB08J2</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.7.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-comment">// 发布版本号</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;总控组件包&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sc&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-comment">// sc engine plugin agent</span><br>  <span class="hljs-attr">&quot;checksum&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;v1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1234567890abcdef1234567890abcdef&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-comment">// 依赖管理</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SE&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;engine&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;compatible_versions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;&gt;=2.1.0&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&lt;3.0.0&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;incompatible_versions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;2.1.2&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;引擎组件包&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;proto_version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>   <span class="hljs-comment">// 协议版本</span><br>  <span class="hljs-attr">&quot;changelog&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;This is the changelog content. \n- Added new features \n- Fixed bugs \n- Improved performance&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;component&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;sc&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;sc-core&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;installer&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>       <span class="hljs-comment">// 这里就是组件目录名，组件名要和组件目录名一致，也就是在 able.json 中 name 要对上</span><br><span class="hljs-punctuation">&#125;</span><br><br><br><br></code></pre></td></tr></table></figure><ul><li><strong>引擎示例</strong></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SE&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-comment">// 产品定义的组件英文简称</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.1.1&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-comment">// 发布版本号</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;引擎组件包&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;engine&quot;</span><span class="hljs-punctuation">,</span>     <span class="hljs-comment">// sc engine plugin agent</span><br>  <span class="hljs-attr">&quot;checksum&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;v1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1234567890abcdef1234567890abcdef&quot;</span><span class="hljs-punctuation">,</span>   <br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;comp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>       <span class="hljs-comment">// 小组件和目录</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>   <span class="hljs-comment">// 依赖管理</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SC&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sc&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;compatible_versions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&gt;=1.5.1, &lt;2.0.0&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;incompatible_versions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;1.6.0&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;1.7.0&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;总控组件包&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;acl&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-comment">// 产品定义的组件英文简称</span><br>      <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ACL 插件包&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;plugin&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;incompatible_versions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;4.1.5&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>      <br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;proto_version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;changelog&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;This is the changelog content. \n- Added new features \n- Fixed bugs \n- Improved performance&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><ul><li><p><strong>Agent 示例</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;srfa&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-comment">// 产品定义的组件英文简称</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.6.1&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-comment">// 发布版本号</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;流量 Agent 组件包&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;agent&quot;</span><span class="hljs-punctuation">,</span>     <span class="hljs-comment">// sc engine plugin agent</span><br>  <span class="hljs-attr">&quot;checksum&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;v1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1234567890abcdef1234567890abcdef&quot;</span><span class="hljs-punctuation">,</span>   <br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>   <span class="hljs-comment">// 依赖管理</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;srfm&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-comment">// 镜像引擎</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;engine&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;compatible_versions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&gt;=1.5.1, &lt;2.0.0&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;incompatible_versions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;1.6.1&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;镜像引擎组件包&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;proto_version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;changelog&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;This is the changelog content. \n- Added new features \n- Fixed bugs \n- Improved performance&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure></li><li><p><strong>插件示例</strong></p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;acl&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-comment">// 产品定义的组件英文简称</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;4.1.3&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ACL 插件包&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-comment">// 界面上对于组件包信息描述</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;plugin&quot;</span><span class="hljs-punctuation">,</span>     <span class="hljs-comment">// sc engine plugin agent</span><br>  <span class="hljs-attr">&quot;checksum&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;v1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1234567890abcdef1234567890abcdef&quot;</span><span class="hljs-punctuation">,</span>  <br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>   <span class="hljs-comment">// 依赖管理</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SE&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;engine&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;compatible_versions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&gt;=2.1.0, &lt;3.0.0&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;incompatible_versions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;2.1.2&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;引擎组件包&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SC&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sc&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;compatible_versions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&gt;=1.5.1, &lt;2.0.0&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;incompatible_versions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;1.6.0&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;1.7.0&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;总控组件包&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;proto_version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;changelog&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;This is the changelog content. \n- Added new features \n- Fixed bugs \n- Improved performance&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><ul><li><strong>完整性校验机制机制</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 排除 meta.json 本身递归计算 目录下所有文件的 md5 值，注意，发布时要和导入校验时算法保持一致</span><br>find . -<span class="hljs-built_in">type</span> f ! -name <span class="hljs-string">&#x27;meta.json&#x27;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">md5sum</span> &#123;&#125; + | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>  | <span class="hljs-built_in">md5sum</span><br><br></code></pre></td></tr></table></figure></li></ul><h4 id="运行时信息"><a href="#运行时信息" class="headerlink" title="运行时信息"></a>运行时信息</h4><p>包含 二进制可执行文件，配置文件，内置脚本，等信息</p><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><h2 id="组件包集"><a href="#组件包集" class="headerlink" title="组件包集"></a>组件包集</h2><h3 id="组件包集定义"><a href="#组件包集定义" class="headerlink" title="组件包集定义"></a>组件包集定义</h3><p>组件包集由多个组件包组成，软件交付时，大概率是多个组件包构建为一个组件包集给到用户，才能给用户完整的体验。</p><h3 id="结构和构建规则"><a href="#结构和构建规则" class="headerlink" title="结构和构建规则"></a>结构和构建规则</h3><p>组件包集文件名格式：20240618-SRBundle-batch.tar.gz，组件包集由多个组件包和一个名为 batch.json 的文件组成。batch.json 文件记录了每个组件包的校验和（checksum）值，用于验证组件包的完整性。组件包集的目录结构如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Text">SRBundle-batch/<br>├── SC_v1.0.0.tar.gz<br>├── SE_v2.0.0.tar.gz<br>├── acl_v3.0.0.tar.gz<br>├── install.sh<br>├── uninstall.sh<br>└── batch.json<br><br></code></pre></td></tr></table></figure><p>batch.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;components&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SC_v1.0.0.tar.gz&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;checksum&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;v1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SE_v2.0.0.tar.gz&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;checksum&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;v1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;abcde1234567890abcdef1234567890abcdef1234567890abcdef1234567890&quot;</span> <br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;acl_v3.0.0.tar.gz&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;checksum&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;v1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;7890abcdef1234567890abcdef1234567890abcdef1234567890abcdef123456&quot;</span> <br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;proto_version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><h3 id="导入规则"><a href="#导入规则" class="headerlink" title="导入规则"></a>导入规则</h3><p>导入组件包集时，系统会首先读取 batch.json 文件并校验每个组件包的完整性。校验通过后，系统会开始导入每个组件包，执行相应的导入逻辑。导入过程如下：</p><ul><li>解压组件包集文件</li><li>读取并解析 batch.json 文件，校验每个组件包的完整性。</li><li>校验通过后，依次导入每个组件包，执行相应的导入逻辑。</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="升级兼容问题"><a href="#升级兼容问题" class="headerlink" title="升级兼容问题"></a>升级兼容问题</h3><h4 id="1-5-总控如何适配新构建的组件包和组件包集"><a href="#1-5-总控如何适配新构建的组件包和组件包集" class="headerlink" title="1.5 总控如何适配新构建的组件包和组件包集"></a>1.5 总控如何适配新构建的组件包和组件包集</h4><ul><li><p>中间版本方案？<br>符合现有逻辑，有实现的可行性。决定做，现在开始开发中间版本，至少需要兼容新的导包逻辑，正常展示组件的交互接口</p></li><li><p>不兼容直接重装<br>如果有些存在服务彻底不兼容的情况，那就不做兼容逻辑。</p></li></ul><h3 id="组件包和组件包集信息遗漏"><a href="#组件包和组件包集信息遗漏" class="headerlink" title="组件包和组件包集信息遗漏"></a>组件包和组件包集信息遗漏</h3><h4 id="补充信息"><a href="#补充信息" class="headerlink" title="补充信息"></a>补充信息</h4><ul><li>发布方信息</li><li>发布时间</li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="组件包安装脚本"><a href="#组件包安装脚本" class="headerlink" title="组件包安装脚本"></a>组件包安装脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 用户解压组件包</span><br><span class="hljs-comment">#tar zxvf SC_v1.0.0.tar.gz</span><br><br>./install.sh<br><br></code></pre></td></tr></table></figure><h3 id="组件包集安装脚本"><a href="#组件包集安装脚本" class="headerlink" title="组件包集安装脚本"></a>组件包集安装脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 用户解压组件包集</span><br><span class="hljs-comment"># tar zxvf 20240618-SRBundle-batch.tar.gz</span><br>./install.sh<br><br></code></pre></td></tr></table></figure><h4 id="构建工具（打包平台使用）"><a href="#构建工具（打包平台使用）" class="headerlink" title="构建工具（打包平台使用）"></a>构建工具（打包平台使用）</h4><p>生成 meta.json 后续可再开发或内嵌到打包平台中自动完成 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># Function to prompt user for input</span><br><span class="hljs-function"><span class="hljs-title">prompt</span></span>() &#123;<br>  <span class="hljs-built_in">local</span> var_name=<span class="hljs-variable">$1</span><br>  <span class="hljs-built_in">local</span> prompt_text=<span class="hljs-variable">$2</span><br>  <span class="hljs-built_in">local</span> default_value=<span class="hljs-variable">$3</span><br>  <span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$prompt_text</span>&quot;</span> input<br>  <span class="hljs-built_in">eval</span> <span class="hljs-variable">$var_name</span>=<span class="hljs-string">&quot;&#x27;<span class="hljs-variable">$&#123;input:-<span class="hljs-variable">$default_value</span>&#125;</span>&#x27;&quot;</span><br>&#125;<br><br><span class="hljs-comment"># Prompt for required fields</span><br>prompt name <span class="hljs-string">&quot;输入组件名 component name (required): &quot;</span><br>prompt <span class="hljs-built_in">type</span> <span class="hljs-string">&quot;输入组件类型 component type (required) [sc/engine/plugin/agent]: &quot;</span><br>prompt version <span class="hljs-string">&quot;输入组件版本 the component version (required): &quot;</span><br>prompt checksum <span class="hljs-string">&quot;输出组件 md5 the checksum (MD5) (required): &quot;</span><br><br><span class="hljs-comment"># Start building the JSON structure</span><br>json_content=<span class="hljs-string">&quot;&#123;\n&quot;</span><br>json_content+=<span class="hljs-string">&quot;  \&quot;name\&quot;: \&quot;<span class="hljs-variable">$name</span>\&quot;,\n&quot;</span><br>json_content+=<span class="hljs-string">&quot;  \&quot;version\&quot;: \&quot;<span class="hljs-variable">$version</span>\&quot;,\n&quot;</span><br>json_content+=<span class="hljs-string">&quot;  \&quot;type\&quot;: \&quot;<span class="hljs-variable">$type</span>\&quot;,\n&quot;</span><br>json_content+=<span class="hljs-string">&quot;  \&quot;checksum\&quot;: &#123;\n&quot;</span><br>json_content+=<span class="hljs-string">&quot;    \&quot;v1\&quot;: \&quot;<span class="hljs-variable">$checksum</span>\&quot;\n&quot;</span><br>json_content+=<span class="hljs-string">&quot;  &#125;&quot;</span><br><br><span class="hljs-comment"># Prompt for optional fields</span><br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;新增 description? (y/n): &quot;</span> add_description<br><span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$add_description</span> == <span class="hljs-string">&quot;y&quot;</span> ]]; <span class="hljs-keyword">then</span><br>  prompt description <span class="hljs-string">&quot;Enter the description: &quot;</span><br>  json_content+=<span class="hljs-string">&quot;,\n  \&quot;description\&quot;: \&quot;<span class="hljs-variable">$description</span>\&quot;&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># Prompt for dependencies</span><br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;新增 dependencies? (y/n): &quot;</span> add_dependencies<br><span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$add_dependencies</span> == <span class="hljs-string">&quot;y&quot;</span> ]]; <span class="hljs-keyword">then</span><br>  dependencies=<span class="hljs-string">&quot;[]&quot;</span><br>  <span class="hljs-keyword">while</span> : ; <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Add a dependency? (y/n): &quot;</span> add_dependency<br>    <span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$add_dependency</span> != <span class="hljs-string">&quot;y&quot;</span> ]]; <span class="hljs-keyword">then</span><br>      <span class="hljs-built_in">break</span><br>    <span class="hljs-keyword">fi</span><br>    prompt dep_name <span class="hljs-string">&quot;Enter the dependency name: &quot;</span><br>    prompt dep_type <span class="hljs-string">&quot;Enter the dependency type [sc/engine/plugin/agent]: &quot;</span><br>    prompt dep_compatible_versions <span class="hljs-string">&quot;输入 compatible versions: &quot;</span><br>    prompt dep_incompatible_versions <span class="hljs-string">&quot;输入 incompatible versions (使用 , 隔开 如：&gt;=1.5.1, &lt;2.0.0): &quot;</span><br>    prompt dep_description <span class="hljs-string">&quot;输入依赖描述 ：&quot;</span><br><br>    <span class="hljs-comment"># Add the dependency to the dependencies array</span><br>    dependency=<span class="hljs-string">&quot;&#123;\&quot;name\&quot;: \&quot;<span class="hljs-variable">$dep_name</span>\&quot;, \&quot;type\&quot;: \&quot;<span class="hljs-variable">$dep_type</span>\&quot;, \&quot;compatibleVersions\&quot;: \&quot;<span class="hljs-variable">$dep_compatible_versions</span>\&quot;, \&quot;incompatibleVersions\&quot;: [<span class="hljs-subst">$(echo $dep_incompatible_versions | sed &#x27;s/,/<span class="hljs-string">&quot;,&quot;</span>/g&#x27; | sed &#x27;s/^/<span class="hljs-string">&quot;/&#x27; | sed &#x27;s/$/&quot;</span>/&#x27;)</span>], \&quot;description\&quot;: \&quot;<span class="hljs-variable">$dep_description</span>\&quot;&#125;&quot;</span><br>    <span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$dependencies</span> == <span class="hljs-string">&quot;[]&quot;</span> ]]; <span class="hljs-keyword">then</span><br>      dependencies=<span class="hljs-string">&quot;[<span class="hljs-variable">$dependency</span>]&quot;</span><br>    <span class="hljs-keyword">else</span><br>      dependencies=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$dependencies</span> | sed <span class="hljs-string">&#x27;s/]$/,&#x27;</span><span class="hljs-string">&quot;<span class="hljs-variable">$&#123;dependency&#125;</span>&quot;</span><span class="hljs-string">&#x27;]/&#x27;</span>)<br>    <span class="hljs-keyword">fi</span><br>  <span class="hljs-keyword">done</span><br>  json_content+=<span class="hljs-string">&quot;,\n  \&quot;dependencies\&quot;: <span class="hljs-variable">$dependencies</span>&quot;</span><br><span class="hljs-keyword">fi</span><br><br>json_content+=<span class="hljs-string">&quot;,\n  \&quot;protoVersion\&quot;: 1\n&quot;</span><br><br><span class="hljs-comment"># Prompt for changelog content</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;请输入 changelog 内容 (结束输入使用 Ctrl+D):&quot;</span><br>changelog=$(&lt;/dev/stdin)<br>json_content+=<span class="hljs-string">&quot;,\n  \&quot;changelog\&quot;: \&quot;<span class="hljs-variable">$changelog</span>\&quot;\n&quot;</span><br><br>json_content+=<span class="hljs-string">&quot;&#125;&quot;</span><br><br><span class="hljs-built_in">echo</span> -e <span class="hljs-variable">$json_content</span> &gt; meta.json<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;meta.json has been created with the provided information.&quot;</span><br><br></code></pre></td></tr></table></figure><p>生成 batch.json</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-function"><span class="hljs-title">calculate_checksum</span></span>() &#123;<br>  <span class="hljs-built_in">local</span> file=<span class="hljs-variable">$1</span><br>  <span class="hljs-built_in">md5sum</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> | awk <span class="hljs-string">&#x27;&#123; print $1 &#125;&#x27;</span><br>&#125;<br><br>json_content=<span class="hljs-string">&quot;&#123;\n&quot;</span><br>json_content+=<span class="hljs-string">&quot;  \&quot;components\&quot;: [\n&quot;</span><br><br><span class="hljs-comment"># 找到 tar.gz 后缀文件</span><br>first=<span class="hljs-literal">true</span><br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> *.tar.gz; <span class="hljs-keyword">do</span><br>  <span class="hljs-keyword">if</span> [[ -f <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> ]]; <span class="hljs-keyword">then</span><br>    <span class="hljs-comment"># Calculate the checksum</span><br>    checksum=$(calculate_checksum <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span>)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-variable">$first</span>; <span class="hljs-keyword">then</span><br>      first=<span class="hljs-literal">false</span><br>    <span class="hljs-keyword">else</span><br>      json_content+=<span class="hljs-string">&quot;,\n&quot;</span><br>    <span class="hljs-keyword">fi</span><br><br>    json_content+=<span class="hljs-string">&quot;    &#123;\n&quot;</span><br>    json_content+=<span class="hljs-string">&quot;      \&quot;name\&quot;: \&quot;<span class="hljs-variable">$file</span>\&quot;,\n&quot;</span><br>    json_content+=<span class="hljs-string">&quot;      \&quot;checksum\&quot;: &#123;\n&quot;</span><br>    json_content+=<span class="hljs-string">&quot;        \&quot;v1\&quot;: \&quot;<span class="hljs-variable">$checksum</span>\&quot;\n&quot;</span><br>    json_content+=<span class="hljs-string">&quot;      &#125;\n&quot;</span><br>    json_content+=<span class="hljs-string">&quot;    &#125;&quot;</span><br>  <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br><br>json_content+=<span class="hljs-string">&quot;\n  ],\n&quot;</span><br>json_content+=<span class="hljs-string">&quot;  \&quot;protoVersion\&quot;: 1\n&quot;</span><br>json_content+=<span class="hljs-string">&quot;&#125;&quot;</span><br><br><span class="hljs-built_in">echo</span> -e <span class="hljs-variable">$json_content</span> &gt; batch.json<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;batch.json has been created with the checksums of all .tar.gz files in the current directory.&quot;</span><br></code></pre></td></tr></table></figure><h4 id="导入接口-golang-kit"><a href="#导入接口-golang-kit" class="headerlink" title="导入接口 golang-kit"></a>导入接口 golang-kit</h4><p>解析 meta.json 文件内容，校验包完整性后，再保存基本信息，版本更新日志，依赖关系。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;archive/tar&quot;</span><br><span class="hljs-string">&quot;compress/gzip&quot;</span><br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;os/exec&quot;</span><br><span class="hljs-string">&quot;path/filepath&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><br>_ <span class="hljs-string">&quot;github.com/go-sql-driver/mysql&quot;</span><br><span class="hljs-string">&quot;xorm.io/xorm&quot;</span><br>)<br><br><span class="hljs-comment">// ComponentBall represents the structure of the meta.json file and changelog.md combined</span><br><span class="hljs-keyword">type</span> ComponentBall <span class="hljs-keyword">struct</span> &#123;<br>ID               <span class="hljs-type">int64</span>        <span class="hljs-string">`xorm:&quot;pk autoincr&quot; json:&quot;id&quot;`</span><br>Name             <span class="hljs-type">string</span>       <span class="hljs-string">`json:&quot;name&quot;`</span><br>Version          <span class="hljs-type">string</span>       <span class="hljs-string">`json:&quot;version&quot;`</span><br>Description      <span class="hljs-type">string</span>       <span class="hljs-string">`json:&quot;description,omitempty&quot;`</span><br>Type             <span class="hljs-type">string</span>       <span class="hljs-string">`json:&quot;type&quot;`</span><br>Checksum         <span class="hljs-type">string</span>       <span class="hljs-string">`json:&quot;checksum&quot;`</span><br>Dependencies     <span class="hljs-type">string</span>       <span class="hljs-string">`json:&quot;dependencies,omitempty&quot;`</span> <span class="hljs-comment">// Store dependencies as JSON string</span><br>ProtoVersion     <span class="hljs-type">int</span>          <span class="hljs-string">`json:&quot;protoVersion&quot;`</span><br>Changelog        <span class="hljs-type">string</span>       <span class="hljs-string">`xorm:&quot;TEXT&quot; json:&quot;changelog&quot;`</span><br>DependenciesList []Dependency <span class="hljs-string">`json:&quot;dependenciesList&quot; xorm:&quot;-&quot;`</span><br>&#125;<br><br><span class="hljs-comment">// Meta represents the structure of the meta.json file</span><br><span class="hljs-keyword">type</span> Meta <span class="hljs-keyword">struct</span> &#123;<br>Name         <span class="hljs-type">string</span>       <span class="hljs-string">`json:&quot;name&quot;`</span><br>Version      <span class="hljs-type">string</span>       <span class="hljs-string">`json:&quot;version&quot;`</span><br>Description  <span class="hljs-type">string</span>       <span class="hljs-string">`json:&quot;description,omitempty&quot;`</span><br>Type         <span class="hljs-type">string</span>       <span class="hljs-string">`json:&quot;type&quot;`</span><br>Checksum     Checksum     <span class="hljs-string">`json:&quot;checksum&quot;`</span><br>Dependencies []Dependency <span class="hljs-string">`json:&quot;dependencies,omitempty&quot;`</span><br>ProtoVersion <span class="hljs-type">int</span>          <span class="hljs-string">`json:&quot;protoVersion&quot;`</span><br>Changelog    <span class="hljs-type">string</span>       <span class="hljs-string">`json:&quot;changelog&quot;`</span><br>&#125;<br><br><span class="hljs-comment">// Checksum represents the checksum structure</span><br><span class="hljs-keyword">type</span> Checksum <span class="hljs-keyword">struct</span> &#123;<br>V1 <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;v1&quot;`</span><br>&#125;<br><br><span class="hljs-comment">// Dependency represents a dependency in the meta.json file</span><br><span class="hljs-keyword">type</span> Dependency <span class="hljs-keyword">struct</span> &#123;<br>Name                 <span class="hljs-type">string</span>   <span class="hljs-string">`json:&quot;name&quot;`</span><br>Type                 <span class="hljs-type">string</span>   <span class="hljs-string">`json:&quot;type&quot;`</span><br>CompatibleVersions   <span class="hljs-type">string</span>   <span class="hljs-string">`json:&quot;compatibleVersions&quot;`</span><br>IncompatibleVersions []<span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;incompatibleVersions&quot;`</span><br>Description          <span class="hljs-type">string</span>   <span class="hljs-string">`json:&quot;description&quot;`</span><br>&#125;<br><br><span class="hljs-comment">// validateChecksum validates the checksum of the extracted files</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">validateChecksum</span><span class="hljs-params">(extractedDir <span class="hljs-type">string</span>, expectedChecksum <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>cmd := exec.Command(<span class="hljs-string">&quot;bash&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;find . -type f ! -name &#x27;meta.json&#x27; -exec md5sum &#123;&#125; + | awk &#x27;&#123;print $1&#125;&#x27; | md5sum&quot;</span>)<br>cmd.Dir = extractedDir<br>output, err := cmd.Output()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;Error executing checksum validation command: %v&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br>actualChecksumLs := strings.Fields(<span class="hljs-type">string</span>(output))<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(actualChecksumLs) &lt; <span class="hljs-number">2</span> &#123;<br>log.Println(<span class="hljs-string">&quot;Error executing command:&quot;</span>, err)<br>&#125;<br>actualChecksum := actualChecksumLs[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">return</span> actualChecksum == expectedChecksum<br>&#125;<br><br><span class="hljs-comment">// extractTarGz extracts a tar.gz file to a specified directory</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">extractTarGz</span><span class="hljs-params">(gzipStream io.Reader, dst <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>uncompressedStream, err := gzip.NewReader(gzipStream)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">defer</span> uncompressedStream.Close()<br><br>tarReader := tar.NewReader(uncompressedStream)<br><span class="hljs-keyword">for</span> &#123;<br>header, err := tarReader.Next()<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>target := filepath.Join(dst, header.Name)<br><span class="hljs-keyword">switch</span> header.Typeflag &#123;<br><span class="hljs-keyword">case</span> tar.TypeDir:<br><span class="hljs-keyword">if</span> err := os.MkdirAll(target, os.FileMode(header.Mode)); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">case</span> tar.TypeReg:<br>f, err := os.OpenFile(target, os.O_CREATE|os.O_RDWR, os.FileMode(header.Mode))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> _, err := io.Copy(f, tarReader); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>f.Close()<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// saveComponent saves the parsed component information to the database</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">saveComponent</span><span class="hljs-params">(engine *xorm.Engine, component ComponentBall)</span></span> <span class="hljs-type">error</span> &#123;<br>session := engine.NewSession()<br><span class="hljs-keyword">defer</span> session.Close()<br><br>err := session.Begin()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>_, err = session.Insert(&amp;component)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>session.Rollback()<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">return</span> session.Commit()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ImportComponent</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>packageFile := <span class="hljs-string">&quot;SC_v1.5.15.linux-x86_64.tar.gz&quot;</span><br>extractedDir := <span class="hljs-string">&quot;SC_v1.5.15.linux-x86_64&quot;</span><br>err := os.MkdirAll(extractedDir, os.ModePerm)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>file, err := os.Open(packageFile)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Error opening package file: %v&quot;</span>, err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br><br>err = extractTarGz(file, extractedDir)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Error extracting package file: %v&quot;</span>, err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>metaFile := filepath.Join(extractedDir, <span class="hljs-string">&quot;meta.json&quot;</span>)<br>metaData, err := ioutil.ReadFile(metaFile)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Error reading meta.json: %v&quot;</span>, err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// Parse meta.json content</span><br><span class="hljs-keyword">var</span> meta Meta<br>err = json.Unmarshal(metaData, &amp;meta)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Error parsing meta.json: %v&quot;</span>, err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// Validate package integrity</span><br><span class="hljs-keyword">if</span> !validateChecksum(extractedDir, meta.Checksum.V1) &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Package integrity validation failed for %s&quot;</span>, packageFile)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// Convert dependencies to JSON string for storage</span><br>dependenciesJSON, err := json.Marshal(meta.Dependencies)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Error marshaling dependencies: %v&quot;</span>, err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// Create component struct</span><br>component := ComponentBall&#123;<br>Name:             meta.Name,<br>Version:          meta.Version,<br>Description:      meta.Description,<br>Type:             meta.Type,<br>Checksum:         meta.Checksum.V1,<br>Dependencies:     <span class="hljs-type">string</span>(dependenciesJSON),<br>ProtoVersion:     meta.ProtoVersion,<br>Changelog:        meta.Changelog,<br>DependenciesList: meta.Dependencies,<br>&#125;<br><br><span class="hljs-comment">// Connect to the database</span><br>dbURL := <span class="hljs-string">&quot;user:password@tcp(127.0.0.1:3306)/dbname?charset=utf8&amp;parseTime=True&quot;</span><br>engine, err := xorm.NewEngine(<span class="hljs-string">&quot;mysql&quot;</span>, dbURL)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Error connecting to the database: %v&quot;</span>, err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// Save component information to the database</span><br>err = saveComponent(engine, component)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Error saving component information to the database: %v&quot;</span>, err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;Parsed component information saved to the database successfully.&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>err := ImportComponent()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Error importing component: %v&quot;</span>, err)<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>installer目录结构.md</title>
    <link href="/2024/06/17/mdstorage/project/sr/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%9B%B8%E5%85%B3/installer%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <url>/2024/06/17/mdstorage/project/sr/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%9B%B8%E5%85%B3/installer%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="逻辑入口"><a href="#逻辑入口" class="headerlink" title="逻辑入口"></a>逻辑入口</h2><h3 id="流量引擎安装-InstallProcess"><a href="#流量引擎安装-InstallProcess" class="headerlink" title="流量引擎安装 InstallProcess"></a>流量引擎安装 InstallProcess</h3><p>manager&#x2F;manager_route.go:6</p><h3 id="流量引擎资源检测-ResourceCheck"><a href="#流量引擎资源检测-ResourceCheck" class="headerlink" title="流量引擎资源检测 ResourceCheck"></a>流量引擎资源检测 ResourceCheck</h3><p>manager&#x2F;manager.go:1380</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>sxctl 镜像引擎</p><h2 id="逻辑整理"><a href="#逻辑整理" class="headerlink" title="逻辑整理"></a>逻辑整理</h2><p>每个组件已有的取消安装逻辑</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>引擎安装管理.md</title>
    <link href="/2024/06/17/mdstorage/project/sr/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%9B%B8%E5%85%B3/%E5%BC%95%E6%93%8E%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/"/>
    <url>/2024/06/17/mdstorage/project/sr/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%9B%B8%E5%85%B3/%E5%BC%95%E6%93%8E%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="引擎节点管理模块文档"><a href="#引擎节点管理模块文档" class="headerlink" title="引擎节点管理模块文档"></a>引擎节点管理模块文档</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>引擎节点管理的需求最早可追溯到v1.0.x版本，当时是希望实现任意数量的节点管理构成一个集群，但是因为实现过程中遇到了一些无法解决的问题，故以一种很多限制的形式流传了下来。<br>限制有不少，其中最大的限制是：管理节点必须为奇数，且引擎一旦安装成功，管理节点无法以任何一种形式变更数量、机器、IP地址等。<br>管理节点的数量变更需求每个版本都会有人提起，现如今又正式提出了，故对现状和历史状态进行一次梳理，以便看清前路。</p><h2 id="名词旧解释"><a href="#名词旧解释" class="headerlink" title="名词旧解释"></a>名词旧解释</h2><ul><li>引擎节点: 一般用来概括称呼管理节点、工作节点、调度节点，不同的类型的节点区别主要是运行的组件不同</li><li>节点添加：为一个全新的OS安装工作节点或调度节点的组件；或者为一个当前引擎其他节点添加工作节点或者调度节点的组件。</li><li>agent: 是installer-sr-server的一部分，它是一个运行在引擎节点的服务，下文中，会将其称呼为installer-sr-agent</li></ul><h2 id="名词新解释"><a href="#名词新解释" class="headerlink" title="名词新解释"></a>名词新解释</h2><ul><li>引擎节点：指一个机器，或者说一个OS上装了石犀引擎的情况下。和旧版的区别在于其不可分&#x2F;不可共享性。</li><li>节点添加：为一个全新的OS安装引擎组件。</li><li>agent：是一个类似边车引擎的东西，属于镜像引擎的需求一部分，下文中，会将其称呼为sr-agent</li></ul><h2 id="演变历史"><a href="#演变历史" class="headerlink" title="演变历史"></a>演变历史</h2><p>目前installer-sr-server能追溯的最早代码位于release-v2.0.2分支，其核心功能是引擎组件的安装。对于节点添加的支持，仅支持工作节点的添加。其添加的实现非常简单，和安装是一致的。也就是说，为某个OS添加工作节点的实现为安装所有引擎组件（含非工作节点组件），通过设置systemd的enabled属性来控制是否运行某些组件。<br>后续版本添加了调度节点的节点添加，但是实现上和工作节点添加差异并不大。</p><p>在1.5版本中，对安装逻辑做了一次重构, 在去掉了installer-sr-agent之后，虽然安装的逻辑发生了较多的变化，但是从节点管理这部分逻辑来看，并没有本质变化。都是和引擎安装复用同一个函数，根据节点类型筛选出需要安装的组件列表，依次执行他们的安装脚本。</p><h3 id="整体设计演变"><a href="#整体设计演变" class="headerlink" title="整体设计演变"></a>整体设计演变</h3><h4 id="原设计伪代码描述"><a href="#原设计伪代码描述" class="headerlink" title="原设计伪代码描述"></a>原设计伪代码描述</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// installer-sr-manager</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Service)</span></span>Install(req InstallReqParam)&#123;<br>    dbGlobalParam := dosomething(req)<br>    s.db.Save(dbGlobalParam)<br><br>    dbGlobalParam = s.db.Query(req.EngineID)<br>    http.PostRequest(install-sr-agent.ip:port, dbGlobalParam)<br>&#125;<br><br><br><span class="hljs-comment">// installer-sr-agent</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Service)</span></span> Install(req GlobalParam) &#123;<br>    <span class="hljs-comment">// download files from manager</span><br>    http.GetRequest(installer-sr-manager.ip:port/download, req.PackageVersion)<br>    s.SaveLocalFile(packagePath,md5)<br><br>    <span class="hljs-comment">// parse install config </span><br>    installConfig := s.ParseConfig(req,enginePackage)<br>    <br>    <span class="hljs-keyword">for</span> _, elem := <span class="hljs-keyword">range</span> installConfig.ComponentList &#123;<br>        elem.Install()<br>        <span class="hljs-keyword">if</span> elem.Start &#123;<br>            systemctlStart(elem)<br>        &#125;<br>        <span class="hljs-keyword">if</span> elem.Boot &#123;<br>            systemctlEnable(elem)<br>        &#125;<br><br>        s.SaveLocalFile(elem,installed)<br>        http.PostRequest(installer-sr-manager.ip:port/report, Progress++)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-5设计伪代码描述"><a href="#1-5设计伪代码描述" class="headerlink" title="1.5设计伪代码描述"></a>1.5设计伪代码描述</h4><p>1.5的版本里面，进度相关的表已经名存实亡，进度和取消由另外的机制来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// installer-sr-manager</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Service)</span></span>Install(req InstallReqParam)&#123;<br>    dbGlobalParam := dosomething(req)<br>    s.db.Save(dbGlobalParam)<br><br>    dbGlobalParam = s.db.Query(req.EngineID)<br><br>    sshClient := sshv2.NewClientWithPwd(req)<br>    sshClient.Upload(req.enginePackage)<br><br>    <span class="hljs-keyword">for</span> _, elem := <span class="hljs-keyword">range</span> installConfig.ComponentList &#123;<br>        <span class="hljs-comment">// elem.Install() </span><br>        grpc.PostRequest(webserver.Cmd, <span class="hljs-string">&quot;mv $elem /opt/$elem&quot;</span>)<br>        grpc.PostRequest(webserver.Cmd, <span class="hljs-string">&quot;/opt/$elem/scripts/install.sh&quot;</span>)<br>        s.db.Save(elem)<br>        progress++<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// webserver</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Service)</span></span> Cmd(req CmdParam) &#123;<br>    cmd := exec.Command(req.Name,req.Args...)<br>    cmd.Run()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="依赖问题"><a href="#依赖问题" class="headerlink" title="依赖问题"></a>依赖问题</h2><p>对于将引擎的组件按照类型分割成3部分，并且允许独立安装的做法，最需要考虑的问题是节点与节点间的依赖、组件与组件间的依赖问题。<br>工作节点安装时，其实可以认为是独立的，它不需要依赖管理节点或者调度节点的信息。<br>但是工作节点要想正常工作，那么调度节点就需要知道有哪些工作节点。为了解决信息同步的问题，SX-HA模块从最早开始就介入了节点管理模块，节点的变更的实现对SX-HA模块有较强的依赖，可以认为节点管理是SX-HA和installer-sr-server共同实现的。</p><p>SX-HA主要负责的部分其实是通过k8s+etcd来实现一个动态更新节点列表，并且动态下发配置，并将其称为节点发现模块。它的理念是：SX-HA模块运行时，往公共的注册中心注册自身的节点信息，通过注册中心来保持节点信息的一致性。通过watch机制，来感知注册中心信息的变化，然后更新自身节点的一些配置。<br>在之前的版本实现中，SX-HA还接管了etcd的启动配置生成，这是因为当时也对管理节点的添加删除做了一些尝试，但是以失败告终。</p><h2 id="节点新增"><a href="#节点新增" class="headerlink" title="节点新增"></a>节点新增</h2><p>1.5版本，节点新增支持调度节点新增和工作节点新增。<br>假设有以下引擎</p><table><thead><tr><th>所属引擎</th><th>IP</th><th>角色组合</th></tr></thead><tbody><tr><td>A</td><td>1.1.1.1</td><td>M</td></tr><tr><td>A</td><td>1.1.1.2</td><td>MS</td></tr><tr><td>A</td><td>1.1.1.3</td><td>MW</td></tr><tr><td>B</td><td>1.1.1.100</td><td>MSW</td></tr></tbody></table><p>它在manager的节点表中，记录如下</p><table><thead><tr><th>所属引擎</th><th>IP</th><th>角色枚举</th></tr></thead><tbody><tr><td>A</td><td>1.1.1.1</td><td>M</td></tr><tr><td>A</td><td>1.1.1.2</td><td>M</td></tr><tr><td>A</td><td>1.1.1.2</td><td>S</td></tr><tr><td>A</td><td>1.1.1.3</td><td>M</td></tr><tr><td>A</td><td>1.1.1.3</td><td>W</td></tr><tr><td>B</td><td>1.1.1.100</td><td>M</td></tr><tr><td>B</td><td>1.1.1.100</td><td>S</td></tr><tr><td>B</td><td>1.1.1.100</td><td>W</td></tr></tbody></table><p>对于引擎A，它可以通过&lt;节点添加&gt;接口来添加一个1.1.1.1 W（或者S）<br>过程为：<br>在节点表中，添加一条记录<br>| A | 1.1.1.1 | W |<br>然后将每个工作节点的组件都执行一次安装脚本（引擎包会重新传一遍过去）<br>添加完毕后，会调用SX-HA的结构通知一下，后续流程应该是SX-HA模块在处理。</p><h2 id="节点删除"><a href="#节点删除" class="headerlink" title="节点删除"></a>节点删除</h2><p>节点删除并没有什么特别的设计，同样是执行对应组件的脚本，然后通知SX-HA</p><h2 id="节点替换"><a href="#节点替换" class="headerlink" title="节点替换"></a>节点替换</h2><p>调度节点是没有替换的，只有工作节点支持替换</p><p>替换的流程是先在新的节点执行节点添加逻辑，然后在旧的节点执行节点删除逻辑。</p><h2 id="1-6迭代思路"><a href="#1-6迭代思路" class="headerlink" title="1.6迭代思路"></a>1.6迭代思路</h2><p>首先是节点表的定义和需求匹配度已经不够了，要么重新定义一张表，要么修改原有字段的含义，各有各的做法。不过我认为原来的表定义字段存在一些意义不明的字段，直接重设计可以省去理解上的时间。<br>管理节点的添加、删除应该是主要的障碍，目前没有研究过这方面。调度节点1.5没有支持替换，原因可能只有原开发（贺泽）知道</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>生命周期管理方案.md</title>
    <link href="/2024/06/17/mdstorage/project/sr/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%9B%B8%E5%85%B3/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/"/>
    <url>/2024/06/17/mdstorage/project/sr/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%9B%B8%E5%85%B3/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h3 id="引擎生命周期管理方案整理"><a href="#引擎生命周期管理方案整理" class="headerlink" title="引擎生命周期管理方案整理"></a>引擎生命周期管理方案整理</h3><h4 id="1-生命周期管理框架和组件依赖的常量、变量的约定"><a href="#1-生命周期管理框架和组件依赖的常量、变量的约定" class="headerlink" title="1. 生命周期管理框架和组件依赖的常量、变量的约定"></a>1. 生命周期管理框架和组件依赖的常量、变量的约定</h4><p><strong>配置文件（config.env）</strong>：</p><p>配置文件用于管理节点初始化时的常量和变量，所有组件的生命周期脚本均从该配置文件中读取必要的参数。</p><p>示例配置文件内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">Version</span>=<span class="hljs-number">1</span> <br><span class="hljs-attr">LogPath</span>=/opt/private/log<br><br><span class="hljs-comment"># MetaInfo</span><br><span class="hljs-attr">VIRD</span>=<span class="hljs-number">211</span><br><span class="hljs-attr">Mode</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">GS</span>=f8fb61b0ce16ba41<br><span class="hljs-attr">GS_EE</span>=SA1014QTGVL9<br><span class="hljs-attr">MasterIP</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">122.124</span><br><span class="hljs-attr">GS_WW</span>=SA1014WZMKVC<br><br><span class="hljs-comment"># ShareInfo</span><br><span class="hljs-attr">CompVar1</span>=a<br><span class="hljs-attr">CompVar2</span>=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h5 id="配置文件内容解析"><a href="#配置文件内容解析" class="headerlink" title="配置文件内容解析"></a>配置文件内容解析</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 版本控制，向后兼容</span><br>Version=1 <br><span class="hljs-comment"># 日志目录</span><br>LogPath=/opt/private/log<br><br><span class="hljs-comment"># MetaInfo 节点元信息</span><br><br><br><span class="hljs-comment"># ShareInfo 组件共享信息，组件可以自己注册信息，进行组件间通信（不同版本组件通信）</span><br><br></code></pre></td></tr></table></figure><ul><li>MetaInfo ShareInfo 之间不可重复定义常量、变量</li><li>MetaInfo 不常修改，不可新增、删除</li><li>MetaInfo ShareInfo 可分别进行 列出、监听</li></ul><h5 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h5><p>根据特性提供工具集，将提供两种形式的工具对 内容进行感知</p><ul><li>命令行工具</li><li>golang kit</li></ul><p><strong>命令行</strong> : 内容 增删查改，一般只会 查<br><strong>golang kit</strong> : 内容 增删查改 ，监听变化 ， 查看节点修改日志</p><h4 id="2-生命周期管理框架和组件定义的生命周期脚本约定"><a href="#2-生命周期管理框架和组件定义的生命周期脚本约定" class="headerlink" title="2. 生命周期管理框架和组件定义的生命周期脚本约定"></a>2. 生命周期管理框架和组件定义的生命周期脚本约定</h4><p>每个组件在生命周期的不同阶段需要执行特定的脚本，这些脚本约定统一读取配置文件中的参数。</p><p><strong>生命周期脚本目录结构</strong>：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">/path/<span class="hljs-keyword">to</span>/component1/<br>    ├── install.<span class="hljs-keyword">sh</span><br>    ├── initialize.<span class="hljs-keyword">sh</span><br>    ├── start.<span class="hljs-keyword">sh</span><br>    ├── <span class="hljs-keyword">stop</span>.<span class="hljs-keyword">sh</span><br>    └── destroy.<span class="hljs-keyword">sh</span><br></code></pre></td></tr></table></figure><p><strong>生命周期脚本模板</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">source</span> /path/to/config.env<br><br><span class="hljs-comment"># 脚本逻辑</span><br></code></pre></td></tr></table></figure><p>具体示例：</p><p><strong>install.sh</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">source</span> /path/to/config.env<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Installing component with VIRD=<span class="hljs-variable">$VIRD</span>&quot;</span><br><span class="hljs-comment"># 安装逻辑</span><br></code></pre></td></tr></table></figure><p><strong>initialize.sh</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">source</span> /path/to/config.env<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Initializing component with GS=<span class="hljs-variable">$GS</span> and MasterIP=<span class="hljs-variable">$MasterIP</span>&quot;</span><br><span class="hljs-comment"># 初始化逻辑</span><br></code></pre></td></tr></table></figure><p><strong>start.sh</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">source</span> /path/to/config.env<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Starting component in mode <span class="hljs-variable">$Mode</span>&quot;</span><br><span class="hljs-comment"># 启动逻辑</span><br></code></pre></td></tr></table></figure><p><strong>stop.sh</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">source</span> /path/to/config.env<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Stopping component&quot;</span><br><span class="hljs-comment"># 停止逻辑</span><br></code></pre></td></tr></table></figure><p><strong>destroy.sh</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">source</span> /path/to/config.env<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Destroying component&quot;</span><br><span class="hljs-comment"># 销毁逻辑</span><br></code></pre></td></tr></table></figure><h4 id="3-各生命周期脚本统一共同动作"><a href="#3-各生命周期脚本统一共同动作" class="headerlink" title="3. 各生命周期脚本统一共同动作"></a>3. 各生命周期脚本统一共同动作</h4><p>所有生命周期脚本均需统一执行以下共同动作：</p><ol><li>加载配置文件：<code>source /path/to/config.env</code></li><li>打印当前操作信息：<code>echo &quot;操作信息&quot;</code></li><li>执行特定的生命周期逻辑</li></ol><h4 id="4-特殊场景整理"><a href="#4-特殊场景整理" class="headerlink" title="4. 特殊场景整理"></a>4. 特殊场景整理</h4><p>在实际应用中，可能会遇到一些特殊场景，需要针对这些场景制定相应的处理措施。</p><p><strong>特殊场景1：节点重启</strong></p><p>当节点重启时，需要确保各组件能够自动恢复到之前的工作状态。可以在节点启动时执行统一的恢复脚本。</p><p><strong>恢复脚本（recover.sh）</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 组件列表</span><br>components=(<span class="hljs-string">&quot;component1&quot;</span> <span class="hljs-string">&quot;component2&quot;</span> <span class="hljs-string">&quot;component3&quot;</span>)<br><br><span class="hljs-comment"># 恢复操作</span><br><span class="hljs-keyword">for</span> component <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;components[@]&#125;</span>&quot;</span>; <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Recovering <span class="hljs-variable">$component</span>&quot;</span><br>    /path/to/<span class="hljs-variable">$component</span>/start.sh<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p><strong>特殊场景2：配置参数更新</strong></p><p>当配置参数发生变化时，需要确保各组件能够及时读取新的配置参数。可以通过统一的更新脚本来实现。</p><p><strong>更新脚本（update_config.sh）</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 写入新的配置文件</span><br><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOL &gt; /path/to/config.env</span><br><span class="hljs-string">VIRD=212</span><br><span class="hljs-string">Mode=2</span><br><span class="hljs-string">GS=new_value</span><br><span class="hljs-string">GS_EE=new_value</span><br><span class="hljs-string">MasterIP=192.168.122.125</span><br><span class="hljs-string">GS_WW=new_value</span><br><span class="hljs-string">EOL</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Configuration file updated&quot;</span><br><br><span class="hljs-comment"># 重启各组件以加载新的配置</span><br>components=(<span class="hljs-string">&quot;component1&quot;</span> <span class="hljs-string">&quot;component2&quot;</span> <span class="hljs-string">&quot;component3&quot;</span>)<br><br><span class="hljs-keyword">for</span> component <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;components[@]&#125;</span>&quot;</span>; <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Restarting <span class="hljs-variable">$component</span>&quot;</span><br>    /path/to/<span class="hljs-variable">$component</span>/stop.sh<br>    /path/to/<span class="hljs-variable">$component</span>/start.sh<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h3 id="5-错误处理机制"><a href="#5-错误处理机制" class="headerlink" title="5. 错误处理机制"></a>5. 错误处理机制</h3><p>在生命周期脚本中，需要增加错误处理机制，以确保在脚本执行过程中出现错误时能够及时记录并采取相应的措施。</p><p><strong>示例错误处理</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">source</span> /path/to/config.env<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Starting component in mode <span class="hljs-variable">$Mode</span>&quot;</span><br><br><span class="hljs-comment"># 示例操作</span><br><span class="hljs-keyword">if</span> ! operation; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Error: Failed to perform operation&quot;</span> &gt;&amp;2<br>    <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Component started successfully&quot;</span><br></code></pre></td></tr></table></figure><h3 id="6-日志记录"><a href="#6-日志记录" class="headerlink" title="6. 日志记录"></a>6. 日志记录</h3><p>为了方便调试和维护，每个生命周期脚本应该包含日志记录功能，将操作过程和结果记录到日志文件中。</p><p><strong>示例日志记录</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">source</span> /path/to/config.env<br><br>LOGFILE=<span class="hljs-string">&quot;/var/log/component.log&quot;</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;[<span class="hljs-subst">$(date)</span>] Starting component in mode <span class="hljs-variable">$Mode</span>&quot;</span> &gt;&gt; <span class="hljs-variable">$LOGFILE</span><br><br><span class="hljs-keyword">if</span> ! operation; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;[<span class="hljs-subst">$(date)</span>] Error: Failed to perform operation&quot;</span> &gt;&gt; <span class="hljs-variable">$LOGFILE</span><br>    <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;[<span class="hljs-subst">$(date)</span>] Component started successfully&quot;</span> &gt;&gt; <span class="hljs-variable">$LOGFILE</span><br></code></pre></td></tr></table></figure><h3 id="7-组件间的依赖关系"><a href="#7-组件间的依赖关系" class="headerlink" title="7. 组件间的依赖关系"></a>7. 组件间的依赖关系</h3><p>如果组件之间存在依赖关系（例如，组件A必须在组件B之后启动），需要在管理脚本中处理这些依赖关系。</p><p><strong>示例管理脚本（manage_components.sh）</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 组件列表及其依赖关系</span><br><span class="hljs-built_in">declare</span> -A components=(<br>    [<span class="hljs-string">&quot;component1&quot;</span>]=<span class="hljs-string">&quot;install initialize start&quot;</span><br>    [<span class="hljs-string">&quot;component2&quot;</span>]=<span class="hljs-string">&quot;install initialize start&quot;</span><br>    [<span class="hljs-string">&quot;component3&quot;</span>]=<span class="hljs-string">&quot;install initialize start&quot;</span><br>)<br><br><span class="hljs-comment"># 操作</span><br>operation=<span class="hljs-variable">$1</span><br><br><span class="hljs-comment"># 依次执行每个组件的生命周期操作</span><br><span class="hljs-keyword">for</span> component <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;!components[@]&#125;</span>&quot;</span>; <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;components[$component]&#125;</span>; <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$action</span>&quot;</span> == <span class="hljs-string">&quot;<span class="hljs-variable">$operation</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>            <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Executing <span class="hljs-variable">$operation</span> for <span class="hljs-variable">$component</span>&quot;</span><br>            /path/to/<span class="hljs-variable">$component</span>/<span class="hljs-variable">$operation</span>.sh<br>        <span class="hljs-keyword">fi</span><br>    <span class="hljs-keyword">done</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h3 id="8-环境配置和依赖安装"><a href="#8-环境配置和依赖安装" class="headerlink" title="8. 环境配置和依赖安装"></a>8. 环境配置和依赖安装</h3><p>在初始化节点时，可能需要安装一些依赖的软件包或进行环境配置，以确保脚本能够正确执行。</p><p><strong>示例环境配置脚本（setup_environment.sh）</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 安装必要的软件包</span><br><span class="hljs-built_in">sudo</span> apt-get update<br><span class="hljs-built_in">sudo</span> apt-get install -y package1 package2<br><br><span class="hljs-comment"># 设置环境变量</span><br><span class="hljs-built_in">export</span> VAR1=value1<br><span class="hljs-built_in">export</span> VAR2=value2<br><br><span class="hljs-comment"># 写入配置文件</span><br>./write_config.sh<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Environment setup completed&quot;</span><br></code></pre></td></tr></table></figure><h3 id="9-安全性"><a href="#9-安全性" class="headerlink" title="9. 安全性"></a>9. 安全性</h3><p>确保配置文件、脚本和日志文件的访问权限设置正确，防止未经授权的访问和修改。</p><p><strong>示例权限设置</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 设置配置文件权限</span><br><span class="hljs-built_in">chmod</span> 600 /path/to/config.env<br><br><span class="hljs-comment"># 设置脚本文件权限</span><br><span class="hljs-built_in">chmod</span> 700 /path/to/*.sh<br><br><span class="hljs-comment"># 设置日志文件权限</span><br><span class="hljs-built_in">chmod</span> 600 /var/log/component.log<br></code></pre></td></tr></table></figure><h3 id="10-文档和说明"><a href="#10-文档和说明" class="headerlink" title="10. 文档和说明"></a>10. 文档和说明</h3><p>为了便于使用和维护，需要为整个方案编写详细的文档和说明，包括配置文件格式、脚本使用方法、常见问题处理等。</p><p><strong>示例文档结构</strong>：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dos">docs/<br>    ├── introduction.<span class="hljs-built_in">md</span><br>    ├── configuration.<span class="hljs-built_in">md</span><br>    ├── scripts_usage.<span class="hljs-built_in">md</span><br>    ├── troubleshooting.<span class="hljs-built_in">md</span><br>    └── faq.<span class="hljs-built_in">md</span><br></code></pre></td></tr></table></figure><h3 id="方案整理总结"><a href="#方案整理总结" class="headerlink" title="方案整理总结"></a>方案整理总结</h3><ol><li><p><strong>生命周期管理框架和组件依赖的常量、变量的约定</strong>：</p><ul><li>配置文件管理和写入脚本</li></ul></li><li><p><strong>生命周期管理框架和组件定义的生命周期脚本约定</strong>：</p><ul><li>各生命周期脚本的模板和约定</li></ul></li><li><p><strong>各生命周期脚本统一共同动作</strong>：</p><ul><li>加载配置文件</li><li>打印操作信息</li><li>执行特定逻辑</li></ul></li><li><p><strong>特殊场景整理</strong>：</p><ul><li>节点重启的恢复脚本</li><li>配置参数更新的更新脚本</li></ul></li><li><p><strong>错误处理机制</strong>：</p><ul><li>错误记录和退出处理</li></ul></li><li><p><strong>日志记录</strong>：</p><ul><li>操作过程和结果记录</li></ul></li><li><p><strong>组件间的依赖关系</strong>：</p><ul><li>管理脚本处理组件依赖</li></ul></li><li><p><strong>环境配置和依赖安装</strong>：</p><ul><li>环境配置和依赖安装脚本</li></ul></li><li><p><strong>安全性</strong>：</p><ul><li>文件访问权限设置</li></ul></li><li><p><strong>文档和说明</strong>：</p><ul><li>详细的使用和维护文档</li></ul></li></ol><p>通过上述整理和补充，可以确保引擎生命周期管理方案更加完善、合理和具体，具有更好的可操作性和维护性。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1.6任务评估</title>
    <link href="/2024/06/12/mdstorage/project/sr/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%9B%B8%E5%85%B3/1.6%E4%BB%BB%E5%8A%A1%E8%AF%84%E4%BC%B0/"/>
    <url>/2024/06/12/mdstorage/project/sr/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%9B%B8%E5%85%B3/1.6%E4%BB%BB%E5%8A%A1%E8%AF%84%E4%BC%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="总控-P2"><a href="#总控-P2" class="headerlink" title="总控 (P2)"></a>总控 (P2)</h2><h3 id="总控安装相关需求"><a href="#总控安装相关需求" class="headerlink" title="总控安装相关需求"></a>总控安装相关需求</h3><h4 id="安装脚本中加入IP设置的交互：文档-编码"><a href="#安装脚本中加入IP设置的交互：文档-编码" class="headerlink" title="安装脚本中加入IP设置的交互：文档+编码"></a>安装脚本中加入IP设置的交互：文档+编码</h4><ul><li><strong>工时评估</strong>：2.4d</li></ul><h4 id="打总控包时需要将安装脚本挪到安装包的第一层目录下"><a href="#打总控包时需要将安装脚本挪到安装包的第一层目录下" class="headerlink" title="打总控包时需要将安装脚本挪到安装包的第一层目录下"></a>打总控包时需要将安装脚本挪到安装包的第一层目录下</h4><ul><li><strong>工时评估</strong>：0.34d</li></ul><h4 id="需要调整安装脚本的默认工作目录"><a href="#需要调整安装脚本的默认工作目录" class="headerlink" title="需要调整安装脚本的默认工作目录"></a>需要调整安装脚本的默认工作目录</h4><ul><li><strong>工时评估</strong>：0.34d</li></ul><h4 id="安装的残留清除：文档-编码"><a href="#安装的残留清除：文档-编码" class="headerlink" title="安装的残留清除：文档+编码"></a>安装的残留清除：文档+编码</h4><ul><li><strong>工时评估</strong>：2.4d</li></ul><h4 id="在总控安装时需要将上次残留的总控给清除干净，并进行安装"><a href="#在总控安装时需要将上次残留的总控给清除干净，并进行安装" class="headerlink" title="在总控安装时需要将上次残留的总控给清除干净，并进行安装"></a>在总控安装时需要将上次残留的总控给清除干净，并进行安装</h4><ul><li><strong>工时评估</strong>：2.2d</li></ul><h4 id="环境检测时将内存、CPU核心数、磁盘存储空间的资源校验调整为非硬性要求的安装检测条件"><a href="#环境检测时将内存、CPU核心数、磁盘存储空间的资源校验调整为非硬性要求的安装检测条件" class="headerlink" title="环境检测时将内存、CPU核心数、磁盘存储空间的资源校验调整为非硬性要求的安装检测条件"></a>环境检测时将内存、CPU核心数、磁盘存储空间的资源校验调整为非硬性要求的安装检测条件</h4><ul><li><strong>工时评估</strong>：0.8d</li></ul><h4 id="总控数据初始化调整：纯执行"><a href="#总控数据初始化调整：纯执行" class="headerlink" title="总控数据初始化调整：纯执行"></a>总控数据初始化调整：纯执行</h4><ul><li><strong>工时评估</strong>：2d</li></ul><h3 id="总控卸载相关的需求"><a href="#总控卸载相关的需求" class="headerlink" title="总控卸载相关的需求"></a>总控卸载相关的需求</h3><h4 id="打包时将总控的卸载脚本的调整到第一层目录"><a href="#打包时将总控的卸载脚本的调整到第一层目录" class="headerlink" title="打包时将总控的卸载脚本的调整到第一层目录"></a>打包时将总控的卸载脚本的调整到第一层目录</h4><ul><li><strong>工时评估</strong>：0.34d</li></ul><h4 id="卸载脚本需要调整默认的工作目录位置"><a href="#卸载脚本需要调整默认的工作目录位置" class="headerlink" title="卸载脚本需要调整默认的工作目录位置"></a>卸载脚本需要调整默认的工作目录位置</h4><ul><li><strong>工时评估</strong>：0.34d</li></ul><h3 id="总控升级相关的需求"><a href="#总控升级相关的需求" class="headerlink" title="总控升级相关的需求"></a>总控升级相关的需求</h3><h4 id="总控包、插件包的打包拆分：纯执行（需要前置完成—-组件与结构与定义）"><a href="#总控包、插件包的打包拆分：纯执行（需要前置完成—-组件与结构与定义）" class="headerlink" title="总控包、插件包的打包拆分：纯执行（需要前置完成—-组件与结构与定义）"></a>总控包、插件包的打包拆分：纯执行（需要前置完成—-组件与结构与定义）</h4><ul><li><strong>工时评估</strong>：5.6d</li></ul><h4 id="在总控数据初始化的时候插件包数据初始化的代码需要做相关调整"><a href="#在总控数据初始化的时候插件包数据初始化的代码需要做相关调整" class="headerlink" title="在总控数据初始化的时候插件包数据初始化的代码需要做相关调整"></a>在总控数据初始化的时候插件包数据初始化的代码需要做相关调整</h4><ul><li><strong>工时评估</strong>：2.2d</li></ul><h4 id="在总控升级包导入的时候需要对插件包导入逻辑做相关的调整"><a href="#在总控升级包导入的时候需要对插件包导入逻辑做相关的调整" class="headerlink" title="在总控升级包导入的时候需要对插件包导入逻辑做相关的调整"></a>在总控升级包导入的时候需要对插件包导入逻辑做相关的调整</h4><ul><li><strong>工时评估</strong>：4.2d</li></ul><h4 id="增加对插件增量包导入的支持"><a href="#增加对插件增量包导入的支持" class="headerlink" title="增加对插件增量包导入的支持"></a>增加对插件增量包导入的支持</h4><ul><li><strong>工时评估</strong>：1.4d</li></ul><h4 id="新增升级管理模块：升级包导入"><a href="#新增升级管理模块：升级包导入" class="headerlink" title="新增升级管理模块：升级包导入"></a>新增升级管理模块：升级包导入</h4><ul><li><strong>工时评估</strong>：4.2d</li><li><strong>细节</strong>：<ul><li>在升级包导入时需要拆分、校验、与记录各个升级单位的数据，如：总控、流量引擎、某个插件。</li><li>需要展示升级包导入状态。</li><li>各个升级单位的版本识别。</li></ul></li></ul><h4 id="新增升级管理模块：展示每个升级单位的版本日志（插件升级，由-sc-调用插件管理程序实现）"><a href="#新增升级管理模块：展示每个升级单位的版本日志（插件升级，由-sc-调用插件管理程序实现）" class="headerlink" title="新增升级管理模块：展示每个升级单位的版本日志（插件升级，由 sc 调用插件管理程序实现）"></a>新增升级管理模块：展示每个升级单位的版本日志（插件升级，由 sc 调用插件管理程序实现）</h4><ul><li><strong>工时评估</strong>：1.4d</li></ul><h4 id="新增升级管理模块：各个升级单位的版本日志维护（文案由产品维护，写到包中，导入包时写入一张表中维护）"><a href="#新增升级管理模块：各个升级单位的版本日志维护（文案由产品维护，写到包中，导入包时写入一张表中维护）" class="headerlink" title="新增升级管理模块：各个升级单位的版本日志维护（文案由产品维护，写到包中，导入包时写入一张表中维护）"></a>新增升级管理模块：各个升级单位的版本日志维护（文案由产品维护，写到包中，导入包时写入一张表中维护）</h4><h4 id="新增升级管理模块：聚合已安装-绑定的流量引擎、边车引擎、镜像引擎、插件的数据以展示升级列表"><a href="#新增升级管理模块：聚合已安装-绑定的流量引擎、边车引擎、镜像引擎、插件的数据以展示升级列表" class="headerlink" title="新增升级管理模块：聚合已安装&#x2F;绑定的流量引擎、边车引擎、镜像引擎、插件的数据以展示升级列表"></a>新增升级管理模块：聚合已安装&#x2F;绑定的流量引擎、边车引擎、镜像引擎、插件的数据以展示升级列表</h4><ul><li><strong>工时评估</strong>：3.2d</li></ul><h4 id="新增升级管理模块：升级状态与进度的展示"><a href="#新增升级管理模块：升级状态与进度的展示" class="headerlink" title="新增升级管理模块：升级状态与进度的展示"></a>新增升级管理模块：升级状态与进度的展示</h4><ul><li><strong>工时评估</strong>：1.4d</li></ul><h4 id="总控升级核心功能：总控各个组件的升级调度逻辑"><a href="#总控升级核心功能：总控各个组件的升级调度逻辑" class="headerlink" title="总控升级核心功能：总控各个组件的升级调度逻辑"></a>总控升级核心功能：总控各个组件的升级调度逻辑</h4><ul><li><strong>工时评估</strong>：0.8d</li></ul><h4 id="总控升级核心功能：升级进度的反馈逻辑"><a href="#总控升级核心功能：升级进度的反馈逻辑" class="headerlink" title="总控升级核心功能：升级进度的反馈逻辑"></a>总控升级核心功能：升级进度的反馈逻辑</h4><ul><li><strong>工时评估</strong>：0.8d</li></ul><h4 id="总控升级核心功能：升级失败信息的反馈"><a href="#总控升级核心功能：升级失败信息的反馈" class="headerlink" title="总控升级核心功能：升级失败信息的反馈"></a>总控升级核心功能：升级失败信息的反馈</h4><ul><li><strong>工时评估</strong>：0.8d</li></ul><h4 id="总控升级核心功能：升级失败的回滚调度"><a href="#总控升级核心功能：升级失败的回滚调度" class="headerlink" title="总控升级核心功能：升级失败的回滚调度"></a>总控升级核心功能：升级失败的回滚调度</h4><ul><li><strong>工时评估</strong>：2.2d</li></ul><h4 id="总控升级核心功能：升级成功的确认调度"><a href="#总控升级核心功能：升级成功的确认调度" class="headerlink" title="总控升级核心功能：升级成功的确认调度"></a>总控升级核心功能：升级成功的确认调度</h4><ul><li><strong>工时评估</strong>：2.2d</li></ul><h2 id="流量引擎-P1"><a href="#流量引擎-P1" class="headerlink" title="流量引擎 (P1)"></a>流量引擎 (P1)</h2><h3 id="引擎安装界面相关"><a href="#引擎安装界面相关" class="headerlink" title="引擎安装界面相关"></a>引擎安装界面相关</h3><h4 id="引擎安装界面新增授权状态过滤选项"><a href="#引擎安装界面新增授权状态过滤选项" class="headerlink" title="引擎安装界面新增授权状态过滤选项"></a>引擎安装界面新增授权状态过滤选项</h4><ul><li><strong>分析</strong>：这个需要 installer 这边查询授权接口，聚合查询。</li><li><strong>关键词</strong>：总控联调、前后端联调</li><li><strong>工时评估</strong>：0.8d</li></ul><h4 id="引擎安装界面新增可用节点、调出待安装工作节点、已安装工作节点"><a href="#引擎安装界面新增可用节点、调出待安装工作节点、已安装工作节点" class="headerlink" title="引擎安装界面新增可用节点、调出待安装工作节点、已安装工作节点"></a>引擎安装界面新增可用节点、调出待安装工作节点、已安装工作节点</h4><ul><li><strong>分析</strong>：这里设计前端修改较大，后端改动不多。</li><li><strong>关键词</strong>：前后端联调</li><li><strong>工时评估</strong>：0.4d</li></ul><h4 id="引擎安装、卸载失败原因后端记录、展示"><a href="#引擎安装、卸载失败原因后端记录、展示" class="headerlink" title="引擎安装、卸载失败原因后端记录、展示"></a>引擎安装、卸载失败原因后端记录、展示</h4><ul><li><strong>分析</strong>：需要加一张引擎生命周期操作表，记录某引擎下的操作，失败原因，时间等信息，便于查询展示。</li><li><strong>关键词</strong>：表结构设计、前后端联调、引擎联调</li><li><strong>工时评估</strong>：1.3d</li></ul><h4 id="已到期、未到期引擎工作节点展示"><a href="#已到期、未到期引擎工作节点展示" class="headerlink" title="已到期、未到期引擎工作节点展示"></a>已到期、未到期引擎工作节点展示</h4><ul><li><strong>分析</strong>：installer 各个工作节点查询授权，聚合展示。</li><li><strong>关键词</strong>：前后端联调</li><li><strong>工时评估</strong>：0.8d</li></ul><h3 id="节点新增"><a href="#节点新增" class="headerlink" title="节点新增"></a>节点新增</h3><h4 id="节点扩容新增校验逻辑：管理节点只能是技术，节点名称不允许重复，业务口网卡不与总控同网段"><a href="#节点扩容新增校验逻辑：管理节点只能是技术，节点名称不允许重复，业务口网卡不与总控同网段" class="headerlink" title="节点扩容新增校验逻辑：管理节点只能是技术，节点名称不允许重复，业务口网卡不与总控同网段"></a>节点扩容新增校验逻辑：管理节点只能是技术，节点名称不允许重复，业务口网卡不与总控同网段</h4><ul><li><strong>分析</strong>：新增检测项目。</li><li><strong>关键词</strong>：前后端联调</li><li><strong>工时评估</strong>：1.3d</li></ul><h4 id="允许管理节点扩容，技术调研"><a href="#允许管理节点扩容，技术调研" class="headerlink" title="允许管理节点扩容，技术调研"></a>允许管理节点扩容，技术调研</h4><ul><li><strong>分析</strong>：需要做技术调研，测试，查看相关代码。</li><li><strong>关键词</strong>：技术难点</li><li><strong>工时评估</strong>：3d (做不到)</li></ul><h4 id="管理节点扩容，实现"><a href="#管理节点扩容，实现" class="headerlink" title="管理节点扩容，实现"></a>管理节点扩容，实现</h4><ul><li><strong>分析</strong>：实现管理节点新增。</li><li><strong>关键词</strong>：引擎配合</li><li><strong>工时评估</strong>：3d (做不到)</li></ul><h3 id="引擎安装资源检测"><a href="#引擎安装资源检测" class="headerlink" title="引擎安装资源检测"></a>引擎安装资源检测</h3><h4 id="硬件检测是否满足基础要求，去掉标准要求，结果展示逻辑变更"><a href="#硬件检测是否满足基础要求，去掉标准要求，结果展示逻辑变更" class="headerlink" title="硬件检测是否满足基础要求，去掉标准要求，结果展示逻辑变更"></a>硬件检测是否满足基础要求，去掉标准要求，结果展示逻辑变更</h4><ul><li><strong>分析</strong>：检测逻辑变更，展示逻辑变更。</li><li><strong>关键词</strong>：前后端联调</li><li><strong>工时评估</strong>：2.6d</li></ul><h4 id="程序冲突检测，冲突则不符合"><a href="#程序冲突检测，冲突则不符合" class="headerlink" title="程序冲突检测，冲突则不符合"></a>程序冲突检测，冲突则不符合</h4><ul><li><strong>分析</strong>：统一程序冲突检测定义逻辑，出相应文档。</li><li><strong>关键词</strong>：前后端联调</li><li><strong>工时评估</strong>：1.3d</li></ul><h4 id="多节点安装并行执行"><a href="#多节点安装并行执行" class="headerlink" title="多节点安装并行执行"></a>多节点安装并行执行</h4><ul><li><strong>分析</strong>：已实现。</li><li><strong>工时评估</strong>：0</li></ul><h4 id="多节点安装，安装失败的引擎节点触发清理操作，卸载干净"><a href="#多节点安装，安装失败的引擎节点触发清理操作，卸载干净" class="headerlink" title="多节点安装，安装失败的引擎节点触发清理操作，卸载干净"></a>多节点安装，安装失败的引擎节点触发清理操作，卸载干净</h4><ul><li><strong>分析</strong>：触发卸载操作，难点在可靠性的保证，当作一个新脚本实现，<code>uninstall --force</code>。</li><li><strong>关键词</strong>：引擎联调、技术方案</li><li><strong>工时评估</strong>：4.2d</li></ul><h4 id="多账户引擎安装操作时，提示引擎正在安装中"><a href="#多账户引擎安装操作时，提示引擎正在安装中" class="headerlink" title="多账户引擎安装操作时，提示引擎正在安装中"></a>多账户引擎安装操作时，提示引擎正在安装中</h4><ul><li><strong>分析</strong>：当重入时，返回相应异常信息。</li><li><strong>关键词</strong>：前后端联调</li><li><strong>工时评估</strong>：1.4d</li></ul><h4 id="引擎编辑页名称重复校验"><a href="#引擎编辑页名称重复校验" class="headerlink" title="引擎编辑页名称重复校验"></a>引擎编辑页名称重复校验</h4><ul><li><strong>分析</strong>：接口处做重复校验。</li><li><strong>关键词</strong>：前后端联调</li><li><strong>工时评估</strong>：0.4d</li></ul><h4 id="引擎安装详情优化"><a href="#引擎安装详情优化" class="headerlink" title="引擎安装详情优化"></a>引擎安装详情优化</h4><ul><li><strong>分析</strong>：前端去掉了一些字段，增加了跳转。</li><li><strong>关键词</strong>：前后端联调</li><li><strong>工时评估</strong>：0.34d</li></ul><h3 id="卸载优化"><a href="#卸载优化" class="headerlink" title="卸载优化"></a>卸载优化</h3><h4 id="引擎离线时可以强制卸载，（删除对此节点授权）"><a href="#引擎离线时可以强制卸载，（删除对此节点授权）" class="headerlink" title="引擎离线时可以强制卸载，（删除对此节点授权）"></a>引擎离线时可以强制卸载，（删除对此节点授权）</h4><ul><li><strong>分析</strong>：技术难点在于当引擎恢复后，是否影响引擎和总控的工作，需要将所有引擎与总控的通信机制整理出来后，修改机制，当没有获得总控认可，流量不被处理。</li><li><strong>关键词</strong>：前后端联调、技术难点、技术方案</li><li><strong>工时评估</strong>：6.8d</li></ul><h4 id="新增引擎节点离线卸载脚本（执行后该节点会释放资源）"><a href="#新增引擎节点离线卸载脚本（执行后该节点会释放资源）" class="headerlink" title="新增引擎节点离线卸载脚本（执行后该节点会释放资源）"></a>新增引擎节点离线卸载脚本（执行后该节点会释放资源）</h4><ul><li><strong>分析</strong>：每个组件实现节点卸载脚本，卸载脚本执行节点卸载。</li><li><strong>关键词</strong>：引擎联调</li><li><strong>工时评估</strong>：2.6d</li></ul><h4 id="界面卸载交互确认密码"><a href="#界面卸载交互确认密码" class="headerlink" title="界面卸载交互确认密码"></a>界面卸载交互确认密码</h4><ul><li><strong>分析</strong>：确认密码接口。</li><li><strong>关键词</strong>：前后端联调、总控联调</li><li><strong>工时评估</strong>：0.34d</li></ul><h2 id="边车引擎-P1"><a href="#边车引擎-P1" class="headerlink" title="边车引擎 (P1)"></a>边车引擎 (P1)</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="边车引擎安装列表优化"><a href="#边车引擎安装列表优化" class="headerlink" title="边车引擎安装列表优化"></a>边车引擎安装列表优化</h4><ul><li><strong>工时评估</strong>：2d</li></ul><h4 id="安装弹窗优化"><a href="#安装弹窗优化" class="headerlink" title="安装弹窗优化"></a>安装弹窗优化</h4><ul><li><strong>工时评估</strong>：1d</li></ul><h4 id="安装详情页优化"><a href="#安装详情页优化" class="headerlink" title="安装详情页优化"></a>安装详情页优化</h4><ul><li><strong>工时评估</strong>：0.5d</li></ul><h4 id="编辑页面优化"><a href="#编辑页面优化" class="headerlink" title="编辑页面优化"></a>编辑页面优化</h4><ul><li><strong>工时评估</strong>：0.5d</li></ul><h4 id="边车引擎资源检测前优化"><a href="#边车引擎资源检测前优化" class="headerlink" title="边车引擎资源检测前优化"></a>边车引擎资源检测前优化</h4><ul><li><strong>工时评估</strong>：0.5d</li></ul><h4 id="安装失败回滚"><a href="#安装失败回滚" class="headerlink" title="安装失败回滚"></a>安装失败回滚</h4><ul><li><strong>工时评估</strong>：1.5d</li></ul><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><h4 id="提供后台强制卸载脚本"><a href="#提供后台强制卸载脚本" class="headerlink" title="提供后台强制卸载脚本"></a>提供后台强制卸载脚本</h4><ul><li><strong>工时评估</strong>：0.5d</li></ul><h4 id="新增强制卸载功能"><a href="#新增强制卸载功能" class="headerlink" title="新增强制卸载功能"></a>新增强制卸载功能</h4><ul><li><strong>工时评估</strong>：0.5d</li></ul><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><h4 id="边车升级包导入"><a href="#边车升级包导入" class="headerlink" title="边车升级包导入"></a>边车升级包导入</h4><ul><li><strong>工时评估</strong>：2d</li></ul><h4 id="边车正常升级功能（需要C-组配合提供polycube和envoy升级脚本）"><a href="#边车正常升级功能（需要C-组配合提供polycube和envoy升级脚本）" class="headerlink" title="边车正常升级功能（需要C++组配合提供polycube和envoy升级脚本）"></a>边车正常升级功能（需要C++组配合提供polycube和envoy升级脚本）</h4><ul><li><strong>工时评估</strong>：3d</li></ul><h4 id="升级失败回滚"><a href="#升级失败回滚" class="headerlink" title="升级失败回滚"></a>升级失败回滚</h4><ul><li><strong>工时评估</strong>：3d</li><li><strong>细节</strong>：实现方案或许可以在升级前把<code>/opt</code>目录下的组件先备份，升级失败后恢复相应目录，重启相关组件进程；升级成功则把备份数据删掉。</li></ul><h2 id="镜像引擎-P2"><a href="#镜像引擎-P2" class="headerlink" title="镜像引擎 (P2)"></a>镜像引擎 (P2)</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><h4 id="引擎授权状态查询（暂定调总控接口后聚合）"><a href="#引擎授权状态查询（暂定调总控接口后聚合）" class="headerlink" title="引擎授权状态查询（暂定调总控接口后聚合）"></a>引擎授权状态查询（暂定调总控接口后聚合）</h4><ul><li><strong>工时评估</strong>：0.5d</li></ul><h4 id="名称重复校验（只对已安装的检测）"><a href="#名称重复校验（只对已安装的检测）" class="headerlink" title="名称重复校验（只对已安装的检测）"></a>名称重复校验（只对已安装的检测）</h4><ul><li><strong>工时评估</strong>：0.5d</li></ul><h4 id="名称限制在63长度以下"><a href="#名称限制在63长度以下" class="headerlink" title="名称限制在63长度以下"></a>名称限制在63长度以下</h4><ul><li><strong>工时评估</strong>：0.5d</li></ul><h4 id="安装过程中点击取消安装（速度很快，可能还没点击就安装完了）（需新增接口，可新增一个状态）"><a href="#安装过程中点击取消安装（速度很快，可能还没点击就安装完了）（需新增接口，可新增一个状态）" class="headerlink" title="安装过程中点击取消安装（速度很快，可能还没点击就安装完了）（需新增接口，可新增一个状态）"></a>安装过程中点击取消安装（速度很快，可能还没点击就安装完了）（需新增接口，可新增一个状态）</h4><ul><li><strong>工时评估</strong>：3d</li></ul><h4 id="多账号安装时要加锁"><a href="#多账号安装时要加锁" class="headerlink" title="多账号安装时要加锁"></a>多账号安装时要加锁</h4><ul><li><strong>工时评估</strong>：0.5d</li></ul><h4 id="相关日志要做记录（中间件或统一一种记录方式）"><a href="#相关日志要做记录（中间件或统一一种记录方式）" class="headerlink" title="相关日志要做记录（中间件或统一一种记录方式）"></a>相关日志要做记录（中间件或统一一种记录方式）</h4><ul><li><strong>工时评估</strong>：1d</li></ul><h4 id="进度条（与前端约定或自行计算（可能要修改返回字段））"><a href="#进度条（与前端约定或自行计算（可能要修改返回字段））" class="headerlink" title="进度条（与前端约定或自行计算（可能要修改返回字段））"></a>进度条（与前端约定或自行计算（可能要修改返回字段））</h4><ul><li><strong>工时评估</strong>：1.5d</li></ul><h4 id="离线安装：生成对应的安装包（拆包再修改再打包，CPU和磁盘性能差时会影响效率，需新增接口）"><a href="#离线安装：生成对应的安装包（拆包再修改再打包，CPU和磁盘性能差时会影响效率，需新增接口）" class="headerlink" title="离线安装：生成对应的安装包（拆包再修改再打包，CPU和磁盘性能差时会影响效率，需新增接口）"></a>离线安装：生成对应的安装包（拆包再修改再打包，CPU和磁盘性能差时会影响效率，需新增接口）</h4><ul><li><strong>工时评估</strong>：1.5d</li></ul><h4 id="离线安装：系统资源可用性检测，判断是否满足安装要求"><a href="#离线安装：系统资源可用性检测，判断是否满足安装要求" class="headerlink" title="离线安装：系统资源可用性检测，判断是否满足安装要求"></a>离线安装：系统资源可用性检测，判断是否满足安装要求</h4><ul><li><strong>工时评估</strong>：1d</li></ul><h4 id="离线安装：卸载残留检测"><a href="#离线安装：卸载残留检测" class="headerlink" title="离线安装：卸载残留检测"></a>离线安装：卸载残留检测</h4><ul><li><strong>工时评估</strong>：0.5d</li></ul><h4 id="离线安装：安装包下载接口（新增接口）"><a href="#离线安装：安装包下载接口（新增接口）" class="headerlink" title="离线安装：安装包下载接口（新增接口）"></a>离线安装：安装包下载接口（新增接口）</h4><ul><li><strong>工时评估</strong>：1d</li></ul><h4 id="离线安装：失败重试-回滚（大概率也会失败，次数和形式待定，是否需要交互）"><a href="#离线安装：失败重试-回滚（大概率也会失败，次数和形式待定，是否需要交互）" class="headerlink" title="离线安装：失败重试&#x2F;回滚（大概率也会失败，次数和形式待定，是否需要交互）"></a>离线安装：失败重试&#x2F;回滚（大概率也会失败，次数和形式待定，是否需要交互）</h4><ul><li><strong>工时评估</strong>：1.5d</li></ul><h4 id="离线安装：安装后向总控（installer）注册（成功失败都需要；需总控实现一个注册接口）"><a href="#离线安装：安装后向总控（installer）注册（成功失败都需要；需总控实现一个注册接口）" class="headerlink" title="离线安装：安装后向总控（installer）注册（成功失败都需要；需总控实现一个注册接口）"></a>离线安装：安装后向总控（installer）注册（成功失败都需要；需总控实现一个注册接口）</h4><ul><li><strong>工时评估</strong>：1d</li></ul><h3 id="卸载-1"><a href="#卸载-1" class="headerlink" title="卸载"></a>卸载</h3><h4 id="强制卸载，清除相关注册信息"><a href="#强制卸载，清除相关注册信息" class="headerlink" title="强制卸载，清除相关注册信息"></a>强制卸载，清除相关注册信息</h4><ul><li><strong>工时评估</strong>：1d</li></ul><h4 id="被强制卸载的引擎若再次重连则不做处理"><a href="#被强制卸载的引擎若再次重连则不做处理" class="headerlink" title="被强制卸载的引擎若再次重连则不做处理"></a>被强制卸载的引擎若再次重连则不做处理</h4><ul><li><strong>工时评估</strong>：5d</li></ul><h4 id="进度条（与前端约定或自行计算（可能要修改返回字段））-1"><a href="#进度条（与前端约定或自行计算（可能要修改返回字段））-1" class="headerlink" title="进度条（与前端约定或自行计算（可能要修改返回字段））"></a>进度条（与前端约定或自行计算（可能要修改返回字段））</h4><ul><li><strong>工时评估</strong>：1.5d</li></ul><h4 id="失败重试（大概率也会失败，次数和形式待定，是否需要交互）"><a href="#失败重试（大概率也会失败，次数和形式待定，是否需要交互）" class="headerlink" title="失败重试（大概率也会失败，次数和形式待定，是否需要交互）"></a>失败重试（大概率也会失败，次数和形式待定，是否需要交互）</h4><ul><li><strong>工时评估</strong>：1d</li></ul><h3 id="升级-1"><a href="#升级-1" class="headerlink" title="升级"></a>升级</h3><h4 id="升级包导入、取消导入（需新增接口，或共用接口）"><a href="#升级包导入、取消导入（需新增接口，或共用接口）" class="headerlink" title="升级包导入、取消导入（需新增接口，或共用接口）"></a>升级包导入、取消导入（需新增接口，或共用接口）</h4><ul><li><strong>工时评估</strong>：2d</li></ul><h4 id="changelog（生成方式、内容和存放位置待定）"><a href="#changelog（生成方式、内容和存放位置待定）" class="headerlink" title="changelog（生成方式、内容和存放位置待定）"></a>changelog（生成方式、内容和存放位置待定）</h4><ul><li><strong>工时评估</strong>：1d</li></ul><h4 id="升级包合法性、版本、依赖校验（需约定包结构和内容和检测方式）"><a href="#升级包合法性、版本、依赖校验（需约定包结构和内容和检测方式）" class="headerlink" title="升级包合法性、版本、依赖校验（需约定包结构和内容和检测方式）"></a>升级包合法性、版本、依赖校验（需约定包结构和内容和检测方式）</h4><ul><li><strong>工时评估</strong>：2d</li></ul><h4 id="多账号升级时要加锁"><a href="#多账号升级时要加锁" class="headerlink" title="多账号升级时要加锁"></a>多账号升级时要加锁</h4><ul><li><strong>工时评估</strong>：0.5d</li></ul><h4 id="卸载升级中的引擎时要报错"><a href="#卸载升级中的引擎时要报错" class="headerlink" title="卸载升级中的引擎时要报错"></a>卸载升级中的引擎时要报错</h4><ul><li><strong>工时评估</strong>：0.5d</li></ul><h4 id="升级时禁止对相关agent操作"><a href="#升级时禁止对相关agent操作" class="headerlink" title="升级时禁止对相关agent操作"></a>升级时禁止对相关agent操作</h4><ul><li><strong>工时评估</strong>：0.5d</li></ul><h4 id="升级包要做依赖记录（需约定记录方式）"><a href="#升级包要做依赖记录（需约定记录方式）" class="headerlink" title="升级包要做依赖记录（需约定记录方式）"></a>升级包要做依赖记录（需约定记录方式）</h4><ul><li><strong>工时评估</strong>：1d</li></ul><h4 id="升级失败回滚（大概率也会失败，次数和形式待定，是否需要交互）"><a href="#升级失败回滚（大概率也会失败，次数和形式待定，是否需要交互）" class="headerlink" title="升级失败回滚（大概率也会失败，次数和形式待定，是否需要交互）"></a>升级失败回滚（大概率也会失败，次数和形式待定，是否需要交互）</h4><ul><li><strong>工时评估</strong>：1d</li></ul><h2 id="流量-Agent-P2"><a href="#流量-Agent-P2" class="headerlink" title="流量 Agent (P2)"></a>流量 Agent (P2)</h2><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><h4 id="Agent授权状态查询（暂定调总控接口后聚合）"><a href="#Agent授权状态查询（暂定调总控接口后聚合）" class="headerlink" title="Agent授权状态查询（暂定调总控接口后聚合）"></a>Agent授权状态查询（暂定调总控接口后聚合）</h4><ul><li><strong>工时评估</strong>：0.5d</li></ul><h4 id="名称重复校验（只对已安装的检测）-1"><a href="#名称重复校验（只对已安装的检测）-1" class="headerlink" title="名称重复校验（只对已安装的检测）"></a>名称重复校验（只对已安装的检测）</h4><ul><li><strong>工时评估</strong>：0.5d</li></ul><h4 id="名称限制在63长度以下-1"><a href="#名称限制在63长度以下-1" class="headerlink" title="名称限制在63长度以下"></a>名称限制在63长度以下</h4><ul><li><strong>工时评估</strong>：0.5d</li></ul><h4 id="进度条（与前端约定或自行计算（可能要修改返回字段））-2"><a href="#进度条（与前端约定或自行计算（可能要修改返回字段））-2" class="headerlink" title="进度条（与前端约定或自行计算（可能要修改返回字段））"></a>进度条（与前端约定或自行计算（可能要修改返回字段））</h4><ul><li><strong>工时评估</strong>：1.5d</li></ul><h4 id="安装过程中点击取消安装（速度很快，可能还没点击就安装完了）（需新增接口，可新增一个状态）-1"><a href="#安装过程中点击取消安装（速度很快，可能还没点击就安装完了）（需新增接口，可新增一个状态）-1" class="headerlink" title="安装过程中点击取消安装（速度很快，可能还没点击就安装完了）（需新增接口，可新增一个状态）"></a>安装过程中点击取消安装（速度很快，可能还没点击就安装完了）（需新增接口，可新增一个状态）</h4><ul><li><strong>工时评估</strong>：3d</li></ul><h4 id="多账号安装时要加锁-1"><a href="#多账号安装时要加锁-1" class="headerlink" title="多账号安装时要加锁"></a>多账号安装时要加锁</h4><ul><li><strong>工时评估</strong>：0.5d</li></ul><h4 id="相关日志要做记录（中间件或统一一种记录方式）（给总控做）"><a href="#相关日志要做记录（中间件或统一一种记录方式）（给总控做）" class="headerlink" title="相关日志要做记录（中间件或统一一种记录方式）（给总控做）"></a>相关日志要做记录（中间件或统一一种记录方式）（给总控做）</h4><h4 id="组件要加版本号并记录（信息存放位置及内容不确定）"><a href="#组件要加版本号并记录（信息存放位置及内容不确定）" class="headerlink" title="组件要加版本号并记录（信息存放位置及内容不确定）"></a>组件要加版本号并记录（信息存放位置及内容不确定）</h4><ul><li><strong>工时评估</strong>：2d</li></ul><h3 id="卸载-2"><a href="#卸载-2" class="headerlink" title="卸载"></a>卸载</h3><h4 id="强制卸载，清除相关注册信息-1"><a href="#强制卸载，清除相关注册信息-1" class="headerlink" title="强制卸载，清除相关注册信息"></a>强制卸载，清除相关注册信息</h4><ul><li><strong>工时评估</strong>：0.5d</li></ul><h4 id="被强制卸载的Agent若再次重连则不做处理（需要C-组处理）"><a href="#被强制卸载的Agent若再次重连则不做处理（需要C-组处理）" class="headerlink" title="被强制卸载的Agent若再次重连则不做处理（需要C++组处理）"></a>被强制卸载的Agent若再次重连则不做处理（需要C++组处理）</h4><h4 id="进度条（与前端约定或自行计算（可能要修改返回字段））-3"><a href="#进度条（与前端约定或自行计算（可能要修改返回字段））-3" class="headerlink" title="进度条（与前端约定或自行计算（可能要修改返回字段））"></a>进度条（与前端约定或自行计算（可能要修改返回字段））</h4><ul><li><strong>工时评估</strong>：1.5d</li></ul><h4 id="失败重试（大概率也会失败，次数和形式待定，是否需要交互）-1"><a href="#失败重试（大概率也会失败，次数和形式待定，是否需要交互）-1" class="headerlink" title="失败重试（大概率也会失败，次数和形式待定，是否需要交互）"></a>失败重试（大概率也会失败，次数和形式待定，是否需要交互）</h4><ul><li><strong>工时评估</strong>：1d</li></ul><h3 id="卸载-3"><a href="#卸载-3" class="headerlink" title="卸载"></a>卸载</h3><h4 id="强制卸载，清除相关注册信息-2"><a href="#强制卸载，清除相关注册信息-2" class="headerlink" title="强制卸载，清除相关注册信息"></a>强制卸载，清除相关注册信息</h4><ul><li><strong>工时评估</strong>：0.5d</li></ul><h4 id="被强制卸载的Agent若再次重连则不做处理（需要C-组处理）-1"><a href="#被强制卸载的Agent若再次重连则不做处理（需要C-组处理）-1" class="headerlink" title="被强制卸载的Agent若再次重连则不做处理（需要C++组处理）"></a>被强制卸载的Agent若再次重连则不做处理（需要C++组处理）</h4><h4 id="进度条（与前端约定或自行计算（可能要修改返回字段））-4"><a href="#进度条（与前端约定或自行计算（可能要修改返回字段））-4" class="headerlink" title="进度条（与前端约定或自行计算（可能要修改返回字段））"></a>进度条（与前端约定或自行计算（可能要修改返回字段））</h4><ul><li><strong>工时评估</strong>：1.5d</li></ul><h4 id="失败重试（大概率也会失败，次数和形式待定，是否需要交互）-2"><a href="#失败重试（大概率也会失败，次数和形式待定，是否需要交互）-2" class="headerlink" title="失败重试（大概率也会失败，次数和形式待定，是否需要交互）"></a>失败重试（大概率也会失败，次数和形式待定，是否需要交互）</h4><ul><li><strong>工时评估</strong>：1d</li></ul><h3 id="升级-2"><a href="#升级-2" class="headerlink" title="升级"></a>升级</h3><h4 id="升级包导入、取消导入（需新增接口，或共用接口）-1"><a href="#升级包导入、取消导入（需新增接口，或共用接口）-1" class="headerlink" title="升级包导入、取消导入（需新增接口，或共用接口）"></a>升级包导入、取消导入（需新增接口，或共用接口）</h4><ul><li><strong>工时评估</strong>：2d</li></ul><h4 id="changelog（生成方式、内容和存放位置待定）-1"><a href="#changelog（生成方式、内容和存放位置待定）-1" class="headerlink" title="changelog（生成方式、内容和存放位置待定）"></a>changelog（生成方式、内容和存放位置待定）</h4><ul><li><strong>工时评估</strong>：1d</li></ul><h4 id="升级包合法性、版本、依赖校验（需约定包结构和内容和检测方式）-1"><a href="#升级包合法性、版本、依赖校验（需约定包结构和内容和检测方式）-1" class="headerlink" title="升级包合法性、版本、依赖校验（需约定包结构和内容和检测方式）"></a>升级包合法性、版本、依赖校验（需约定包结构和内容和检测方式）</h4><ul><li><strong>工时评估</strong>：2d</li></ul><h4 id="多账号升级时要加锁-1"><a href="#多账号升级时要加锁-1" class="headerlink" title="多账号升级时要加锁"></a>多账号升级时要加锁</h4><ul><li><strong>工时评估</strong>：0.5d</li></ul><h4 id="卸载升级中的引擎时要报错-1"><a href="#卸载升级中的引擎时要报错-1" class="headerlink" title="卸载升级中的引擎时要报错"></a>卸载升级中的引擎时要报错</h4><ul><li><strong>工时评估</strong>：0.5d</li></ul><h4 id="升级时禁止编辑挂起等等操作"><a href="#升级时禁止编辑挂起等等操作" class="headerlink" title="升级时禁止编辑挂起等等操作"></a>升级时禁止编辑挂起等等操作</h4><ul><li><strong>工时评估</strong>：0.5d</li></ul><h4 id="升级包要做依赖记录（需约定记录方式）-1"><a href="#升级包要做依赖记录（需约定记录方式）-1" class="headerlink" title="升级包要做依赖记录（需约定记录方式）"></a>升级包要做依赖记录（需约定记录方式）</h4><ul><li><strong>工时评估</strong>：1d</li></ul><h4 id="升级失败回滚（大概率也会失败，次数和形式待定，是否需要交互）-1"><a href="#升级失败回滚（大概率也会失败，次数和形式待定，是否需要交互）-1" class="headerlink" title="升级失败回滚（大概率也会失败，次数和形式待定，是否需要交互）"></a>升级失败回滚（大概率也会失败，次数和形式待定，是否需要交互）</h4><ul><li><strong>工时评估</strong>：1d</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1.6任务评估v2.md</title>
    <link href="/2024/06/12/mdstorage/project/sr/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%9B%B8%E5%85%B3/1.6%E4%BB%BB%E5%8A%A1%E8%AF%84%E4%BC%B0v2/"/>
    <url>/2024/06/12/mdstorage/project/sr/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%9B%B8%E5%85%B3/1.6%E4%BB%BB%E5%8A%A1%E8%AF%84%E4%BC%B0v2/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>需求</th><th>子任务</th><th>优先级</th><th>负责人</th><th>工时评估</th><th>计划开始时间</th><th>计划完成时间</th><th>岗位组别</th><th>任务状态</th><th>前置任务</th><th>备注</th></tr></thead><tbody><tr><td>总控安装相关需求</td><td>安装脚本中加入IP设置的交互：文档+编码</td><td>P2</td><td></td><td>2.4</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>总控安装相关需求</td><td>打总控包时需要将安装脚本挪到安装包的第一层目录下</td><td>P2</td><td></td><td>0.34</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>总控安装相关需求</td><td>需要调整安装脚本的默认工作目录</td><td>P2</td><td></td><td>0.34</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>总控安装相关需求</td><td>安装的残留清除：文档+编码</td><td>P2</td><td></td><td>2.4</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>总控安装相关需求</td><td>在总控安装时需要将上次残留的总控给清除干净，并进行安装</td><td>P2</td><td></td><td>2.2</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>总控安装相关需求</td><td>环境检测时将内存、CPU核心数、磁盘存储空间的资源校验调整为非硬性要求的安装检测条件</td><td>P2</td><td></td><td>0.8</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>总控安装相关需求</td><td>总控数据初始化调整：纯执行</td><td>P2</td><td></td><td>2</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>总控卸载相关的需求</td><td>打包时将总控的卸载脚本的调整到第一层目录</td><td>P2</td><td></td><td>0.34</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>总控卸载相关的需求</td><td>卸载脚本需要调整默认的工作目录位置</td><td>P2</td><td></td><td>0.34</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>总控升级相关的需求</td><td>总控包、插件包的打包拆分：纯执行（需要前置完成—-组件与结构与定义）</td><td>P2</td><td></td><td>5.6</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>总控升级相关的需求</td><td>在总控数据初始化的时候插件包数据初始化的代码需要做相关调整</td><td>P2</td><td></td><td>2.2</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>总控升级相关的需求</td><td>在总控升级包导入的时候需要对插件包导入逻辑做相关的调整</td><td>P2</td><td></td><td>4.2</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>总控升级相关的需求</td><td>增加对插件增量包导入的支持</td><td>P2</td><td></td><td>1.4</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>总控升级管理模块：升级包导入</td><td>在升级包导入时需要拆分、校验、与记录各个升级单位的数据</td><td>P2</td><td></td><td>4.2</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>总控升级管理模块：展示每个升级单位的版本日志</td><td>插件升级，由 sc 调用插件管理程序实现</td><td>P2</td><td></td><td>1.4</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>总控升级管理模块</td><td>聚合已安装&#x2F;绑定的流量引擎、边车引擎、镜像引擎、插件的数据以展示升级列表</td><td>P2</td><td></td><td>3.2</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>总控升级管理模块</td><td>升级状态与进度的展示</td><td>P2</td><td></td><td>1.4</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>总控升级核心功能</td><td>总控各个组件的升级调度逻辑</td><td>P2</td><td></td><td>0.8</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>总控升级核心功能</td><td>升级进度的反馈逻辑</td><td>P2</td><td></td><td>0.8</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>总控升级核心功能</td><td>升级失败信息的反馈</td><td>P2</td><td></td><td>0.8</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>总控升级核心功能</td><td>升级失败的回滚调度</td><td>P2</td><td></td><td>2.2</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>总控升级核心功能</td><td>升级成功的确认调度</td><td>P2</td><td></td><td>2.2</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>流量引擎安装</td><td>引擎安装界面新增授权状态过滤选项</td><td>P1</td><td></td><td>0.8</td><td></td><td></td><td></td><td>未开始</td><td></td><td>分析：这个需要 installer 这边查询授权接口，聚合查询。关键词：总控联调、前后端联调</td></tr><tr><td>流量引擎安装</td><td>引擎安装界面新增可用节点、调出待安装工作节点、已安装工作节点</td><td>P1</td><td></td><td>0.4</td><td></td><td></td><td></td><td>未开始</td><td></td><td>分析：这里设计前端修改较大，后端改动不多。关键词：前后端联调</td></tr><tr><td>流量引擎安装</td><td>引擎安装、卸载失败原因后端记录、展示</td><td>P1</td><td></td><td>1.3</td><td></td><td></td><td></td><td>未开始</td><td></td><td>分析：需要加一张引擎生命周期操作表，记录某引擎下的操作，失败原因，时间等信息，便于查询展示。关键词：表结构设计、前后端联调、引擎联调</td></tr><tr><td>流量引擎安装</td><td>已到期、未到期引擎工作节点展示</td><td>P1</td><td></td><td>0.8</td><td></td><td></td><td></td><td>未开始</td><td></td><td>分析：installer 各个工作节点查询授权，聚合展示。关键词：前后端联调</td></tr><tr><td>流量引擎安装</td><td>节点扩容新增校验逻辑：管理节点只能是技术，节点名称不允许重复，业务口网卡不与总控同网段</td><td>P1</td><td></td><td>1.3</td><td></td><td></td><td></td><td>未开始</td><td></td><td>分析：新增检测项目。关键词：前后端联调</td></tr><tr><td>流量引擎安装</td><td>允许管理节点扩容，技术调研</td><td>P1</td><td></td><td>3d</td><td></td><td></td><td></td><td>未开始</td><td></td><td>分析：需要做技术调研，测试，查看相关代码。关键词：技术难点</td></tr><tr><td>流量引擎安装</td><td>管理节点扩容，实现</td><td>P1</td><td></td><td>3d</td><td></td><td></td><td></td><td>未开始</td><td></td><td>分析：实现管理节点新增。关键词：引擎配合</td></tr><tr><td>流量引擎安装</td><td>硬件检测是否满足基础要求，去掉标准要求，结果展示逻辑变更</td><td>P1</td><td></td><td>2.6</td><td></td><td></td><td></td><td>未开始</td><td></td><td>分析：检测逻辑变更，展示逻辑变更。关键词：前后端联调</td></tr><tr><td>流量引擎安装</td><td>程序冲突检测，冲突则不符合</td><td>P1</td><td></td><td>1.3</td><td></td><td></td><td></td><td>未开始</td><td></td><td>分析：统一程序冲突检测定义逻辑，出相应文档。关键词：前后端联调</td></tr><tr><td>流量引擎安装</td><td>多节点安装并行执行</td><td>P1</td><td></td><td>0</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>流量引擎安装</td><td>多节点安装，安装失败的引擎节点触发清理操作，卸载干净</td><td>P1</td><td></td><td>4.2</td><td></td><td></td><td></td><td>未开始</td><td></td><td>分析：触发卸载操作，难点在可靠性的保证，当作一个新脚本实现，<code>uninstall --force</code>。关键词：引擎联调、技术方案</td></tr><tr><td>流量引擎安装</td><td>多账户引擎安装操作时，提示引擎正在安装中</td><td>P1</td><td></td><td>1.4</td><td></td><td></td><td></td><td>未开始</td><td></td><td>分析：当重入时，返回相应异常信息。关键词：前后端联调</td></tr><tr><td>流量引擎安装</td><td>引擎编辑页名称重复校验</td><td>P1</td><td></td><td>0.4</td><td></td><td></td><td></td><td>未开始</td><td></td><td>分析：接口处做重复校验。关键词：前后端联调</td></tr><tr><td>流量引擎安装</td><td>引擎安装详情优化</td><td>P1</td><td></td><td>0.34</td><td></td><td></td><td></td><td>未开始</td><td></td><td>分析：前端去掉了一些字段，增加了跳转。关键词：前后端联调</td></tr><tr><td>流量引擎安装</td><td>引擎离线时可以强制卸载，（删除对此节点授权）</td><td>P1</td><td></td><td>6.8</td><td></td><td></td><td></td><td>未开始</td><td></td><td>分析：技术难点在于当引擎恢复后，是否影响引擎和总控的工作，需要将所有引擎与总控的通信机制整理出来后，修改机制，当没有获得总控认可，流量不被处理。关键词：前后端联调、技术难点、技术方案</td></tr><tr><td>流量引擎安装</td><td>新增引擎节点离线卸载脚本（执行后该节点会释放资源）</td><td>P1</td><td></td><td>2.6</td><td></td><td></td><td></td><td>未开始</td><td></td><td>分析：每个组件实现节点卸载脚本，卸载脚本执行节点卸载。关键词：引擎联调</td></tr><tr><td>流量引擎安装</td><td>界面卸载交互确认密码</td><td>P1</td><td></td><td>0.34</td><td></td><td></td><td></td><td>未开始</td><td></td><td>分析：确认密码接口。关键词：前后端联调、总控联调</td></tr><tr><td>边车引擎安装</td><td>边车引擎安装列表优化</td><td>P1</td><td></td><td>2</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>边车引擎安装</td><td>安装弹窗优化</td><td>P1</td><td></td><td>1</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>边车引擎安装</td><td>安装详情页优化</td><td>P1</td><td></td><td>0.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>边车引擎安装</td><td>编辑页面优化</td><td>P1</td><td></td><td>0.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>边车引擎安装</td><td>边车引擎资源检测前优化</td><td>P1</td><td></td><td>0.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>边车引擎安装</td><td>安装失败回滚</td><td>P1</td><td></td><td>1.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>边车引擎安装</td><td>提供后台强制卸载脚本</td><td>P1</td><td></td><td>0.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>边车引擎安装</td><td>新增强制卸载功能</td><td>P1</td><td></td><td>0.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>边车引擎安装</td><td>边车升级包导入</td><td>P1</td><td></td><td>2</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>边车引擎安装</td><td>边车正常升级功能（需要C++组配合提供polycube和envoy升级脚本）</td><td>P1</td><td></td><td>3</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>升级失败回滚</td><td>实现方案或许可以在升级前把<code>/opt</code>目录下的组件先备份，升级失败后恢复相应目录，重启相关组件进程；升级成功则把备份数据删掉</td><td>P1</td><td></td><td>3</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>引擎授权状态查询（暂定调总控接口后聚合）</td><td>P2</td><td></td><td>0.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>名称重复校验（只对已安装的检测）</td><td>P2</td><td></td><td>0.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>名称限制在63长度以下</td><td>P2</td><td></td><td>0.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>安装过程中点击取消安装（速度很快，可能还没点击就安装完了）（需新增接口，可新增一个状态）</td><td>P2</td><td></td><td>3</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>多账号安装时要加锁</td><td>P2</td><td></td><td>0.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>相关日志要做记录（中间件或统一一种记录方式）</td><td>P2</td><td></td><td>1</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>进度条（与前端约定或自行计算（可能要修改返回字段））</td><td>P2</td><td></td><td>1.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>离线安装：生成对应的安装包（拆包再修改再打包，CPU和磁盘性能差时会影响效率，需新增接口）</td><td>P2</td><td></td><td>1.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>离线安装：系统资源可用性检测，判断是否满足安装要求</td><td>P2</td><td></td><td>1</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>离线安装：卸载残留检测</td><td>P2</td><td></td><td>0.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>离线安装：安装包下载接口（新增接口）</td><td>P2</td><td></td><td>1</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>离线安装：失败重试&#x2F;回滚（大概率也会失败，次数和形式待定，是否需要交互）</td><td>P2</td><td></td><td>1.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>离线安装：安装后向总控（installer）注册（成功失败都需要；需总控实现一个注册接口）</td><td>P2</td><td></td><td>1</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>强制卸载，清除相关注册信息</td><td>P2</td><td></td><td>1</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>被强制卸载的引擎若再次重连则不做处理</td><td>P2</td><td></td><td>5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>进度条（与前端约定或自行计算（可能要修改返回字段））</td><td>P2</td><td></td><td>1.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>失败重试（大概率也会失败，次数和形式待定，是否需要交互）</td><td>P2</td><td></td><td>1</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>升级包导入、取消导入（需新增接口，或共用接口）</td><td>P2</td><td></td><td>2</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>changelog（生成方式、内容和存放位置待定）</td><td>P2</td><td></td><td>1</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>升级包合法性、版本、依赖校验（需约定包结构和内容和检测方式）</td><td>P2</td><td></td><td>2</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>多账号升级时要加锁</td><td>P2</td><td></td><td>0.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>卸载升级中的引擎时要报错</td><td>P2</td><td></td><td>0.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>升级时禁止对相关agent操作</td><td>P2</td><td></td><td>0.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>升级包要做依赖记录（需约定记录方式）</td><td>P2</td><td></td><td>1</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>镜像引擎安装</td><td>升级失败回滚（大概率也会失败，次数和形式待定，是否需要交互）</td><td>P2</td><td></td><td>1</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>流量Agent 安装</td><td>Agent授权状态查询（暂定调总控接口后聚合）</td><td>P2</td><td></td><td>0.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>流量Agent 安装</td><td>名称重复校验（只对已安装的检测）</td><td>P2</td><td></td><td>0.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>流量Agent 安装</td><td>名称限制在63长度以下</td><td>P2</td><td></td><td>0.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>流量Agent 安装</td><td>进度条（与前端约定或自行计算（可能要修改返回字段））</td><td>P2</td><td></td><td>1.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>流量Agent 安装</td><td>安装过程中点击取消安装（速度很快，可能还没点击就安装完了）（需新增接口，可新增一个状态）</td><td>P2</td><td></td><td>3</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>流量Agent 安装</td><td>多账号安装时要加锁</td><td>P2</td><td></td><td>0.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>流量Agent 安装</td><td>相关日志要做记录（中间件或统一一种记录方式）（给总控做）</td><td>P2</td><td></td><td>1</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>流量Agent 安装</td><td>组件要加版本号并记录（信息存放位置及内容不确定）</td><td>P2</td><td></td><td>2</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>流量Agent 安装</td><td>强制卸载，清除相关注册信息</td><td>P2</td><td></td><td>0.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>流量Agent 安装</td><td>被强制卸载的Agent若再次重连则不做处理</td><td>P2</td><td></td><td>1</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>流量Agent 安装</td><td>进度条（与前端约定或自行计算（可能要修改返回字段））</td><td>P2</td><td></td><td>1.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>流量Agent 安装</td><td>失败重试（大概率也会失败，次数和形式待定，是否需要交互）</td><td>P2</td><td></td><td>1</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>流量Agent 安装</td><td>升级包导入、取消导入（需新增接口，或共用接口）</td><td>P2</td><td></td><td>2</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>流量Agent 安装</td><td>changelog（生成方式、内容和存放位置待定）</td><td>P2</td><td></td><td>1</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>流量Agent 安装</td><td>升级包合法性、版本、依赖校验（需约定包结构和内容和检测方式）</td><td>P2</td><td></td><td>2</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>流量Agent 安装</td><td>多账号升级时要加锁</td><td>P2</td><td></td><td>0.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>流量Agent 安装</td><td>卸载升级中的引擎时要报错</td><td>P2</td><td></td><td>0.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>流量Agent 安装</td><td>升级时禁止编辑挂起等等操作</td><td>P2</td><td></td><td>0.5</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>流量Agent 安装</td><td>升级包要做依赖记录（需约定记录方式）</td><td>P2</td><td></td><td>1</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr><tr><td>流量Agent 安装</td><td>升级失败回滚（大概率也会失败，次数和形式待定，是否需要交互）</td><td>P2</td><td></td><td>1</td><td></td><td></td><td></td><td>未开始</td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sr安装.md</title>
    <link href="/2024/06/07/mdstorage/project/sr/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%9B%B8%E5%85%B3/sr%E5%AE%89%E8%A3%85/"/>
    <url>/2024/06/07/mdstorage/project/sr/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%9B%B8%E5%85%B3/sr%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="需求文档存在问题"><a href="#需求文档存在问题" class="headerlink" title="需求文档存在问题"></a>需求文档存在问题</h2><p>对象 定义不明，功能边界不清晰</p><p>需求理解困难：</p><pre><code class="hljs">歧义与误解：研发团队可能会对需求产生不同的理解，导致开发出的功能不符合用户的实际需求。需求变更频繁：由于最初的需求不明确，在开发过程中可能会频繁调整和变更需求，增加开发成本和时间。</code></pre><p>设计与架构挑战：</p><pre><code class="hljs">设计难度增加：不明确的需求使得设计团队无法确定系统的边界和行为，从而难以进行有效的系统设计。架构不稳定：功能边界不清晰可能导致系统架构反复调整，影响系统的稳定性和扩展性。</code></pre><p>开发效率降低：</p><pre><code class="hljs">迭代开发：由于需求的不确定性，开发团队可能需要反复迭代和重构代码，影响开发效率。资源浪费：投入大量时间和资源去实现不明确的功能，可能导致人力和物力的浪费。</code></pre><p>测试与质量保障难度增大：</p><pre><code class="hljs">测试用例难以编写：测试团队无法明确功能的预期行为，难以编写全面的测试用例，可能导致遗漏重要的测试场景。缺陷难以定位：由于功能定义不明确，发现缺陷后难以确定是需求问题还是实现问题。</code></pre><p>项目管理风险：</p><pre><code class="hljs">进度与预算超支：由于需求变更和开发效率低下，项目可能超出预期的进度和预算。团队士气受挫：频繁的变更和不确定性会导致团队成员的士气受挫，影响工作积极性和生产力。</code></pre><h2 id="镜像-Agent"><a href="#镜像-Agent" class="headerlink" title="镜像 Agent"></a>镜像 Agent</h2><h3 id="安装机制"><a href="#安装机制" class="headerlink" title="安装机制"></a>安装机制</h3><p>用 ssh 连上节点执行 安装</p><h3 id="升级、卸载机制"><a href="#升级、卸载机制" class="headerlink" title="升级、卸载机制"></a>升级、卸载机制</h3><p>向其 镜像流量 Mirror 发送命令，Mirror 的组件 AgentServer 提供了升级、卸载接口</p><h3 id="镜像-Agent-公共常量的定义"><a href="#镜像-Agent-公共常量的定义" class="headerlink" title="镜像 Agent 公共常量的定义"></a>镜像 Agent 公共常量的定义</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>watch.md</title>
    <link href="/2024/06/06/mdstorage/domain/linux/watch/"/>
    <url>/2024/06/06/mdstorage/domain/linux/watch/</url>
    
    <content type="html"><![CDATA[<p><code>watch</code> 命令是一个在终端上定期执行指定命令并更新其输出的工具。它通常用于监控命令的输出，例如查看系统状态、监控文件变化等。默认情况下，<code>watch</code> 每 2 秒执行一次指定命令。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">watch [选项] 命令<br></code></pre></td></tr></table></figure><h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><ul><li><code>-n</code> 或 <code>--interval</code>：指定命令执行的间隔时间（以秒为单位）。</li><li><code>-d</code> 或 <code>--differences</code>：高亮显示自上次更新以来发生变化的部分。</li><li><code>-t</code> 或 <code>--no-title</code>：不显示标题。</li><li><code>-g</code> 或 <code>--chgexit</code>：当命令的输出发生变化时退出。</li><li><code>-c</code> 或 <code>--color</code>：强制启用或禁用颜色。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ol><li><p><strong>每 5 秒显示一次当前时间：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">watch -n 5 <span class="hljs-built_in">date</span><br></code></pre></td></tr></table></figure></li><li><p><strong>每 2 秒列出 <code>/home</code> 目录的内容，并高亮显示变化：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">watch -d <span class="hljs-built_in">ls</span> /home<br></code></pre></td></tr></table></figure></li><li><p><strong>监控一个文件的大小变化：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">watch -d <span class="hljs-built_in">ls</span> -lh /path/to/file<br></code></pre></td></tr></table></figure></li><li><p><strong>每 10 秒监控系统的内存使用情况：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">watch -n 10 free -h<br></code></pre></td></tr></table></figure></li><li><p><strong>监控某个网络接口的统计信息：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">watch -d ifconfig eth0<br></code></pre></td></tr></table></figure></li><li><p><strong>退出 <code>watch</code> 命令输出变化时：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">watch -g <span class="hljs-built_in">ls</span> /path/to/directory<br></code></pre></td></tr></table></figure></li><li><p><strong>不显示标题：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">watch -t <span class="hljs-built_in">date</span><br></code></pre></td></tr></table></figure></li><li><p>**带管道符: **</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">watch <span class="hljs-string">&#x27;ps -elf | grep opt&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>watch</code> 命令会持续运行，直到你按 <code>Ctrl+C</code> 终止它。</li><li>使用 <code>-n</code> 选项时，时间间隔不要设置得太短，否则会导致系统性能下降。</li><li>某些命令的输出可能会受缓存影响而不显示实时变化。</li></ul><p>通过这些选项和示例，你可以有效地使用 <code>watch</code> 命令来监控系统状态和文件变化。如果你有更具体的需求，请告诉我，我可以提供更详细的帮助。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>watch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>etcd问题导致引擎运行告警.md</title>
    <link href="/2024/05/30/mdstorage/project/sr/etcd%E9%97%AE%E9%A2%98%E5%AF%BC%E8%87%B4%E5%BC%95%E6%93%8E%E8%BF%90%E8%A1%8C%E5%91%8A%E8%AD%A6/"/>
    <url>/2024/05/30/mdstorage/project/sr/etcd%E9%97%AE%E9%A2%98%E5%AF%BC%E8%87%B4%E5%BC%95%E6%93%8E%E8%BF%90%E8%A1%8C%E5%91%8A%E8%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>从提供的 etcd 日志中，可以观察到以下几点可能导致问题的线索：</p><ol><li><p>**时钟漂移 (Clock Drift)**：</p><ul><li>多次出现时钟漂移的警告，例如：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;level&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;warn&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;ts&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2024-05-30T16:29:50.127958+0800&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;caller&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;rafthttp/probing_status.go:82&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;msg&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;prober found high clock drift&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;round-tripper-name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ROUND_TRIPPER_SNAPSHOT&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;remote-peer-id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;980160cbc9bad363&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;clock-drift&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;1.108841426s&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;rtt&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;6.684067ms&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li>这表明 etcd 节点之间的时钟不同步，时钟不同步会导致分布式系统中数据的一致性问题。</li></ul></li><li><p>**请求处理时间过长 (Apply Request Took Too Long)**：</p><ul><li>多次出现请求处理时间超过预期的警告，例如：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;level&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;warn&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;ts&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2024-05-30T16:29:43.717108+0800&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;caller&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;etcdserver/util.go:170&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;msg&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;apply request took too long&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;took&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;288.810682ms&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;expected-duration&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;100ms&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;prefix&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;read-only range &quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;key:\&quot;/registry/nettools.ouryun.com.cn/dataifaces/\&quot; range_end:\&quot;/registry/nettools.ouryun.com.cn/dataifaces0\&quot; cou&gt;&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li>请求处理时间过长可能是由于系统负载过高、磁盘性能低下或者其他资源瓶颈。</li></ul></li><li><p>**领导者心跳超时 (Leader Heartbeat Timeout)**：</p><ul><li>多次出现领导者心跳超时的警告，例如：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;level&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;warn&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;ts&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2024-05-30T16:29:28.574033+0800&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;caller&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;etcdserver/raft.go:416&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;msg&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;leader failed to send out heartbeat on time; took too long, leader is overloaded likely from slow disk&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;to&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;1199e95a63037f54&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;heartbeat-interval&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;100ms&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;expected-duration&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;200ms&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;exceeded-duration&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;158.790811ms&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li>这表明 etcd 领导者节点可能由于磁盘性能问题导致无法及时发送心跳信号，进而影响集群稳定性。</li></ul></li><li><p>**慢的磁盘同步 (Slow Disk Sync)**：</p><ul><li>出现了慢磁盘同步的警告，例如：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;level&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;warn&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;ts&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2024-05-30T16:28:05.556009+0800&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;caller&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;wal/wal.go:805&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;msg&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;slow fdatasync&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;took&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;1.008456685s&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;expected-duration&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;1s&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li>这进一步支持了磁盘性能问题的可能性。</li></ul></li></ol><p>综上所述，etcd 可能存在以下问题：</p><ul><li><strong>时钟不同步</strong>：节点之间的时钟漂移可能导致数据一致性问题。</li><li><strong>高负载或资源瓶颈</strong>：请求处理时间过长和领导者心跳超时是由于系统负载过高或资源不足（例如 CPU、内存、磁盘 IO）。</li><li><strong>磁盘性能问题</strong>：多次出现慢磁盘同步警告，表明磁盘可能是性能瓶颈。</li></ul><p><strong>建议措施</strong>：</p><ol><li><strong>时钟同步</strong>：后续使用 ntp 算法时间同步。</li><li><strong>性能优化</strong>：检查系统负载，优化 etcd 的资源配置，确保有足够的 CPU、内存和磁盘 IO。</li><li><strong>磁盘性能</strong>：检查磁盘性能，考虑使用性能更好的存储设备或者优化现有存储设备的配置。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据迁移操作手册.md</title>
    <link href="/2024/05/28/mdstorage/project/sr/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
    <url>/2024/05/28/mdstorage/project/sr/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="石犀总控平台数据迁移工具操作手册"><a href="#石犀总控平台数据迁移工具操作手册" class="headerlink" title="石犀总控平台数据迁移工具操作手册"></a>石犀总控平台数据迁移工具操作手册</h3><h4 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h4><p>本手册介绍如何使用石犀总控平台数据迁移工具，将1.4版本的数据迁移到新版本的石犀总控平台。</p><h4 id="特性支持"><a href="#特性支持" class="headerlink" title="特性支持"></a>特性支持</h4><ol><li><strong>总控数据迁移</strong></li><li><strong>引擎数据迁移</strong><ul><li>支持迁移的内容包括：网关、虚拟服务、业务&#x2F;业务组、证书、健康检查、SDS数据。</li><li>迁移过程中会根据1.5版本特性重新生成所有资源的名称（采用ULID格式）。</li><li>迁移虚拟服务数据时，会清除其绑定的插件配置（内置插件除外）。</li></ul></li></ol><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li><strong>备份操作系统镜像</strong><ul><li>在进行数据迁移前，请务必备份操作系统镜像，以防止意外发生时能够恢复数据。</li></ul></li></ol><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><h5 id="1-引擎数据备份与迁移"><a href="#1-引擎数据备份与迁移" class="headerlink" title="1. 引擎数据备份与迁移"></a>1. 引擎数据备份与迁移</h5><ol><li><p><strong>拷贝porter二进制文件</strong></p><ul><li>将<code>porter</code>二进制文件拷贝到需要备份或恢复数据的机器上。</li></ul></li><li><p><strong>数据备份</strong></p><ul><li>在需要备份数据的机器上执行以下命令： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./porter backup engine --backup-dir=/tmp/backup<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>数据恢复</strong></p><ul><li>将备份数据（即<code>/tmp/backup</code>目录下的所有文件和文件夹）拷贝到需要恢复数据的机器上，然后在该机器上执行以下命令： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./porter recover engine --backup-dir=/tmp/backup<br></code></pre></td></tr></table></figure></li></ul></li></ol><h5 id="2-总控数据备份与迁移"><a href="#2-总控数据备份与迁移" class="headerlink" title="2. 总控数据备份与迁移"></a>2. 总控数据备份与迁移</h5><ol><li><p><strong>拷贝porter二进制文件</strong></p><ul><li>将<code>porter</code>二进制文件拷贝到需要备份或恢复数据的机器上。</li></ul></li><li><p><strong>数据备份</strong></p><ul><li>在需要备份数据的机器上执行以下命令： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./porter backup engine --backup-dir=/tmp/backup -i [MySQL IP 地址]<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>数据恢复</strong></p><ul><li>将备份数据（即<code>/tmp/backup</code>目录下的所有文件和文件夹）拷贝到需要恢复数据的机器上，然后在该机器上执行以下命令： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./porter recover engine --backup-dir=/tmp/backup -i [MySQL IP 地址]<br></code></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p><strong>注意</strong>：如果当前操作是在总控机器上进行，则<code>-i</code>参数应为<code>127.0.0.1</code>。</p></blockquote><p>以上就是石犀总控平台数据迁移工具的使用说明，如有疑问，请参考相关技术文档或联系技术支持。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vsn-c.md</title>
    <link href="/2024/05/22/mdstorage/domain/communication/vsn-c/"/>
    <url>/2024/05/22/mdstorage/domain/communication/vsn-c/</url>
    
    <content type="html"><![CDATA[<h2 id="使用VSN-C框架"><a href="#使用VSN-C框架" class="headerlink" title="使用VSN-C框架"></a>使用VSN-C框架</h2><p>为了确保让听众或读者了解你的愿景目标，以及你已经为此付出的行动，你需要借助一个陈述框架，帮助自己掌控发言和书写的节奏。为了有效沟通，我自创了一个VSN-C方法。首先，要简要陈述你希望实现的愿景目标（Vision）；其次，列举你为推动愿景目标实现已经采取的行动步骤（Steps）；再次，报告你近期工作的进展（News）；最后，展示你的工作成果（Contributions）。</p><p><img src="/vsn-c-1.png" alt="vsn-c 框架"></p><h2 id="提出愿景目标"><a href="#提出愿景目标" class="headerlink" title="提出愿景目标"></a>提出愿景目标</h2><p>你的愿景目标应当包括：人们关心的问题及其解决方案。你不能只顾自己一个人对相关问题充满热情，还务必要引起你的受众也对问题感到兴趣。</p><h3 id="针对不同群体提出不同的愿景目标"><a href="#针对不同群体提出不同的愿景目标" class="headerlink" title="针对不同群体提出不同的愿景目标"></a>针对不同群体提出不同的愿景目标</h3><p>根据特定群体确定演讲标题</p><h3 id="根据特定群体确定演讲标题"><a href="#根据特定群体确定演讲标题" class="headerlink" title="根据特定群体确定演讲标题"></a>根据特定群体确定演讲标题</h3><p>你可以交替使用“挑战”“机遇”“目标”“假设”等词语</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>communication</category>
      
    </categories>
    
    
    <tags>
      
      <tag>沟通</tag>
      
      <tag>communication</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>systemd.md</title>
    <link href="/2024/05/22/mdstorage/domain/linux/systemd/"/>
    <url>/2024/05/22/mdstorage/domain/linux/systemd/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>systemd</code> 系列的命令包括一组管理和操作 <code>systemd</code> 系统和服务的命令。以下是一些常用的 <code>systemd</code> 命令：</p><ol><li><p><strong>systemctl</strong>：</p><ul><li><code>systemctl start &lt;service&gt;</code>：启动服务。</li><li><code>systemctl stop &lt;service&gt;</code>：停止服务。</li><li><code>systemctl restart &lt;service&gt;</code>：重启服务。</li><li><code>systemctl reload &lt;service&gt;</code>：重新加载服务配置。</li><li><code>systemctl enable &lt;service&gt;</code>：设置服务在引导时启动。</li><li><code>systemctl disable &lt;service&gt;</code>：取消服务在引导时启动。</li><li><code>systemctl status &lt;service&gt;</code>：查看服务状态。</li><li><code>systemctl is-active &lt;service&gt;</code>：检查服务是否正在运行。</li><li><code>systemctl is-enabled &lt;service&gt;</code>：检查服务是否设置为在引导时启动。</li><li><code>systemctl list-units</code>：列出所有已加载的单元。</li><li><code>systemctl list-units --type=service</code>：列出所有已加载的服务单元。</li><li><code>systemctl list-timers</code>：列出所有已激活的计时器单元。</li></ul></li><li><p><strong>journalctl</strong>：</p><ul><li><code>journalctl</code>：查看系统日志。</li><li><code>journalctl -u &lt;service&gt;</code>：查看特定服务的日志。</li><li><code>journalctl -b</code>：查看当前引导过程的日志。</li><li><code>journalctl -f</code>：实时查看日志（类似于 <code>tail -f</code>）。</li><li><code>journalctl --since &quot;YYYY-MM-DD HH:MM:SS&quot;</code>：查看指定时间之后的日志。</li></ul></li><li><p><strong>loginctl</strong>：</p><ul><li><code>loginctl</code>：管理和查询用户登录会话。</li><li><code>loginctl list-sessions</code>：列出当前的会话。</li><li><code>loginctl session-status &lt;session-id&gt;</code>：查看指定会话的状态。</li><li><code>loginctl terminate-session &lt;session-id&gt;</code>：终止指定会话。</li><li><code>loginctl list-users</code>：列出当前的用户。</li><li><code>loginctl user-status &lt;username&gt;</code>：查看指定用户的状态。</li></ul></li><li><p><strong>hostnamectl</strong>：</p><ul><li><code>hostnamectl</code>：查看和设置系统主机名。</li><li><code>hostnamectl set-hostname &lt;hostname&gt;</code>：设置系统主机名。</li><li><code>hostnamectl status</code>：查看当前主机名和其他相关信息。</li></ul></li><li><p><strong>timedatectl</strong>：</p><ul><li><code>timedatectl</code>：查看和设置系统时间和日期。</li><li><code>timedatectl set-time &lt;time&gt;</code>：设置系统时间。</li><li><code>timedatectl set-timezone &lt;timezone&gt;</code>：设置系统时区。</li><li><code>timedatectl status</code>：查看当前时间、日期和时区信息。</li></ul></li><li><p><strong>localectl</strong>：</p><ul><li><code>localectl</code>：查看和设置系统本地化配置。</li><li><code>localectl set-locale &lt;locale&gt;</code>：设置系统区域设置。</li><li><code>localectl status</code>：查看当前区域设置和键盘布局。</li></ul></li></ol><p>这些命令提供了强大的工具来管理和操作基于 <code>systemd</code> 的 Linux 系统和服务。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="journalctl"><a href="#journalctl" class="headerlink" title="journalctl"></a>journalctl</h3><ul><li>journalctl</li></ul><h2 id="docker-systemctl"><a href="#docker-systemctl" class="headerlink" title="docker systemctl"></a>docker systemctl</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">curl -fLsS --retry 3 -o /bin/systemctl &#x27;https://raw.githubusercontent.com/gdraheim/docker-systemctl-replacement/v1.5.8066/files/docker/systemctl3.py&#x27;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows-docker.md</title>
    <link href="/2024/05/21/mdstorage/domain/%E8%99%9A%E6%8B%9F%E5%8C%96/windows-docker/"/>
    <url>/2024/05/21/mdstorage/domain/%E8%99%9A%E6%8B%9F%E5%8C%96/windows-docker/</url>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a><strong>环境准备</strong></h2><p>我们依旧是先从环境准备开始。想要使用这个方案，我们需要准备的东西有三个：安装了 Docker 的操作系统（我使用 Ubuntu）、Windows<br>操作系统的安装光盘（从 WinXP ～ Win11 都行）、开源项目<br><strong><a href="https://link.zhihu.com/?target=https://github.com/dockur/windows">dockur&#x2F;windows[2]</a></strong><br>的 Docker 镜像。</p><h3 id="安装-Ubuntu-操作系统和-Docker"><a href="#安装-Ubuntu-操作系统和-Docker" class="headerlink" title="安装 Ubuntu 操作系统和 Docker"></a><strong>安装 Ubuntu 操作系统和 Docker</strong></h3><p>这套方案中采用了 KVM 加速，所以体验最好的方案是使用或者安装一个 Linux 环境，如果你本身就在使用 Ubuntu 之类的支持 KVM<br>非常方便的操作系统的话，那么只需要安装 Docker 就好啦。</p><p>如果你确实需要在容器中运行 Windows，想从零开始，可以参考之前的文章《**[在笔记本上搭建高性价比的 Linux<br>学习环境：基础篇[3]](<a href="https://link.zhihu.com/?target=https://soulteary.com/2022/06/21/building-">https://link.zhihu.com/?target=https%3A//soulteary.com/2022/06/21/building-</a><br>a-cost-effective-linux-learning-environment-on-a-laptop-the-basics.html)**<br>》的方法来进行实践。安装 Ubuntu 的流程和以往并没有太大不同，依旧是老生常谈的三步曲：下载镜像、制作启动盘、安装系统。</p><p>如果你已经有了可以使用的 Linux 环境，可以参考上面文章中的 “更简单的 Docker 安装” 章节，完成基础环境的准备。</p><p>完成操作系统和 Docker 的准备后，我们还需要检查操作系统是否支持 KVM，需要先安装 <code>cpu-checker</code>。</p><pre><code class="hljs">sudo apt install cpu-checker -y</code></pre><p>然后，执行 <code>kvm-ok</code>，顺利的话，将能够看到类似下面的日志输出：</p><pre><code class="hljs"># sudo kvm-okINFO: /dev/kvm existsKVM acceleration can be used</code></pre><h3 id="获取-WIndows-操作系统光盘"><a href="#获取-WIndows-操作系统光盘" class="headerlink" title="获取 WIndows 操作系统光盘"></a><strong>获取 WIndows 操作系统光盘</strong></h3><p>虽然开源项目<br><strong><a href="https://link.zhihu.com/?target=https://github.com/dockur/windows">dockur&#x2F;windows[4]</a></strong><br>会根据用户指令，从 <code>dl.bobpony.com</code><br>、<code>archive.org</code>，以及微软官网自动下载合适的英文版系统镜像，但如果你想更快的完成系统的安装，或者想快速的启动多个 Windows Docker<br>容器，那么手动下载 Windows 光盘还是非常有必要的。</p><p>开源项目包含了一些自动安装的预设配置，不过，这需要使用英文版的操作系统，你可以从**[这里下载[5]](<a href="https://link.zhihu.com/?target=https://www.microsoft.com/en-">https://link.zhihu.com/?target=https%3A//www.microsoft.com/en-</a><br>us&#x2F;software-download&#x2F;windows11)** 。</p><p>当然，如果你需要使用中文版的操作系统，同样可以从**[官方下载[6]](<a href="https://link.zhihu.com/?target=https://www.microsoft.com/zh-">https://link.zhihu.com/?target=https%3A//www.microsoft.com/zh-</a><br>cn&#x2F;software-download&#x2F;windows11)** ，在初始化操作系统的时候，相比英文操作系统你需要额外点一些“下一步”。</p><h3 id="获取-Windows-in-Docker-容器镜像"><a href="#获取-Windows-in-Docker-容器镜像" class="headerlink" title="获取 Windows in Docker 容器镜像"></a><strong>获取 Windows in Docker 容器镜像</strong></h3><p>获取在 Docker 中运行 Windows 的容器镜像很简单：</p><pre><code class="hljs">docker pull dockurr/windows</code></pre><p>当然，如果不能够直接下载，也可以选择本地构建：</p><pre><code class="hljs">git clone https://github.com/dockur/windows.gitcd windowsdocker build -t dockurr/windows .</code></pre><p>这个镜像主要依赖了几项技术：</p><ul><li><strong><a href="https://link.zhihu.com/?target=https://github.com/qemus/qemu-docker">qemus&#x2F;qemu-docker[7]</a></strong> ，在容器中使用 QEMU，能够提供接近本机速度的虚拟机的网络、IO 速度等。</li><li><strong><a href="https://link.zhihu.com/?target=https://github.com/christgau/wsdd">christgau&#x2F;wsdd[8]</a></strong> ，让容器中的 Windows 能够出现在局域网中的其他设备的共享设备中。（Windows 10 的 1511 版本后，默认开始禁用 SMBv1，NetBIOS 设备发现功能失效，导致其他设备不能对其进行服务发现）。</li><li><strong><a href="https://link.zhihu.com/?target=https://github.com/qemus/virtiso">qemus&#x2F;virtiso[9]</a></strong> ，精简到 27MB 的 KVM&#x2F;QEMU Virtio 驱动程序，能够让 Windows 在 Docker 环境中正常使用。</li><li><strong><a href="https://link.zhihu.com/?target=https://github.com/krallin/tini">krallin&#x2F;tini[10]</a></strong> ，正确启动 Docker 中 QEMU，以及确保进程异常能够被正确处理，或正确的终止容器进程。</li></ul><p>好了，准备工作就绪后，我们就可以开始使用这个有趣的技术方案啦。</p><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a><strong>基础使用</strong></h2><p>我们先聊聊最简单的使用方案，启动一个“无状态”的临时的 Windows 操作系统，容器会自动下载我们所需要的镜像：</p><pre><code class="hljs">version: &quot;3&quot;services:  windows:    image: dockurr/windows    container_name: windows    devices:      - /dev/kvm    cap_add:      - NET_ADMIN    ports:      - 8006:8006      - 3389:3389/tcp      - 3389:3389/udp    stop_grace_period: 2m    restart: on-failure</code></pre><p>将上面的配置保存为 <code>docker-compose.yml</code>，然后使用 <code>docker compose up</code> 或 <code>docker compose -d</code><br>启动服务。</p><p>因为我们没有指定本地的镜像，所以如果你的网络环境访问微软 CDN 不够快的话，启动过程需要等待一些时间。</p><pre><code class="hljs"># docker compose up     [+] Running 2/1 ✔ Network win_default  Created                                                                                                                                                     0.1s  ✔ Container windows    Created                                                                                                                                                     0.1s Attaching to windowswindows  | ❯ Starting Windows for Docker v2.04...windows  | ❯ For support visit https://github.com/dockur/windowswindows  | windows  | windows  | ❯ Downloading Windows 11...windows  | [i] Downloading Windows media from official Microsoft servers...windows  | [i] Downloading Windows 11...windows  | [+] Got latest ISO download link (valid for 24 hours): https://software.download.prss.microsoft.com/dbazure/Win11_23H2_English_x64v2.iso?t=c603adeb-c6d7-4bb9-b084-875f3beabfc2&amp;P1=1710146067&amp;P2=601&amp;P3=2&amp;P4=ynPQkgNxZoZxQkmfORJRE5yaf94m7ONuLVngMtHmDfsYTooFKSXiAdWXTKJ8dpoF2WuDkUZ4fkP1u%2bhwAh%2brAdghU%2f1ssngioKg2aLDe2UXOG3ESUAGTyRk1q515ONoXIvyJby2xPoKBVoj%2bsNp6ECqosBjx9HllmF3saRvQFPQox6v8kuhtMxyuNiXT%2fYgKppSZOifx34t6YQb0Hpo6gTkLjxlxiFBF42jLt%2blVhf1HW7ELEtvVUW7eAn9UGfs9HF6yC3p1ep7ouKYNrY0Ek0fo%2bn2v%2by3bTGbqg8lHfXjxb6bPHGE6HWP3sSZDZw4JmPt53hr1uQl%2fmjT50p504Q%3windows  | #=#=#                                                                                                                                                     windows  | #=#=#                                                                                                                                                     0.0%                                                                           0.1%                                                                           0.2%                                                                           0.3%...#######################################################################   99.7%#######################################################################   99.8%#######################################################################  100.0%######################################################################## 100.0%windows  | windows  | [+] Successfully downloaded Windows image!windows  | windows  | ❯ Extracting Windows 11 image...windows  | ❯ Adding XML file for automatic installation...windows  | ❯ Building Windows 11 image...windows  | ❯ Creating a 64G growable disk image in raw format...windows  | ❯ Booting Windows using QEMU emulator version 8.2.1 ...windows  | ...</code></pre><p>当一切就绪后，我们可以使用两个方式来访问这个运行在 Docker 中的 Windows。</p><p>第一种方法，是使用浏览器访问容器所在主机的 <code>IP地址:8006</code>。</p><p><img src="https://pic3.zhimg.com/v2-35abfa98c98ed48fe4342dd23e920646_b.jpg"></p><p><img src="/./Windows-Docker_files/v2-35abfa98c98ed48fe4342dd23e920646_720w.webp"></p><p>在容器中自动部署的 Windows</p><p>容器启动后，会自动下载、部署 Windows，稍等片刻，就能够在浏览器中正常使用它啦：</p><p><img src="https://pic4.zhimg.com/v2-c974ed5cd28781576ef9d0f70ec2787f_b.jpg"></p><p><img src="/./Windows-Docker_files/v2-c974ed5cd28781576ef9d0f70ec2787f_720w.webp"></p><p>在浏览器中访问 Windows</p><p>第二种方法，是使用支持 RDP 远程访问功能的软件，在软件服务器地址和端口内容中分别填写 <code>IP地址</code> 和 <code>3389</code>，在用户名栏填写<br><code>docker</code>，密码保持空白即可。</p><p><img src="https://pic1.zhimg.com/v2-8fb663c4f64b77df60e0142152f0c870_b.jpg"></p><p><img src="/./Windows-Docker_files/v2-8fb663c4f64b77df60e0142152f0c870_720w.webp"></p><p>在 RDP 客户端中访问 Windows</p><h2 id="加速使用-Windows-容器"><a href="#加速使用-Windows-容器" class="headerlink" title="加速使用 Windows 容器"></a><strong>加速使用 Windows 容器</strong></h2><p><img src="https://pic2.zhimg.com/v2-fd0ac9ea8293e73f1602164d05186831_b.jpg"></p><p><img src="/./Windows-Docker_files/v2-fd0ac9ea8293e73f1602164d05186831_720w.webp"></p><p>默认情况，每次启动都需要见到它</p><p>当然，如果你的网络环境不是那么好，或者你不想每次启动容器都要等待很久，可以使用下面的方法。</p><p>让部署使用加速，主要和两个细节有关：是否进行了容器内容的持久化，是否提供了高性能的安装镜像下载方式。</p><p>比如，我们在上面的准备工作中，我们预先下载好 Windows 的安装镜像，然后将文件重命名为 <code>win11x64.iso</code>，接着将文件放置在目录的<br><code>./iso</code> 子目录中。那么，借助 Nginx，可以让整个安装部署过程变的飞快。</p><pre><code class="hljs">version: &quot;3&quot;services:  windows:    image: dockurr/windows    container_name: windows    devices:      - /dev/kvm    cap_add:      - NET_ADMIN    ports:      - 8006:8006      - 3389:3389/tcp      - 3389:3389/udp    stop_grace_period: 2m    restart: on-failure    environment:      VERSION: &quot;http://winiso/win11x64.iso&quot;      MANUAL: &quot;N&quot;    volumes:      - ./win:/storage    depends_on:      - winiso  winiso:    image: nginx:alpine    container_name: winiso    restart: on-failure    volumes:     - ./iso:/usr/share/nginx/html</code></pre><p>在上面的配置中，我们增加了一个用来将本地的 Windows 安装文件转换为 <code>dockurr/windows</code> 快速可安装的在线地址的容器。</p><p>将配置文件保存为 <code>docker-compose.yml</code>，然后使用 <code>docker compose up</code> 或者 <code>docker compose up -d</code> 启动配置，我们将看到类似下面的日志：</p><pre><code class="hljs">windows  | .windows  | .winiso   | 172.20.2.3 - - [11/Mar/2024:03:54:47 +0000] &quot;GET /win11x64.iso HTTP/1.1&quot; 200 6813366272 &quot;-&quot; &quot;Wget/1.21.4&quot; &quot;-&quot;windows  | . 99% 1.59G 0swindows  | windows  | 6651904K .windows  |                           windows  |         100% 1.95Gwindows  | =3.7swindows  | windows  | windows  | ❯ Extracting downloaded ISO image...windows  | ❯ Detecting Windows version from ISO image...windows  | ❯ Detected: Windows 11windows  | ❯ Adding XML file for automatic installation...windows  | ❯ Building Windows 11 image...windows  | ❯ Creating a 64G growable disk image in raw format...windows  | ❯ Booting Windows using QEMU emulator version 8.2.1 ...</code></pre><p>下载镜像的速度马上从几MB、几十MB增加到了接近每秒 2GB，不到 4s 就能完成镜像的下载和处理。</p><p>因为在配置中增加了 <code>volumes</code> 卷的持久化（<code>- ./win:/storage</code>），所以我们可以放心的停止或者重新启动容器，而不必担心每次都要重新初始化“一台”新的 Windows Docker 容器。</p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a><strong>使用技巧</strong></h2><p>聊聊其他的使用技巧。</p><h3 id="更换-Windows-版本（不提前准备镜像）"><a href="#更换-Windows-版本（不提前准备镜像）" class="headerlink" title="更换 Windows 版本（不提前准备镜像）"></a><strong>更换 Windows 版本（不提前准备镜像）</strong></h3><p>如果你的网络环境非常棒，不需要提前下载安装镜像，或者直接使用云主机进行项目部署，那么可以考虑直接调整配置文件中的内容为合适的数值：</p><pre><code class="hljs">environment:  VERSION: &quot;win11&quot;</code></pre><p>支持我们调整使用的值包含：<code>win11</code>、<code>win10</code>、<code>ltsc10</code>、<code>win81</code>、<code>win7</code>、<code>vista</code>、<code>winxp</code>、<code>2022</code>、<code>2019</code>、<code>2016</code>、<code>2012</code>、<code>2008</code>。</p><h3 id="调整-Windows-容器资源配置"><a href="#调整-Windows-容器资源配置" class="headerlink" title="调整 Windows 容器资源配置"></a><strong>调整 Windows 容器资源配置</strong></h3><p>默认情况下，这个 Windows 容器会使用 vCPU x2、4GB 内存、64G 的磁盘空间，来满足 Win11<br>的最低安装需求。我们可以根据自己的实际需求，来动态的调整容器的硬件资源限制。</p><pre><code class="hljs">environment:  RAM_SIZE: &quot;8G&quot;  CPU_CORES: &quot;4&quot;  DISK_SIZE: &quot;256G&quot;</code></pre><p>比如，在上面的配置中，我们调整 CPU 核心数到 4，内存到 8GB，磁盘到 256GB。</p><h3 id="为容器分配独立的-IP-地址"><a href="#为容器分配独立的-IP-地址" class="headerlink" title="为容器分配独立的 IP 地址"></a><strong>为容器分配独立的 IP 地址</strong></h3><p>默认情况下，Docker 会共享宿主机的 IP，如果我们想要让容器拥有独立的 IP 地址，需要先创建一个 <code>macvlan</code> 网络：</p><pre><code class="hljs">docker network create -d macvlan \    --subnet=192.168.0.0/24 \    --gateway=192.168.0.1 \    --ip-range=192.168.0.100/28 \    -o parent=eth0 vlan</code></pre><p>创建完网卡后，调整上面使用的容器配置，根据自己的需求指定容器 IP 即可：</p><pre><code class="hljs">services:  windows:    container_name: windows    ..&lt;snip&gt;..    networks:      vlan:        ipv4_address: 192.168.0.100networks:  vlan:    external: true</code></pre><h3 id="使用一整块磁盘"><a href="#使用一整块磁盘" class="headerlink" title="使用一整块磁盘"></a><strong>使用一整块磁盘</strong></h3><p>如果你的主机上有多块磁盘，或者想将某一块磁盘完整的分配给 Windows，可以采用下面的方法，其中 <code>DEVICE</code> 将作为你的主磁盘：</p><pre><code class="hljs">environment:  DEVICE: &quot;/dev/sda&quot;  DEVICE2: &quot;/dev/sdb&quot;devices:  - /dev/sda  - /dev/sdb</code></pre><h3 id="在-Docker-中的-Windows-使用-USB-设备"><a href="#在-Docker-中的-Windows-使用-USB-设备" class="headerlink" title="在 Docker 中的 Windows 使用 USB 设备"></a><strong>在 Docker 中的 Windows 使用 USB 设备</strong></h3><p>我们首先需要使用 <code>lsusb</code> 来获取 USB 设备的 <code>VendorID</code> 和 <code>ProductID</code> ，然后将这些信息添加到配置中：</p><pre><code class="hljs">environment:  ARGUMENTS: &quot;-device usb-host,vendorid=0x1234,productid=0x1234&quot;devices:  - /dev/bus/usb</code></pre>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>提案.md</title>
    <link href="/2024/05/21/mdstorage/project/sr/%E4%B8%93%E5%88%A9/%E6%8F%90%E6%A1%88/"/>
    <url>/2024/05/21/mdstorage/project/sr/%E4%B8%93%E5%88%A9/%E6%8F%90%E6%A1%88/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>flock.md</title>
    <link href="/2024/05/16/mdstorage/domain/linux/flock/"/>
    <url>/2024/05/16/mdstorage/domain/linux/flock/</url>
    
    <content type="html"><![CDATA[<h1 id="flock"><a href="#flock" class="headerlink" title="flock"></a>flock</h1><p>本教程旨在帮助开发者和系统管理员了解如何使用 <code>flock</code> 命令来管理文件锁定，从而避免文件在多个进程之间的竞争条件。通过阅读本教程，读者将能够学会如何使用 <code>flock</code> 实现文件锁定，并掌握一些实际应用场景。</p><p><strong>为什么要学习这个教程？</strong></p><p>在开发和系统管理中，多个进程可能会同时访问和修改同一个文件，导致数据不一致或文件损坏。使用 <code>flock</code> 可以有效地防止这些问题，确保文件操作的原子性和一致性。<br>同时也可以依赖此机制实现进程间读写锁机制</p><h2 id="教程大纲"><a href="#教程大纲" class="headerlink" title="教程大纲"></a>教程大纲</h2><p>在本教程中，将学习如何：</p><ul><li>使用 <code>flock</code> 命令对文件进行锁定</li><li>在脚本中应用 <code>flock</code> 以确保文件操作的安全</li></ul><h2 id="在开始之前"><a href="#在开始之前" class="headerlink" title="在开始之前"></a>在开始之前</h2><p>请确保已具备以下条件：</p><ul><li>在系统上已安装 <code>flock</code> 命令。大多数 Linux 发行版默认包含 <code>flock</code>，如果没有，可以通过包管理器安装。</li><li>具备基本的 Linux 命令行操作知识。</li></ul><h2 id="第1部分"><a href="#第1部分" class="headerlink" title="第1部分"></a>第1部分</h2><p>在第一部分，将学习如何使用 <code>flock</code> 命令来实现文件锁定。</p><ol><li><p>在终端中执行以下命令，创建一个测试文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;测试内容&quot;</span> &gt; /tmp/testfile<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>flock</code> 命令对文件进行锁定，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">flock -x /tmp/testfile -c <span class="hljs-string">&#x27;echo &quot;文件已锁定&quot;&#x27;</span><br></code></pre></td></tr></table></figure><p>该命令会对 <code>/tmp/testfile</code> 进行独占锁定，并执行 <code>echo &quot;文件已锁定&quot;</code> 命令。锁定期间，其他进程将无法获得该文件的独占锁。</p></li><li><p>尝试在另一个终端中对同一文件进行锁定，验证锁定效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">flock -x /tmp/testfile -c <span class="hljs-string">&#x27;echo &quot;另一个进程尝试锁定&quot;&#x27;</span><br></code></pre></td></tr></table></figure><p>由于文件已被锁定，第二个 <code>flock</code> 命令将等待，直到第一个命令释放锁。</p></li></ol><h2 id="第2部分"><a href="#第2部分" class="headerlink" title="第2部分"></a>第2部分</h2><p>在第二部分，将学习如何在脚本中使用 <code>flock</code> 实现安全的文件操作。</p><ol><li><p>创建一个示例脚本 <code>script.sh</code>，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">exec</span> 200&gt;/tmp/testfile.lock<br>flock -x 200<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;开始执行安全的文件操作&quot;</span><br><span class="hljs-built_in">sleep</span> 10<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;文件操作完成&quot;</span><br><br>flock -u 200<br></code></pre></td></tr></table></figure></li><li><p>确保脚本具有执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x script.sh<br></code></pre></td></tr></table></figure></li><li><p>在终端中执行脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./script.sh<br></code></pre></td></tr></table></figure><p>该脚本首先在文件 <code>/tmp/testfile.lock</code> 上创建一个文件描述符 <code>200</code>，然后对该描述符进行独占锁定。执行完文件操作后，释放锁定。</p></li></ol><h2 id="总结-id-”what-learned”"><a href="#总结-id-”what-learned”" class="headerlink" title="总结 {id&#x3D;”what-learned”}"></a>总结 {id&#x3D;”what-learned”}</h2><p>通过完成本教程，读者学会了如何使用 <code>flock</code> 命令对文件进行锁定，以确保多个进程对同一文件的访问不发生冲突。同时，读者还掌握了在脚本中应用 <code>flock</code> 进行安全文件操作的方法。</p><seealso>- [Linux `flock` 命令手册](https://man7.org/linux/man-pages/man1/flock.1.html)- [如何在 Bash 脚本中使用文件锁](https://www.cyberciti.biz/faq/linux-file-locking-using-flock-command/)</seealso><h2 id="附录-golang-flock"><a href="#附录-golang-flock" class="headerlink" title="附录 golang flock"></a>附录 golang flock</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> flock<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/gofrs/flock&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Case</span><span class="hljs-params">()</span></span> &#123;<br>f := flock.New(os.TempDir() + <span class="hljs-string">&quot;/go-lock.lock&quot;</span>)<br>lock, err := f.TryLock()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>log.Println(<span class="hljs-string">&quot;2:---&quot;</span>)<br>f2 := flock.New(os.TempDir() + <span class="hljs-string">&quot;/go-lock.lock&quot;</span>)<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>l := f2.Locked()<br>log.Printf(<span class="hljs-string">&quot;2:--- : %v&quot;</span>, l)<br><span class="hljs-comment">// todo 试试 未获取到锁的情况下进行写入 case</span><br>&#125;()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;lock error: %v\n&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>file, err := os.OpenFile(os.TempDir()+<span class="hljs-string">&quot;/go-lock.lock&quot;</span>, os.O_RDWR, <span class="hljs-number">0600</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;open file error: %v\n&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br>_, err = file.WriteString(<span class="hljs-string">&quot;Hello, world!&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 写入错误处理</span><br>&#125;<br><br>log.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, lock)<br>time.Sleep(<span class="hljs-number">20</span> * time.Second)<br>log.Printf(<span class="hljs-string">&quot;locked: %v\n&quot;</span>, f.Locked())<br>f.Unlock()<br>log.Printf(<span class="hljs-string">&quot;locked: %v\n&quot;</span>, f.Locked())<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iproute2监控网络配置.md</title>
    <link href="/2024/05/16/mdstorage/domain/network/iproute2%E7%9B%91%E6%8E%A7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/05/16/mdstorage/domain/network/iproute2%E7%9B%91%E6%8E%A7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>iproute2 命令可以监控系统网络配置，link addr route 等</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>要通过外部命令获取 <code>netlink.RouteUpdate</code> 的调用和相关信息，可以使用 <code>ip monitor</code> 命令。这个命令可以监控并显示网络路由、地址和链路的变更，这与 <code>netlink.RouteUpdate</code> 类似。</p><h3 id="使用-ip-monitor-命令"><a href="#使用-ip-monitor-命令" class="headerlink" title="使用 ip monitor 命令"></a>使用 <code>ip monitor</code> 命令</h3><p><code>ip monitor</code> 命令可以监控网络路由、地址和链路的变化，并在控制台输出这些变化的信息。这对于调试和了解 <code>netlink.RouteUpdate</code> 的调用非常有用。</p><p>以下是一些示例：</p><h4 id="1-监控路由变更"><a href="#1-监控路由变更" class="headerlink" title="1. 监控路由变更"></a>1. 监控路由变更</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip monitor route<br></code></pre></td></tr></table></figure><p>这个命令会实时输出所有路由的增删改信息。</p><h4 id="2-监控地址变更"><a href="#2-监控地址变更" class="headerlink" title="2. 监控地址变更"></a>2. 监控地址变更</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip monitor addr<br></code></pre></td></tr></table></figure><p>这个命令会实时输出所有网络接口地址的增删改信息。</p><h4 id="3-监控链路状态变更"><a href="#3-监控链路状态变更" class="headerlink" title="3. 监控链路状态变更"></a>3. 监控链路状态变更</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip monitor <span class="hljs-built_in">link</span><br></code></pre></td></tr></table></figure><p>这个命令会实时输出所有网络接口的状态变化信息。</p><h4 id="4-综合监控所有变更"><a href="#4-综合监控所有变更" class="headerlink" title="4. 综合监控所有变更"></a>4. 综合监控所有变更</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip monitor all<br></code></pre></td></tr></table></figure><p>这个命令会实时输出所有网络路由、地址和链路的变更信息。</p><h3 id="示例输出"><a href="#示例输出" class="headerlink" title="示例输出"></a>示例输出</h3><p>运行 <code>ip monitor route</code> 后，可能会看到类似以下的输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">10.0.0.0/24 dev eth0 proto kernel scope <span class="hljs-built_in">link</span> src 10.0.0.1<br>192.168.1.0/24 dev wlan0 proto kernel scope <span class="hljs-built_in">link</span> src 192.168.1.2<br>default via 192.168.1.1 dev wlan0<br></code></pre></td></tr></table></figure><p>每当有路由被添加、删除或更改时，都会实时打印类似的信息。</p><h3 id="使用-ip-monitor-调试-netlink-RouteUpdate"><a href="#使用-ip-monitor-调试-netlink-RouteUpdate" class="headerlink" title="使用 ip monitor 调试 netlink.RouteUpdate"></a>使用 <code>ip monitor</code> 调试 <code>netlink.RouteUpdate</code></h3><p>通过 <code>ip monitor</code>，你可以实时看到路由变更，帮助你了解和调试程序中的 <code>netlink.RouteUpdate</code> 调用。以下是一个示例步骤：</p><ol><li><p><strong>运行 <code>ip monitor</code> 命令</strong>：</p><p>打开一个终端，运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip monitor route<br></code></pre></td></tr></table></figure></li><li><p><strong>运行你的程序</strong>：</p><p>在另一个终端或环境中运行你的 Go 程序，触发 <code>netlink.RouteUpdate</code> 调用。</p></li><li><p><strong>观察输出</strong>：</p><p>观察 <code>ip monitor</code> 命令的输出，查看路由变更的信息。这将帮助你了解哪些路由变更导致了 <code>netlink.RouteUpdate</code> 调用。</p></li></ol><h2 id="ss-命令查看网络连接"><a href="#ss-命令查看网络连接" class="headerlink" title="ss 命令查看网络连接"></a>ss 命令查看网络连接</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 查看所有 socket 连接和端口</span><br>ss -anp<br><span class="hljs-comment"># 查看所有监听的 tcp socket 连接列表</span><br>ss -anplt<br><br></code></pre></td></tr></table></figure><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 示例:</span><br><span class="hljs-comment"># 过滤端口 </span><br>ss -anp src :22<br><span class="hljs-comment"># 过滤地址和端口</span><br>ss -anp dst 119.75.213.51:80<br><span class="hljs-comment"># 过滤协议</span><br>ss -anp src :ssh  <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>弱网测试.md</title>
    <link href="/2024/05/16/mdstorage/domain/network/%E5%BC%B1%E7%BD%91%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/05/16/mdstorage/domain/network/%E5%BC%B1%E7%BD%91%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="https://blog.csdn.net/meihualing/article/details/129938973" alt="弱网测试"></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Bash">NIC=docker0<br>PORT=20111<br>DELAY=100ms<br>LOSS=50%<br><br><span class="hljs-comment"># 标记流量</span><br><span class="hljs-built_in">sudo</span> iptables -t mangle -A OUTPUT -p tcp --dport <span class="hljs-variable">$&#123;PORT&#125;</span> -j MARK --set-mark 1<br><br><span class="hljs-comment"># 添加根 qdisc</span><br><span class="hljs-built_in">sudo</span> tc qdisc add dev <span class="hljs-variable">$&#123;NIC&#125;</span> root handle 1: prio<br><br><span class="hljs-comment"># 添加 netem qdisc 并设置延迟和丢包</span><br><span class="hljs-built_in">sudo</span> tc qdisc add dev <span class="hljs-variable">$&#123;NIC&#125;</span> parent 1:3 handle 30: netem delay <span class="hljs-variable">$&#123;DELAY&#125;</span> loss <span class="hljs-variable">$&#123;LOSS&#125;</span><br><br><span class="hljs-comment"># 添加过滤器，将标记流量绑定到 netem qdisc</span><br><span class="hljs-built_in">sudo</span> tc filter add dev <span class="hljs-variable">$&#123;NIC&#125;</span> protocol ip parent 1:0 prio 3 handle 1 fw flowid 1:3<br><br><br><span class="hljs-comment"># 移除延迟</span><br><span class="hljs-comment"># 删除 iptables 规则</span><br><span class="hljs-built_in">sudo</span> iptables -t mangle -D OUTPUT -p tcp --dport <span class="hljs-variable">$&#123;PORT&#125;</span> -j MARK --set-mark 1<br><span class="hljs-comment"># 删除 tc 配置</span><br><span class="hljs-built_in">sudo</span> tc qdisc del dev <span class="hljs-variable">$&#123;NIC&#125;</span> root<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>network</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>golang高性能编程.md</title>
    <link href="/2024/05/11/mdstorage/domain/golang/golang%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/05/11/mdstorage/domain/golang/golang%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="切片语法-buf"><a href="#切片语法-buf" class="headerlink" title="切片语法 buf[:]"></a>切片语法 buf[:]</h3><p>在Go语言中，当处理数组或切片时，buf和buf[:]有不同含义：<br>buf：代表整个数组本身。数组是值类型，因此传递数组时会复制整个数组的内容，这在大多数情况下不是高效或所需的行为，特别是对于大的数据结构或I&#x2F;O操作。<br>buf[:]：创建了数组buf的一个切片视图。切片是引用类型，这意味着它不复制底层数组的数据，而是持有对原数组的引用以及一些描述切片范围的信息（起始位置和长度）。在进行读写等操作时，使用切片可以更高效地直接操作原始数据，而不需要复制整个数组。<br>在I&#x2F;O操作如unix.Read中，通常希望直接操作数据缓冲区，而不是复制它，因此使用buf[:]来传递一个指向数组的切片，这样可以避免不必要的数据复制，提高效率，并且允许函数修改缓冲区的内容。此外，这种方式让代码更加灵活，即使缓冲区的大小在未来需要调整，只需要改变数组声明，而不必改动读写操作的代码。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>grpc-go客户端.md</title>
    <link href="/2024/05/11/mdstorage/domain/network/%E5%8D%8F%E8%AE%AE/grpc-go%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <url>/2024/05/11/mdstorage/domain/network/%E5%8D%8F%E8%AE%AE/grpc-go%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="1-客户端代码示例"><a href="#1-客户端代码示例" class="headerlink" title="1 客户端代码示例"></a>1 客户端代码示例</h2><h2 id="1-1-main-函数"><a href="#1-1-main-函数" class="headerlink" title="1.1 main 函数"></a>1.1 main 函数</h2><p><img src="https://pic2.zhimg.com/v2-0fbd37c1514195654ea09974927530a1_b.jpg"></p><p>首先给出 grpc-go 启动客户端的代码示例，核心内容分三块：</p><ul><li><p>调用 grpc.Dial 方法，指定服务端 target，创建 grpc 连接代理对象 ClientConn</p></li><li><p>调用 proto.NewHelloServiceClient 方法，基于 pb 桩代码构造客户端实例</p></li><li><p>调用 client.SayHello 方法，真正发起 grpc 请求</p><p>  package main</p><p>  import (<br>  “context”<br>  “fmt”<br><br>  “github.com&#x2F;grpc_demo&#x2F;proto”<br><br>  “google.golang.org&#x2F;grpc”<br>  “google.golang.org&#x2F;grpc&#x2F;credentials&#x2F;insecure”<br>  )<br>  func main() {<br>  conn, err :&#x3D; grpc.Dial(“localhost:8093”, grpc.WithTransportCredentials(insecure.NewCredentials()))<br>  &#x2F;&#x2F; …<br>  defer conn.Close()<br><br>  client :&#x3D; proto.NewHelloServiceClient(conn)<br><br><br>  resp, err :&#x3D; client.SayHello(context.Background(), &amp;proto.HelloReq{<br>      Name: “xiaoxuxiansheng”,<br>  })<br>  &#x2F;&#x2F; …<br><br><br>  fmt.Printf(“resp: %+v”, resp)<br>  }</p></li></ul><h2 id="1-2-proto-文件"><a href="#1-2-proto-文件" class="headerlink" title="1.2 proto 文件"></a>1.2 proto 文件</h2><p>对应的 proto 文件定义：</p><pre><code class="hljs">syntax = &quot;proto3&quot;; // 固定语法前缀option go_package = &quot;.&quot;;  // 指定生成的Go代码在你项目中的导入路径package pb; // 包名// 定义服务service HelloService &#123;    // SayHello 方法    rpc SayHello (HelloReq) returns (HelloResp) &#123;&#125;&#125;// 请求消息message HelloReq &#123;    string name = 1;&#125;// 响应消息message HelloResp &#123;    string reply = 1;&#125;</code></pre><h2 id="2-核心数据结构"><a href="#2-核心数据结构" class="headerlink" title="2 核心数据结构"></a>2 核心数据结构</h2><p><img src="https://pic2.zhimg.com/v2-c842a0159d6bcee06dcf5772a3443acd_b.jpg"></p><p>下面对 grpc-go 客户端涉及到的几个核心数据结构以及其间的关联做个介绍.</p><h2 id="2-1-ClientConn"><a href="#2-1-ClientConn" class="headerlink" title="2.1 ClientConn"></a>2.1 ClientConn</h2><p>ClientConn 是广义上的 grpc 连接代理对象，和 grpc 客户端是一对一的关系，内部包含了一个连接池，根据配置可能同时管理多笔连接.<br>其中几个核心字段包括：</p><ul><li><p>target&#x2F;parsedTarget：对服务端地址信息的封装</p></li><li><p>balancerWrapper：负载均衡器. 初始化时会启动一个守护协程，动态地对 ClientConn 及 Subconn 的状态进行刷新</p></li><li><p>blockingpicker：连接选择器. 在发送请求时，由其最终挑选出使用的 Subconn</p></li><li><p>resolverWrapper：解析器. 负责根据不同的 schema，通过 target 解析出服务端的实际地址</p><p>  type ClientConn struct {<br>  &#x2F;&#x2F; 连接上下文<br>  ctx    context.Context<br>  &#x2F;&#x2F; 上下文终止控制器<br>  cancel context.CancelFunc<br><br><br>  &#x2F;&#x2F; 连接的目标地址<br>  target          string<br>  &#x2F;&#x2F; 对连接目标地址的封装<br>  parsedTarget    resolver.Target<br>  &#x2F;&#x2F; …<br>  &#x2F;&#x2F; 连接配置项<br>  dopts           dialOptions<br>  &#x2F;&#x2F; 负载均衡器，底层基于 gracefulswitch.balancer<br>  balancerWrapper *ccBalancerWrapper<br><br><br>  &#x2F;&#x2F; 连接状态管理器<br>  csMgr              *connectivityStateManager<br>  &#x2F;&#x2F; 连接选择器<br>  blockingpicker     *pickerWrapper<br>  &#x2F;&#x2F; …<br>  &#x2F;&#x2F; 读写互斥锁<br>  mu              sync.RWMutex<br>  &#x2F;&#x2F; 解析器<br>  resolverWrapper *ccResolverWrapper<br>  &#x2F;&#x2F; 连接池<br>  conns           map[*addrConn]struct{}     &#x2F;&#x2F; Set to nil on close.<br>  &#x2F;&#x2F; …<br>  }</p></li></ul><h2 id="2-2-ccBalancerWrapper"><a href="#2-2-ccBalancerWrapper" class="headerlink" title="2.2 ccBalancerWrapper"></a>2.2 ccBalancerWrapper</h2><p>ccBalancerWrapper是在负载均衡器Balancer的基础上做的封装.<br>在ccBalancerWrapper被初始化时，会开启一个守护协程，通过监听 updateCh 中到达的事件，对 ClientConn 和 Subconn<br>的状态进行刷新.</p><pre><code class="hljs">type ccBalancerWrapper struct &#123;    // 指向所属的 clientConn    cc *ClientConn    // 负载均衡器    balancer        *gracefulswitch.Balancer    curBalancerName string      // 接收更新事件的 chan    updateCh *buffer.Unbounded     // 接收处理结果的 chan    resultCh *buffer.Unbounded     // ...&#125;</code></pre><p>ccBalancerWrapper 的核心是一个负载均衡器 Balancer 接口,其中包含了几个核心方法:</p><ul><li><p>UpdateClientConnState：更新 ClientConn 的连接状态</p></li><li><p>ResolverError：错误后处理</p></li><li><p>UpdateSubConnState：更新子连接 Subconn 状态</p></li><li><p>Close：关闭负载均衡器</p><p>  type Balancer interface {<br>  UpdateClientConnState(ClientConnState) error<br>  ResolverError(error)<br>  UpdateSubConnState(SubConn, SubConnState)<br>  Close()<br>  }</p></li></ul><p>在默认情况下，grpc客户端框架会为我们提供一个默认的负载均衡器 pickfirstBalancer：</p><pre><code class="hljs">type pickfirstBalancer struct &#123;    state   connectivity.State    cc      balancer.ClientConn    subConn balancer.SubConn&#125;</code></pre><p>与pickfirstBalancer具体的交互流程我们在第3章再作展开.</p><h2 id="2-3-ccResolverWrapper"><a href="#2-3-ccResolverWrapper" class="headerlink" title="2.3 ccResolverWrapper"></a>2.3 ccResolverWrapper</h2><p>ccResolverWrapper的核心是内置的解析器 resolver.</p><pre><code class="hljs">type ccResolverWrapper struct &#123;    // 指向所属的 clientConn    cc         *ClientConn    resolverMu sync.Mutex    // 核心成员：内置的解析器    resolver   resolver.Resolver    // ...&#125;</code></pre><p>resolver通过Builder构造，对应的Buidler是一个interface,用户也可以提供自己的实现版本:</p><pre><code class="hljs">type Builder interface &#123;    // 构造解析器 resolver    Build(target Target, cc ClientConn, opts BuildOptions) (Resolver, error)    // Scheme returns the scheme supported by this resolver.    // Scheme is defined at https://github.com/grpc/grpc/blob/master/doc/naming.md.    Scheme() string&#125;</code></pre><p>resolver本身是一个接口，核心的方法是 ResolveNow：通过 target 解析出实际的客户端地址.</p><pre><code class="hljs">type Resolver interface &#123;    // 解析 target    ResolveNow(ResolveNowOptions)    // 关闭 resolver    Close()&#125;</code></pre><p>grpc客户端为我们提供了一个默认的resolver：passthroughResolver：</p><pre><code class="hljs">type passthroughResolver struct &#123;    target resolver.Target    cc     resolver.ClientConn&#125;</code></pre><p>passthroughResolver在解析 target 时的策略是直接透传不作处理. 具体交互流程见第3章.</p><h2 id="2-4-ClientStream"><a href="#2-4-ClientStream" class="headerlink" title="2.4 ClientStream"></a>2.4 ClientStream</h2><p>在grpc客户端客户端发起请求时，会首先创建出一个 ClientStream，并依赖其核心方法 SendMsg 和 RecvMsg<br>进行请求的发送和响应的接受.</p><pre><code class="hljs">type ClientStream interface &#123;    // 获取元数据    Header() (metadata.MD, error)    // 获取上下文    Context() context.Context    // 发送消息    SendMsg(m interface&#123;&#125;) error    // 接收消息    RecvMsg(m interface&#123;&#125;) error&#125;</code></pre><p>ClientStream是一个interface，其默认的实现是 clientStream：</p><pre><code class="hljs">type clientStream struct &#123;    // ...    cc       *ClientConn    desc     *StreamDesc    // 编码模块    codec baseCodec    // 压缩模块    cp    Compressor    comp  encoding.Compressor    // ...    // 上下文    ctx context.Context     // 请求尝试    attempt *csAttempt    // ...&#125;</code></pre><h2 id="2-5-csAttempt"><a href="#2-5-csAttempt" class="headerlink" title="2.5 csAttempt"></a>2.5 csAttempt</h2><p>csAttempt 代表了一次 grpc 请求尝试，本身是具有生命周期的.</p><pre><code class="hljs">type csAttempt struct &#123;    ctx        context.Context    cs         *clientStream    t          transport.ClientTransport    s          *transport.Stream    p          *parser    pickResult balancer.PickResult    // 解压模块    dc        Decompressor    decomp    encoding.Compressor    decompSet bool    // ...&#125;</code></pre><h2 id="3-grpc-Dial"><a href="#3-grpc-Dial" class="headerlink" title="3 grpc.Dial"></a>3 grpc.Dial</h2><p><img src="https://pic2.zhimg.com/v2-d55c7ce48f8ab26c9f0d712e5bb75125_b.jpg"></p><h2 id="3-1-grpc-Dial"><a href="#3-1-grpc-Dial" class="headerlink" title="3.1 grpc.Dial"></a>3.1 grpc.Dial</h2><pre><code class="hljs">func Dial(target string, opts ...DialOption) (*ClientConn, error) &#123;    return DialContext(context.Background(), target, opts...)&#125;func DialContext(ctx context.Context, target string, opts ...DialOption) (conn *ClientConn, err error) &#123;    cc := &amp;ClientConn&#123;        target:            target,        csMgr:             &amp;connectivityStateManager&#123;&#125;,        conns:             make(map[*addrConn]struct&#123;&#125;),        dopts:             defaultDialOptions(),        blockingpicker:    newPickerWrapper(),        czData:            new(channelzData),        firstResolveEvent: grpcsync.NewEvent(),    &#125;    // ...    // Determine the resolver to use.    resolverBuilder, err := cc.parseTargetAndFindResolver()    // ...    cc.balancerWrapper = newCCBalancerWrapper(cc, balancer.BuildOptions&#123;        DialCreds:        credsClone,        CredsBundle:      cc.dopts.copts.CredsBundle,        Dialer:           cc.dopts.copts.Dialer,        Authority:        cc.authority,        CustomUserAgent:  cc.dopts.copts.UserAgent,        ChannelzParentID: cc.channelzID,        Target:           cc.parsedTarget,    &#125;)    // ...    rWrapper, err := newCCResolverWrapper(cc, resolverBuilder)    // ...    cc.mu.Lock()    cc.resolverWrapper = rWrapper    cc.mu.Unlock()    // ...    return cc, nil&#125;</code></pre><p>在通过 DialContext 创建 grpc 连接代理 ClientConn 时，核心步骤包括：</p><ul><li>创建 ClientConn 实例</li><li>调用 ClientConn.parseTargetAndFindResolver 方法，通过 target 中的 schema 获取到对应的解析器构造器 resolverBuilder</li><li>调用 newCCBalancerWrapper 方法构造出负载均衡器封装对象 ccBalancerWrapper，在内部会开启守护协程感知和处理 ClientConn 和 Subconn 状态变更的事件</li><li>调用 newCCResolverWrapper 方法，内部会调用 resolverBuilder 构造并启动 resolver 实例，同时会通过 ccBalancerWrapper 方法对 ClientConn 的状态进行更新</li></ul><h2 id="3-2-ClientConn-parseTargetAndFindResolver"><a href="#3-2-ClientConn-parseTargetAndFindResolver" class="headerlink" title="3.2 ClientConn.parseTargetAndFindResolver"></a>3.2 ClientConn.parseTargetAndFindResolver</h2><p><img src="https://pic1.zhimg.com/v2-2d9d5ced9a49aaeba25003e2b27a4f88_b.jpg"></p><pre><code class="hljs">func (cc *ClientConn) parseTargetAndFindResolver() (resolver.Builder, error) &#123;    // ...    var rb resolver.Builder    parsedTarget, err := parseTarget(cc.target)        rb = cc.getResolver(parsedTarget.URL.Scheme)    if rb != nil &#123;        cc.parsedTarget = parsedTarget        return rb, nil    &#125;    // ...&#125;</code></pre><p>ClientConn.parseTargetAndFindResolver 方法通过 target 中的 schema，会获取到对应的<br>resolverBuilder，后续用于构建出能解析出服务端地址的 resolver.</p><p>在 grpc-go 的 resolver 包下，会通过一个全局 map 实现 schema 到 resolverBuilder 的映射，同时会暴露出注册方法<br>Register，供用户自定义实现特定 schema 下的 resolverBuilder 和 resolver 并注入到 map 中.</p><pre><code class="hljs">var (    m = make(map[string]Builder)    defaultScheme = &quot;passthrough&quot;)func Register(b Builder) &#123;    m[b.Scheme()] = b&#125;func Get(scheme string) Builder &#123;    if b, ok := m[scheme]; ok &#123;        return b    &#125;    return nil&#125;</code></pre><p>grpc-go 中，默认的 resolverBuilder 和对应的 resolver 是 passthrough 类型，这类 resolver<br>的解析策略是对 target 直接透传，不作解析处理.</p><p>其中，passthroughBuilder.Build 方法中，会执行 passthroughResolver.start<br>方法一键启动解析器，这部分逻辑我们放到 3.4 小节中，在 passthroughBuilder.Build 方法真正被调用时再作展开.</p><pre><code class="hljs">const scheme = &quot;passthrough&quot;type passthroughBuilder struct&#123;&#125;func (*passthroughBuilder) Build(target resolver.Target, cc resolver.ClientConn, opts resolver.BuildOptions) (resolver.Resolver, error) &#123;    // ...    r := &amp;passthroughResolver&#123;        target: target,        cc:     cc,    &#125;    r.start()    return r, nil&#125;type passthroughResolver struct &#123;    target resolver.Target    cc     resolver.ClientConn&#125;func (r *passthroughResolver) start() &#123;    r.cc.UpdateState(resolver.State&#123;Addresses: []resolver.Address&#123;&#123;Addr: r.target.Endpoint()&#125;&#125;&#125;)&#125;func (*passthroughResolver) ResolveNow(o resolver.ResolveNowOptions)&#123;&#125;</code></pre><h2 id="3-3-newCCBalancerWrapper"><a href="#3-3-newCCBalancerWrapper" class="headerlink" title="3.3 newCCBalancerWrapper"></a>3.3 newCCBalancerWrapper</h2><pre><code class="hljs">func newCCBalancerWrapper(cc *ClientConn, bopts balancer.BuildOptions) *ccBalancerWrapper &#123;    ccb := &amp;ccBalancerWrapper&#123;        cc:       cc,        updateCh: buffer.NewUnbounded(),        resultCh: buffer.NewUnbounded(),        closed:   grpcsync.NewEvent(),        done:     grpcsync.NewEvent(),    &#125;    go ccb.watcher()    ccb.balancer = gracefulswitch.NewBalancer(ccb, bopts)    return ccb&#125;</code></pre><p><img src="https://pic3.zhimg.com/v2-3a59f74b043f0c9e9494a4738390eb06_b.jpg"></p><pre><code class="hljs">func (ccb *ccBalancerWrapper) watcher() &#123;    for &#123;        select &#123;        case u := &lt;-ccb.updateCh.Get():            ccb.updateCh.Load()            if ccb.closed.HasFired() &#123;                break            &#125;            switch update := u.(type) &#123;            case *ccStateUpdate:                ccb.handleClientConnStateChange(update.ccs)            case *scStateUpdate:                ccb.handleSubConnStateChange(update)            case *exitIdleUpdate:                ccb.handleExitIdle()            case *resolverErrorUpdate:                ccb.handleResolverError(update.err)            case *switchToUpdate:                ccb.handleSwitchTo(update.name)            case *subConnUpdate:                ccb.handleRemoveSubConn(update.acbw)            default:                logger.Errorf(&quot;ccBalancerWrapper.watcher: unknown update %+v, type %T&quot;, update, update)            &#125;        case &lt;-ccb.closed.Done():        &#125;        // ...    &#125;&#125;</code></pre><p>newCCBalancerWrapper 方法构造了 ccBalancer 实例，然后调用 ccBalancerWrapper.watcher<br>方法开启守护协程，分别监听 ClientConn 状态变更（ccStateUpdate）、Subconn<br>状态变更（scStateUpdate）、设定负载均衡器<br>balancer（switchToUpdate）、连接移除（subConnUpdate）等事件，并分别进行处理.</p><p>在 newCCBalancerWrapper 方法中，还调用了 gracefulswitch.NewBalancer<br>构造了内置负载均衡器的外壳，但真正的负载均衡器 Balancer 此时还未注入，注入实际会在 3.4 小节，resovler 启动的链路当中.</p><h2 id="3-4-newCCResolverWrapper"><a href="#3-4-newCCResolverWrapper" class="headerlink" title="3.4 newCCResolverWrapper"></a>3.4 newCCResolverWrapper</h2><p><img src="https://pic3.zhimg.com/v2-0d381d5a8047a3677b7065974dbf43fa_b.png"></p><pre><code class="hljs">func newCCResolverWrapper(cc *ClientConn, rb resolver.Builder) (*ccResolverWrapper, error) &#123;    ccr := &amp;ccResolverWrapper&#123;        cc:   cc,        done: grpcsync.NewEvent(),    &#125;    // ...    var err error    ccr.resolverMu.Lock()    defer ccr.resolverMu.Unlock()    ccr.resolver, err = rb.Build(cc.parsedTarget, ccr, rbo)    // ...    return ccr, nil&#125;</code></pre><p>newCCResolverWrapper 方法构造了 ccResolverWrapper 实例，但真正的核心逻辑是根据传入的 resolverBuilder<br>构造器出对应的 resolver 然后注入到 ccResolverWrapper 当中.</p><p>grpc-go 客户端默认的 resovlerBuilder 和 resolver 是 passthrough 类型，下面我们再一次展开</p><p>passthroughBuilder.Build 方法来看：</p><pre><code class="hljs">func (*passthroughBuilder) Build(target resolver.Target, cc resolver.ClientConn, opts resolver.BuildOptions) (resolver.Resolver, error) &#123;    // ...    r := &amp;passthroughResolver&#123;        target: target,        cc:     cc,    &#125;    r.start()    return r, nil&#125;</code></pre><p>在方法中，构造了一个 passthroughResolver 实例，并在返回前调用了 passthroughResolver.start 方法启动了解析器.</p><pre><code class="hljs">func (r *passthroughResolver) start() &#123;    r.cc.UpdateState(resolver.State&#123;Addresses: []resolver.Address&#123;&#123;Addr: r.target.Endpoint()&#125;&#125;&#125;)&#125;</code></pre><p><img src="https://pic3.zhimg.com/v2-89bca7305f47501e10a753fdff912812_b.png"></p><p>此处直接透传了用户传入的服务端地址 target.Endpoint，经历了 ccResolverWrapper.UpdateState -&gt;<br>ClientConn.updateResolverState 的调用链路，然后分别通过 ccBalancerWrapper.switchTo 和<br>ccBalancerWrapper.updateClientConnState 方法，通过 updateCh 向 ccBalancerWrapper<br>传递了设定 balancer 和更新 ClientConn 的事件.</p><pre><code class="hljs">func (ccr *ccResolverWrapper) UpdateState(s resolver.State) error &#123;    // ...    ccr.curState = s    if err := ccr.cc.updateResolverState(ccr.curState, nil); err == balancer.ErrBadResolverState &#123;        return balancer.ErrBadResolverState    &#125;    return nil&#125;func (cc *ClientConn) updateResolverState(s resolver.State, err error) error &#123;    // ...    cc.maybeApplyDefaultServiceConfig(s.Addresses)    // ...        uccsErr := bw.updateClientConnState(&amp;balancer.ClientConnState&#123;ResolverState: s, BalancerConfig: balCfg&#125;)    // ...&#125;</code></pre><h3 id="3-4-1-ccBalancerWrapper-switchTo"><a href="#3-4-1-ccBalancerWrapper-switchTo" class="headerlink" title="3.4.1 ccBalancerWrapper.switchTo"></a><strong>3.4.1 ccBalancerWrapper.switchTo</strong></h3><pre><code class="hljs">func (cc *ClientConn) maybeApplyDefaultServiceConfig(addrs []resolver.Address) &#123;    // ...    cc.applyServiceConfigAndBalancer(emptyServiceConfig, &amp;defaultConfigSelector&#123;emptyServiceConfig&#125;, addrs)&#125;const PickFirstBalancerName = &quot;pick_first&quot;func (cc *ClientConn) applyServiceConfigAndBalancer(sc *ServiceConfig, configSelector iresolver.ConfigSelector, addrs []resolver.Address) &#123;    // 倘若未通过 config 设定，则默认的 balancer 是 pickFirst    newBalancerName = PickFirstBalancerName    // ...    cc.balancerWrapper.switchTo(newBalancerName)&#125;func (ccb *ccBalancerWrapper) switchTo(name string) &#123;    ccb.updateCh.Put(&amp;switchToUpdate&#123;name: name&#125;)&#125;</code></pre><p><img src="https://pic2.zhimg.com/v2-c485ed2672bd1d62f47013e2daad7861_b.png"></p><p>接下来在 ccBalancerWrapper 的守护协程中，一旦接收到 swtichToUpdate 类型的消息后，会执行<br>ccBalancerWrapper.handleSwitchTo 执行负载均衡器 Balancer 的设定.</p><pre><code class="hljs">func (ccb *ccBalancerWrapper) watcher() &#123;    for &#123;        select &#123;        case u := &lt;-ccb.updateCh.Get():            ccb.updateCh.Load()            // ...            switch update := u.(type) &#123;            // ...            case *switchToUpdate:                ccb.handleSwitchTo(update.name)            // ...            &#125;        // ...        &#125;        // ...    &#125;&#125;func (ccb *ccBalancerWrapper) handleSwitchTo(name string) &#123;    // ...    builder := balancer.Get(name)    if builder == nil &#123;        // ...        builder = newPickfirstBuilder()    &#125;     if err := ccb.balancer.SwitchTo(builder); err != nil &#123;        // ...    &#125;    ccb.curBalancerName = builder.Name()&#125;</code></pre><p>在 ccBalancerWrapper.handleSwitchTo 方法中，由于传入的 name 为 pick_first，因此会构造出对应的<br>pickerFirst balancer 并注入到 ccBalancerWrapper 中.</p><pre><code class="hljs">func (gsb *Balancer) SwitchTo(builder balancer.Builder) error &#123;    // ...    bw := &amp;balancerWrapper&#123;        gsb: gsb,        lastState: balancer.State&#123;            ConnectivityState: connectivity.Connecting,            Picker:            base.NewErrPicker(balancer.ErrNoSubConnAvailable),        &#125;,        subconns: make(map[balancer.SubConn]bool),    &#125;    // ...    if gsb.balancerCurrent == nil &#123;        gsb.balancerCurrent = bw    &#125; else &#123;        gsb.balancerPending = bw    &#125;    // ...    newBalancer := builder.Build(bw, gsb.bOpts)    // ...    // ...    bw.Balancer = newBalancer    return nil&#125;</code></pre><p>其中 pickerFirst balancer 定义如下：</p><pre><code class="hljs">const PickFirstBalancerName = &quot;pick_first&quot;type pickfirstBuilder struct&#123;&#125;func (*pickfirstBuilder) Build(cc balancer.ClientConn, opt balancer.BuildOptions) balancer.Balancer &#123;    return &amp;pickfirstBalancer&#123;cc: cc&#125;&#125;func (*pickfirstBuilder) Name() string &#123;    return PickFirstBalancerName&#125;type pickfirstBalancer struct &#123;    state   connectivity.State    cc      balancer.ClientConn    subConn balancer.SubConn&#125;</code></pre><h3 id="3-4-2-ccBalancerWrapper-updateClientConnState"><a href="#3-4-2-ccBalancerWrapper-updateClientConnState" class="headerlink" title="3.4.2 ccBalancerWrapper.updateClientConnState"></a><strong>3.4.2 ccBalancerWrapper.updateClientConnState</strong></h3><p><img src="https://pic3.zhimg.com/v2-9d474750a20378dbc9a8724c4f20720e_b.jpg"></p><p>重新回到 ClientConn.updateResolverState 方法中，在处理完 ccBalancerWrapper.switchTo<br>分支完成负载均衡器 Balancer 的创建和设置后，会调用ccBalancerWrapper.updateClientConnState 方法对<br>ClientConn 的状态进行更新.</p><pre><code class="hljs">func (ccb *ccBalancerWrapper) updateClientConnState(ccs *balancer.ClientConnState) error &#123;    ccb.updateCh.Put(&amp;ccStateUpdate&#123;ccs: ccs&#125;)    // ...&#125;</code></pre><p>ccBalancerWrapper 的守护协程接收到 ccStateUpdate 消息后，会调用<br>ccBalancerWrapper.handleClientConnStateChange 方法对 ClientConn 的状态进行更新.</p><pre><code class="hljs">func (ccb *ccBalancerWrapper) watcher() &#123;    for &#123;        select &#123;        case u := &lt;-ccb.updateCh.Get():            ccb.updateCh.Load()            // ...            switch update := u.(type) &#123;            case *ccStateUpdate:                ccb.handleClientConnStateChange(update.ccs)            // ...            &#125;        // ...        &#125;        // ...    &#125;&#125;func (ccb *ccBalancerWrapper) handleClientConnStateChange(ccs *balancer.ClientConnState) &#123;    // ...    ccb.resultCh.Put(ccb.balancer.UpdateClientConnState(*ccs))&#125;func (gsb *Balancer) UpdateClientConnState(state balancer.ClientConnState) error &#123;    // ...    return balToUpdate.UpdateClientConnState(state)&#125;</code></pre><p>此处会一路走到负载均衡器 Balancer 的 UpdateClientConnState 方法中. 对应的 Balancer 为 pickFirst<br>类型，我们展开对应的方法源码：</p><pre><code class="hljs">func (b *pickfirstBalancer) UpdateClientConnState(state balancer.ClientConnState) error &#123;    // ...    subConn, err := b.cc.NewSubConn(state.ResolverState.Addresses, balancer.NewSubConnOptions&#123;&#125;)    // ...    b.subConn = subConn    b.state = connectivity.Idle    b.cc.UpdateState(balancer.State&#123;        ConnectivityState: connectivity.Connecting,        Picker:            &amp;picker&#123;err: balancer.ErrNoSubConnAvailable&#125;,    &#125;)    b.subConn.Connect()    return nil&#125;</code></pre><p>pickfirstBalancer.UpdateClientConnState 方法的核心步骤包括：</p><ul><li>调用 ccBalancerWrapper.NewSubConn 方法创建了子连接 subconn</li><li>调用了 ccBalancerWrapper.UpdateState 方法，</li><li>调用了 subconn.Connect 方法，建立子连接</li></ul><p><strong>（1）ccBalancerWrapper.NewSubConn</strong></p><pre><code class="hljs">func (ccb *ccBalancerWrapper) NewSubConn(addrs []resolver.Address, opts balancer.NewSubConnOptions) (balancer.SubConn, error) &#123;    // ...    ac, err := ccb.cc.newAddrConn(addrs, opts)    // ...    acbw := &amp;acBalancerWrapper&#123;ac: ac, producers: make(map[balancer.ProducerBuilder]*refCountedProducer)&#125;    acbw.ac.mu.Lock()    ac.acbw = acbw    acbw.ac.mu.Unlock()    return acbw, nil&#125;</code></pre><p>在 ccBalancerWrapper.NewSubConn 方法中，基于 target 的 address 构造了连接 addrConn，并将其封装到<br>balancer.SubConn 具体实现类 acBalancerWrapper 中进行返回.</p><pre><code class="hljs">type acBalancerWrapper struct &#123;    mu        sync.Mutex    ac        *addrConn    // ...&#125;type addrConn struct &#123;    ctx    context.Context    cancel context.CancelFunc    cc     *ClientConn    dopts  dialOptions    acbw   balancer.SubConn    // ...    transport transport.ClientTransport // The current transport.    mu      sync.Mutex    curAddr resolver.Address      addrs   []resolver.Address     state connectivity.State    // ...&#125;func (cc *ClientConn) newAddrConn(addrs []resolver.Address, opts balancer.NewSubConnOptions) (*addrConn, error) &#123;    ac := &amp;addrConn&#123;        state:        connectivity.Idle,        cc:           cc,        addrs:        addrs,        scopts:       opts,        dopts:        cc.dopts,        czData:       new(channelzData),        resetBackoff: make(chan struct&#123;&#125;),    &#125;    // ...    cc.conns[ac] = struct&#123;&#125;&#123;&#125;    return ac, nil&#125;</code></pre><p>在构造 addrConn 实例的过程中会将其添加到 ClientConn 的连接池集合 ClientConn.conns 当中.</p><p><strong>（2）ccBalancerWrapper.UpdateState</strong></p><p>在 ccBalancerWrapper.UpdateState 方法中，会对连接选择器 picker 进行设定，然后调用<br>connectivityStateManager.updateState 方法将连接状态设定为 connecting 连接中.</p><pre><code class="hljs">func (ccb *ccBalancerWrapper) UpdateState(s balancer.State) &#123;    // ...    ccb.cc.blockingpicker.updatePicker(s.Picker)    ccb.cc.csMgr.updateState(s.ConnectivityState)&#125;func (pw *pickerWrapper) updatePicker(p balancer.Picker) &#123;    pw.mu.Lock()    if pw.done &#123;        pw.mu.Unlock()        return    &#125;    pw.picker = p    // pw.blockingCh should never be nil.    close(pw.blockingCh)    pw.blockingCh = make(chan struct&#123;&#125;)    pw.mu.Unlock()&#125;</code></pre><p>此处设定的连接选择器 picker 的类型默认为 pickFirst picker. 其中内置了唯一一个 pickResult，在 pick<br>时会固定返回这个结果.</p><pre><code class="hljs">type picker struct &#123;    result balancer.PickResult    err    error&#125;func (p *picker) Pick(balancer.PickInfo) (balancer.PickResult, error) &#123;    return p.result, p.err&#125;</code></pre><p><strong>（3）pickfirstBalancer.UpdateClientConnState</strong></p><p><img src="https://pic4.zhimg.com/v2-ed61d7eba4ac747d8a3077fcb5ed4f9f_b.jpg"></p><p>最后，pickfirstBalancer.UpdateClientConnState 方法还会调用 acBalancerWrapper.Connect<br>方法启动子连接. 其中会异步调用 addrConn.connect 方法</p><pre><code class="hljs">func (acbw *acBalancerWrapper) Connect() &#123;    acbw.mu.Lock()    defer acbw.mu.Unlock()    go acbw.ac.connect()&#125;func (ac *addrConn) connect() error &#123;    ac.mu.Lock()    // ...    ac.updateConnectivityState(connectivity.Connecting, nil)    // ...    ac.resetTransport()    return nil&#125;</code></pre><p>其中会首先通过 addrConn.updateConnectivityState 暂时先将子连接状态设置为 connecting ，后续<br>addrConn.resetTransport 方法中，经由 addrConn.tryAllAddrs -&gt;<br>addrConn.createTransport -&gt; addrConn.startHealthCheck -&gt;<br>ClientConn.handleSubConnStateChange -&gt; ccBalancerWrapper.updateSubConnState<br>的方法链路，会向 ccBalancerWrapper.updateCh 中发送一条 scStateUpdate 类型的消息，将子连接 subconn<br>状态更新为 ready 添加到 picker 的 pickerResult 当中.</p><pre><code class="hljs">func (ac *addrConn) resetTransport() &#123;    // ...    addrs := ac.addrs    // ...    if err := ac.tryAllAddrs(addrs, connectDeadline); err != nil &#123;        //  ...    &#125;    // ...&#125;func (ac *addrConn) tryAllAddrs(addrs []resolver.Address, connectDeadline time.Time) error &#123;    var firstConnErr error    for _, addr := range addrs &#123;        // ...        err := ac.createTransport(addr, copts, connectDeadline)        if err == nil &#123;            return nil        &#125;        // ...    &#125;    // ...&#125;func (ac *addrConn) createTransport(addr resolver.Address, copts transport.ConnectOptions, connectDeadline time.Time) error &#123;    addr.ServerName = ac.cc.getServerName(addr)    hctx, hcancel := context.WithCancel(ac.ctx)    // ...    newTr, err := transport.NewClientTransport(connectCtx, ac.cc.ctx, addr, copts, onClose)    // ...    ac.curAddr = addr    ac.transport = newTr    ac.startHealthCheck(hctx)     return nil&#125;func (ac *addrConn) startHealthCheck(ctx context.Context) &#123;    var healthcheckManagingState bool    defer func() &#123;        if !healthcheckManagingState &#123;            ac.updateConnectivityState(connectivity.Ready, nil)        &#125;    &#125;()    // ...    healthCheckFunc := ac.cc.dopts.healthCheckFunc    if healthCheckFunc == nil &#123;        // ...        return    &#125;    // ...&#125;func (ac *addrConn) updateConnectivityState(s connectivity.State, lastErr error) &#123;    // ...    ac.state = s    // ...    ac.cc.handleSubConnStateChange(ac.acbw, s, lastErr)&#125;func (cc *ClientConn) handleSubConnStateChange(sc balancer.SubConn, s connectivity.State, err error) &#123;    cc.balancerWrapper.updateSubConnState(sc, s, err)&#125;func (ccb *ccBalancerWrapper) updateSubConnState(sc balancer.SubConn, s connectivity.State, err error) &#123;    // ...    ccb.updateCh.Put(&amp;scStateUpdate&#123;        sc:    sc,        state: s,        err:   err,    &#125;)&#125;</code></pre><p>ccBalancerWrapper 的守护协程中，监听到 scStateUpdate 事件到达后，会经历<br>ccBalancerWrapper.handleSubConnStateChange -&gt;<br>gracefulswitch.Balancer.UpdateSubConnState -&gt;<br>pickfirstBalancer.UpdateSubConnState -&gt; ccBalancerWrapper.UpdateState<br>的方法链路，完成对 pickfirstPicker 中 pickerResult 的更新.</p><pre><code class="hljs">func (ccb *ccBalancerWrapper) watcher() &#123;    for &#123;        select &#123;        case u := &lt;-ccb.updateCh.Get():            ccb.updateCh.Load()            // ...            switch update := u.(type) &#123;            // ...            case *scStateUpdate:                ccb.handleSubConnStateChange(update)            // ...            &#125;        case &lt;-ccb.closed.Done():        &#125;        // ...    &#125;&#125;func (ccb *ccBalancerWrapper) handleSubConnStateChange(update *scStateUpdate) &#123;    ccb.balancer.UpdateSubConnState(update.sc, balancer.SubConnState&#123;ConnectivityState: update.state, ConnectionError: update.err&#125;)&#125;func (gsb *Balancer) UpdateSubConnState(sc balancer.SubConn, state balancer.SubConnState) &#123;    // ...    balToUpdate.UpdateSubConnState(sc, state)&#125;func (b *pickfirstBalancer) UpdateSubConnState(subConn balancer.SubConn, state balancer.SubConnState) &#123;    // ...    switch state.ConnectivityState &#123;    case connectivity.Ready:        b.cc.UpdateState(balancer.State&#123;            ConnectivityState: state.ConnectivityState,            Picker:            &amp;picker&#123;result: balancer.PickResult&#123;SubConn: subConn&#125;&#125;,        &#125;)    case connectivity.Connecting:        b.cc.UpdateState(balancer.State&#123;            ConnectivityState: state.ConnectivityState,            Picker:            &amp;picker&#123;err: balancer.ErrNoSubConnAvailable&#125;,        &#125;)    // ...    &#125;&#125;func (ccb *ccBalancerWrapper) UpdateState(s balancer.State) &#123;    // ...    ccb.cc.blockingpicker.updatePicker(s.Picker)    ccb.cc.csMgr.updateState(s.ConnectivityState)&#125;</code></pre><p>到这里为止，通过 grpc.Dial 方法构造 ClientConn 对象，为客户端请求进行前置准备的主线链路就已经梳理完毕.</p><h2 id="4-grpc-Invoke"><a href="#4-grpc-Invoke" class="headerlink" title="4 grpc.Invoke"></a>4 grpc.Invoke</h2><p><img src="https://pic1.zhimg.com/v2-e0813cacbb7221902ad1f611739f26f0_b.jpg"></p><h2 id="4-1-ClientConn-Invoke"><a href="#4-1-ClientConn-Invoke" class="headerlink" title="4.1 ClientConn.Invoke"></a>4.1 ClientConn.Invoke</h2><p>在grpc-go客户端通过pb桩代码发起请求时，内部会调用 ClientConn.Invoke 方法，核心步骤分为三部分：</p><ul><li><p>调用 newClientStream 方法构造一个 clientStream 用于与服务端的通信交互</p></li><li><p>调用 clientStream.SendMsg 方法发送请求</p></li><li><p>调用 clientStream.RecvMsg 方法接收响应</p><p>  func (c *helloServiceClient) SayHello(ctx context.Context, in *HelloReq, opts …grpc.CallOption) (*HelloResp, error) {<br>  out :&#x3D; new(HelloResp)<br>  err :&#x3D; c.cc.Invoke(ctx, “&#x2F;pb.HelloService&#x2F;SayHello”, in, out, opts…)<br>  &#x2F;&#x2F; …<br>  return out, nil<br>  }<br>  func (cc *ClientConn) Invoke(ctx context.Context, method string, args, reply interface{}, opts …CallOption) error {<br>  &#x2F;&#x2F; …<br>  return invoke(ctx, method, args, reply, cc, opts…)<br>  }<br>  func invoke(ctx context.Context, method string, req, reply interface{}, cc *ClientConn, opts …CallOption) error {<br>  cs, err :&#x3D; newClientStream(ctx, unaryStreamDesc, cc, method, opts…)<br>  &#x2F;&#x2F; …<br>  if err :&#x3D; cs.SendMsg(req); err !&#x3D; nil {<br>      return err<br>  }<br>  return cs.RecvMsg(reply)<br>  }</p></li></ul><h2 id="4-2-newClientStream"><a href="#4-2-newClientStream" class="headerlink" title="4.2 newClientStream"></a>4.2 newClientStream</h2><h3 id="4-2-1-newClientStreamWithParams"><a href="#4-2-1-newClientStreamWithParams" class="headerlink" title="4.2.1 newClientStreamWithParams"></a>4.2.1 newClientStreamWithParams</h3><pre><code class="hljs">func newClientStream(ctx context.Context, desc *StreamDesc, cc *ClientConn, method string, opts ...CallOption) (_ ClientStream, err error) &#123;    // ...    var newStream = func(ctx context.Context, done func()) (iresolver.ClientStream, error) &#123;        return newClientStreamWithParams(ctx, desc, cc, method, mc, onCommit, done, opts...)    &#125;    // ...    return newStream(ctx, func() &#123;&#125;)&#125;func newClientStreamWithParams(ctx context.Context, desc *StreamDesc, cc *ClientConn, method string, mc serviceconfig.MethodConfig, onCommit, doneFunc func(), opts ...CallOption) (_ iresolver.ClientStream, err error) &#123;    // ...    // 初始化压缩模块    var cp Compressor    // ...        cs := &amp;clientStream&#123;        callHdr:      callHdr,        ctx:          ctx,        methodConfig: &amp;mc,        opts:         opts,        callInfo:     c,        cc:           cc,        desc:         desc,        codec:        c.codec,        cp:           cp,        comp:         comp,        cancel:       cancel,        firstAttempt: true,        onCommit:     onCommit,    &#125;          // ...    // 获取 csAttempt 的闭包函数    op := func(a *csAttempt) error &#123;        if err := a.getTransport(); err != nil &#123;            return err        &#125;        if err := a.newStream(); err != nil &#123;            return err        &#125;        // ...        cs.attempt = a        return nil    &#125;    if err := cs.withRetry(op, func() &#123; cs.bufferForRetryLocked(0, op) &#125;); err != nil &#123;        return nil, err    &#125;    // ...    return cs, nil&#125;</code></pre><h3 id="4-2-2-clientStream-withRetry"><a href="#4-2-2-clientStream-withRetry" class="headerlink" title="4.2.2 clientStream.withRetry"></a>4.2.2 clientStream.withRetry</h3><p>在 clientStream.withRetry 方法中，会针对 op 方法进行重试，直到处理成功或者返回的错误类型为 io.EOF.</p><pre><code class="hljs">func (cs *clientStream) withRetry(op func(a *csAttempt) error, onSuccess func()) error &#123;    // ...    for &#123;        // ...        err := op(a)        // ...        if err == io.EOF &#123;            &lt;-a.s.Done()        &#125;        // 处理完成        if err == nil || (err == io.EOF &amp;&amp; a.s.Status().Code() == codes.OK) &#123;            onSuccess()            cs.mu.Unlock()            return err        &#125;        // ...    &#125;&#125;</code></pre><h3 id="4-2-3-csAttempt-getTransport"><a href="#4-2-3-csAttempt-getTransport" class="headerlink" title="4.2.3 csAttempt.getTransport"></a>4.2.3 csAttempt.getTransport</h3><p><img src="https://pic4.zhimg.com/v2-72d8df173eeae16f37bd03ad7e63dd2f_b.jpg"></p><p>在 csAttempt.getTransport 方法链路中，最终会通过 pickFirstPicker.pick 方法获取到对应的<br>pickResult，拿到用于请求的的子连接 subconn.</p><p>此处呼应了本文 3.4.2 小节第（3）部分，在构建 resolver 过程中，就提前准备并添加到 pickFirstPicker 中的<br>pickResult.</p><p>在获取到子连接 subconn 后，会调用其中的 addrConn.getReadyTranport 获取到通信器 transport.<br>这部分在后续单开的通信篇再作展开.</p><pre><code class="hljs">func (a *csAttempt) getTransport() error &#123;    cs := a.cs    var err error    a.t, a.pickResult, err = cs.cc.getTransport(a.ctx, cs.callInfo.failFast, cs.callHdr.Method)    // ...    return nil&#125;func (cc *ClientConn) getTransport(ctx context.Context, failfast bool, method string) (transport.ClientTransport, balancer.PickResult, error) &#123;    return cc.blockingpicker.pick(ctx, failfast, balancer.PickInfo&#123;        Ctx:            ctx,        FullMethodName: method,    &#125;)&#125;func (pw *pickerWrapper) pick(ctx context.Context, failfast bool, info balancer.PickInfo) (transport.ClientTransport, balancer.PickResult, error) &#123;    for &#123;        // ...        ch = pw.blockingCh        p := pw.picker        pw.mu.Unlock()        pickResult, err := p.Pick(info)        // ...        acw, ok := pickResult.SubConn.(*acBalancerWrapper)        // ...        if t := acw.getAddrConn().getReadyTransport(); t != nil &#123;            // ...            return t, pickResult, nil        &#125;        // ...            &#125;&#125;func (p *picker) Pick(balancer.PickInfo) (balancer.PickResult, error) &#123;    return p.result, p.err&#125;</code></pre><h3 id="4-2-4-csAttempt-newStream"><a href="#4-2-4-csAttempt-newStream" class="headerlink" title="4.2.4 csAttempt.newStream"></a>4.2.4 csAttempt.newStream</h3><p>在 csAttempt.newStream 方法中，会通过 ClientTransport.NewStream 方法创建一个 rpc stream<br>用于后续的请求通信. 这部分放在后续单开的通信篇中再作展开.</p><pre><code class="hljs">func (a *csAttempt) newStream() error &#123;    cs := a.cs    // ...    // 构造一个 grpc stream    s, err := a.t.NewStream(a.ctx, cs.callHdr)    // ...    a.s = s    a.p = &amp;parser&#123;r: s&#125;    return nil&#125;</code></pre><h2 id="4-3-clientStream-SendMsg"><a href="#4-3-clientStream-SendMsg" class="headerlink" title="4.3 clientStream.SendMsg"></a>4.3 clientStream.SendMsg</h2><p>发送请求是基于 clientStream.SendMsg -&gt; csAttempt.ClientTransport.sendMsg<br>来执行的，有关通信模块的细节，我们后续单开一个通信篇再作展开.</p><pre><code class="hljs">func (cs *clientStream) SendMsg(m interface&#123;&#125;) (err error) &#123;    // ...    // 消息前处理，包括编码、压缩等细节    hdr, payload, data, err := prepareMsg(m, cs.codec, cs.cp, cs.comp)    // ...    // 通过 csAttempt 发送请求    op := func(a *csAttempt) error &#123;        return a.sendMsg(m, hdr, payload, data)    &#125;    err = cs.withRetry(op, func() &#123; cs.bufferForRetryLocked(len(hdr)+len(payload), op) &#125;)    // ...    return err&#125;func (a *csAttempt) sendMsg(m interface&#123;&#125;, hdr, payld, data []byte) error &#123;    cs := a.cs    // ...    if err := a.t.Write(a.s, hdr, payld, &amp;transport.Options&#123;Last: !cs.desc.ClientStreams&#125;); err != nil &#123;        // ...    &#125;    // ...    return nil&#125;</code></pre><h2 id="4-4-clientStream-RecvMsg"><a href="#4-4-clientStream-RecvMsg" class="headerlink" title="4.4 clientStream.RecvMsg"></a>4.4 clientStream.RecvMsg</h2><p>grpc-go客户端接收来自服务端的响应参数时，基于 clientStream.RecvMsg -&gt; csAttempt.recvMsg -&gt; recv<br>的方法链路完成，recv 方法内部会先通过 recvAndDecompress 方法接收响应并进行解压，然后调用 baseCodec.Unmarshal<br>方法，遵循特定的协议对响应进行反序列化.</p><p>这部分通信和编码相关的细节，我们后续单开通信篇章再作展开.</p><pre><code class="hljs">func (cs *clientStream) RecvMsg(m interface&#123;&#125;) error &#123;    // 通过 csAttempt 接收响应    err := cs.withRetry(func(a *csAttempt) error &#123;        return a.recvMsg(m, recvInfo)    &#125;, cs.commitAttemptLocked)    // ...    return err&#125;func (a *csAttempt) recvMsg(m interface&#123;&#125;, payInfo *payloadInfo) (err error) &#123;    cs := a.cs    // ...    err = recv(a.p, cs.codec, a.s, a.dc, m, *cs.callInfo.maxReceiveMessageSize, payInfo, a.decomp)    // ...&#125;func recv(p *parser, c baseCodec, s *transport.Stream, dc Decompressor, m interface&#123;&#125;, maxReceiveMessageSize int, payInfo *payloadInfo, compressor encoding.Compressor) error &#123;    d, err := recvAndDecompress(p, s, dc, maxReceiveMessageSize, payInfo, compressor)    // ...    if err := c.Unmarshal(d, m); err != nil &#123;        return status.Errorf(codes.Internal, &quot;grpc: failed to unmarshal the received message: %v&quot;, err)    &#125;    // ...&#125;</code></pre><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h2><p>本文从grpc-go客户端视角出发，沿着 grpc.Dial 和 grpc.Invoke<br>两条主线进行了源码走读，整体来说代码量偏大，分析的部分较少，更多是在梳理客户端的主流程框架，为后续grpc-go通信篇的展开打好基础.</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>network</category>
      
      <category>协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>grpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eventfd机制.md</title>
    <link href="/2024/05/10/mdstorage/domain/linux/eventfd%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/05/10/mdstorage/domain/linux/eventfd%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-fd-系列-—-eventfd-是什么？"><a href="#Linux-fd-系列-—-eventfd-是什么？" class="headerlink" title="Linux fd 系列 — eventfd 是什么？"></a>Linux fd 系列 — eventfd 是什么？</h1><h2 id="一切皆文件，但-fd-区分类型？"><a href="#一切皆文件，但-fd-区分类型？" class="headerlink" title="一切皆文件，但 fd 区分类型？"></a><strong>一切皆文件，但 fd 区分类型？</strong></h2><p>Linux 一切皆文件，但这个文件 fd 也是有类型的，绝大部分人都知道“文件 fd”，知道 socket fd，甚至知道 pipe fd，可能都不知道<br>fd 还有这么一种叫做 <code>eventfd</code> 的类型。</p><h2 id="eventfd-是什么的？"><a href="#eventfd-是什么的？" class="headerlink" title="eventfd 是什么的？"></a><strong>eventfd 是什么的？</strong></h2><p>不妨拆开来看，event fd ，也就是事件 fd 类型。故名思义，就是专门用于事件通知的文件描述符（ fd ）。很多人可能没怎么用，但是用过的人都说：香<br>！</p><p>哪个版本引入的？</p><p>Linux 2.6.22</p><p>代码位于：<code>fs/eventfd.c</code></p><p>“事件传递”就是通信嘛。eventfd 不仅可以用于进程间的通信，还能用于用户态和内核态的通信。</p><p>思考一个小问题：我们知道“文件”里是保存东西的，eventfd 既然对应了一个“文件”，那么这个“文件”的内容是什么呢？</p><p><strong>划重点：eventfd 是一个计数相关的fd</strong> 。计数不为零是有<strong>可读事件</strong> 发生，<code>read</code> 之后计数会清零，<code>write</code> 则会递增计数器。</p><p>这个怎么理解？</p><p>在之前自制文件系统系列中提到过：文件系统的“文件”是抽象的概念，你看到的一切知识文件系统想让你看到的东西。比如 hellofs<br>中我们没写过任何数据，也会返回 “hello world” 的内容。这个仅仅 hook 到 read&#x2F;write 调用，然后根据逻辑返回数据而已。</p><p>eventfd 也是如此，eventfd 实现了 read&#x2F;write 的调用，在调用里面实现了一套计数器的逻辑。write 仅仅是加计数，read<br>是读计数，并且清零。</p><p>长什么样子呢？笔者找了个进程来观摩下。</p><pre><code class="hljs">root@ubuntu:~# ll /proc/14168/fdlrwx------ 1 root root 64 Jul 10 22:12 3 -&gt; anon_inode:[eventfd]</code></pre><p>在 Linux 的 <code>/proc</code> 下每个进程都会有个目录，目录名为进程 ID 号，在这个目录能看到使用的资源信息，其中有个 fd<br>目录，就是进程打开的所有文件。看出猫腻了不？有个叫做 <code>[eventfd]</code> 的 fd 句柄。</p><h2 id="怎么使用它呢？"><a href="#怎么使用它呢？" class="headerlink" title="怎么使用它呢？"></a><strong>怎么使用它呢？</strong></h2><h3 id="句柄创建"><a href="#句柄创建" class="headerlink" title="句柄创建"></a><strong>句柄创建</strong></h3><pre><code class="hljs">#include &lt;sys/eventfd.h&gt;int eventfd(unsigned int initval, int flags);</code></pre><p>举个栗子：</p><pre><code class="hljs">efd = eventfd(0, 0);if (efd == -1)    handle_error(&quot;eventfd&quot;);</code></pre><p>这样就创建出了一个 eventfd 类型的 fd 啦。会在你的 <code>/proc/$&#123;pid&#125;/fd/</code> 目录中有一个 eventfd 类型的句柄。</p><h3 id="eventfd-api-调用？"><a href="#eventfd-api-调用？" class="headerlink" title="eventfd api 调用？"></a><strong>eventfd api 调用？</strong></h3><p>eventfd new 出来之后，总结来说，可以对它做四个事情：</p><ol><li>可以读这个 fd；</li><li>可以写这个 fd；</li><li>可以监听这个 fd；</li><li>可以关闭这个 fd；</li></ol><p>我怎么知道这个知识点的？</p><p>因为在 Linux 内核代码中，我看到了呀。eventfd 就实现了这几个调用。</p><pre><code class="hljs">static const struct file_operations eventfd_fops = &#123;#ifdef CONFIG_PROC_FS    .show_fdinfo = eventfd_show_fdinfo,#endif    .release = eventfd_release,    .poll  = eventfd_poll,    .read  = eventfd_read,    .write  = eventfd_write,    .llseek  = noop_llseek,&#125;;</code></pre><p>很明显就能看到以上实现的几个调用就是 eventfd 全部的内容所在。</p><h3 id="读写-fd"><a href="#读写-fd" class="headerlink" title="读写 fd"></a><strong>读写 fd</strong></h3><p>简单看下 eventfd 的读写究竟做了什么？</p><p>eventfd 对应的文件内容是一个 8 字节的数字，这个数字是 read&#x2F;write 操作维护的计数。</p><p>首先，write 的时候，累加计数，read 的时候读取计数，并且清零。</p><pre><code class="hljs">uint64_t u;ssize_t n;// 写 eventfd，内部 buffer 必须是 8 字节大小；n = write(efd, &amp;u, sizeof(uint64_t));// 读 eventfdn = read(efd, &amp;u, sizeof(uint64_t));</code></pre><p>读写也就是 read&#x2F;write，读写这个 fd 很容易理解，但是请注意了，只能 8 个字节。这个读写的内容其实是计数。</p><p>举个栗子：如下，我们连续写 3 次</p><pre><code class="hljs">// 写 3 次write(efd, &amp;u /* u = 1 */ , 8)write(efd, &amp;u /* u = 2 */ , 8)write(efd, &amp;u /* u = 3 */ , 8)</code></pre><p>你猜猜读的时候，是多少？</p><pre><code class="hljs">read(ebd, &amp;x, 8)</code></pre><p>读到的值是 6（因为 1+2+3），理解了吧。</p><p><img src="https://pic3.zhimg.com/v2-1aeeec8d6878ce1c1d4502a52ff01c6e_b.gif"></p><p><img src="/./eventfd_files/v2-1aeeec8d6878ce1c1d4502a52ff01c6e_b.jpg" alt="动图封面"></p><p>小结：</p><ol><li>写的时候，写进去一个 8 字节的整数，eventfd 实现的逻辑是累计计数；</li><li>读的时候，读到总计数，并且会清零；</li><li>实现在 <code>eventfd_write</code> 和 <code>eventfd_read</code> 函数中；</li></ol><h3 id="监听-fd"><a href="#监听-fd" class="headerlink" title="监听 fd"></a><strong>监听 fd</strong></h3><p>在 <strong><a href="https://zhuanlan.zhihu.com/write">深入理解 Linux Epoll 池</a></strong> 提到过，不是所有的 fd<br>类型都可用 epoll 池来监听事件的，只有实现了 <code>file_operation-&gt;poll</code> 的调用的“文件” fd 才能被 epoll<br>管理。eventfd 刚好就实现了这个接口。</p><p>eventfd 是专门用来传递事件的 fd ，而 epoll 池则是专门用来管理事件的池子，它们两结合就妙了。</p><p>我们知道 epoll 监听的是<strong>可读可写事件</strong> 。那么你想过 eventfd 的可读可写事件是啥吗？</p><p>“<strong>可读可写事件</strong> ”这是个有趣的问题，我们可以去发散下，对比思考下 socket fd，文件 fd：</p><ul><li>socket fd：可以写入发送数据，那么触发可写事件，网卡数据来了，可以读，触发可读事件；</li><li>文件 fd：文件 fd 的可读可写事件就更有意思了，因为文件一直是可写的，所以一直都触发可写事件，文件里的数据也一直是可读的，所以一直触发可读事件。这个也是为什么类似 ext4 这种文件不实现 poll 接口的原因。<strong>因为文件 fd 一直是可读可写的，poll 监听没有任何意义；</strong></li></ul><p>回到最初问题：eventfd 呢？它的可读可写事件是什么？</p><p>我们之前说过，eventfd 实现的是计数的功能。所以 eventfd 计数不为 0 ，那么 fd 是可读的。</p><p>由于 eventfd 一直可写（可以一直累计计数），所以一直有可写事件。</p><p>所以，这里有个什么隐藏知识点呢？</p><p><strong>eventfd 如果用 epoll 监听事件，那么都是监听读事件，因为监听写事件无意义。</strong></p><h3 id="关闭-fd"><a href="#关闭-fd" class="headerlink" title="关闭 fd"></a><strong>关闭 fd</strong></h3><p>关闭这个很容里理解，就是不需要这个 fd 了，主动调用一把 Close ，当没有人使用的时候，内核会释放这个 fd 的资源。</p><h3 id="fd-的阻塞属性"><a href="#fd-的阻塞属性" class="headerlink" title="fd 的阻塞属性"></a><strong>fd 的阻塞属性</strong></h3><p>我们知道读写 fd 的时候，可能会遇到阻塞，对于 socket fd 来说，没有数据的时候来读，则会阻塞。写 buffer 满了的时候来写，则会阻塞。</p><p>那么对于 eventfd 呢？它的阻塞有可能是怎么样的？</p><p>read eventfd 的时候，<strong>如果计数器的值为 0，就会阻塞</strong> （这种就等同于没“文件”内容）。</p><p>这种可以设置 fd 的属性为非阻塞类型，这样读的时候，如果计数器为 0 ，返回 EAGAIN 即可，这样就不会阻塞整个系统。</p><h2 id="通常的用途"><a href="#通常的用途" class="headerlink" title="通常的用途"></a><strong>通常的用途</strong></h2><p>单独的 eventfd 看似平平无奇，但其实有非常重要的应用。下面列举几个小例子：</p><h3 id="磁盘的异步-IO（-libaio-）"><a href="#磁盘的异步-IO（-libaio-）" class="headerlink" title="磁盘的异步 IO（ libaio ）"></a><strong>磁盘的异步 IO（ libaio ）</strong></h3><p>我们之前说过，类似于 ext4 这种文件系统的文件 fd ，其实是不能用 epoll 来管理的，网络 fd 才可以。因为磁盘文件一直可读可写。</p><p>难道文件就自绝于此吗？用不了事件机制吗？只能同步 IO 吗？</p><p>非也。Linux 内核提供了一个叫做 libaio 的机制，能够同时提交多个 io 请求给内核（这种批量递交能提高优化的概率，大量IO堆积到设备的队列中时,<br>内核可以发挥 IO 调度算法的优势,比如合并 IO 等）。</p><p>aio 请求完成之后，走异步的事件通知。这个事件通知的原理就是把一个 eventfd 和这个 aio 的上下文绑定起来。aio 完成，就会往 eventfd<br>里面写计数，从而触发可读事件。</p><h3 id="kvm-的-ioeventfd-机制"><a href="#kvm-的-ioeventfd-机制" class="headerlink" title="kvm 的 ioeventfd 机制"></a><strong>kvm 的 ioeventfd 机制</strong></h3><p>QEMU 可以将 VM 特定地址关联一个 eventfd，对进行监听，当Guest 进行 IO 操作 exit 到 kvm 后，kvm 可以判断本次exit<br>是否发生在这段特定地址中，如果是则会通过使用 eventfd 进行事件通知，进行 IO 操作，这种方式对比能节省一些时间。</p><h3 id="还有什么朴实的用法？"><a href="#还有什么朴实的用法？" class="headerlink" title="还有什么朴实的用法？"></a><strong>还有什么朴实的用法？</strong></h3><p>最简单的例子，一个消费者和多个生产者，这种就可以借助 eventfd 优雅的完成事件通知。</p><p>生产者：</p><p>是多个线程，会把请求投递到一个 list 中，然后唤醒生产者。</p><pre><code class="hljs">producer:    // 投递请求到链表    list_add( global_list, request )    // 唤醒消费者处理    write(eventfd, &amp;cnt /* 1 */ , 8)</code></pre><p>消费者：</p><p>是一个线程，后台 loop 处理。使用 epoll 监听 eventfd 的可读事件，这样能做到一旦有请求入队，消费者就立马唤醒处理。</p><pre><code class="hljs">consumer     // 添加 eventfd 到监听池    epoll_ctl(ep, EPOLL_CTL_ADD, eventfd, &amp;ee);loop:    // 等待唤醒    epoll_wait(ep, ... );        // 读取新添加到列表里的元素个数，并且进行处理；    n = read(eventfd, ... )    // 遍历链表处理    for each global_list:        // do something</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li>Linux 一切皆文件，但 fd 各有不同；</li><li>eventfd 实现了 read&#x2F;write 的接口，本质是一个计数器的实现；</li><li>eventfd 实现了 poll 接口，所以可以和 epoll 双剑合璧，实现事件的通知管理；</li><li>eventfd 可以和 libaio &amp; epoll 一起，实现 Linux 下的纯异步 IO；</li><li>eventfd 监听可读事件才有意义；</li><li>ext4 这种文件 fd 一直可读可写，所以实现 poll 毫无意义。eventfd 一直可写，所以监听可写毫无意义；</li><li>eventfd 可以结合业务，做一个事件通知的通信机制，非常巧妙；</li></ol>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>epoll机制.md</title>
    <link href="/2024/05/10/mdstorage/domain/network/epoll%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/05/10/mdstorage/domain/network/epoll%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="epoll机制-epoll-create、epoll-ctl、epoll-wait、close-的使用"><a href="#epoll机制-epoll-create、epoll-ctl、epoll-wait、close-的使用" class="headerlink" title="epoll机制:epoll_create、epoll_ctl、epoll_wait、close 的使用"></a>epoll机制:epoll_create、epoll_ctl、epoll_wait、close 的使用</h1><p>在linux的网络编程中，很长的时间都在使用select来做事件触发。在linux新的内核中，有了一种替换它的机制，就是epoll。相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。并且，linux&#x2F;posix_types.h头文件有这样的声明：<br>#define__FD_SETSIZE 1024<br><strong>表示select最多同时监听1024个fd，当然，可以通过修改头文件再重编译内核来扩大这个数目，但这似乎并不治本。</strong></p><p><strong>epoll的接口非常简单，一共就三个函数：</strong><br>1.<strong>创建epoll句柄</strong><br>int epfd &#x3D; epoll_create(intsize);</p><p>创建一个epoll的句柄，<strong>size用来告诉内核这个监听的数目一共有多大</strong><br>。<strong>这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值</strong><br>。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看&#x2F;proc&#x2F;进程id&#x2F;fd&#x2F;，是能够看到这个fd的，<strong>所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</strong><br>函数声明：int epoll_create(int size)<br>该 函数生成一个epoll专用的文件描述符。它其实是在内核申请一空间，用来存放你想关注的socket<br>fd上是否发生以及发生了什么事件。size就是你在这个epoll fd上能关注的最大socket<br>fd数。随你定好了。只要你有空间。可参见上面与select之不同<br>2.<strong>将被监听的描述符添加到epoll句柄或从epool句柄中删除或者对监听事件进行修改。</strong></p><p>*<em>函数声明：int epoll_ctl(int epfd, int op, int fd, struct epoll_event <em>event)</em></em><br><strong>该函数用于控制某个epoll文件描述符上的事件，可以注册事件，修改事件，删除事件。</strong><br><strong>参数：</strong><br><strong>epfd：由 epoll_create 生成的epoll专用的文件描述符；</strong><br><strong>op：要进行的操作例如注册事件，可能的取值EPOLL_CTL_ADD 注册、EPOLL_CTL_MOD 修 改、EPOLL_CTL_DEL 删除</strong></p><p><strong>fd：关联的文件描述符；</strong><br><strong>event：指向epoll_event的指针；</strong><br><strong>如果调用成功返回0,不成功返回-1</strong></p><p>int epoll_ctl(int epfd, int<strong>op</strong> , int fd, struct epoll_event*event);</p><p>epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。</p><p>第一个参数是epoll_create()的返回值，</p><p>第二个参数表示动作，用三个宏来表示：<br>EPOLL_CTL_ADD： 注册新的fd到epfd中；<br>EPOLL_CTL_MOD： 修改已经注册的fd的监听事件；<br>EPOLL_CTL_DEL： 从epfd中删除一个fd；<br>第三个参数是需要监听的fd，</p><p>第四个参数是告诉内核需要监听什么事件，struct epoll_event结构如下：</p><p>typedef union epoll_data {<br>void *ptr;<br>int fd;<br>__uint32_t u32;<br>__uint64_t u64;<br>} epoll_data_t;</p><p>struct epoll_event {<br>__uint32_t events; <em>&#x2F;* Epoll events *&#x2F;</em><br>epoll_data_t data; <em>&#x2F;* User data variable *&#x2F;</em><br>};</p><p>events可以是以下几个宏的集合：<br>EPOLLIN： 触发该事件，表示对应的文件描述符上有可读数据。(包括对端SOCKET正常关闭)；<br>EPOLLOUT： 触发该事件，表示对应的文件描述符上可以写数据；<br>EPOLLPRI： 表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；<br>EPOLLERR： 表示对应的文件描述符发生错误；<br>EPOLLHUP： 表示对应的文件描述符被挂断；<br>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。<br>EPOLLONESHOT： 只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里。<br>如：<br>struct epoll_event ev;<br>&#x2F;&#x2F;设置与要处理的事件相关的文件描述符<br>ev.data.fd&#x3D;listenfd;<br>&#x2F;&#x2F;设置要处理的事件类型<br>ev.events&#x3D;EPOLLIN|EPOLLET;<br>&#x2F;&#x2F;注册epoll事件<br>epoll_ctl(epfd,EPOLL_CTL_ADD,listenfd,&amp;ev);<br><strong>3.等待事件触发，当超过timeout还没有事件触发时，就超时。</strong></p><p><strong>int epoll_wait(int epfd, struct epoll_event * events, intmaxevents, int<br>timeout);</strong><br>等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大(数组成员的个数)，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。</p><p>该函数返回需要处理的事件数目，如返回0表示已超时。</p><h2 id="返回的事件集合在events数组中，数组中实际存放的成员个数是函数的返回值。返回0表示已经超时。函数声明-int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-inttimeout-该函数用于轮询I-O事件的发生；参数：epfd-由epoll-create-生成的epoll专用的文件描述符；epoll-event-用于回传代处理事件的数组；maxevents-每次能处理的事件数；timeout-等待I-O事件发生的超时值-单位我也不太清楚-；-1相当于阻塞，0相当于非阻塞。一般用-1即可返回发生事件数。epoll-wait运行的原理是等侍注册在epfd上的socket-fd的事件的发生，如果发生则将发生的sokct-fd和事件类型放入到events数组中。并-且将注册在epfd上的socket-fd的事件类型给清空-，所以如果下一个循环你还要关注这个socketfd的话，则需要用epoll-ctl-epfd-EPOLL-CTL-MOD-listenfd-ev-来重新设置socketfd的事件类型。这时不用EPOLL-CTL-ADD-因为socket-fd并未清空，只是事件类型清空。这一步非常重要。"><a href="#返回的事件集合在events数组中，数组中实际存放的成员个数是函数的返回值。返回0表示已经超时。函数声明-int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-inttimeout-该函数用于轮询I-O事件的发生；参数：epfd-由epoll-create-生成的epoll专用的文件描述符；epoll-event-用于回传代处理事件的数组；maxevents-每次能处理的事件数；timeout-等待I-O事件发生的超时值-单位我也不太清楚-；-1相当于阻塞，0相当于非阻塞。一般用-1即可返回发生事件数。epoll-wait运行的原理是等侍注册在epfd上的socket-fd的事件的发生，如果发生则将发生的sokct-fd和事件类型放入到events数组中。并-且将注册在epfd上的socket-fd的事件类型给清空-，所以如果下一个循环你还要关注这个socketfd的话，则需要用epoll-ctl-epfd-EPOLL-CTL-MOD-listenfd-ev-来重新设置socketfd的事件类型。这时不用EPOLL-CTL-ADD-因为socket-fd并未清空，只是事件类型清空。这一步非常重要。" class="headerlink" title="返回的事件集合在events数组中，数组中实际存放的成员个数是函数的返回值。返回0表示已经超时。函数声明:int epoll_wait(int epfd,struct epoll_event * events,int maxevents,inttimeout)该函数用于轮询I&#x2F;O事件的发生；参数：epfd:由epoll_create 生成的epoll专用的文件描述符；epoll_event:用于回传代处理事件的数组；maxevents:每次能处理的事件数；timeout:等待I&#x2F;O事件发生的超时值(单位我也不太清楚)；-1相当于阻塞，0相当于非阻塞。一般用-1即可返回发生事件数。epoll_wait运行的原理是等侍注册在epfd上的socket fd的事件的发生，如果发生则将发生的sokct fd和事件类型放入到events数组中。并 且将注册在epfd上的socket fd的事件类型给清空 ，所以如果下一个循环你还要关注这个socketfd的话，则需要用epoll_ctl(epfd,EPOLL_CTL_MOD,listenfd,&amp;ev)来重新设置socketfd的事件类型。这时不用EPOLL_CTL_ADD,因为socket fd并未清空，只是事件类型清空。这一步非常重要。  "></a>返回的事件集合在events数组中，数组中实际存放的成员个数是函数的返回值。返回0表示已经超时。<br>函数声明:int epoll_wait(int epfd,struct epoll_event * events,int maxevents,int<br>timeout)<br>该函数用于轮询I&#x2F;O事件的发生；<br>参数：<br>epfd:由epoll_create 生成的epoll专用的文件描述符；<br>epoll_event:用于回传代处理事件的数组；<br>maxevents:每次能处理的事件数；<br>timeout:等待I&#x2F;O事件发生的超时值(单位我也不太清楚)；-1相当于阻塞，0相当于非阻塞。一般用-1即可<br>返回发生事件数。<br>epoll_wait运行的原理是<br>等侍注册在epfd上的socket fd的事件的发生，如果发生则将发生的sokct fd和事件类型放入到events数组中。<br><strong>并 且将注册在epfd上的socket fd的事件类型给清空</strong> ，所以如果下一个循环你还要关注这个socket<br>fd的话，则需要用epoll_ctl(epfd,EPOLL_CTL_MOD,listenfd,&amp;ev)来重新设置socket<br>fd的事件类型。这时不用EPOLL_CTL_ADD,因为socket fd并未清空，只是事件类型清空。这一步非常重要。  </h2><p>从man手册中，得到ET和LT的具体描述如下<br>EPOLL事件有两种模型：<br>Edge Triggered(ET) &#x2F;&#x2F;<strong>高速工作方式，错误率比较大，只支持no_block socket (非阻塞socket)</strong><br>LevelTriggered(LT) &#x2F;&#x2F;<strong>缺省工作方式，即默认的工作方式,支持blocksocket和no_blocksocket，错误率比较小。</strong></p><p>假如有这样一个例子：(LT方式，即默认方式下，内核会继续通知，可以读数据，ET方式，内核不会再通知，可以读数据)<br>1.我们已经把一个用来从管道中读取数据的文件句柄(RFD)添加到epoll描述符<br>2. 这个时候从管道的另一端被写入了2KB的数据<br>3. 调用epoll_wait(2)，并且它会返回RFD，说明它已经准备好读取操作<br>4. 然后我们读取了1KB的数据<br>5. 调用epoll_wait(2)……</p><p><strong>Edge Triggered工作模式：</strong><br>如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait(2)之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候ET工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。在上面的例子中，会有一个事件产生在RFD句柄上，因为在第2步执行了一个写操作，然后，事件将会在第3步被销毁。因为第4步的读取操作没有读空文件输入缓冲区内的数据，因此我们在第5步调用epoll_wait(2)完成后，是否挂起是不确定的。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。最好以下面的方式调用ET模式的epoll接口，<strong>在后面会介绍避免可能的缺陷。(LT方式可以解决这种缺陷)</strong>  </p><p>i 基于非阻塞文件句柄<br>ii 只有当read(2)或者write(2)返回EAGAIN时(认为读完)才需要挂起，等待。<strong>但这并不是说每次read()时都需要循环读，直到读到产生一个EAGAIN才认为此次事件处理完成，当read()返回的读到的数据长度小于请求的数据长度时(即小于sizeof(buf))，就可以确定此时缓冲中已没有数据了，也就可以认为此事读事件已处理完成。</strong></p><p><strong>Level Triggered工作模式 (默认的工作方式)</strong><br>相反的，以LT方式调用epoll接口的时候，它就相当于一个速度比较快的poll(2)，并且无论后面的数据是否被使用，因此他们具有同样的职能。因为即使使用ET模式的epoll，在收到多个chunk的数据的时候仍然会产生多个事件。调用者可以设定EPOLLONESHOT标志，在epoll_wait(2)收到事件后epoll会与事件关联的文件句柄从epoll描述符中禁止掉。因此当EPOLLONESHOT设定后，使用带有EPOLL_CTL_MOD标志的epoll_ctl(2)处理文件句柄就成为调用者必须作的事情。</p><p><strong>然后详细解释ET, LT:</strong><br><strong>&#x2F;&#x2F;没有对就绪的fd进行IO操作，内核会不断的通知。</strong><br>LT(leveltriggered)是缺省的工作方式，并且同时支持block和no-<br>blocksocket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，<strong>内核还是会继续通知你的</strong><br>，所以，这种模式编程出错误可能性要小一点。传统的select&#x2F;poll都是这种模型的代表。<br><strong>&#x2F;&#x2F;没有对就绪的fd进行IO操作，内核不会再进行通知。</strong><br>ET(edge-triggered)是高速工作方式，只支持no-blocksocket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(<strong>比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK错误）。但是请注意，如果一直不</strong><br>对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only<br>once),<strong><em>不过在TCP协议中，ET模式的加速效用仍需要更多的benchmark确认（这句话不理解）。</em></strong></p><p>另外，当使用epoll的ET模型(epoll的非默认工作方式)来工作时，当产生了一个EPOLLIN事件后，<br>读数据的时候需要考虑的是当recv()返回的大小如果等于要求的大小，即sizeof(buf)，那么很有可能是缓冲区还有数据未读完，也意味着该次事件还没有处理完，所以还需要再次读取：<br>while(rs) &#x2F;&#x2F;ET模型<br>{<br>buflen &#x3D; recv(activeevents[i].data.fd, buf, sizeof(buf), 0);<br>if(buflen &lt; 0)<br>{<br>&#x2F;&#x2F;由于是非阻塞的模式,所以当errno为EAGAIN时,表示当前缓冲区已无数据可读<br>&#x2F;&#x2F; 在这里就当作是该次事件已处理处.<br>if(errno&#x3D;&#x3D; EAGAIN || errno &#x3D;&#x3D; EINT)<br>&#x2F;&#x2F;即当buflen&lt;0且errno&#x3D;EAGAIN时，表示没有数据了。(读&#x2F;写都是这样)<br>break;<br>else</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>network</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>conn的封装和实现.md</title>
    <link href="/2024/05/09/mdstorage/domain/network/conn%E7%9A%84%E5%B0%81%E8%A3%85%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/05/09/mdstorage/domain/network/conn%E7%9A%84%E5%B0%81%E8%A3%85%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>经典 Conn 的封装和实现解析</p><h2 id="conn-的解析"><a href="#conn-的解析" class="headerlink" title="conn 的解析"></a>conn 的解析</h2><p>conn 实现基于流的 网络连接，通用的面向流的网络连接，多个Goroutine可以同时调用Conn上的方法。<br>主要通过Read(b []byte)读取数据，Write(b [byte]) 写数据 及Close() 关闭连接。</p><p>Conn 接口定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// Conn is a generic stream-oriented network connection.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Multiple goroutines may invoke methods on a Conn simultaneously.</span><br><span class="hljs-keyword">type</span> Conn <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Read reads data from the connection.</span><br><span class="hljs-comment">// Read can be made to time out and return an error after a fixed</span><br><span class="hljs-comment">// time limit; see SetDeadline and SetReadDeadline.</span><br>Read(b []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br><br><span class="hljs-comment">// Write writes data to the connection.</span><br><span class="hljs-comment">// Write can be made to time out and return an error after a fixed</span><br><span class="hljs-comment">// time limit; see SetDeadline and SetWriteDeadline.</span><br>Write(b []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br><br><span class="hljs-comment">// Close closes the connection.</span><br><span class="hljs-comment">// Any blocked Read or Write operations will be unblocked and return errors.</span><br>Close() <span class="hljs-type">error</span><br><br><span class="hljs-comment">// LocalAddr returns the local network address, if known.</span><br>LocalAddr() Addr<br><br><span class="hljs-comment">// RemoteAddr returns the remote network address, if known.</span><br>RemoteAddr() Addr<br><br><span class="hljs-comment">// SetDeadline sets the read and write deadlines associated</span><br><span class="hljs-comment">// with the connection. It is equivalent to calling both</span><br><span class="hljs-comment">// SetReadDeadline and SetWriteDeadline.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// A deadline is an absolute time after which I/O operations</span><br><span class="hljs-comment">// fail instead of blocking. The deadline applies to all future</span><br><span class="hljs-comment">// and pending I/O, not just the immediately following call to</span><br><span class="hljs-comment">// Read or Write. After a deadline has been exceeded, the</span><br><span class="hljs-comment">// connection can be refreshed by setting a deadline in the future.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// If the deadline is exceeded a call to Read or Write or to other</span><br><span class="hljs-comment">// I/O methods will return an error that wraps os.ErrDeadlineExceeded.</span><br><span class="hljs-comment">// This can be tested using errors.Is(err, os.ErrDeadlineExceeded).</span><br><span class="hljs-comment">// The error&#x27;s Timeout method will return true, but note that there</span><br><span class="hljs-comment">// are other possible errors for which the Timeout method will</span><br><span class="hljs-comment">// return true even if the deadline has not been exceeded.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// An idle timeout can be implemented by repeatedly extending</span><br><span class="hljs-comment">// the deadline after successful Read or Write calls.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// A zero value for t means I/O operations will not time out.</span><br>SetDeadline(t time.Time) <span class="hljs-type">error</span><br><br><span class="hljs-comment">// SetReadDeadline sets the deadline for future Read calls</span><br><span class="hljs-comment">// and any currently-blocked Read call.</span><br><span class="hljs-comment">// A zero value for t means Read will not time out.</span><br>SetReadDeadline(t time.Time) <span class="hljs-type">error</span><br><br><span class="hljs-comment">// SetWriteDeadline sets the deadline for future Write calls</span><br><span class="hljs-comment">// and any currently-blocked Write call.</span><br><span class="hljs-comment">// Even if write times out, it may return n &gt; 0, indicating that</span><br><span class="hljs-comment">// some of the data was successfully written.</span><br><span class="hljs-comment">// A zero value for t means Write will not time out.</span><br>SetWriteDeadline(t time.Time) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>conn 实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">type</span> conn struct &#123;<br>fd *netFD<br>&#125;<br></code></pre></td></tr></table></figure><p>fd 实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Go">socketFunc        <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>)  = syscall.Socket<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>network</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Socket的封装.md</title>
    <link href="/2024/05/09/mdstorage/domain/network/Socket%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <url>/2024/05/09/mdstorage/domain/network/Socket%E7%9A%84%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Socket与系统调用深度分析-https-www-cnblogs-com-RichardTAO-p-12070548-html-“发布于"><a href="#Socket与系统调用深度分析-https-www-cnblogs-com-RichardTAO-p-12070548-html-“发布于" class="headerlink" title="[ Socket与系统调用深度分析 ](https://www.cnblogs.com/RichardTAO/p/12070548.html “发布于"></a>[ Socket与系统调用深度分析 ](<a href="https://www.cnblogs.com/RichardTAO/p/12070548.html">https://www.cnblogs.com/RichardTAO/p/12070548.html</a> “发布于</h1><p>2019-12-19 22:08”)</p><p>目录</p><ul><li><a href="https://www.cnblogs.com/RichardTAO/p/12070548.html#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">系统调用</a><ul><li><a href="https://www.cnblogs.com/RichardTAO/p/12070548.html#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B">系统调用的过程</a></li><li><a href="https://www.cnblogs.com/RichardTAO/p/12070548.html#%E7%A4%BA%E4%BE%8B%E5%88%86%E6%9E%90">示例分析</a></li><li><a href="https://www.cnblogs.com/RichardTAO/p/12070548.html#socket%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%88%86%E6%9E%90">Socket系统调用分析</a><ul><li><a href="https://www.cnblogs.com/RichardTAO/p/12070548.html#sock_map_fd">sock_map_fd</a></li><li><a href="https://www.cnblogs.com/RichardTAO/p/12070548.html#sock_create">sock_create</a></li></ul></li></ul></li><li><a href="https://www.cnblogs.com/RichardTAO/p/12070548.html#%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90">实验代码分析</a><ul><li><a href="https://www.cnblogs.com/RichardTAO/p/12070548.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF">服务器端</a><ul><li><a href="https://www.cnblogs.com/RichardTAO/p/12070548.html#initializeservice%E6%96%B9%E6%B3%95">InitializeService方法</a></li><li><a href="https://www.cnblogs.com/RichardTAO/p/12070548.html#servicestart%E6%96%B9%E6%B3%95">ServiceStart方法</a></li><li><a href="https://www.cnblogs.com/RichardTAO/p/12070548.html#recvmsg%E4%B8%8Esendmsg%E6%96%B9%E6%B3%95">RecvMsg与SendMsg方法</a></li><li><a href="https://www.cnblogs.com/RichardTAO/p/12070548.html#servicestop%E4%B8%8Eshutdownservice%E6%96%B9%E6%B3%95">ServiceStop与ShutdownService方法</a></li></ul></li><li><a href="https://www.cnblogs.com/RichardTAO/p/12070548.html#%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端</a></li></ul></li><li><a href="https://www.cnblogs.com/RichardTAO/p/12070548.html#%E8%B7%9F%E8%B8%AAsocket%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">跟踪socket相关系统调用的内核处理函数</a><ul><li><a href="https://www.cnblogs.com/RichardTAO/p/12070548.html#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96">系统调用初始化</a></li><li><a href="https://www.cnblogs.com/RichardTAO/p/12070548.html#socket%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">socket相关的系统调用</a></li></ul></li><li><a href="https://www.cnblogs.com/RichardTAO/p/12070548.html#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li></ul><h1 id="1-0-系统调用"><a href="#1-0-系统调用" class="headerlink" title="1 |**0**系统调用"></a><strong><em>1</em></strong> |**<em>0</em>**<strong>系统调用</strong></h1><h2 id="1-1-系统调用的过程"><a href="#1-1-系统调用的过程" class="headerlink" title="1 |**1**系统调用的过程"></a><strong><em>1</em></strong> |**<em>1</em>**<strong>系统调用的过程</strong></h2><p>系统调用的过程如下：</p><ul><li>用户程序</li><li>C库（API）：INT 0x80</li><li>system_call</li><li>系统调用服务例程</li><li>内核程序</li></ul><blockquote><p>说明：</p><ol><li>我们常说的用户 API 其实就是系统提供的 C 库；</li><li>系统调用是通过软中断指令 INT 0x80 实现的，而这条 INT 0x80 指令就被封装在 C 库的函数中。</li><li>INT 0x80 这条指令的执行会让系统跳转到一个预设的内核空间地址，它指向系统调用处理程序，即 system_call 函数</li></ol></blockquote><p>下图为系统调用具体的流程。</p><p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219215912966-312816293.jpg"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219215912966-312816293.jpg"></a></p><p>值得一提的是：系统调用处理程序 system_call 并不是系统调用服务例程。</p><p>系统调用服务例程是对一个具体的系统调用的内核实现函数，而系统调用处理程序是在执行系统调用服务例程之前的一个引导过程，是针对 INT 0x80<br>这条指令，面向所有的系统调用的。</p><p>简单来讲，执行任何系统调用，都是先通过调用 C 库中的函数，这个函数里面就会有软中断 INT 0x80 语句，然后转到执行系统调用处理程序<br>system_call，system_call 再根据具体的系统调用号转到执行具体的系统调用服务例程。</p><hr><blockquote><p>那么，system_call 函数是怎么找到具体的系统调用服务例程的呢？</p></blockquote><p>答案是：通过系统调用号查找系统调用表 sys_call_table。</p><p>软中断指令 INT 0x80 执行时，系统调用号会被放入 eax 寄存器中，system_call 函数可以读取 eax 寄存器获取，然后将其乘以<br>4，生成偏移地址，然后以 sys_call_table 为基址，基址加上偏移地址，就可以得到具体的系统调用服务例程的地址了！</p><p>然后就可以根据这个地址找到对应的系统调用服务例程了。</p><hr><blockquote><p>系统调用可以被进程抢占、进入阻塞状态</p></blockquote><p>其原因在于：</p><p>系统调用通过软中断 INT 0x80 陷入内核，跳转到系统调用处理程序 system_call<br>函数，然后执行相应的服务例程。但是由于是代表用户进程，所以这个执行过程并不属于中断上下文，而是进程上下文。</p><p>因此，系统调用执行过程中，可以访问用户进程的许多信息，可以被其他进程抢占，可以休眠。<br>当系统调用完成后，把控制权交回到发起调用的用户进程前，内核会有一次调度。如果发现有优先级更高的进程或当前进程的时间片用完，那么会选择优先级更高的进程或重新选择进程执行。</p><h2 id="1-2-示例分析"><a href="#1-2-示例分析" class="headerlink" title="1 |**2**示例分析"></a><strong><em>1</em></strong> |**<em>2</em>**<strong>示例分析</strong></h2><p>了解系统调用的过程之后，我们举个例子来分析用户态是如何陷入到内核态的。</p><p>由于本次实验的目的是调研<code>socket</code>相关的系统调用，因此我们以一个<code>bind</code>绑定事件作为例子。</p><p>__</p><pre><code class="hljs"># include &lt;sys/socket.h&gt;#include &lt;sys/un.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MY_SOCK_PATH &quot;/somepath&quot;#define LISTEN_BACKLOG 50#define handle_error(msg) \    do &#123; perror(msg); exit(EXIT_FAILURE); &#125; while (0)int main(int argc, char *argv[])&#123;    int sfd, cfd;    struct sockaddr_un my_addr, peer_addr;    socklen_t peer_addr_size;    sfd = socket(AF_UNIX, SOCK_STREAM, 0);    if (sfd == -1)        handle_error(&quot;socket&quot;);    memset(&amp;my_addr, 0, sizeof(struct sockaddr_un));                        /* Clear structure */    my_addr.sun_family = AF_UNIX;    strncpy(my_addr.sun_path, MY_SOCK_PATH,            sizeof(my_addr.sun_path) - 1);    if (bind(sfd, (struct sockaddr *) &amp;my_addr,            sizeof(struct sockaddr_un)) == -1)        handle_error(&quot;bind&quot;);   if (listen(sfd, LISTEN_BACKLOG) == -1)       handle_error(&quot;listen&quot;);</code></pre><blockquote><p>在用户态我们调用了<code>bind</code>函数，它声明在<code>&lt;sys/socket.h&gt;</code>。</p></blockquote><p>__</p><pre><code class="hljs">/* Give the socket FD the local address ADDR (which is LEN bytes long).  */extern int bind (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len)     __THROW;</code></pre><p>我们之前提到过，用户态进程只需要调用库函数即可，而不用管这个函数是如何实现的。</p><blockquote><p><code>linux</code>中这些具体函数的实现则由<code>glibc</code>统一提供。它定义在<code>glibc-2.23/sysdeps/unix/sysv/linux/bind.c</code></p></blockquote><p>__</p><pre><code class="hljs">int __bind (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len)&#123;#ifdef __ASSUME_BIND_SYSCALL  return INLINE_SYSCALL (bind, 3, fd, addr.__sockaddr__, len);#else  return SOCKETCALL (bind, fd, addr.__sockaddr__, len, 0, 0, 0);#endif&#125;weak_alias (__bind, bind)</code></pre><p>在<code>syscall</code>之前需要先将参数传入寄存器。</p><p>之前，如我们之前分析的一样：使用0x80中断去陷入内核，并将返回值存放到eax寄存器中，通常0表示成功。</p><blockquote><p>syscall的name为<code>__NR_##name</code>，在本例中即为<code>__NR_bind</code>。</p></blockquote><p>其定义在<code>/usr/include/asm/unistd_64.h</code>中。</p><p>__</p><pre><code class="hljs"># define __NR_bind 49#define __NR_listen 50#define __NR_getsockname 51</code></pre><p><strong>这样，用户态和内核态通过系统调用号（49）来确定本次系统调用是哪个功能。</strong></p><h2 id="1-3-Socket系统调用分析"><a href="#1-3-Socket系统调用分析" class="headerlink" title="1 |**3**Socket系统调用分析"></a><strong><em>1</em></strong> |**<em>3</em>**<strong>Socket系统调用分析</strong></h2><blockquote><p>Socket系统调用主要完成socket的创建，必要字段的初始化，关联传输控制块，绑定文件等任务，完成返回socket绑定的文件描述符。</p></blockquote><p>socket的调用关系如下：</p><p>__</p><pre><code class="hljs">/** * sys_socket *   |--&gt;sock_create *   |      |--&gt;__sock_create *   |            |--&gt;inet_create            *   |--&gt;sock_map_fd */</code></pre><h3 id="sock-map-fd"><a href="#sock-map-fd" class="headerlink" title="sock_map_fd"></a>sock_map_fd</h3><p>该函数的主要功能在于：负责分配文件，并实现与socket的绑定。</p><p>__</p><pre><code class="hljs">/* 套接口与文件描述符绑定 */static int sock_map_fd(struct socket *sock, int flags)&#123;    struct file *newfile;    /* 获取未使用的文件描述符 */    int fd = get_unused_fd_flags(flags);    if (unlikely(fd &lt; 0))        return fd;     /* 分配socket文件 */    newfile = sock_alloc_file(sock, flags, NULL);    if (likely(!IS_ERR(newfile))) &#123;        /* fd和文件进行绑定 */        fd_install(fd, newfile);        return fd;    &#125;     /* 释放fd */    put_unused_fd(fd);    return PTR_ERR(newfile);&#125;</code></pre><h3 id="sock-create"><a href="#sock-create" class="headerlink" title="sock_create"></a>sock_create</h3><p>其主要功能为：负责创建<code>socket</code>，并进行必要的初始化工作。</p><p>__</p><pre><code class="hljs">int sock_create(int family, int type, int protocol, struct socket **res)&#123;    return __sock_create(current-&gt;nsproxy-&gt;net_ns, family, type, protocol, res, 0);&#125;</code></pre><p>之后，<code>sock_create</code>调用<code>__socket_create</code>函数来进行必要的检查项，并创建和初始化<code>socket</code>。</p><p>在<code>__socket_create</code>函数中，调用对应协议族的<code>pf-&gt;create</code>函数来创建传输控制块，并且与socket进行关联。</p><p>__</p><pre><code class="hljs">/* 创建socket */int __sock_create(struct net *net, int family, int type, int protocol,             struct socket **res, int kern)&#123;    int err;    struct socket *sock;    const struct net_proto_family *pf;    /*     *      Check protocol is in range     */    /* 检查协议族 */    if (family &lt; 0 || family &gt;= NPROTO)        return -EAFNOSUPPORT;    /* 检查类型 */    if (type &lt; 0 || type &gt;= SOCK_MAX)        return -EINVAL;    /* Compatibility.       This uglymoron is moved from INET layer to here to avoid       deadlock in module load.     */    /* ipv4协议族的packet已经废除，检测到，则替换成packet协议族 */    if (family == PF_INET &amp;&amp; type == SOCK_PACKET) &#123;        pr_info_once(&quot;%s uses obsolete (PF_INET,SOCK_PACKET)\n&quot;,                 current-&gt;comm);        family = PF_PACKET;    &#125;    /* 安全模块检查套接口 */    err = security_socket_create(family, type, protocol, kern);    if (err)        return err;    /*     *    Allocate the socket and allow the family to set things up. if     *    the protocol is 0, the family is instructed to select an appropriate     *    default.     */    /* 分配socket，内部和inode已经绑定 */    sock = sock_alloc();    if (!sock) &#123;        net_warn_ratelimited(&quot;socket: no more sockets\n&quot;);        return -ENFILE;    /* Not exactly a match, but its the                   closest posix thing */    &#125;    /* 设定类型 */    sock-&gt;type = type;#ifdef CONFIG_MODULES    /* Attempt to load a protocol module if the find failed.     *     * 12/09/1996 Marcin: But! this makes REALLY only sense, if the user     * requested real, full-featured networking support upon configuration.     * Otherwise module support will break!     */    if (rcu_access_pointer(net_families[family]) == NULL)        request_module(&quot;net-pf-%d&quot;, family);#endif    rcu_read_lock();    /* 找到协议族 */    pf = rcu_dereference(net_families[family]);    err = -EAFNOSUPPORT;    if (!pf)        goto out_release;    /*     * We will call the -&gt;create function, that possibly is in a loadable     * module, so we have to bump that loadable module refcnt first.     */     /* 增加模块的引用计数 */    if (!try_module_get(pf-&gt;owner))        goto out_release;    /* Now protected by module ref count */    rcu_read_unlock();    /* 调用协议族的创建函数 */    err = pf-&gt;create(net, sock, protocol, kern);    if (err &lt; 0)        goto out_module_put;    /*     * Now to bump the refcnt of the [loadable] module that owns this     * socket at sock_release time we decrement its refcnt.     */    if (!try_module_get(sock-&gt;ops-&gt;owner))        goto out_module_busy;    /*     * Now that we&#39;re done with the -&gt;create function, the [loadable]     * module can have its refcnt decremented     */    module_put(pf-&gt;owner);    err = security_socket_post_create(sock, family, type, protocol, kern);    if (err)        goto out_sock_release;    *res = sock;    return 0;out_module_busy:    err = -EAFNOSUPPORT;out_module_put:    sock-&gt;ops = NULL;    module_put(pf-&gt;owner);out_sock_release:    sock_release(sock);    return err;out_release:    rcu_read_unlock();    goto out_sock_release;&#125;EXPORT_SYMBOL(__sock_create);</code></pre><p>对于<code>PF_INET</code>协议族来讲，上述的<code>pf-&gt;create</code>函数将调用<code>inet_create</code>函数。</p><p>熟悉设备驱动的同学应该都知道这些操作被定义在<code>file_operations</code>结构中。</p><p>__</p><pre><code class="hljs">static const struct net_proto_family inet_family_ops = &#123;    .family = PF_INET,    .create = inet_create,    .owner    = THIS_MODULE,&#125;;</code></pre><p>最后，在<code>inet_create</code>函数中完成创建传输控制块，并且将socket与传输控制块进行关联。至于该函数代码这里不再展开分析。</p><h1 id="2-0-实验代码分析"><a href="#2-0-实验代码分析" class="headerlink" title="2 |**0**实验代码分析"></a><strong><em>2</em></strong> |**<em>0</em>**<strong>实验代码分析</strong></h1><p>在<a href="https://www.cnblogs.com/RichardTAO/p/12021971.html">上一次实验</a>中，我们已经将老师提供的客户端以及服务器端的程序集成到了<code>MenuOS</code>中，可以在<code>qemu</code>虚拟机中使用<code>replyhi</code>和<code>hello</code>两个命令。</p><p>但是对于这两个程序的内部实现还没有深入分析，这里我们通过阅读代码来找出这两个程序在执行时所使用到的<code>Socket API</code>。</p><h2 id="2-1-服务器端"><a href="#2-1-服务器端" class="headerlink" title="2 |**1**服务器端"></a><strong><em>2</em></strong> |**<em>1</em>**<strong>服务器端</strong></h2><blockquote><p>首先，分析一下服务器端的代码。</p><p>在我们使用<code>replyhi</code>命令时，会执行<code>main.c</code>文件中的StartReplyhi函数。</p></blockquote><p>__</p><pre><code class="hljs">MenuConfig( &quot;replyhi&quot;, &quot;Reply hi TCP Service&quot;, StartReplyhi);</code></pre><blockquote><p>继续阅读<code>StartReplyhi</code>函数的代码。</p><p>可以发现，在满足连接条件的判断语句中，程序继续调用了Replyhi函数。</p></blockquote><p>__</p><pre><code class="hljs">int StartReplyhi(int argc, char *argv[])&#123;    int pid;    /* fork another process */    pid = fork();    if (pid &lt; 0)    &#123;        /* error occurred */        fprintf(stderr, &quot;Fork Failed!&quot;);        exit(-1);    &#125;    else if (pid == 0)    &#123;        /* child process */        Replyhi();        printf(&quot;Reply hi TCP Service Started!\n&quot;);    &#125;    else    &#123;        /* parent process */        printf(&quot;Please input hello...\n&quot;);    &#125;&#125;</code></pre><blockquote><p>查看<code>Replyhi</code>函数的实现。</p><p>在函数中总共调用了六个方法，从字面意思来看，不难推测出它们的具体含义分别是：初始化服务、启动服务、接收消息、发送消息、停止服务以及关闭服务。</p><p>这些方法都在头文件<code>syswrapper.h</code>中定义。</p><p>下面将对这些方法逐一展开分析。</p></blockquote><p>__</p><pre><code class="hljs">int Replyhi()&#123;    char szBuf[MAX_BUF_LEN] = &quot;\0&quot;;    char szReplyMsg[MAX_BUF_LEN] = &quot;hi\0&quot;;    InitializeService();    while (1)    &#123;        ServiceStart();        RecvMsg(szBuf);        SendMsg(szReplyMsg);        ServiceStop();    &#125;    ShutdownService();    return 0;&#125;</code></pre><h3 id="InitializeService方法"><a href="#InitializeService方法" class="headerlink" title="InitializeService方法"></a>InitializeService方法</h3><p>__</p><pre><code class="hljs"># define InitializeService()                             \        PrepareSocket(IP_ADDR,PORT);                    \        InitServer();</code></pre><p>可以看到，在头文件中使用宏定义的方式将其具体实现私有化。</p><blockquote><p>根据第一部分的socket创建过程分析，我们可以很自然地理解<code>PrepareSocket</code>函数就是用于创建服务器端socket：在定义了<code>serveraddr</code>中的协议族、端口、IP地址信息后，通过<code>socket</code>这一系统调用完成服务器端socket的创建，并返回文件描述符信息。</p></blockquote><blockquote><p><code>InitServer</code>函数则是调用<code>bind</code>和<code>PrepareSocket</code>函数中得到的文件描述符完成绑定，绑定成功后，服务器进入监听状态，即等待客户端的连接，通过调用<code>listen</code>来实现监听。</p></blockquote><p>__</p><pre><code class="hljs"># define PrepareSocket(addr,port)                        \        int sockfd = -1;                                \        struct sockaddr_in serveraddr;                  \        struct sockaddr_in clientaddr;                  \        socklen_t addr_len = sizeof(struct sockaddr);   \        serveraddr.sin_family = AF_INET;                \        serveraddr.sin_port = htons(port);              \        serveraddr.sin_addr.s_addr = inet_addr(addr);   \        memset(&amp;serveraddr.sin_zero, 0, 8);             \        sockfd = socket(PF_INET,SOCK_STREAM,0);        #define InitServer()                                    \        int ret = bind( sockfd,                         \                        (struct sockaddr *)&amp;serveraddr, \                        sizeof(struct sockaddr));       \        if(ret == -1)                                   \        &#123;                                               \            fprintf(stderr,&quot;Bind Error,%s:%d\n&quot;,        \                            __FILE__,__LINE__);         \            close(sockfd);                              \            return -1;                                  \        &#125;                                               \        listen(sockfd,MAX_CONNECT_QUEUE); </code></pre><p>因此，在初始化服务中我们所使用到的<code>Socket API</code>共有三个，分别为：<strong>socket，bind，listen</strong> 。</p><h3 id="ServiceStart方法"><a href="#ServiceStart方法" class="headerlink" title="ServiceStart方法"></a>ServiceStart方法</h3><blockquote><p>在调用初始化服务方法之后，我们完成了服务器端socket的创建、绑定以及监听。</p><p>因此，在该方法的实现中，我们所实现的是接收客户端所发出的连接请求，通过调用<code>accept</code>来实现，可以看到该函数的参数中<code>clientaddr</code>则标明服务器与哪个客户端进行连接。</p></blockquote><p>__</p><pre><code class="hljs"># define ServiceStart()                                  \        int newfd = accept( sockfd,                     \                    (struct sockaddr *)&amp;clientaddr,     \                    &amp;addr_len);                         \        if(newfd == -1)                                 \        &#123;                                               \            fprintf(stderr,&quot;Accept Error,%s:%d\n&quot;,      \                            __FILE__,__LINE__);         \        &#125;   </code></pre><p>因此，在启动服务中我们所使用到的<code>Socket API</code>只有一个：<strong>accept</strong> 。</p><h3 id="RecvMsg与SendMsg方法"><a href="#RecvMsg与SendMsg方法" class="headerlink" title="RecvMsg与SendMsg方法"></a>RecvMsg与SendMsg方法</h3><blockquote><p>与客户端经历三次握手建立TCP连接之后，就可以与客户端进行消息的发送与接收。</p><p>代码的实现与之前类似，其过程就不再赘述。不过，需要注意的是在这两个方法中，都包含<code>newfd</code>这个参数，此参数是客户端与服务器建立连接时所获得的返回值，也就是说这个值标识了这条TCP连接，确认了消息发送、接收的双方。</p></blockquote><p>__</p><pre><code class="hljs"># define RecvMsg(buf)                                    \       ret = recv(newfd,buf,MAX_BUF_LEN,0);             \       if(ret &gt; 0)                                      \       &#123;                                                \            printf(&quot;recv \&quot;%s\&quot; from %s:%d\n&quot;,          \            buf,                                        \            (char*)inet_ntoa(clientaddr.sin_addr),      \            ntohs(clientaddr.sin_port));                \       &#125;#define SendMsg(buf)                                    \        ret = send(newfd,buf,strlen(buf),0);            \        if(ret &gt; 0)                                     \        &#123;                                               \            printf(&quot;send \&quot;hi\&quot; to %s:%d\n&quot;,            \            (char*)inet_ntoa(clientaddr.sin_addr),      \            ntohs(clientaddr.sin_port));                \        &#125;</code></pre><p>因此，在消息接收与发送中我们所使用到的<code>Socket API</code>共有两个：<strong>recv，send</strong> 。</p><h3 id="ServiceStop与ShutdownService方法"><a href="#ServiceStop与ShutdownService方法" class="headerlink" title="ServiceStop与ShutdownService方法"></a>ServiceStop与ShutdownService方法</h3><blockquote><p>这两个方法都用于终止连接，因此在代码中所调用的API也都是<code>close</code>。</p></blockquote><p>__</p><pre><code class="hljs"># define ShutdownService()                               \        close(sockfd);        #define ServiceStop()                                   \        close(newfd);</code></pre><p>因此，在停止和关闭服务中我们所使用到的<code>Socket API</code>为：<strong>close</strong> 。</p><h2 id="2-2-客户端"><a href="#2-2-客户端" class="headerlink" title="2 |**2**客户端"></a><strong><em>2</em></strong> |**<em>2</em>**<strong>客户端</strong></h2><blockquote><p>同样的，在我们使用<code>hello</code>命令时，程序会调用Hello函数。</p></blockquote><p>__</p><pre><code class="hljs">MenuConfig( &quot;hello&quot;, &quot;Hello TCP Client&quot;, Hello);</code></pre><blockquote><p>在Hello函数中，我们又见到了消息发送和接收这两个方法的“身影”。</p></blockquote><p>__</p><pre><code class="hljs">int Hello(int argc, char *argv[])&#123;    char szBuf[MAX_BUF_LEN] = &quot;\0&quot;;    char szMsg[MAX_BUF_LEN] = &quot;hello\0&quot;;    OpenRemoteService();    SendMsg(szMsg);    RecvMsg(szBuf);    CloseRemoteService();    return 0;&#125;</code></pre><p>其调用的方法内部实现与服务器端类似，这里我们给出结论：</p><p>客户端所使用到的Socket API有：<strong>socket， connect，send，recv，close</strong> 。</p><hr><h1 id="3-0-跟踪socket相关系统调用的内核处理函数"><a href="#3-0-跟踪socket相关系统调用的内核处理函数" class="headerlink" title="3 |**0**跟踪socket相关系统调用的内核处理函数"></a><strong><em>3</em></strong> |**<em>0</em>**<strong>跟踪socket相关系统调用的内核处理函数</strong></h1><h2 id="3-1-系统调用初始化"><a href="#3-1-系统调用初始化" class="headerlink" title="3 |**1**系统调用初始化"></a><strong><em>3</em></strong> |**<em>1</em>**<strong>系统调用初始化</strong></h2><p>系统调用初始化的过程：</p><blockquote><ul><li>在32位系统中：<code>start_kernel -&gt; trap_init -&gt; idt_setup_traps -&gt; 0x80</code></li><li>在64位系统中：<code>start_kernel -&gt; trap_init -&gt; cpu_init -&gt; syscall_init</code></li></ul></blockquote><p>为了验证这个初始化过程是否正确，我们使用上一次实验使用过的<code>gdb</code>进行调试。</p><p>由于我们上次实验构建的是32位的MenuOS系统，因此我们在<code>start_kernel</code>， <code>trap_init</code>以及<br><code>idt_setup_traps</code>这三个函数打上断点来完成验证。</p><blockquote><p>命令</p></blockquote><p>__</p><pre><code class="hljs">sudo qemu -kernel ../linux -5.0.1/arch/x86/boot/bzImage -initrd ../rootfs.img -append  nokaslr -s -S #启动# 新建终端gdb #进入gdb命令行file ../LinuxKernel/linux-5.0.1/vmlinux #在gdb界面中targe remote之前加载符号表target remote:1234 # 建立gdb和gdbserver之间的连接break start_kernel # 设置断点1break trap_init # 设置断点2break idt_setup_traps # 设置断点3</code></pre><p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220313106-160394591.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220313106-160394591.png"></a></p><p>接着，我们可以使用<code>continue</code>命令让<code>qemu</code>虚拟机继续运行起来。</p><p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220327771-703485049.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220327771-703485049.png"></a></p><p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220337160-1475253107.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220337160-1475253107.png"></a></p><p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220353159-565830860.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220353159-565830860.png"></a></p><p>为避免出现断点捕捉顺序与断点设置顺序相关的情况发生，这里我故意将后两个函数的断点设置顺序调换了一下。</p><p>而结果如我们之前分析的一样，我们捕获到了三个断点，并且这三个断点的捕捉顺序正是系统调用初始化过程所经历的顺序。</p><h2 id="3-2-socket相关的系统调用"><a href="#3-2-socket相关的系统调用" class="headerlink" title="3 |**2**socket相关的系统调用"></a><strong><em>3</em></strong> |**<em>2</em>**<strong>socket相关的系统调用</strong></h2><p>通过查阅<a href="https://github.com/mengning/linux/blob/master/arch/x86/entry/syscalls/syscall_32.tbl">32位的系统调用表</a>，我们发现与<code>socket</code>相关的系统调用分为以下两种：</p><blockquote><ul><li>sys_socketcall</li></ul><p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220422911-665150556.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220422911-665150556.png"></a></p><ul><li>socket api对应的单独系统调用</li></ul><p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220442073-678615520.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220442073-678615520.png"></a></p></blockquote><p>通过查阅资料我们发现：</p><p><code>sys_socketcall()</code>是内核中为 socket 设置的<code>总入口 </code>，也就是说，在调用socket其他相关的<code>API</code>时都需要先调用sys_socketcall()。</p><p>而在前一章中的<code>实验代码分析</code>中，我们对于已经集成到<code>MenuOS</code>中<code>replyhi</code>和<code>hello</code>命令所对应的客户端、服务器端程序进行了分析，并且已经得出结论，即这两个命令在执行时所使用到的<code>Socket API</code>。分别为：</p><p>__</p><pre><code class="hljs">服务器端：socket，bind，listen，accept，recv，send，close 客户端：socket，connect，send，recv，close</code></pre><p>理清楚了<code>socket</code>相关的系统调用之后，下面我们同样通过<code>gdb</code>调试的方法来验证我们的分析是否正确。</p><blockquote><p>命令</p></blockquote><p>__</p><pre><code class="hljs">break sys_socketcall # 设置断点continue </code></pre><p>经过调试，我们捕捉到了该断点，并通过<code>list</code>命令找到了<code>sys_socketcall</code>系统调用所对应的内核处理函数<code>SYSCALL_DEFINE2(socketcall, int, call, unsigned long __user *, args)</code>。</p><p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220038758-277367624.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220038758-277367624.png"></a></p><p>那么，下面简要的分析以下这个<a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?h=v5.0.1">内核处理函数</a>。</p><p>__</p><pre><code class="hljs">/* *System call vectors. * *Argument checking cleaned up. Saved 20% in size. *  This function doesn&#39;t need to set the kernel lock because *  it is set by the callees. */SYSCALL_DEFINE2(socketcall, int, call, unsigned long __user *, args)&#123;    unsigned long a[AUDITSC_ARGS];    unsigned long a0, a1;    int err;    unsigned int len;    if (call &lt; 1 || call &gt; SYS_SENDMMSG)        return -EINVAL;    call = array_index_nospec(call, SYS_SENDMMSG + 1);    len = nargs[call];    if (len &gt; sizeof(a))        return -EINVAL;    /* copy_from_user should be SMP safe. */    if (copy_from_user(a, args, len))        return -EFAULT;    err = audit_socketcall(nargs[call] / sizeof(unsigned long), a);    if (err)        return err;    a0 = a[0];    a1 = a[1];    switch (call) &#123;    case SYS_SOCKET:        err = __sys_socket(a0, a1, a[2]);        break;    case SYS_BIND:        err = __sys_bind(a0, (struct sockaddr __user *)a1, a[2]);        break;    case SYS_CONNECT:        err = __sys_connect(a0, (struct sockaddr __user *)a1, a[2]);        break;    case SYS_LISTEN:        err = __sys_listen(a0, a1);        break;    case SYS_ACCEPT:        err = __sys_accept4(a0, (struct sockaddr __user *)a1,                    (int __user *)a[2], 0);        break;    case SYS_GETSOCKNAME:        err =            __sys_getsockname(a0, (struct sockaddr __user *)a1,                      (int __user *)a[2]);        break;    case SYS_GETPEERNAME:        err =            __sys_getpeername(a0, (struct sockaddr __user *)a1,                      (int __user *)a[2]);        break;    case SYS_SOCKETPAIR:        err = __sys_socketpair(a0, a1, a[2], (int __user *)a[3]);        break;    case SYS_SEND:        err = __sys_sendto(a0, (void __user *)a1, a[2], a[3],                   NULL, 0);        break;    case SYS_SENDTO:        err = __sys_sendto(a0, (void __user *)a1, a[2], a[3],                   (struct sockaddr __user *)a[4], a[5]);        break;    case SYS_RECV:        err = __sys_recvfrom(a0, (void __user *)a1, a[2], a[3],                     NULL, NULL);        break;    case SYS_RECVFROM:        err = __sys_recvfrom(a0, (void __user *)a1, a[2], a[3],                     (struct sockaddr __user *)a[4],                     (int __user *)a[5]);        break;    case SYS_SHUTDOWN:        err = __sys_shutdown(a0, a1);        break;    case SYS_SETSOCKOPT:        err = __sys_setsockopt(a0, a1, a[2], (char __user *)a[3],                       a[4]);        break;    case SYS_GETSOCKOPT:        err =            __sys_getsockopt(a0, a1, a[2], (char __user *)a[3],                     (int __user *)a[4]);        break;    case SYS_SENDMSG:        err = __sys_sendmsg(a0, (struct user_msghdr __user *)a1,                    a[2], true);        break;    case SYS_SENDMMSG:        err = __sys_sendmmsg(a0, (struct mmsghdr __user *)a1, a[2],                     a[3], true);        break;    case SYS_RECVMSG:        err = __sys_recvmsg(a0, (struct user_msghdr __user *)a1,                    a[2], true);        break;    case SYS_RECVMMSG:        if (IS_ENABLED(CONFIG_64BIT) || !IS_ENABLED(CONFIG_64BIT_TIME))            err = __sys_recvmmsg(a0, (struct mmsghdr __user *)a1,                         a[2], a[3],                         (struct __kernel_timespec __user *)a[4],                         NULL);        else            err = __sys_recvmmsg(a0, (struct mmsghdr __user *)a1,                         a[2], a[3], NULL,                         (struct old_timespec32 __user *)a[4]);        break;    case SYS_ACCEPT4:        err = __sys_accept4(a0, (struct sockaddr __user *)a1,                    (int __user *)a[2], a[3]);        break;    default:        err = -EINVAL;        break;    &#125;    return err;&#125;</code></pre><p>其核心代码在于<code>switch...case</code>中，可以看到在函数执行时它会按照参数<code>call</code>的值去调用不同的内核处理程序，如<code>__sys_socket</code>，<code>__sys_bind</code>等。至于call的值，<code>SYS_SOCKET</code>对应值为1，下面的<code>case</code>条件所对应的call值则以此递增。</p><p>这样，我们就很容易理解为什么说<code>sys_socketcall()</code>是内核中为 socket 设置的总入口。</p><p>接着，我们将<code>Socket API</code>所对应的各个内核处理函数打上断点。</p><blockquote><p>命令</p></blockquote><p>__</p><pre><code class="hljs">break  __sys_socketbreak  __sys_bindbreak  __sys_listenbreak  __sys_connectbreak  __sys_accept4break  __sys_recvmsgbreak  __sys_sendmsgbreak  __sys_recvfrombreak  __sys_sendtobreak  __sys_shutdown</code></pre><p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220104626-1320211378.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220104626-1320211378.png"></a></p><p>然后，使用<code>continue</code>命令来康康我们是否能够捕获到这些断点。</p><p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220110932633-776686874.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220110932633-776686874.png"></a></p><p>可以发现在初始化的过程中我们共捕获到6次断点，分别是三次<code>sys_socketcall()</code>和三次<code>__sys_socket</code>。</p><p>都是三次，有这么巧合吗？另外，我们可以发现捕获顺序的规律总是先<code>sys_socketcall()</code>后捕获<code>__sys_socket</code>。</p><p>其实，我们之前已经提到过：<code>sys_socketcall()</code>是内核为socket设置的总入口，我们需要先进入到这个总入口，然后根据<code>call</code>值来进入不同的分支去调用对应的内核处理函数，这也就是为什么我们捕获断点时有上面的规律。</p><p>通过<code>qemu</code>虚拟机中的提示信息，该初始化的过程其实主要完成的是对网卡的配置与启动。</p><hr><p>继续。</p><p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220112841339-722490150.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220112841339-722490150.png"></a></p><p>在又一次捕获到<code>sys_socketcall()</code>且此时call值为1时，我们发现gdb调试界面停止，</p><p>这时，按照之前服务器端代码分析的思路，我们需要在<code>MenuOS</code>系统输入<code>replyhi</code>命令来创建socket。</p><p>在输入命令之后，gdb调试继续。并且再次捕获断点时可以看到我们捕获到了<code>__sys_socket</code>，即调用了该内核处理函数完成了我们服务器端socket的创建。</p><hr><p>继续捕获断点：</p><p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220119325-1227384307.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220119325-1227384307.png"></a></p><p>与之前分析的一样，需要先进入<code>sys_socketcall()</code>这个总入口；</p><p>然后通过我们之前在源代码分析中看到的<strong>switch结构</strong> ，根据<code>call=2</code>的信息，可以知道它进入了<code>case SYS_BIND</code>这个分支；</p><p>继续使用<code>continue</code>命令可以看到，我们捕获到了<code>__sys_bind</code>这个断点，即确实按照分支的语句调用了所对应的内核处理函数，在这里，我们所调用的是socket的绑定函数。</p><p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220135410-1102664032.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220135410-1102664032.png"></a></p><hr><p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220113820375-991637153.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220113820375-991637153.png"></a></p><p>这一次，我们捕获到<code>__sys_accept4</code>，按照服务器端代码的思路，我们知道此时服务器准备好接收客户端的请求。</p><p>在<code>qemu</code>虚拟机中输入<code>hello</code>命令，来创建客户端socket。</p><p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220114004900-39215539.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220114004900-39215539.png"></a></p><p>没错，在经历<code>sys_socketcall()</code>总入口之后我们再一次使用<code>__sys_socket</code>完成了客户端socket的创建。</p><hr><p>同理，我们捕获到<code>__sys_connect</code>断点，该内核处理函数完成了客户端与服务器端的连接。</p><p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220114310702-177767569.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220114310702-177767569.png"></a></p><p>接着，我们会捕捉到收发消息相关的一系列系统调用，而与此同时，在<code>qemu</code>虚拟机中，我们也能够看到服务器与客户端交互的情况。</p><p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220114430988-1788804597.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220114430988-1788804597.png"></a></p><p>之后捕获断点我们又会<strong>重新创建</strong> 一个客户端socket。</p><p>其原因在于<code>Replyhi</code>的实现中使用到了while循环，即服务器端不会主动关闭服务，而是不断等待新的客户端连接，然后与其进行交互。实现的是一个简单的多线程功能。</p><p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220115302859-2131351471.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220115302859-2131351471.png"></a></p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>network</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>主机路由转发qemu虚拟机网络.md</title>
    <link href="/2024/05/09/mdstorage/domain/network/%E4%B8%BB%E6%9C%BA%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91qemu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/05/09/mdstorage/domain/network/%E4%B8%BB%E6%9C%BA%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91qemu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>将 机器 B 的 虚拟机网络 192.168.122.1&#x2F;24 路由转发出去提供给 机器 A 进行访问</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>保证 B 机器可以访问 A ，wlp2s0 网卡状态 UP</li><li>B 配置 sysctl 参数</li><li>B 配置 路由伪装</li><li>A 配置 路由规则</li></ul><h2 id="B-配置-sysctl-参数"><a href="#B-配置-sysctl-参数" class="headerlink" title="B 配置 sysctl 参数"></a>B 配置 sysctl 参数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">sudo</span> sysctl -w net.ipv4.icmp_echo_ignore_all=0<br><span class="hljs-built_in">sudo</span> sysctl -w net.ipv4.icmp_echo_ignore_broadcasts=0<br><br></code></pre></td></tr></table></figure><h2 id="B-配置路由伪装"><a href="#B-配置路由伪装" class="headerlink" title="B 配置路由伪装"></a>B 配置路由伪装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># virbr0 是 qemu 的虚拟网络的网桥</span><br><span class="hljs-built_in">sudo</span> iptables -t nat -A POSTROUTING -o virbr0 -j MASQUERADE<br><span class="hljs-comment"># 允许所有流量，通过清除 LIBVIRT_FWI 链中的规则：</span><br><span class="hljs-built_in">sudo</span> iptables -F LIBVIRT_FWI<br><span class="hljs-built_in">sudo</span> iptables -A LIBVIRT_FWI -j ACCEPT<br><br><br></code></pre></td></tr></table></figure><h2 id="A-配置路由规则"><a href="#A-配置路由规则" class="headerlink" title="A 配置路由规则"></a>A 配置路由规则</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># enp6s0 目标网卡   169.254.98.174 是 B 的 ip 地址</span><br><span class="hljs-built_in">sudo</span> ip route add 192.168.122.0/24 dev enp6s0 via 169.254.98.174  proto static<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>conda.md</title>
    <link href="/2024/05/08/mdstorage/domain/python/conda/"/>
    <url>/2024/05/08/mdstorage/domain/python/conda/</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="第-1-步-–-准备-Anaconda-安装程序"><a href="#第-1-步-–-准备-Anaconda-安装程序" class="headerlink" title="第 1 步 – 准备 Anaconda 安装程序"></a>第 1 步 – 准备 Anaconda 安装程序</h2><p>使用 cd 命令，进入<code>/tmp</code>目录：</p><pre><code class="hljs">cd /tmp </code></pre><p>接下来，使用 curl 命令从官网下载 Anaconda 安装程序脚本。访问 Anaconda<br>安装程序脚本<a href="https://repo.anaconda.com/archive/">下载页面</a>，以检查最新版本。执行命令下载脚本：</p><pre><code class="hljs"># 示例curl --output anaconda.sh https://repo.anaconda.com/archive/Anaconda3-2021.05-Linux-x86_64.sh </code></pre><p>要检查脚本 SHA-256 校验和：</p><pre><code class="hljs">sha256sum anconda.sh Output：25e3ebae8905450ddac0f5c93f89c467 anaconda.sh</code></pre><p>检查哈希码是否与下载页面上显示的代码匹配。</p><h2 id="第-2-步-–-在-Debian-11-上安装-Anaconda"><a href="#第-2-步-–-在-Debian-11-上安装-Anaconda" class="headerlink" title="第 2 步 – 在 Debian 11 上安装 Anaconda"></a>第 2 步 – 在 Debian 11 上安装 Anaconda</h2><p>执行 Anaconda 安装程序脚本，如下所示：</p><pre><code class="hljs">bash anaconda.sh </code></pre><p>按照向导说明完成 Anaconda 安装过程。</p><p>Anaconda 已成功安装在 Debian 上。使用以下命令激活 Anaconda 环境：</p><pre><code class="hljs">source ~/.bashrc </code></pre><p>为了验证安装情况，我们打开 conda 列表。</p><pre><code class="hljs">conda list Output:# packages in environment at /home/tecadmin/anaconda3:## Name                    Version                   Build  Channel_ipyw_jlab_nb_ext_conf    0.1.0                    py38_0_libgcc_mutex             0.1                        mainalabaster                 0.7.12             pyhd3eb1b0_0anaconda                  2021.05                  py38_0anaconda-client           1.7.2                    py38_0anaconda-navigator        2.0.3                    py38_0anaconda-project          0.9.1              pyhd3eb1b0_1anyio                     2.2.0            py38h06a4308_1appdirs                   1.4.4                      py_0</code></pre><h2 id="如何更新-Anaconda"><a href="#如何更新-Anaconda" class="headerlink" title="如何更新 Anaconda"></a>如何更新 Anaconda</h2><p>可以使用 conda 二进制文件更新 Anaconda 软件包。要升级系统上的 Anaconda，请执行下面的命令：</p><pre><code class="hljs">conda update --all </code></pre>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>conda</tag>
      
      <tag>Anaconda</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有线连接两台ubuntu.md</title>
    <link href="/2024/05/07/mdstorage/domain/linux/%E6%9C%89%E7%BA%BF%E8%BF%9E%E6%8E%A5%E4%B8%A4%E5%8F%B0ubuntu/"/>
    <url>/2024/05/07/mdstorage/domain/linux/%E6%9C%89%E7%BA%BF%E8%BF%9E%E6%8E%A5%E4%B8%A4%E5%8F%B0ubuntu/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>通过网线连接两台物理机使相连</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>网线连接</li><li>设置机器A</li><li>设置机器B</li></ul><h2 id="机器设置"><a href="#机器设置" class="headerlink" title="机器设置"></a>机器设置</h2><ul><li>设置 -&gt; 网络 -&gt; 选择网卡 mac -&gt; ipv4 选择手动，不需要设置网关</li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络扫描工具.md</title>
    <link href="/2024/05/07/mdstorage/domain/network/%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/"/>
    <url>/2024/05/07/mdstorage/domain/network/%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="fping"><a href="#fping" class="headerlink" title="fping"></a>fping</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># apt install fping</span><br><span class="hljs-comment"># 扫描局域网 192.168.1.1/24 存活的主机</span><br>fping -a -g 192.168.1.1/24<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
      <tag>scan</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>editorconfig.md</title>
    <link href="/2024/05/07/mdstorage/domain/%E6%96%87%E6%A1%A3/editorconfig/"/>
    <url>/2024/05/07/mdstorage/domain/%E6%96%87%E6%A1%A3/editorconfig/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>编辑器配置，放入到 项目根目录中</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://editorconfig.org/">editor config 官网</a></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Ini"><span class="hljs-comment">; https://editorconfig.org/</span><br><br><span class="hljs-attr">root</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-section">[*]</span><br><span class="hljs-attr">insert_final_newline</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">charset</span> = utf-<span class="hljs-number">8</span><br><span class="hljs-attr">trim_trailing_whitespace</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">indent_style</span> = space<br><span class="hljs-attr">indent_size</span> = <span class="hljs-number">2</span><br><br><span class="hljs-section">[&#123;Makefile,go.mod,go.sum,*.go,.gitmodules&#125;]</span><br><span class="hljs-attr">indent_style</span> = tab<br><span class="hljs-attr">indent_size</span> = <span class="hljs-number">4</span><br><br><span class="hljs-section">[*.md]</span><br><span class="hljs-attr">indent_size</span> = <span class="hljs-number">4</span><br><span class="hljs-attr">trim_trailing_whitespace</span> = <span class="hljs-literal">false</span><br><br><span class="hljs-attr">eclint_indent_style</span> = unset<br><br><span class="hljs-section">[Dockerfile]</span><br><span class="hljs-attr">indent_size</span> = <span class="hljs-number">4</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>editor config</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html2markdown.md</title>
    <link href="/2024/05/07/mdstorage/domain/%E6%96%87%E6%A1%A3/html2markdown/"/>
    <url>/2024/05/07/mdstorage/domain/%E6%96%87%E6%A1%A3/html2markdown/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://github.com/Alir3z4/html2text">html to markdown</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>见 github</p><h2 id="使用（从获取-html）"><a href="#使用（从获取-html）" class="headerlink" title="使用（从获取 html）"></a>使用（从获取 html）</h2><ul><li>浏览器打开目标 html</li><li>C-s 保存 html 到本地</li><li>执行 <code>html2text xxx.html utf-8</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mkfifo.md</title>
    <link href="/2024/05/06/mdstorage/domain/shell/mkfifo/"/>
    <url>/2024/05/06/mdstorage/domain/shell/mkfifo/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>mkfifo 是 shell 命令，用于创建有名管道，进程间通信的一种形式</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>shell</tag>
      
      <tag>IPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>short_video.md</title>
    <link href="/2024/05/06/mdstorage/project/short_media/short_video/"/>
    <url>/2024/05/06/mdstorage/project/short_media/short_video/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="技术领域"><a href="#技术领域" class="headerlink" title="技术领域"></a>技术领域</h2><ul><li>蓝河操作系统布道师</li><li>鸿蒙操作系统布道师</li><li></li></ul><h2 id="每日"><a href="#每日" class="headerlink" title="每日"></a>每日</h2><ul><li>开放原子开源基金会</li></ul><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul><li><a href="https://developers.vivo.com/product/blueOpen/ability/doc/reference/quickstart/introduction">蓝河os开发者教程</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>project</category>
      
      <category>short_media</category>
      
    </categories>
    
    
    <tags>
      
      <tag>media</tag>
      
      <tag>short_video</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang.md</title>
    <link href="/2024/05/06/mdstorage/domain/%E6%8B%9B%E8%81%98/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/golang/"/>
    <url>/2024/05/06/mdstorage/domain/%E6%8B%9B%E8%81%98/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/golang/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://xiaolincoding.com/">小林</a><br><a href="https://www.zhihu.com/people/xu-xian-sheng-80-10">小徐</a></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>招聘</category>
      
      <category>面试资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>goimport.md</title>
    <link href="/2024/04/30/mdstorage/domain/golang/goimport/"/>
    <url>/2024/04/30/mdstorage/domain/golang/goimport/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>goimports</code> 是 Go 语言的一个工具，用于自动修正（添加缺失的包和删除不必要的包）并格式化 Go 指定文件的代码。它类似于 <code>gofmt</code>，但 <code>goimports</code> 还额外处理了导入的部分。</p><h3 id="安装-goimports"><a href="#安装-goimports" class="headerlink" title="安装 goimports"></a>安装 goimports</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go install golang.org/x/tools/cmd/goimports@latest<br></code></pre></td></tr></table></figure><p>确保 <code>GOPATH/bin</code> 或 <code>GOBIN</code> 在系统的 <code>PATH</code> 中，这样就可以从任何地方运行 <code>goimports</code>。</p><h3 id="使用-goimports-格式化目录下的-Go-文件"><a href="#使用-goimports-格式化目录下的-Go-文件" class="headerlink" title="使用 goimports 格式化目录下的 Go 文件"></a>使用 goimports 格式化目录下的 Go 文件</h3><p><code>goimports</code> 命令可以应用于单个文件或整个目录。要格式化一个目录下的所有 Go 文件（包括子目录），运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">goimports -w .<br></code></pre></td></tr></table></figure><p>这里的命令参数说明：</p><ul><li><code>-w</code>：写模式，告诉 <code>goimports</code> 直接修改文件，而不是打印到标准输出。</li><li><code>.</code>：表示当前目录。可替换成任何指定的目录路径。</li></ul><p>只想看到哪些文件会被修改，而不实际写入更改，可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">goimports -d .<br></code></pre></td></tr></table></figure><p>这里的 <code>-d</code> 参数让 <code>goimports</code> 打印出将会进行的修改的差异。</p><h3 id="自动化-goimports"><a href="#自动化-goimports" class="headerlink" title="自动化 goimports"></a>自动化 goimports</h3><p>使用 Goland ，可以在设置中启用这个特性或通过扩展实现它。</p><h4 id="在-Goland-中"><a href="#在-Goland-中" class="headerlink" title="在 Goland 中"></a>在 Goland 中</h4><ol><li>确保安装了 File Watchers 语言扩展。</li><li>打开设置（File Watchers Settings）。</li><li>添加 <code>goimports</code>。</li></ol><p>[Media]<br>comment &#x3D; Media<br>public &#x3D; Yes<br>path &#x3D; &#x2F;opt&#x2F;share<br>browseable &#x3D; Yes<br>read only &#x3D; No<br>guest ok &#x3D; Yes<br>create mask &#x3D; 0777<br>directory mask &#x3D; 0777<br>force user &#x3D; root</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>format</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>samba.md</title>
    <link href="/2024/04/30/mdstorage/domain/linux/samba/"/>
    <url>/2024/04/30/mdstorage/domain/linux/samba/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="ubuntu-smb-服务"><a href="#ubuntu-smb-服务" class="headerlink" title="ubuntu smb 服务"></a>ubuntu smb 服务</h3><p>语法：<a href="https://www.cnblogs.com/fatt/p/5856892.html">https://www.cnblogs.com/fatt/p/5856892.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">apt install samba samba-common<br><span class="hljs-built_in">chmod</span> 777 /opt/xiaoy-share<br>nano /etc/samba/smb.conf<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Text"># 示例 共享 /opt/xiaoy-share 允许匿名访问 , 加到底部即可<br>[share]<br>path = /opt/xiaoy-share<br>public = yes<br>read only = no<br>guest ok = Yes<br>create mask = 0644<br>force create mode = 0644<br>directory mask = 0755<br>force directory mode = 0755<br>available = yes<br></code></pre></td></tr></table></figure><h3 id="ubuntu-debian-smb-客户端"><a href="#ubuntu-debian-smb-客户端" class="headerlink" title="ubuntu debian smb 客户端"></a>ubuntu debian smb 客户端</h3><p><strong>smb:&#x2F;&#x2F;${DOMAIN}:${PORT}</strong> <em>port 可以默认不填</em></p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>samba</tag>
      
      <tag>debian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>synergy.md</title>
    <link href="/2024/04/30/mdstorage/domain/linux/synergy/"/>
    <url>/2024/04/30/mdstorage/domain/linux/synergy/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://github.com/DEAKSoftware/Synergy-Binaries/releases">synergy 鼠标跨屏</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><a href="https://www.cnblogs.com/qikeyishu/p/10288079.html">使用</a></p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker network.md</title>
    <link href="/2024/04/30/mdstorage/domain/%E8%99%9A%E6%8B%9F%E5%8C%96/docker%20network/"/>
    <url>/2024/04/30/mdstorage/domain/%E8%99%9A%E6%8B%9F%E5%8C%96/docker%20network/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="macvlan"><a href="#macvlan" class="headerlink" title="macvlan"></a>macvlan</h3><p>docker network create 命令用于在 Docker 中创建新的网络，支持不同的网络驱动模式。macvlan 是其中一种网络驱动，它允许你将容器配置为看起来就像是物理网络上的一个独立设备，每个容器都有自己的 MAC 地址。使用 macvlan 网络驱动可以使容器直接与外部网络交互，而不是通过 Docker 主机的端口映射。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Bash">docker network create -d macvlan \<br>--subnet=172.16.0.0/23 \<br>--gateway=172.16.1.253 \<br>-o parent=wlp1s0 \<br>docker_mac<br><br><span class="hljs-comment">#docker network create -d macvlan \</span><br><span class="hljs-comment">#    --subnet=[子网(建议与虚拟机在同一网段 例172.16.89.0/23)] \</span><br><span class="hljs-comment">#    --gateway=[网关ip 例172.16.88.254] \</span><br><span class="hljs-comment">#    -o parent=[父网卡名(例如ens60)] \</span><br><span class="hljs-comment">#    [网络名(例如mac1)]</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>grpc.md</title>
    <link href="/2024/04/30/mdstorage/domain/network/%E5%8D%8F%E8%AE%AE/grpc/"/>
    <url>/2024/04/30/mdstorage/domain/network/%E5%8D%8F%E8%AE%AE/grpc/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://www.cnblogs.com/voipman/p/15352001.html">Golang grpc实现原理和 proxy 实现原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/614986579">grpc-go 服务端使用介绍及源码分析</a></p><h2 id="protoc"><a href="#protoc" class="headerlink" title="protoc"></a>protoc</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 下载并安装</span><br><span class="hljs-comment"># https://link.zhihu.com/?target=https%3A//github.com/google/protobuf/releases</span><br><br>go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28<br>protoc-gen-go --version<br>go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2<br>protoc-gen-go-grpc --version<br></code></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="编写-proto-文件"><a href="#编写-proto-文件" class="headerlink" title="编写 proto 文件"></a>编写 proto 文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs protobuffer">syntax = &quot;proto3&quot;; // 固定语法前缀<br><br><br>option go_package = &quot;.&quot;;  // 指定生成的Go代码在你项目中的导入路径<br><br><br>package pb; // 包名<br><br><br>// 定义服务<br>service HelloService &#123;<br>    // SayHello 方法<br>    rpc SayHello (HelloReq) returns (HelloResp) &#123;&#125;<br>&#125;<br><br><br>// 请求消息<br>message HelloReq &#123;<br>    string name = 1;<br>&#125;<br><br><br>// 响应消息<br>message HelloResp &#123;<br>    string reply = 1<br>&#125;<br><br></code></pre></td></tr></table></figure><p>该文件以 .proto 作为后缀，扮演着 grpc 客户端与服务端通信交互的接口定义语言（DDL）的角色.</p><p>protobuf 的细节内容与底层原理，后续我们单开章节再作介绍，此处能理解其基本用法即可.</p><p>上述内容中，抛开前置的固定语法标识外，分为三个核心部分：</p><p>定义业务处理服务 HelloService，声明业务方法的名称（SayHello）以及出入参协议（HelloReq&#x2F;HelloResp）<br>遵循 protobuf 的风格，分别声明出入参的类型定义：HelloReq 和 HelloResp，其中分别包含了字符串类型的成员字段 name 和 reply</p><h4 id="生成-pb-go-文件"><a href="#生成-pb-go-文件" class="headerlink" title="生成 pb.go 文件"></a>生成 pb.go 文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">protoc --go_out=. --go-grpc_out=. pb/hello.proto<br><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">package</span> proto<br><br><br><span class="hljs-keyword">import</span> (<br>    protoreflect <span class="hljs-string">&quot;google.golang.org/protobuf/reflect/protoreflect&quot;</span><br>    protoimpl <span class="hljs-string">&quot;google.golang.org/protobuf/runtime/protoimpl&quot;</span><br>    reflect <span class="hljs-string">&quot;reflect&quot;</span><br>    sync <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 请求消息</span><br><span class="hljs-keyword">type</span> HelloReq <span class="hljs-keyword">struct</span> &#123;<br>    state         protoimpl.MessageState<br>    sizeCache     protoimpl.SizeCache<br>    unknownFields protoimpl.UnknownFields<br>    Name <span class="hljs-type">string</span> <span class="hljs-string">`protobuf:&quot;bytes,1,opt,name=name,proto3&quot; json:&quot;name,omitempty&quot;`</span><br>    Age  <span class="hljs-type">int32</span>  <span class="hljs-string">`protobuf:&quot;varint,2,opt,name=age,proto3&quot; json:&quot;age,omitempty&quot;`</span><br>&#125;<br><br><br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 响应消息</span><br><span class="hljs-keyword">type</span> HelloResp <span class="hljs-keyword">struct</span> &#123;<br>    state         protoimpl.MessageState<br>    sizeCache     protoimpl.SizeCache<br>    unknownFields protoimpl.UnknownFields<br>    <br>    Reply <span class="hljs-type">string</span> <span class="hljs-string">`protobuf:&quot;bytes,1,opt,name=reply,proto3&quot; json:&quot;reply,omitempty&quot;`</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述代码展示了 pb.go 文件中的内容，核心是基于 .proto 定义的出入参协议，生成对应的 golang 类定义代码.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> proto<br><br><br><span class="hljs-keyword">import</span> (<br>    context <span class="hljs-string">&quot;context&quot;</span><br>    grpc <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>    codes <span class="hljs-string">&quot;google.golang.org/grpc/codes&quot;</span><br>    status <span class="hljs-string">&quot;google.golang.org/grpc/status&quot;</span><br>)<br><br><br><span class="hljs-comment">// 基于 .proto 文件生成的客户端框架代码</span><br><span class="hljs-comment">// 客户端 interface</span><br><span class="hljs-keyword">type</span> HelloServiceClient <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-comment">// SayHello 方法</span><br>    SayHello(ctx context.Context, in *HelloReq, opts ...grpc.CallOption) (*HelloResp, <span class="hljs-type">error</span>)<br>&#125;<br><br><br><span class="hljs-comment">// 客户端实现类</span><br><span class="hljs-keyword">type</span> helloServiceClient <span class="hljs-keyword">struct</span> &#123;<br>    cc grpc.ClientConnInterface<br>&#125;<br><br><br><span class="hljs-comment">// 客户端构造器函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewHelloServiceClient</span><span class="hljs-params">(cc grpc.ClientConnInterface)</span></span> HelloServiceClient &#123;<br>    <span class="hljs-keyword">return</span> &amp;helloServiceClient&#123;cc&#125;<br>&#125;<br><br><br><span class="hljs-comment">// 客户端请求入口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *helloServiceClient)</span></span> SayHello(ctx context.Context, in *HelloReq, opts ...grpc.CallOption) (*HelloResp, <span class="hljs-type">error</span>) &#123;<br>    out := <span class="hljs-built_in">new</span>(HelloResp)<br>    err := c.cc.Invoke(ctx, <span class="hljs-string">&quot;/pb.HelloService/SayHello&quot;</span>, in, out, opts...)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> out, <span class="hljs-literal">nil</span><br>&#125;<br><br><br><span class="hljs-comment">// 服务端注册入口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterHelloServiceServer</span><span class="hljs-params">(s grpc.ServiceRegistrar, srv HelloServiceServer)</span></span> &#123;<br>    s.RegisterService(&amp;HelloService_ServiceDesc, srv)<br>&#125;<br><br><br><span class="hljs-comment">// 服务端业务方法框架代码</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> _<span class="hljs-title">HelloService_SayHello_Handler</span><span class="hljs-params">(srv <span class="hljs-keyword">interface</span>&#123;&#125;, ctx context.Context, dec <span class="hljs-keyword">func</span>(<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span>, interceptor grpc.UnaryServerInterceptor) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>    in := <span class="hljs-built_in">new</span>(HelloReq)<br>    <span class="hljs-keyword">if</span> err := dec(in); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">if</span> interceptor == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> srv.(HelloServiceServer).SayHello(ctx, in)<br>    &#125;<br>    info := &amp;grpc.UnaryServerInfo&#123;<br>        Server:     srv,<br>        FullMethod: <span class="hljs-string">&quot;/pb.HelloService/SayHello&quot;</span>,<br>    &#125;<br>    handler := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>        <span class="hljs-keyword">return</span> srv.(HelloServiceServer).SayHello(ctx, req.(*HelloReq))<br>    &#125;<br>    <span class="hljs-keyword">return</span> interceptor(ctx, in, info, handler)<br>&#125;<br><br><br><span class="hljs-comment">// 服务端业务处理服务描述符</span><br><span class="hljs-keyword">var</span> HelloService_ServiceDesc = grpc.ServiceDesc&#123;<br>    ServiceName: <span class="hljs-string">&quot;pb.HelloService&quot;</span>,<br>    HandlerType: (*HelloServiceServer)(<span class="hljs-literal">nil</span>),<br>    Methods: []grpc.MethodDesc&#123;<br>        &#123;<br>            MethodName: <span class="hljs-string">&quot;SayHello&quot;</span>,<br>            Handler:    _HelloService_SayHello_Handler,<br>        &#125;,<br>    &#125;,<br>    Streams:  []grpc.StreamDesc&#123;&#125;,<br>    Metadata: <span class="hljs-string">&quot;proto/hello.proto&quot;</span>,<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述代码展示了 grpc.pb.go 文件中的内容，核心内容包括：</p><ul><li>基于 .proto 文件生成了客户端的桩代码，后续作为用户使用 grpc 客户端模块的 sdk 入口.</li><li>基于 .proto 文件生成了服务端的服务注册桩代码，后续作为用户使用 grpc 服务端模块的 sdk 入口</li><li>基于 .proto 文件生成了业务处理服务（pb.HelloService）的描述符，每个描述符内部会建立基于方法名（SayHello）到具体处理函数（_<br>HelloService_SayHello_Handler）的映射关系</li></ul><h4 id="服务端启动"><a href="#服务端启动" class="headerlink" title="服务端启动"></a>服务端启动</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br><br><br>    <span class="hljs-string">&quot;github.com/grpc_demo/proto&quot;</span><br><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>)<br><br><br><span class="hljs-comment">// 业务处理服务</span><br><span class="hljs-keyword">type</span> HelloService <span class="hljs-keyword">struct</span> &#123;<br>    proto.UnimplementedHelloServiceServer<br>&#125;<br><br><br><span class="hljs-comment">// 实现具体的业务方法逻辑</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *HelloService)</span></span> SayHello(ctx context.Context, req *proto.HelloReq) (*proto.HelloResp, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> &amp;proto.HelloResp&#123;<br>        Reply: fmt.Sprintf(<span class="hljs-string">&quot;hello name: %s&quot;</span>, req.Name),<br>    &#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建 tcp 端口监听器</span><br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8093&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br><br>    <span class="hljs-comment">// 创建 grpc server</span><br>    server := grpc.NewServer()<br>    <span class="hljs-comment">// 将自定义的业务处理服务注册到 grpc server 中</span><br>    proto.RegisterHelloServiceServer(server, &amp;HelloService&#123;&#125;)<br>    <span class="hljs-comment">// 运行 grpc server</span><br>    <span class="hljs-keyword">if</span> err := server.Serve(listener); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>预声明业务处理服务 HelloService，实现好桩文件中定义的业务处理方法 SayHello</li><li>调用 net.Listen 方法，创建 tcp 端口监听器</li><li>调用 grpc.NewServer 方法，创建一个 grpc server 对象</li><li>调用桩文件中预生成好的注册方法 proto.RegisterHelloServiceServer，将 HelloService 注册到 grpc server 对象当中</li><li>运行 server.Serve 方法，监听指定的端口，真正启动 grpc server</li></ul><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br><br><br>    <span class="hljs-string">&quot;github.com/grpc_demo/proto&quot;</span><br><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span><br>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 通过指定地址，建立与 grpc 服务端的连接</span><br>    conn, err := grpc.Dial(<span class="hljs-string">&quot;localhost:8093&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 调用 .grpc.pb.go 文件中预生成好的客户端构造器方法，创建 grpc 客户端</span><br>    client := proto.NewHelloServiceClient(conn)<br>  <br>    <span class="hljs-comment">// 调用 .grpc.pb.go 文件预生成好的客户端请求方法，使用 .pb.go 文件中预生成好的请求参数作为入参，向 grpc 服务端发起请求</span><br>    resp, err := client.SayHello(context.Background(), &amp;proto.HelloReq&#123;<br>        Name: <span class="hljs-string">&quot;xiaoxuxiansheng&quot;</span>,<br>    &#125;)<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 打印取得的响应参数</span><br>    fmt.Printf(<span class="hljs-string">&quot;resp: %+v&quot;</span>, resp)<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>调用 grpc.Dial 方法，与指定地址的 grpc 服务端建立连接</li><li>调用桩文件中的方法 proto.NewHelloServiceClient，创建 pb 文件预声明好的 grpc 客户端对象</li><li>调用 client.SayHello 方法，发送 grpc 请求，并处理响应结果</li></ul><h2 id="3-服务端"><a href="#3-服务端" class="headerlink" title="3 服务端"></a>3 服务端</h2><h2 id="3-1-核心数据结构"><a href="#3-1-核心数据结构" class="headerlink" title="3.1 核心数据结构"></a>3.1 核心数据结构</h2><p><img src="https://pic2.zhimg.com/v2-10c9b2d942978a3a687453e08cbf841d_b.jpg" alt="核心数据结构"></p><p>在 grpc 服务端领域，自上而下有着三个层次分明的结构：server-&gt;service-&gt;method</p><ul><li>最高级别是 server，是对整个 grpc 服务端的抽象</li><li>一个 server 下可以注册挂载多个业务服务 service</li><li>一个 service 下存在多个业务处理方法 method</li></ul><p><strong>（1）server</strong></p><pre><code class="hljs">type Server struct &#123;    // 配置项    opts serverOptions    // 互斥锁保证并发安全    mu  sync.Mutex     // tcp 端口监听器池    lis map[net.Listener]bool    // ...    // 连接池    conns    map[string]map[transport.ServerTransport]bool    serve    bool    cv       *sync.Cond              // 业务服务映射管理      services map[string]*serviceInfo // service name -&gt; service info    // ...    serveWG            sync.WaitGroup     // ...&#125;</code></pre><p>Server 类是对 grpc 服务端的代码实现，其中通过一个名为 services 的 map，记录了由服务名到具体业务服务模块的映射关系.</p><p><strong>（2）serviceInfo</strong></p><pre><code class="hljs">type serviceInfo struct &#123;    // 业务服务类    serviceImpl interface&#123;    // 业务方法映射管理      methods     map[string]*MethodDesc    // ...&#125;</code></pre><p>serviceInfo 是某一个具体的业务服务模块，其中通过一个名为 methods 的 map 记录了由方法名到具体方法的映射关系.</p><p><strong>（3）MethodDesc</strong></p><pre><code class="hljs">type MethodDesc struct &#123;    MethodName string    Handler    methodHandler&#125;</code></pre><p>MethodDesc 是对方法的封装，其中的字段 Handler 是真正的业务处理方法.</p><p><strong>（4）methodHandler</strong></p><pre><code class="hljs">type methodHandler func(srv interface&#123;&#125;, ctx context.Context, dec func(interface&#123;&#125;) error, interceptor UnaryServerInterceptor) (interface&#123;&#125;, error)</code></pre><p>methodsHandler 是业务处理方法的类型，其中几个关键入参的含义分别是：</p><ul><li>srv：业务处理方法从属的业务服务模块</li><li>dec：进行入参 req 反序列化的闭包函数</li><li>interceptor：业务处理方法外部包裹的拦截器方法</li></ul><h2 id="3-2-创建-server"><a href="#3-2-创建-server" class="headerlink" title="3.2 创建 server"></a>3.2 创建 server</h2><pre><code class="hljs">func NewServer(opt ...ServerOption) *Server &#123;    opts := defaultServerOptions    for _, o := range extraServerOptions &#123;        o.apply(&amp;opts)    &#125;    for _, o := range opt &#123;        o.apply(&amp;opts)    &#125;    s := &amp;Server&#123;        lis:      make(map[net.Listener]bool),        opts:     opts,        conns:    make(map[string]map[transport.ServerTransport]bool),        services: make(map[string]*serviceInfo),        quit:     grpcsync.NewEvent(),        done:     grpcsync.NewEvent(),        czData:   new(channelzData),    &#125;    chainUnaryServerInterceptors(s)    //...    s.cv = sync.NewCond(&amp;s.mu)    // ...       return s&#125;</code></pre><p>grpc.NewServer 方法中会创建 server 实例，并调用 chainUnaryServerInterceptors 方法，将一系列拦截器<br>interceptor 成链，并注入到 ServerOption 当中. 有关拦截器的内容，放在本文第 4 章再作展开.</p><pre><code class="hljs">func chainUnaryServerInterceptors(s *Server) &#123;    interceptors := s.opts.chainUnaryInts    if s.opts.unaryInt != nil &#123;        interceptors = append([]UnaryServerInterceptor&#123;s.opts.unaryInt&#125;, s.opts.chainUnaryInts...)    &#125;    var chainedInt UnaryServerInterceptor    if len(interceptors) == 0 &#123;        chainedInt = nil    &#125; else if len(interceptors) == 1 &#123;        chainedInt = interceptors[0]    &#125; else &#123;        chainedInt = chainUnaryInterceptors(interceptors)    &#125;        s.opts.unaryInt = chainedInt&#125;</code></pre><h2 id="3-3-注册-service"><a href="#3-3-注册-service" class="headerlink" title="3.3 注册 service"></a>3.3 注册 service</h2><p><img src="https://pic2.zhimg.com/v2-4539ddc98cad05e360cdace864b47309_b.png" alt="service 注册"></p><p>创建好 grpc server 后，接下来通过使用桩代码中预生成好的 RegisterXXXServer 方法，业务处理服务 service 模块注入到<br>server 当中.</p><pre><code class="hljs">func RegisterHelloServiceServer(s grpc.ServiceRegistrar, srv HelloServiceServer) &#123;    s.RegisterService(&amp;HelloService_ServiceDesc, srv)&#125;func (s *Server) RegisterService(sd *ServiceDesc, ss interface&#123;&#125;) &#123;    // ...    s.register(sd, ss)&#125;func (s *Server) register(sd *ServiceDesc, ss interface&#123;&#125;) &#123;    s.mu.Lock()    defer s.mu.Unlock()    // ...    info := &amp;serviceInfo&#123;        serviceImpl: ss,        methods:     make(map[string]*MethodDesc),        streams:     make(map[string]*StreamDesc),        mdata:       sd.Metadata,    &#125;    for i := range sd.Methods &#123;        d := &amp;sd.Methods[i]        info.methods[d.MethodName] = d    &#125;    // ...    s.services[sd.ServiceName] = info&#125;</code></pre><p>注册过程会经历 RegisterHelloServiceServer-&gt;Server.RegisterService -&gt; Server.register<br>的调用链路，把 service 的所有方法注册到 serviceInfo 的 methods map 当中，然后将 service 封装到<br>serviceInfo 实例中，注册到 server 的 services map 当中</p><h2 id="3-4-运行-server"><a href="#3-4-运行-server" class="headerlink" title="3.4 运行 server"></a>3.4 运行 server</h2><pre><code class="hljs">func (s *Server) Serve(lis net.Listener) error &#123;    // ...    var tempDelay time.Duration // how long to sleep on accept failure    for &#123;        rawConn, err := lis.Accept()        if err != nil &#123;            // ...        &#125;        // ...        s.serveWG.Add(1)        go func() &#123;            s.handleRawConn(lis.Addr().String(), rawConn)            s.serveWG.Done()        &#125;()    &#125;&#125;</code></pre><p><img src="https://pic3.zhimg.com/v2-3f4fbcb65c1607ae613bcba33b515df2_b.jpg" alt="grpc 运行关系"></p><p>grpc server 运行的流程，核心是基于 for 循环实现的主动轮询模型，每轮会通过调用 net.Listener.Accept 方法，基于 IO<br>多路复用 epoll 方式，阻塞等待 grpc 请求的到达.</p><p>每当有新的连接到达后，服务端会开启一个 goroutine，调用对应的 Server.handleRawConn 方法对请求进行处理.</p><h2 id="3-5-处理请求"><a href="#3-5-处理请求" class="headerlink" title="3.5 处理请求"></a>3.5 处理请求</h2><pre><code class="hljs">func (s *Server) handleRawConn(lisAddr string, rawConn net.Conn) &#123;    // ...    st := s.newHTTP2Transport(rawConn)    // ...    go func() &#123;        s.serveStreams(st)        s.removeConn(lisAddr, st)    &#125;()&#125;</code></pre><p><img src="https://pic4.zhimg.com/v2-e1e467b062fa6d4999ea15f874684817_b.jpg" alt="处理请求关系图"></p><p>在 Server.handleRawConn 方法中，会基于原始的 net.Conn 封装生成一个 HTTP2Transport，然后开启<br>goroutine 调用 Server.serveStream 方法处理请求.</p><pre><code class="hljs">func (s *Server) serveStreams(st transport.ServerTransport) &#123;    var wg sync.WaitGroup    var roundRobinCounter uint32    st.HandleStreams(func(stream *transport.Stream) &#123;        go func() &#123;            defer wg.Done()            s.handleStream(st, stream, s.traceInfo(st, stream))        &#125;()    &#125;, func(ctx context.Context, method string) context.Context &#123;        // ...    &#125;)    wg.Wait()&#125;func (s *Server) handleStream(t transport.ServerTransport, stream *transport.Stream, trInfo *traceInfo) &#123;    sm := stream.Method()    // ...    pos := strings.LastIndex(sm, &quot;/&quot;)        service := sm[:pos]    method := sm[pos+1:]    srv, knownService := s.services[service]    if knownService &#123;        if md, ok := srv.methods[method]; ok &#123;            s.processUnaryRPC(t, stream, srv, md, trInfo)            return        &#125;        if sd, ok := srv.streams[method]; ok &#123;            s.processStreamingRPC(t, stream, srv, sd, trInfo)            return        &#125;    &#125;    // ...&#125;func (s *Server) processUnaryRPC(t transport.ServerTransport, stream *transport.Stream, info *serviceInfo, md *MethodDesc, trInfo *traceInfo) (err error) &#123;    // ...    d, err := recvAndDecompress(&amp;parser&#123;r: stream&#125;, stream, dc, s.opts.maxReceiveMessageSize, payInfo, decomp)    // ...    df := func(v interface&#123;&#125;) error &#123;        if err := s.getCodec(stream.ContentSubtype()).Unmarshal(d, v); err != nil &#123;           // ...        &#125;        // ...    &#125;    ctx := NewContextWithServerTransportStream(stream.Context(), stream)    reply, appErr := md.Handler(info.serviceImpl, ctx, df, s.opts.unaryInt)    // ...    if err := s.sendResponse(t, stream, reply, cp, opts, comp); err != nil &#123;        // ...    &#125;    // ...&#125;</code></pre><p><img src="https://pic3.zhimg.com/v2-c220c0e7ae720c5cc0d9cb3027125742_b.jpg" alt="stream 调用链"></p><p>接下来一连建立了 Server.serveStreams -&gt; http2Server.HandleStreams -&gt;<br>http2Server.operateHeaders -&gt; http2Server.handleStream -&gt;<br>Server.processUnaryRPC 的方法调用链：</p><ul><li><p>在 Server.handleStream 方法中，会拆解来自客户端的请求路径 ${service}&#x2F;${method}，通过”&#x2F;“ 前段得到 service 名称，通过 “&#x2F;“<br>后端得到 method 名称，并分别映射到对应的业务服务和业务方法</p></li><li><p>在 Server.processUnaryRPC 方法中，会通过 recvAndDecompress 读取到请求内容字节流，然后通过闭包函数 df 封装好反序列请求参数的逻辑，继而调用<br>md.Handler 方法处理请求，最终通过 Server.sendResponse 方法将响应结果进行返回</p><p>  func _HelloService_SayHello_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {<br>  in :&#x3D; new(HelloReq)<br>  if err :&#x3D; dec(in); err !&#x3D; nil {<br>      return nil, err<br>  }<br>  if interceptor &#x3D;&#x3D; nil {<br>      return srv.(HelloServiceServer).SayHello(ctx, in)<br>  }<br>  info :&#x3D; &amp;grpc.UnaryServerInfo{<br>      Server:     srv,<br>      FullMethod: “&#x2F;pb.HelloService&#x2F;SayHello”,<br>  }<br>  handler :&#x3D; func(ctx context.Context, req interface{}) (interface{}, error) {<br>      return srv.(HelloServiceServer).SayHello(ctx, req.(*HelloReq))<br>  }<br>  return interceptor(ctx, in, info, handler)<br>  }</p></li></ul><p>以本文介绍的 helloService 为例，客户端调用 SayHello 方法后，服务端对应的 md.Handler 正是 .proto 文件生成的位于<br>.grpc.pb.go 文件中的桩方法 _HelloService_SayHello_Handler.</p><p>在该桩方法内部中，包含的执行步骤如下：</p><ul><li>调用闭包函数 dec，将请求内容反序列化到请求入参 in 当中</li><li>将业务处理方法 HelloServiceServer.SayHello 闭包封装到一个 UnaryHandler 当中</li><li>调用 intercetor 方法，分别执行拦截器和 handler 的处理逻辑</li></ul><h2 id="4-拦截器"><a href="#4-拦截器" class="headerlink" title="4 拦截器"></a>4 拦截器</h2><p>有关 grpc 中拦截器 interceptor 部分的内容理解起来比较费脑，我们单开一章来展开聊聊.</p><h2 id="4-1-原理介绍"><a href="#4-1-原理介绍" class="headerlink" title="4.1 原理介绍"></a>4.1 原理介绍</h2><p>拦截器的作用，是在执行核心业务方法的前后，创造出一个统一的切片，来执行所有业务方法锁共有的通用逻辑.<br>此外，我们还能够通过这部分通用逻辑的执行结果，来判断是否需要熔断当前的执行链路，以起到所谓的”拦截“效果.</p><p>有关 grpc 拦截器的内容，其实和 gin 框架中的 handlersChain 是异曲同工的. 在我之前分享的文章 ”解析 Gin 框架底层原理“ 的第<br>5 章内容中有作详细介绍，大家不妨引用对比，以此来触类旁通，加深理解.</p><p>下面我们看看 grpc 中对于一个拦截器函数的具体定义：</p><pre><code class="hljs">type UnaryServerInterceptor func(ctx context.Context, req interface&#123;&#125;, info *UnaryServerInfo, handler UnaryHandler) (resp interface&#123;&#125;, err error)</code></pre><p>其中几个入参的含义分别为：</p><ul><li>req：业务处理方法的请求参数</li><li>info：当前所属的业务服务 service</li><li>handler：真正的业务处理方法</li></ul><p>因此一个拦截器函数的使用模式应该是：</p><pre><code class="hljs">var myInterceptor1 = func(ctx context.Context, req interface&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface&#123;&#125;, err error) &#123;    // 前处理校验    if err := preLogicCheck();err != nil&#123;       // 前处理校验不通过，则拦截，不调用业务方法直接返回       return nil,err     &#125;         // 前处理校验通过，正常调用业务方法     resp, err = handle(ctx,req)     if err != nil&#123;         return nil,err      &#125;           // 后置处理校验      if err := postLogicCheck();err != nil&#123;         // 后置处理校验不通过，则拦截结果，包装错误返回         return nil,err       &#125;            // 正常返回结果      return resp,nil &#125;</code></pre><h2 id="4-2-拦截器链"><a href="#4-2-拦截器链" class="headerlink" title="4.2 拦截器链"></a>4.2 拦截器链</h2><p><img src="https://pic1.zhimg.com/v2-3cf5229939d702ea9ecd39d915c60730_b.jpg" alt="拦截器链"></p><pre><code class="hljs">func chainUnaryInterceptors(interceptors []UnaryServerInterceptor) UnaryServerInterceptor &#123;    return func(ctx context.Context, req interface&#123;&#125;, info *UnaryServerInfo, handler UnaryHandler) (interface&#123;&#125;, error) &#123;        return interceptors[0](ctx, req, info, getChainUnaryHandler(interceptors, 0, info, handler))    &#125;&#125;func getChainUnaryHandler(interceptors []UnaryServerInterceptor, curr int, info *UnaryServerInfo, finalHandler UnaryHandler) UnaryHandler &#123;    if curr == len(interceptors)-1 &#123;        return finalHandler    &#125;    return func(ctx context.Context, req interface&#123;&#125;) (interface&#123;&#125;, error) &#123;        return interceptors[curr+1](ctx, req, info, getChainUnaryHandler(interceptors, curr+1, info, finalHandler))    &#125;&#125;</code></pre><p>首先，chainUnaryInterceptors 方法会将一系列拦截器 interceptor 成链，并返回首枚interceptor 供<br>ServerOption 接收设置.</p><p>其中，拦截器成链的关键在于 getChainUnaryHandler 方法中，其中会闭包调用拦截器数组的首枚拦截器函数，接下来依次用下一枚拦截器对业务方法<br>handler 进行包裹，封装成一个新的 ”handler“ 供当前拦截器使用.</p><p><img src="https://pic1.zhimg.com/v2-71a5d1eadee67d7a730eda67e24182a4_b.jpg" alt="拦截器链关系"></p><h2 id="4-3-操作实践"><a href="#4-3-操作实践" class="headerlink" title="4.3 操作实践"></a>4.3 操作实践</h2><p>下面展示一下 grpc 拦截器链的实操例子.</p><ul><li><p>依次声明拦截器1 myInterceptor1 和 拦截器2 myInterceptor2，会在调用业务方法 handler 前后分别打印一行内容</p></li><li><p>在创建 grpc server 时，将两个拦截器基于 option 注入</p></li><li><p>通过客户端请求服务端，通过输出日志观察拦截器运行效果</p><p>  var myInterceptor1 &#x3D; func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) {<br>  fmt.Printf(“interceptor1 preprocess, req: %+v\n”, req)<br>  resp, err &#x3D; handler(ctx, req)<br>  fmt.Printf(“interceptor1 postprocess, req: %+v\n”, resp)<br>  return<br>  }</p><p>  var myInterceptor2 &#x3D; func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) {<br>  fmt.Printf(“interceptor2 preprocess, req: %+v\n”, req)<br>  resp, err &#x3D; handler(ctx, req)<br>  fmt.Printf(“interceptor2 postprocess, resp: %+v\n”, resp)<br>  return<br>  }</p><p>  func (s *Server) SayHello(ctx context.Context, req *proto.HelloReq) (*proto.HelloResp, error) {<br>  fmt.Println(“core handle logic……”)<br>  return &amp;proto.HelloResp{<br>      Reply: fmt.Sprintf(“hello name: %s”, req.Name),<br>  }, nil<br>  }</p><p>  func main() {<br>  listener, err :&#x3D; net.Listen(“tcp”, “:8093”)<br>  if err !&#x3D; nil {<br>      panic(err)<br>  }<br><br><br>  server :&#x3D; grpc.NewServer(grpc.ChainUnaryInterceptor(myInterceptor1, myInterceptor2))<br>  proto.RegisterHelloServiceServer(server, &amp;Server{})<br><br><br>  if err :&#x3D; server.Serve(listener); err !&#x3D; nil {<br>      panic(err)<br>  }<br>  }</p></li></ul><p><img src="https://pic1.zhimg.com/v2-82ded9b086505bf0455e62c4368d7700_b.jpg" alt="拦截器输出"></p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>network</category>
      
      <category>协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>grpc</tag>
      
      <tag>rpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gopackage.md</title>
    <link href="/2024/04/29/mdstorage/domain/golang/gopackage/"/>
    <url>/2024/04/29/mdstorage/domain/golang/gopackage/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>存放 golang 的 package 使用技巧</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="errgroup"><a href="#errgroup" class="headerlink" title="errgroup"></a>errgroup</h3><p>提供多个协程间同步机制，一个协程出错，其他协程可以被同步到这个错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;golang.org/x/sync/errgroup&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    g, ctx := errgroup.WithContext(context.Background())<br><br>    g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Start executing task1&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;)<br><br>    g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Start executing task2&quot;</span>)<br>        <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;error happened in task2&quot;</span>)<br>    &#125;)<br><br>    g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>            fmt.Println(<span class="hljs-string">&quot;task3 canceled&quot;</span>)<br>            <span class="hljs-keyword">return</span> ctx.Err()<br>        <span class="hljs-keyword">default</span>:<br>            fmt.Println(<span class="hljs-string">&quot;Start executing task3&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>    &#125;)<br><br>    <span class="hljs-keyword">if</span> err := g.Wait(); err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Error happened: &quot;</span>, err)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Start executing task1</span><br><span class="hljs-comment">//Start executing task2</span><br><span class="hljs-comment">//Start executing task3</span><br><span class="hljs-comment">//task3 canceled</span><br><span class="hljs-comment">//Error happened:  error happened in task2</span><br></code></pre></td></tr></table></figure><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my.md</title>
    <link href="/2024/04/25/mdstorage/my/"/>
    <url>/2024/04/25/mdstorage/my/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="Linux-配置"><a href="#Linux-配置" class="headerlink" title="Linux 配置"></a>Linux 配置</h2><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><h4 id="edge-安装"><a href="#edge-安装" class="headerlink" title="edge 安装"></a>edge 安装</h4><h4 id="firefox-安装"><a href="#firefox-安装" class="headerlink" title="firefox 安装"></a>firefox 安装</h4><h4 id="clash-安装"><a href="#clash-安装" class="headerlink" title="clash 安装"></a>clash 安装</h4><h4 id="dida-安装"><a href="#dida-安装" class="headerlink" title="dida 安装"></a>dida 安装</h4><h4 id="listen1-安装"><a href="#listen1-安装" class="headerlink" title="listen1 安装"></a>listen1 安装</h4><h4 id="snipaste-安装"><a href="#snipaste-安装" class="headerlink" title="snipaste 安装"></a>snipaste 安装</h4><h4 id="virt-manager-安装"><a href="#virt-manager-安装" class="headerlink" title="virt-manager 安装"></a>virt-manager 安装</h4><h4 id="fcitx5-安装"><a href="#fcitx5-安装" class="headerlink" title="fcitx5 安装"></a>fcitx5 安装</h4><h3 id="桌面美化"><a href="#桌面美化" class="headerlink" title="桌面美化"></a>桌面美化</h3><h3 id="定时脚本"><a href="#定时脚本" class="headerlink" title="定时脚本"></a>定时脚本</h3><h4 id="定时提交"><a href="#定时提交" class="headerlink" title="定时提交"></a>定时提交</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Text">0 2 * * * /opt/mystorage/github/dairy/script/commit_cron.sh<br></code></pre></td></tr></table></figure><h2 id="快捷键配置"><a href="#快捷键配置" class="headerlink" title="快捷键配置"></a>快捷键配置</h2><h3 id="Jetbrains-keymap"><a href="#Jetbrains-keymap" class="headerlink" title="Jetbrains keymap"></a>Jetbrains keymap</h3><h4 id="keymap"><a href="#keymap" class="headerlink" title="keymap"></a>keymap</h4><ul><li>emacs </li><li>previous project window  : C-q</li><li>back                     : C-M-,</li><li>forward                  : C-M-.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>my</tag>
      
      <tag>me</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gnome桌面美化.md</title>
    <link href="/2024/04/25/mdstorage/domain/linux/gnome%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/"/>
    <url>/2024/04/25/mdstorage/domain/linux/gnome%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="任务栏美化"><a href="#任务栏美化" class="headerlink" title="任务栏美化"></a>任务栏美化</h2><p><a href="https://extensions.gnome.org/extension/307/dash-to-dock/">dash to dock</a><br>注意要选择 gnome 版本，不然存在不兼容情况</p><p>搜索 扩展 应用，里面将 Dash to Dock 进行设置即可</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bash</span><br><span class="hljs-keyword"></span><br>sudo apt update<br>sudo apt <span class="hljs-keyword">install </span>gnome-<span class="hljs-keyword">shell-extension-prefs</span><br><span class="hljs-keyword"></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>gnome</tag>
      
      <tag>Ubuntu</tag>
      
      <tag>Debian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python</title>
    <link href="/2024/04/25/mdstorage/domain/python/python%E5%AE%89%E8%A3%85/"/>
    <url>/2024/04/25/mdstorage/domain/python/python%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>python3 Linux 安装</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>python3 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><br><span class="hljs-comment">#! /bin/bash</span><br><span class="hljs-comment"># debian安装python3</span><br><br><span class="hljs-comment"># openssl-devel libffi-devel gcc 如果不安装，将会导致后面出问题；其他的没试过</span><br><span class="hljs-built_in">sudo</span> apt-get install aptitude<br><span class="hljs-built_in">sudo</span> aptitude -y install gcc make zlib1g-dev libffi-dev libssl-dev<br><br><span class="hljs-keyword">if</span> [ ! -d <span class="hljs-string">&quot;/opt/software&quot;</span> ]<br>  <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">mkdir</span> -p /opt/software<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">cd</span> /opt/software<br><br>version=3.12.3<br>short_version=3.12<br><br><span class="hljs-comment">#wget https://www.python.org/ftp/python/$&#123;version&#125;/Python-$&#123;version&#125;.tar.xz</span><br>wget https://mirrors.aliyun.com/python-release/source/Python-<span class="hljs-variable">$&#123;version&#125;</span>.tar.xz<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;解压 ...&quot;</span><br>xz -d Python-<span class="hljs-variable">$&#123;version&#125;</span>.tar.xz<br>tar -xf Python-<span class="hljs-variable">$&#123;version&#125;</span>.tar<br><span class="hljs-built_in">cd</span> Python-<span class="hljs-variable">$&#123;version&#125;</span><br><br><span class="hljs-comment"># 配置 ssl，不然pip install会出问题</span><br><span class="hljs-built_in">sudo</span> ./configure --prefix=/usr/local/python3 --with-ssl --enable-optimizations<br><br><span class="hljs-comment"># make altinstall将不会让python3替代原本的python2，不会使yum出问题</span><br><span class="hljs-built_in">sudo</span> make &amp;&amp; make altinstall<br><span class="hljs-built_in">ln</span> -s /usr/local/python3/bin/python<span class="hljs-variable">$&#123;short_version&#125;</span> /usr/bin/python3<br><span class="hljs-built_in">ln</span> -s /usr/local/python3/bin/pip<span class="hljs-variable">$&#123;short_version&#125;</span> /usr/bin/pip3<br><br><br></code></pre></td></tr></table></figure><p>virtualenvwrapper 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-meta">#! /bin/bash</span><br><br><span class="hljs-comment"># 安装python3 的虚拟环境 virtualenvwrapper</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;install virtualenv tool ....&#x27;</span><br>pip3 install virtualenv -i https://pypi.tuna.tsinghua.edu.cn/simple<br>pip3 install virtualenvwrapper -i https://pypi.tuna.tsinghua.edu.cn/simple<br><br>VM_HOME=~/py_vm<br><br><span class="hljs-built_in">mkdir</span> <span class="hljs-variable">$&#123;VM_HOME&#125;</span><br><br><span class="hljs-comment"># 添加wrapper的配置</span><br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3\nexport WORKON_HOME=<span class="hljs-variable">$&#123;VM_HOME&#125;</span>\nexport VIRTUALENVWRAPPER_VIRTUALENV=~/.local/bin/virtualenv\nsource ~/.local/bin/virtualenvwrapper.sh&quot;</span> &gt;&gt; ~/.bashrc<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>pip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>delve.md</title>
    <link href="/2024/04/24/mdstorage/domain/golang/delve/"/>
    <url>/2024/04/24/mdstorage/domain/golang/delve/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Go 的调试工具</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">go install github.com/go-delve/delve/cmd/dlv@latest<br></code></pre></td></tr></table></figure><h2 id="Goland-配合本地调试（本地-Ubuntu）"><a href="#Goland-配合本地调试（本地-Ubuntu）" class="headerlink" title="Goland 配合本地调试（本地 Ubuntu）"></a>Goland 配合本地调试（本地 Ubuntu）</h2><p>本地执行 <code>dlv debug --headless --listen=:2345 --api-version=2 --accept-multiclient $main_path</code></p><p>Goland Debug -&gt; Go remote </p><h2 id="Goland-配合远程调试"><a href="#Goland-配合远程调试" class="headerlink" title="Goland 配合远程调试"></a>Goland 配合远程调试</h2><p>dlv –headless –listen&#x3D;:2345 –api-version&#x3D;2 –log attach ${PID}  </p><p>开启 Goland 远程 debug，要填入远程机器地址</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>delve</tag>
      
      <tag>dlv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose.md</title>
    <link href="/2024/04/22/mdstorage/domain/%E8%99%9A%E6%8B%9F%E5%8C%96/docker-compose/"/>
    <url>/2024/04/22/mdstorage/domain/%E8%99%9A%E6%8B%9F%E5%8C%96/docker-compose/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">version=v2.26.1<br><span class="hljs-built_in">sudo</span> curl -L <span class="hljs-string">&quot;https://github.com/docker/compose/releases/download/<span class="hljs-variable">$&#123;version&#125;</span>/docker-compose-<span class="hljs-subst">$(uname -s)</span>-<span class="hljs-subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chmod</span> +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>docker-compose</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>installer.md</title>
    <link href="/2024/04/22/mdstorage/project/sr/%E7%BB%84%E4%BB%B6/installer/"/>
    <url>/2024/04/22/mdstorage/project/sr/%E7%BB%84%E4%BB%B6/installer/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="容器测试"><a href="#容器测试" class="headerlink" title="容器测试"></a>容器测试</h3><h4 id="容器测试1"><a href="#容器测试1" class="headerlink" title="容器测试1"></a>容器测试1</h4><p>容器编译运行 installer-manager</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># mysql 依赖</span><br>docker run --name mysql  -e MYSQL_DATABASE=manager -e MYSQL_ROOT_PASSWORD=123.com/456 -p 127.0.0.1:3306:3306 -d mysql:5.7<br><br>docker build -t installer .<br><br>docker run --net=host -e SC_IP=127.0.0.1 -d -p 8098:8098 --name installer installer<br><span class="hljs-comment"># docker run --net=host -e SC_IP=172.18.0.3 -d -p 8098:8098 --name installer installer</span><br></code></pre></td></tr></table></figure><h4 id="容器测试2"><a href="#容器测试2" class="headerlink" title="容器测试2"></a>容器测试2</h4><p>准备 se 机器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -f <span class="hljs-built_in">test</span>/se/Dockerfile -t se .<br><br>docker run -d -p 22222:22222 --privileged --name se -v /sys/fs/cgroup:/sys/fs/cgroup:ro  -v /run/dbus/system_bus_socket:/run/dbus/system_bus_socket:ro -v /run/dbus:/run/dbus  --cap-add SYS_ADMIN se &amp;&amp; docker <span class="hljs-built_in">exec</span> se /scripts/startup.sh<br></code></pre></td></tr></table></figure><h4 id="容器测试3"><a href="#容器测试3" class="headerlink" title="容器测试3"></a>容器测试3</h4><p>docker compose 将 mysql installer-manager se 都启动，使 installer-manager 对执行测试用例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t installer . &amp;&amp; docker-compose -f <span class="hljs-built_in">test</span>/e2e/base.yml up -d<br><br><span class="hljs-comment"># 停止 docker-compose  -f test/e2e/base.yml down</span><br></code></pre></td></tr></table></figure><h4 id="容器测试4"><a href="#容器测试4" class="headerlink" title="容器测试4"></a>容器测试4</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> sccore<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;crypto/tls&quot;</span><br><span class="hljs-string">&quot;crypto/x509&quot;</span><br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;google.golang.org/grpc/credentials&quot;</span><br><br><span class="hljs-string">&quot;git.ouryun.cn/base/go-kit/pkg/ca&quot;</span><br>mdv1 <span class="hljs-string">&quot;git.ouryun.cn/base/proto-store/pkg/api/common/metadata/v1&quot;</span><br><span class="hljs-string">&quot;git.ouryun.cn/base/proto-store/pkg/client&quot;</span><br>proto_common <span class="hljs-string">&quot;git.ouryun.cn/base/proto-store/pkg/common&quot;</span><br><span class="hljs-string">&quot;git.ouryun.cn/base/proto-store/pkg/interfaces&quot;</span><br><span class="hljs-string">&quot;git.ouryun.cn/base/proto-store/pkg/options&quot;</span><br><span class="hljs-string">&quot;git.ouryun.cn/base/proto-store/pkg/proto_store&quot;</span><br><span class="hljs-string">&quot;git.ouryun.cn/base/proto-store/pkg/types&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>managerClientReconnectTimeout = time.Second * <span class="hljs-number">3</span><br>scCoreAddress                 = <span class="hljs-string">&quot;sc.srhino.svc.local&quot;</span><br>scCorePort                    = <span class="hljs-number">20111</span><br>)<br><span class="hljs-keyword">const</span> (<br>ExecCommand = <span class="hljs-string">&quot;/v1/agent/cmd&quot;</span><br>UploadFile  = <span class="hljs-string">&quot;/v1/agent/upload&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>managerClientInstance *managerClient<br>mgntClientMu          = sync.Mutex&#123;&#125;<br>)<br><br><span class="hljs-keyword">type</span> ExitError <span class="hljs-keyword">struct</span> &#123;<br>code <span class="hljs-type">int</span><br><br><span class="hljs-comment">// Stderr holds a subset of the standard error output from the</span><br><span class="hljs-comment">// Cmd.Output method if standard error was not otherwise being</span><br><span class="hljs-comment">// collected.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// If the error output is long, Stderr may contain only a prefix</span><br><span class="hljs-comment">// and suffix of the output, with the middle replaced with</span><br><span class="hljs-comment">// text about the number of omitted bytes.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Stderr is provided for debugging, for inclusion in error messages.</span><br><span class="hljs-comment">// Users with other needs should redirect Cmd.Stderr as needed.</span><br>Stderr []<span class="hljs-type">byte</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *ExitError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;exit with status %d, err info: %s&quot;</span>, e.code, e.Stderr)<br>&#125;<br><br><span class="hljs-keyword">type</span> RPCError <span class="hljs-keyword">struct</span> &#123;<br>statusCode proto_common.StatusCode<br>err        <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *RPCError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;rpc error %v, status:%v&quot;</span>, e.err.Error(), e.statusCode)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *RPCError)</span></span> Unwrap() <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> e.err<br>&#125;<br><br><span class="hljs-keyword">type</span> managerClient <span class="hljs-keyword">struct</span> &#123;<br>interfaces.CoreClient<br>&#125;<br><br><span class="hljs-keyword">type</span> engineClient <span class="hljs-keyword">struct</span> &#123;<br>mu          sync.RWMutex<br>cli         *managerClient<br>config      *EngineClientConfig<br>nodeClients <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*NodeClient<br>&#125;<br><br><span class="hljs-keyword">type</span> NodeClient <span class="hljs-keyword">struct</span> &#123;<br>engineCli *engineClient<br>nodeId    <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> EngineClientConfig <span class="hljs-keyword">struct</span> &#123;<br>SN <span class="hljs-type">string</span><br><span class="hljs-comment">// zero is no timeout</span><br>Timeout time.Duration<br>&#125;<br><br><span class="hljs-keyword">type</span> CmdRequest <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span>   <span class="hljs-string">`json:&quot;name&quot;`</span><br>Args []<span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;args&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> CmdResponse <span class="hljs-keyword">struct</span> &#123;<br>ExitCode <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;exitCode&quot;`</span><br>Stdout   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;stdout&quot;`</span><br>Stderr   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;stderr&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *NodeClient)</span></span> callExecCommand(name <span class="hljs-type">string</span>, args ...<span class="hljs-type">string</span>) (*CmdResponse, <span class="hljs-type">error</span>) &#123;<br>reqBody := &amp;CmdRequest&#123;<br>Name: name,<br>Args: args,<br>&#125;<br><br>code, bodyBytes, err := c.Post(ExecCommand, reqBody)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>rpcerr := &amp;RPCError&#123;<br>err: err,<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, rpcerr<br>&#125;<br><br><span class="hljs-keyword">if</span> code == proto_common.StatusServiceUnavailable &#123;<br>rpcerr := &amp;RPCError&#123;<br>statusCode: code,<br>err:        proto_common.ErrNotFoundClient,<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, rpcerr<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> code != proto_common.StatusOK &#123;<br>rpcerr := &amp;RPCError&#123;<br>statusCode: code,<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, rpcerr<br>&#125;<br><br>resp := &amp;CmdResponse&#123;&#125;<br><span class="hljs-keyword">if</span> err := json.Unmarshal(bodyBytes, resp); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> resp, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *NodeClient)</span></span> Output(name <span class="hljs-type">string</span>, args ...<span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>resp, err := c.callExecCommand(name, args...)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">if</span> resp.ExitCode != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, &amp;ExitError&#123;code: resp.ExitCode, Stderr: []<span class="hljs-type">byte</span>(resp.Stderr)&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> []<span class="hljs-type">byte</span>(resp.Stdout), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *NodeClient)</span></span> CombinedOutput(name <span class="hljs-type">string</span>, args ...<span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>resp, err := c.callExecCommand(name, args...)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">if</span> resp.ExitCode != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, &amp;ExitError&#123;code: resp.ExitCode, Stderr: []<span class="hljs-type">byte</span>(resp.Stderr)&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> []<span class="hljs-type">byte</span>(resp.Stdout + resp.Stderr), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *NodeClient)</span></span> Upload(local io.Reader, remotePath <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 构造请求</span><br>protoCtx := proto_store.NewRequestContext()<br>dst := &amp;mdv1.Metadata_Info&#123;<br>Engine:    &amp;mdv1.Engine&#123;SerialNumber: c.engineCli.config.SN&#125;,<br>Component: types.COMPONENT_TAG_WEBSERVER,<br>Node:      &amp;mdv1.Node&#123;Id: c.nodeId&#125;,<br>&#125;<br><br>req := protoCtx.SetUrl(UploadFile).SetDst(dst)<br>req.SetParams(<span class="hljs-string">&quot;path&quot;</span>, remotePath)<br>req.SetFileReader(local)<br>req.SetMethod(mdv1.Method_POST.String())<br>resp, err := c.engineCli.cli.FileStream(req)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>rpcerr := &amp;RPCError&#123;<br>err: err,<br>&#125;<br><span class="hljs-keyword">return</span> rpcerr<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Response().Body.Close()<br><br>code := resp.Response().StatusCode<br><span class="hljs-keyword">if</span> code == proto_common.StatusServiceUnavailable &#123;<br>rpcerr := &amp;RPCError&#123;<br>statusCode: code,<br>err:        proto_common.ErrNotFoundClient,<br>&#125;<br><span class="hljs-keyword">return</span> rpcerr<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> code != proto_common.StatusOK &#123;<br>rpcerr := &amp;RPCError&#123;<br>statusCode: code,<br>&#125;<br><span class="hljs-keyword">return</span> rpcerr<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *NodeClient)</span></span> Close() <span class="hljs-type">error</span> &#123;<br>_ = c.engineCli.nodeClose(c.nodeId)<br>c.engineCli = <span class="hljs-literal">nil</span><br>c.nodeId = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *NodeClient)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;node cliet for engine:[%v], node:[%v]&quot;</span>, c.engineCli.config.SN, c.nodeId)<br>&#125;<br><br><span class="hljs-comment">// Hello 用于检查节点的webserver服务是否可用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *NodeClient)</span></span> Hello() <span class="hljs-type">error</span> &#123;<br>outputBytes, err := c.Output(<span class="hljs-string">&quot;echo&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>output := strings.TrimSpace(<span class="hljs-type">string</span>(outputBytes))<br><span class="hljs-keyword">if</span> output != <span class="hljs-string">&quot;hello&quot;</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unexpect result&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *NodeClient)</span></span> Post(api <span class="hljs-type">string</span>, body any) (proto_common.StatusCode, []<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> c.engineCli.Post(c.nodeId, api, body)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *NodeClient)</span></span> Get(api <span class="hljs-type">string</span>) (proto_common.StatusCode, []<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> c.engineCli.Get(c.nodeId, api)<br>&#125;<br><br><span class="hljs-comment">// @parm host 用于定位具体的节点，应该传递nodeUID</span><br><span class="hljs-comment">// @param api 由于这个参数仅包含api路径，不包含能用于定位对端服务的host，所以不起名为url</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *engineClient)</span></span> Post(host <span class="hljs-type">string</span>, api <span class="hljs-type">string</span>, body any) (proto_common.StatusCode, []<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 构造请求</span><br>protoCtx := proto_store.NewRequestContext()<br>dst := &amp;mdv1.Metadata_Info&#123;<br>Engine:    &amp;mdv1.Engine&#123;SerialNumber: c.config.SN&#125;,<br>Component: types.COMPONENT_TAG_WEBSERVER,<br>&#125;<br><span class="hljs-keyword">if</span> host != <span class="hljs-string">&quot;&quot;</span> &#123;<br>dst.Node = &amp;mdv1.Node&#123;Id: host&#125;<br>&#125;<br>req := protoCtx.SetUrl(api).SetDst(dst)<br><span class="hljs-keyword">if</span> c.config.Timeout != <span class="hljs-number">0</span> &#123;<br>req.SetTimeout(c.config.Timeout)<br>&#125;<br><span class="hljs-comment">// 设置body</span><br><span class="hljs-keyword">if</span> body != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err := req.SetRequestBody(body); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br><span class="hljs-comment">// 发送请求</span><br>resp, err := c.cli.Post(req)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-comment">// 资源回收</span><br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br><span class="hljs-comment">// 读取响应</span><br>respBody, err := io.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> resp.StatusCode, respBody, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *engineClient)</span></span> Get(host <span class="hljs-type">string</span>, api <span class="hljs-type">string</span>) (proto_common.StatusCode, []<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 构造请求</span><br>protoCtx := proto_store.NewRequestContext()<br>dst := &amp;mdv1.Metadata_Info&#123;<br>Engine:    &amp;mdv1.Engine&#123;SerialNumber: c.config.SN&#125;,<br>Component: types.COMPONENT_TAG_WEBSERVER,<br>&#125;<br><span class="hljs-keyword">if</span> host != <span class="hljs-string">&quot;&quot;</span> &#123;<br>dst.Node = &amp;mdv1.Node&#123;Id: host&#125;<br>&#125;<br>req := protoCtx.SetUrl(api).SetDst(dst)<br><span class="hljs-keyword">if</span> c.config.Timeout != <span class="hljs-number">0</span> &#123;<br>req.SetTimeout(c.config.Timeout)<br>&#125;<br><br><span class="hljs-comment">// 发送请求</span><br>resp, err := c.cli.Get(req)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-comment">// 资源回收</span><br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br><span class="hljs-comment">// 读取响应</span><br>respBody, err := io.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> resp.StatusCode, respBody, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *engineClient)</span></span> NodeClient(id <span class="hljs-type">string</span>) *NodeClient &#123;<br><span class="hljs-keyword">if</span> id == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;node id should not be empty&quot;</span>)<br>&#125;<br><br>nodeCli, ok := c.nodeClients[id]<br><span class="hljs-keyword">if</span> !ok &#123;<br>nodeCli = &amp;NodeClient&#123;<br>engineCli: c,<br>nodeId:    id,<br>&#125;<br>c.nodeClients[id] = nodeCli<br>&#125;<br><br><span class="hljs-keyword">return</span> nodeCli<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *engineClient)</span></span> nodeClose(id <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-built_in">delete</span>(c.nodeClients, id)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *engineClient)</span></span> Close() <span class="hljs-type">error</span> &#123;<br>c.mu.Lock()<br><span class="hljs-keyword">defer</span> c.mu.Unlock()<br><br><span class="hljs-comment">// 关闭node client</span><br>keys := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(c.nodeClients))<br><span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> c.nodeClients &#123;<br>keys = <span class="hljs-built_in">append</span>(keys, k)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, key := <span class="hljs-keyword">range</span> keys &#123;<br>_ = c.nodeClose(key)<br>&#125;<br><br><span class="hljs-comment">// 关闭连接</span><br><span class="hljs-comment">// c.cli.Stop()</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newManagerClient</span><span class="hljs-params">(tlsConfig *tls.Config)</span></span> *managerClient &#123;<br>creds := credentials.NewTLS(tlsConfig)<br>cli, err := client.NewClientService(context.Background(), options.ServiceOption&#123;<br>Address:   scCoreAddress,<br>Port:      scCorePort,<br>Component: types.COMPONENT_TAG_UNKNOWN,<br>Creds:     creds,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">if</span> err := cli.Connect(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// logger.Logger.Warnf(&quot;connect to sc-core failed:%v&quot;, err)</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>err := cli.Start()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// logger.Logger.Errorf(&quot;manager core client start failed:%v&quot;, err.Error())</span><br>&#125;<br>time.Sleep(managerClientReconnectTimeout)<br><span class="hljs-keyword">if</span> err := cli.Connect(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// logger.Logger.Warnf(&quot;connect to sc-core failed:%v&quot;, err)</span><br>&#125;<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">return</span> &amp;managerClient&#123;CoreClient: cli&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getManagerClient</span><span class="hljs-params">()</span></span> *managerClient &#123;<br>mgntClientMu.Lock()<br><span class="hljs-keyword">defer</span> mgntClientMu.Unlock()<br><span class="hljs-keyword">if</span> managerClientInstance == <span class="hljs-literal">nil</span> &#123;<br>clientCert, err := tls.X509KeyPair(ca.Generate(<span class="hljs-string">&quot;Manager&quot;</span>))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Failed to load client certificate: %v&quot;</span>, err)<br>&#125;<br>caCert, _ := ca.RootCa()<br>caCertPool := x509.NewCertPool()<br>caCertPool.AppendCertsFromPEM(caCert)<br>_ = clientCert<br>clientTLSConfig := &amp;tls.Config&#123;<br><span class="hljs-comment">// ServerName:   &quot;sc.srhino.svc.local&quot;,</span><br><span class="hljs-comment">// Certificates: []tls.Certificate&#123;clientCert&#125;,</span><br><span class="hljs-comment">// RootCAs:      caCertPool, // 信任服务端证书的根 CA</span><br>InsecureSkipVerify: <span class="hljs-literal">true</span>,<br>&#125;<br><br>managerClientInstance = newManagerClient(clientTLSConfig)<br>&#125;<br><br><span class="hljs-keyword">return</span> managerClientInstance<br>&#125;<br><br><span class="hljs-comment">// 当manager与sc-core无法通信时才会返回错误</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewEngineClient</span><span class="hljs-params">(config *EngineClientConfig)</span></span> (*engineClient, <span class="hljs-type">error</span>) &#123;<br>cli := getManagerClient()<br><span class="hljs-keyword">if</span> cli == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;get manager client failed&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">return</span> &amp;engineClient&#123;<br>cli:         cli,<br>config:      config,<br>nodeClients: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*NodeClient),<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestEngineClient</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>engineCli, err := NewEngineClient(&amp;EngineClientConfig&#123;SN: <span class="hljs-string">&quot;SN123&quot;</span>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>t.Error(err)<br>&#125;<br><span class="hljs-keyword">defer</span> engineCli.Close()<br>nodeCli := engineCli.NodeClient(<span class="hljs-string">&quot;69ea20be-8be2-4432-8c0a-288af1c9deae&quot;</span>)<br><span class="hljs-keyword">if</span> err := nodeCli.Hello(); err != <span class="hljs-literal">nil</span> &#123;<br>t.Error(err)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>sr</tag>
      
      <tag>安装</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github.md</title>
    <link href="/2024/04/19/mdstorage/domain/search/github/"/>
    <url>/2024/04/19/mdstorage/domain/search/github/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>github Search 语法可用于搜索代码</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.github.com/en/search-github/github-code-search/understanding-github-code-search-syntax">文档</a></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>语法 option:param 之间没有空格</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><p><strong>单个</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">language:Go OR language:Dockerfile<br></code></pre></td></tr></table></figure><p><strong>多个</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">language:ruby OR language:cpp OR language:csharp<br></code></pre></td></tr></table></figure><h3 id="路径或文件名"><a href="#路径或文件名" class="headerlink" title="路径或文件名"></a>路径或文件名</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">path:**/Dockerfile<br>path:*.txt<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>search</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>code search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sc-core.md</title>
    <link href="/2024/04/19/mdstorage/project/sr/%E7%BB%84%E4%BB%B6/sc-core/"/>
    <url>/2024/04/19/mdstorage/project/sr/%E7%BB%84%E4%BB%B6/sc-core/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>sc-core 是 sc 的通信组件，提供：</p><ul><li>建立总控-引擎连接通道</li><li>通过通道发送信息</li></ul><p>的能力，它是一个 grpc server ，需要建立通道的组件都是 grpc client。</p><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>部署问题：防火墙策略开放不合理；将之前 总控-&gt;引擎 这种开放策略改为 引擎-&gt;总控。原因详见通信链路相关机制讲解</li><li>链路繁杂问题：之前组件负责人各自进行开发，没有站在系统角度考虑问题，导致链路过多，通信混乱，增加了复杂度</li></ul><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul><li>使用 sc-core 作为通用通信组件，将防火墙策略问题解决了，即通信建立的方向为 引擎-&gt;总控。</li><li>客户端连接 sc-core 建立通信通道，将多条链路整合为了一条，降低了系统复杂度。</li></ul><h2 id="架构实现"><a href="#架构实现" class="headerlink" title="架构实现"></a>架构实现</h2><h3 id="主要原理"><a href="#主要原理" class="headerlink" title="主要原理"></a>主要原理</h3><ul><li>grpc 双向通信 （通道建立）</li><li>TLS （安全认证）</li><li>grpc streamInterceptor</li></ul><p><img src="/sc-core-arch.png" alt="img.png"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="基础库"><a href="#基础库" class="headerlink" title="基础库"></a>基础库</h4><h5 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h5><h6 id="core-message"><a href="#core-message" class="headerlink" title="core_message"></a>core_message</h6><p>core_message 是 sc-core 传输消息的协议</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// 元数据</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Metadata</span> &#123;<br>  <span class="hljs-keyword">message </span><span class="hljs-title class_">Info</span> &#123;<br>    <span class="hljs-comment">// 引擎</span><br>    protobuf.common.v1.Engine engine = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 节点</span><br>    protobuf.common.v1.Node node = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 组件标识</span><br>    <span class="hljs-type">string</span> component = <span class="hljs-number">3</span>;<br>  &#125;<br>  <span class="hljs-comment">// 消息来源</span><br>  Info src = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 消息目标</span><br>  Info dst = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">CoreMessage</span> &#123;<br>  <span class="hljs-comment">// 消息标识</span><br>  <span class="hljs-type">uint64</span> messageId = <span class="hljs-number">1</span>;<br><br>  Metadata metadata = <span class="hljs-number">2</span>;<br>  <span class="hljs-comment">// 消息内容</span><br>  <span class="hljs-keyword">oneof</span> message &#123;<br>    <span class="hljs-comment">// 定义请求消息</span><br>    Request request = <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 定义响应消息</span><br>    Response response = <span class="hljs-number">5</span>;<br>  &#125;<br>  <span class="hljs-comment">// 消息过期时间</span><br>  <span class="hljs-type">int64</span> expiredTime = <span class="hljs-number">6</span>;<br><br>  <span class="hljs-type">string</span> version = <span class="hljs-number">7</span>;<br><br>  <span class="hljs-comment">// 消息头</span><br>  map&lt;<span class="hljs-type">string</span>, <span class="hljs-type">string</span>&gt; headers = <span class="hljs-number">9</span>;<br><br>  <span class="hljs-comment">// 消息序号</span><br>  <span class="hljs-type">uint64</span> Seq = <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h6><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">enum </span><span class="hljs-title class_">Method</span> &#123;<br>  GET = <span class="hljs-number">0</span>;<br>  POST = <span class="hljs-number">1</span>;<br>  PUT = <span class="hljs-number">2</span>;<br>  DELETE = <span class="hljs-number">3</span>;<br>  PATCH = <span class="hljs-number">4</span>;<br>  LIST = <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-comment">// 请求消息结构</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Request</span> &#123;<br>  <span class="hljs-comment">// 资源标识地址</span><br>  <span class="hljs-type">string</span> url = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 资源操作类型</span><br>  <span class="hljs-type">string</span> method = <span class="hljs-number">2</span>;<br>  <span class="hljs-comment">// 请求消息体</span><br>  <span class="hljs-type">bytes</span> body = <span class="hljs-number">3</span>;<br>  <span class="hljs-comment">// 请求参数</span><br>  map&lt;<span class="hljs-type">string</span>, <span class="hljs-type">string</span>&gt; params = <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h6><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// 响应消息结构</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Response</span> &#123;<br>  <span class="hljs-keyword">enum </span><span class="hljs-title class_">Code</span> &#123;<br>    SUCCESS_CODE = <span class="hljs-number">0</span>;<br>    FAIL_CODE = <span class="hljs-number">1</span>;<br>  &#125;<br>  Code code = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">bytes</span> body = <span class="hljs-number">2</span>;<br>  <span class="hljs-type">string</span> error = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="service-stream"><a href="#service-stream" class="headerlink" title="service stream"></a>service stream</h6><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">service </span><span class="hljs-title class_">CoreService</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> Agent (stream protobuf.common.v1.CoreMessage) <span class="hljs-keyword">returns</span> (stream protobuf.common.v1.CoreMessage)</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="容器测试"><a href="#容器测试" class="headerlink" title="容器测试"></a>容器测试</h3><h4 id="容器测试1"><a href="#容器测试1" class="headerlink" title="容器测试1"></a>容器测试1</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t core .<br><br>docker run -d -p 20111:20111 --name core core<br></code></pre></td></tr></table></figure><h4 id="容器测试2"><a href="#容器测试2" class="headerlink" title="容器测试2"></a>容器测试2</h4><p>Ubuntu20.04 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -f <span class="hljs-built_in">test</span>/install/Dockerfile -t ubuntu-sc-core .<br><br>docker run -d -p 20111:20111 --privileged --name ubuntu-sc-core -v /sys/fs/cgroup:/sys/fs/cgroup:ro  -v /run/dbus/system_bus_socket:/run/dbus/system_bus_socket:ro -v /run/dbus:/run/dbus  --cap-add SYS_ADMIN ubuntu-sc-core &amp;&amp; docker <span class="hljs-built_in">exec</span> ubuntu-sc-core systemctl start install.service<br><span class="hljs-comment"># 调试</span><br><span class="hljs-comment"># docker run -it -p 20111:20111 ubuntu-sc-core /bin/bash</span><br></code></pre></td></tr></table></figure><h4 id="容器测试3"><a href="#容器测试3" class="headerlink" title="容器测试3"></a>容器测试3</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -f <span class="hljs-built_in">test</span>/e2e/Dockerfile -t core-client .<br><br><span class="hljs-comment"># 本地测试</span><br>docker run --<span class="hljs-built_in">rm</span> --net=host -e ADDR=127.0.0.1 -e LOOP=500 core-client<br><br><span class="hljs-comment"># 远程测试</span><br>docker run --<span class="hljs-built_in">rm</span> -e ADDR=172.16.1.216 -e LOOP=500 core-client<br></code></pre></td></tr></table></figure><h3 id="Makefile-执行-test"><a href="#Makefile-执行-test" class="headerlink" title="Makefile 执行 test"></a>Makefile 执行 test</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make test-e2e<br></code></pre></td></tr></table></figure><h2 id="异常梳理"><a href="#异常梳理" class="headerlink" title="异常梳理"></a>异常梳理</h2><h3 id="hosts-问题"><a href="#hosts-问题" class="headerlink" title="hosts 问题"></a>hosts 问题</h3><p>这个问题特征是sc core 找不到 客户端注册 信息，但是接收到 从客户端来的 request, 所以会返回给 客户端 503 找不到对端， 通过 ss 命令找到连到其他 sc ip 了<br>在 测试环境容易遇到，客户环境不太可能出现，遇到了可以立马查看 &#x2F;etc&#x2F;hosts，或者清理后重试</p><h3 id="对端问题"><a href="#对端问题" class="headerlink" title="对端问题"></a>对端问题</h3><p>对端退出</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Text">2024/05/06 11:03:08 core client connection stop<br>2024/05/06 11:03:08 client handle recv ctx done<br>2024/05/06 11:03:08 rpc err:  rpc error: code = Canceled desc = grpc: the client connection is closing<br>2024/05/06 11:03:08 core client handle receive error rpc error: code = Canceled desc = grpc: the client connection is closing<br>2024/05/06 11:03:13 request: request timeout<br>panic: request timeout<br></code></pre></td></tr></table></figure><h3 id="调试时出现"><a href="#调试时出现" class="headerlink" title="调试时出现"></a>调试时出现</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Text">2024/05/06 15:59:57 server is currently unavailable:  rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 15:59:57 rpc err:  rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 15:59:57 core client handle receive error rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 15:59:57 start client server err: rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 15:59:57 core client connection close error: rpc error: code = Canceled desc = grpc: the client connection is closing<br>2024/05/06 15:59:57 core client connection stop<br>2024/05/06 15:59:58 server is currently unavailable:  rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 15:59:58 rpc err:  rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 15:59:58 request: connect interrupted<br>2024/05/06 15:59:58 core client handle receive error rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 15:59:58 start err:  rpc error: code = Unavailable desc = error reading from server: EOF<br>panic: start client server err: rpc error: code = Unavailable desc = error reading from server: EOF<br><br><br><br>2024/05/06 16:27:29 server is currently unavailable:  rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 16:27:30 rpc err:  rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 16:27:30 server is currently unavailable:  rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 16:27:30 rpc err:  rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 16:27:30 request: message send fail:[EOF]<br>2024/05/06 16:27:30 core client handle receive error rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 16:27:30 start err:  rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 16:27:30 server is currently unavailable:  rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 16:27:30 core client handle receive error rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 16:27:30 start client server err: rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 16:27:30 rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 16:27:30 server is currently unavailable:  rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 16:27:33 message send fail:[EOF]<br>2024/05/06 16:27:35 request chan delete user/info<br>2024/05/06 16:27:35 request: message send fail:[EOF]<br>2024/05/06 16:27:37 connect err:  context deadline exceeded<br>2024/05/06 16:27:37 message send fail:[EOF]<br>panic: context deadline exceeded<br><br><br><br>2024/05/06 16:23:32 server is currently unavailable:  rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 16:23:32 rpc err:  rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 16:23:32 core client handle receive error rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 16:23:32 start err:  rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 16:23:32 server is currently unavailable:  rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 16:23:32 server is currently unavailable:  rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 16:23:32 rpc err:  rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 16:23:32 core client handle receive error rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 16:23:32 start err:  rpc error: code = Unavailable desc = error reading from server: EOF<br>2024/05/06 16:23:33 server is currently unavailable:  rpc error: code = Unavailable desc = error reading from server: EOF<br>panic: rpc error: code = Unavailable desc = error reading from server: EOF<br></code></pre></td></tr></table></figure><h3 id="未知问题"><a href="#未知问题" class="headerlink" title="未知问题"></a>未知问题</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Text">rpc error: code = Unavailable desc = error reading from server: EOF<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Text">dlv --listen=:2345 --headless=true --api-version=2 --accept-multiclient exec ./client dlv --listen=:2345 --headless=true --api-version=2 --accept-multiclient exec ./client -case base.simple -addr 127.0.0.1 -loop 100<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Text"># 调试构建<br>go build -gcflags &quot;all=-N -l&quot; -o client cmd/client/main.go<br><br><br># 调试运行<br>dlv --listen=:2345 --headless=true --api-version=2 --accept-multiclient exec ./client -- -case base.simple -addr 127.0.0.1 -loop 100<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>sr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>find.md</title>
    <link href="/2024/04/18/mdstorage/domain/linux/find/"/>
    <url>/2024/04/18/mdstorage/domain/linux/find/</url>
    
    <content type="html"><![CDATA[<h2 id="find-概述"><a href="#find-概述" class="headerlink" title="find 概述"></a>find 概述</h2><p>linux 下查找文件的工具</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="根据日期查找文件"><a href="#根据日期查找文件" class="headerlink" title="根据日期查找文件"></a>根据日期查找文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 找到 /usr/lib/x86_64-linux-gnu/ 下 昨天到现在 这段时间被</span><br>find /usr/lib/x86_64-linux-gnu/ -<span class="hljs-built_in">type</span> f -newermt <span class="hljs-string">&quot;yesterday&quot;</span> -<span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>find</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dockerfile.md</title>
    <link href="/2024/04/18/mdstorage/domain/%E8%99%9A%E6%8B%9F%E5%8C%96/dockerfile/"/>
    <url>/2024/04/18/mdstorage/domain/%E8%99%9A%E6%8B%9F%E5%8C%96/dockerfile/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>dockerfile 用于构建 docker 镜像</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t <span class="hljs-variable">$name</span> .<br><br>docker build -t <span class="hljs-variable">$name</span>:<span class="hljs-variable">$tagname</span> .<br><br></code></pre></td></tr></table></figure><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><ul><li>尽量使用 &amp;&amp; \ 表示多行语句，使用 <code>&amp;&amp;</code> 连接命令，如果前一个命令成功执行（返回 0），则执行下一个命令。这是确保每个命令依赖于前一个命令成功完成的常用方法</li></ul><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><ul><li>CMD [“.&#x2F;server”]       这是它的 json 数组写法，意味着不使用 shell 进行执行，则不可以使用 cd 等命令</li><li>CMD cd build&#x2F;sc&#x2F; &amp;&amp; .&#x2F;server     这是使用 sh -c 执行的写法</li></ul><h2 id="构建服务示例"><a href="#构建服务示例" class="headerlink" title="构建服务示例"></a>构建服务示例</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 使用官方 Golang 镜像</span><br><span class="hljs-keyword">FROM</span> golang:latest<br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /sc-core</span><br><span class="hljs-comment"># 将你的源代码复制到容器中</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . /sc-core</span><br><span class="hljs-comment"># 拷贝凭证文件到 Docker 容器中</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> .git-credentials /root/.git-credentials</span><br><br><span class="hljs-comment"># 运行 go mod tidy 来清理依赖项</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> git config --global credential.helper <span class="hljs-string">&#x27;store --file=/root/.git-credentials&#x27;</span> &amp;&amp; \</span><br><span class="language-bash">    go <span class="hljs-built_in">env</span> -w GOPRIVATE=git.ouryun.cn,192.168.20.12 &amp;&amp; \</span><br><span class="language-bash">    go <span class="hljs-built_in">env</span> -w GONOSUMDB=git.ouryun.cn,192.168.20.12 &amp;&amp; \</span><br><span class="language-bash">    go <span class="hljs-built_in">env</span> -w GONOPROXY=git.ouryun.cn,192.168.20.12 &amp;&amp; \</span><br><span class="language-bash">    go <span class="hljs-built_in">env</span> -w GOINSECURE=git.ouryun.cn,192.168.20.12 &amp;&amp; \</span><br><span class="language-bash">    go <span class="hljs-built_in">env</span> -w GOPROXY=<span class="hljs-string">&quot;https://goproxy.cn|https://goproxy.io|direct&quot;</span> &amp;&amp; \</span><br><span class="language-bash">    go mod tidy -x</span><br><br><span class="hljs-comment"># 构建应用</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> make release</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">20111</span><br><br><span class="hljs-comment"># 指定容器启动时执行的命令</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">cd</span> build/sc-core &amp;&amp; ./bin/server</span><br><br></code></pre></td></tr></table></figure><h2 id="构建测试示例"><a href="#构建测试示例" class="headerlink" title="构建测试示例"></a>构建测试示例</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">```<br><br><br><span class="hljs-comment">## docker 使用 systemd</span><br><br>```Docker<br><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">22.04</span><br><br><span class="hljs-keyword">ENV</span> DEBIAN_FRONTEND noninteractive<br><span class="hljs-keyword">ENV</span> LC_ALL C.UTF-<span class="hljs-number">8</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">rm</span> /bin/sh &amp;&amp; <span class="hljs-built_in">ln</span> -s /bin/bash /bin/sh</span><br><span class="hljs-keyword">ENV</span> HTTP_PROXY=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">ENV</span> HTTPS_PROXY=<span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i <span class="hljs-string">&#x27;s@archive.ubuntu.com@mirrors.tuna.tsinghua.edu.cn@g&#x27;</span> /etc/apt/sources.list &amp;&amp; \</span><br><span class="language-bash">    sed -i <span class="hljs-string">&#x27;s@security.ubuntu.com@mirrors.tuna.tsinghua.edu.cn@g&#x27;</span> /etc/apt/sources.list</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> 1 2 3 4 5; <span class="hljs-keyword">do</span> \</span><br><span class="language-bash">      apt-get update &amp;&amp; \</span><br><span class="language-bash">      apt-get -y install \</span><br><span class="language-bash">      g++ \</span><br><span class="language-bash">      libtext-iconv-perl \</span><br><span class="language-bash">      default-logind \</span><br><span class="language-bash">      build-essential \</span><br><span class="language-bash">      gcc \</span><br><span class="language-bash">      apt-utils \</span><br><span class="language-bash">      pkg-config \</span><br><span class="language-bash">      software-properties-common \</span><br><span class="language-bash">      apt-transport-https \</span><br><span class="language-bash">      libssl-dev \</span><br><span class="language-bash">      <span class="hljs-built_in">sudo</span> \</span><br><span class="language-bash">      bash \</span><br><span class="language-bash">      curl \</span><br><span class="language-bash">      wget \</span><br><span class="language-bash">      tar \</span><br><span class="language-bash">      git \</span><br><span class="language-bash">      netcat \</span><br><span class="language-bash">      libaspell-dev \</span><br><span class="language-bash">      libhunspell-dev \</span><br><span class="language-bash">      hunspell-en-us \</span><br><span class="language-bash">      aspell-en \</span><br><span class="language-bash">      shellcheck \</span><br><span class="language-bash">      systemd \</span><br><span class="language-bash">      python3 \</span><br><span class="language-bash">      dbus \</span><br><span class="language-bash">      openssh-server \</span><br><span class="language-bash">      iproute2 \</span><br><span class="language-bash">      iputils-ping --fix-missing &amp;&amp; \</span><br><span class="language-bash">      <span class="hljs-built_in">break</span> || <span class="hljs-built_in">sleep</span> 30; \</span><br><span class="language-bash">    <span class="hljs-keyword">done</span> &amp;&amp; \</span><br><span class="language-bash">    apt-get -y update &amp;&amp; \</span><br><span class="language-bash">    apt-get -y autoremove &amp;&amp; \</span><br><span class="language-bash">    apt-get -y autoclean</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y python2</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">rm</span> -f /lib/systemd/system/multi-user.target.wants/* \</span><br><span class="language-bash">        /etc/systemd/system/*.wants/* \</span><br><span class="language-bash">        /lib/systemd/system/local-fs.target.wants/* \</span><br><span class="language-bash">        /lib/systemd/system/sockets.target.wants/*udev* \</span><br><span class="language-bash">        /lib/systemd/system/sockets.target.wants/*initctl* \</span><br><span class="language-bash">        /lib/systemd/system/sysinit.target.wants/systemd-tmpfiles-setup* \</span><br><span class="language-bash">        /lib/systemd/system/systemd-tmpfiles-clean.service \</span><br><span class="language-bash">        /lib/systemd/system/systemd-tmpfiles-setup-dev.service \</span><br><span class="language-bash">        /lib/systemd/system/systemd-tmpfiles-setup.service \</span><br><span class="language-bash">        /lib/systemd/system/systemd-update-utmp*</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> wget --http-user=team --password=xdmybl http://119.91.145.27:12800/repo/lib/systemctl.py -O /bin/systemctl</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">chmod</span> a+x /bin/systemctl</span><br><br><br><span class="hljs-comment"># 修复 systemd 服务文件中的 ExecStart 路径</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-keyword">for</span> service_file <span class="hljs-keyword">in</span> /lib/systemd/system/*.service; <span class="hljs-keyword">do</span> \</span><br><span class="language-bash">        <span class="hljs-keyword">if</span> [ -f <span class="hljs-string">&quot;<span class="hljs-variable">$service_file</span>&quot;</span> ]; <span class="hljs-keyword">then</span> \</span><br><span class="language-bash">            sed -i <span class="hljs-string">&#x27;s|^ExecStart=system|ExecStart=/bin/system|g&#x27;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$service_file</span>&quot;</span>; \</span><br><span class="language-bash">            sed -i <span class="hljs-string">&#x27;s|^ExecStart=journalctl|ExecStart=/bin/journalctl|g&#x27;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$service_file</span>&quot;</span>; \</span><br><span class="language-bash">            sed -i <span class="hljs-string">&#x27;s|^ExecStart=bootctl|ExecStart=/bin/bootctl|g&#x27;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$service_file</span>&quot;</span>; \</span><br><span class="language-bash">            sed -i <span class="hljs-string">&#x27;s|^ExecStop=journalctl|ExecStop=/bin/journalctl|g&#x27;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$service_file</span>&quot;</span>; \</span><br><span class="language-bash">            <span class="hljs-keyword">if</span> ! grep -q <span class="hljs-string">&#x27;\[Service\]&#x27;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$service_file</span>&quot;</span>; <span class="hljs-keyword">then</span> \</span><br><span class="language-bash">                <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Removing <span class="hljs-variable">$service_file</span> due to missing [Service] section&quot;</span>; \</span><br><span class="language-bash">                <span class="hljs-built_in">rm</span> <span class="hljs-string">&quot;<span class="hljs-variable">$service_file</span>&quot;</span>; \</span><br><span class="language-bash">            <span class="hljs-keyword">fi</span>; \</span><br><span class="language-bash">        <span class="hljs-keyword">fi</span>; \</span><br><span class="language-bash">    <span class="hljs-keyword">done</span></span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> /var/run/sshd &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;root:root&#x27;</span> | chpasswd &amp;&amp; \</span><br><span class="language-bash">    sed -i <span class="hljs-string">&#x27;s/#PermitRootLogin prohibit-password/PermitRootLogin yes/&#x27;</span> /etc/ssh/sshd_config &amp;&amp; \</span><br><span class="language-bash">    sed -i <span class="hljs-string">&#x27;s@session\s*required\s*pam_loginuid.so@session optional pam_loginuid.so@g&#x27;</span> /etc/pam.d/sshd &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">mkdir</span> -p /root/.ssh &amp;&amp; <span class="hljs-built_in">chmod</span> 700 /root/.ssh</span><br><br><span class="hljs-comment"># 暴露 SSH 服务端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">22</span><br><br><span class="hljs-keyword">STOPSIGNAL</span> SIGRTMIN+<span class="hljs-number">3</span><br><br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [ <span class="hljs-string">&quot;/sys/fs/cgroup&quot;</span> ]</span><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/lib/systemd/systemd&quot;</span>]</span><br></code></pre></td></tr></table></figure><h3 id="docker-使用-systemd-问题"><a href="#docker-使用-systemd-问题" class="headerlink" title="docker 使用 systemd 问题"></a>docker 使用 systemd 问题</h3><p><a href="https://serverfault.com/questions/1053187/systemd-fails-to-run-in-a-docker-container-when-using-cgroupv2-cgroupns-priva">https://serverfault.com/questions/1053187/systemd-fails-to-run-in-a-docker-container-when-using-cgroupv2-cgroupns-priva</a></p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>dockerfile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git技巧.md</title>
    <link href="/2024/04/17/mdstorage/domain/vsc/git%E6%8A%80%E5%B7%A7/"/>
    <url>/2024/04/17/mdstorage/domain/vsc/git%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 清理本地无用分支</span><br>git fetch -p<br></code></pre></td></tr></table></figure><h2 id="保存-credentials"><a href="#保存-credentials" class="headerlink" title="保存 credentials"></a>保存 credentials</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 默认在 ~/.git-credentials</span><br>git config --global credential.helper store<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>vsc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QEMU虚拟机克隆.md</title>
    <link href="/2024/04/17/mdstorage/domain/%E8%99%9A%E6%8B%9F%E5%8C%96/QEMU%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%8B%E9%9A%86/"/>
    <url>/2024/04/17/mdstorage/domain/%E8%99%9A%E6%8B%9F%E5%8C%96/QEMU%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%8B%E9%9A%86/</url>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/virtualization_deployment_and_administration_guide/sect-guest_virtual_machine_disk_access_with_offline_tools-using_virt_sysprep">virt-sysprep使用文档</a></p><h2 id="virt-sysprep-安装"><a href="#virt-sysprep-安装" class="headerlink" title="virt-sysprep 安装"></a>virt-sysprep 安装</h2><p><code>sudo apt-get install libguestfs-tools</code></p><h2 id="virt-sysprep-使用（克隆和使用）"><a href="#virt-sysprep-使用（克隆和使用）" class="headerlink" title="virt-sysprep 使用（克隆和使用）"></a>virt-sysprep 使用（克隆和使用）</h2><ul><li>关闭虚拟机</li><li>virt-manager 中选择克隆虚拟机</li><li>CMD 中 <code>virt-sysprep -d $NEW_VM_NAME --hostname $NEW_HOSTNAME --root-password password:$NEW_PASSWORD --operations net-hwaddr</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker镜像及其使用.md</title>
    <link href="/2024/04/17/mdstorage/domain/%E8%99%9A%E6%8B%9F%E5%8C%96/docker%E9%95%9C%E5%83%8F%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/04/17/mdstorage/domain/%E8%99%9A%E6%8B%9F%E5%8C%96/docker%E9%95%9C%E5%83%8F%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><p>这个镜像用于统一构建环境和试运行 go 程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --<span class="hljs-built_in">rm</span> -v /opt/mystorage/git.ouryun.cn/sc-core:/sc-core -w /sc-core golang go <span class="hljs-built_in">env</span> -w GOPRIVATE=<span class="hljs-string">&#x27;git.ouryun.cn&#x27;</span> &amp;&amp; go <span class="hljs-built_in">env</span> -w GOPROXY=<span class="hljs-string">&#x27;https://goproxy.cn|https://goproxy.io|direct&#x27;</span> &amp;&amp; go mod tidy &amp;&amp; go build -o server cmd/server<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>actions.md</title>
    <link href="/2024/04/17/mdstorage/domain/ide/idea/actions/"/>
    <url>/2024/04/17/mdstorage/domain/ide/idea/actions/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>jetbrain 系列产品，把操作成为 actions，通过 M-X 唤出界面 </p><h2 id="常用-action-列表"><a href="#常用-action-列表" class="headerlink" title="常用 action 列表"></a>常用 action 列表</h2><h3 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h3><ul><li>restart ide    重启</li></ul><h3 id="切换窗口"><a href="#切换窗口" class="headerlink" title="切换窗口"></a>切换窗口</h3><ul><li>open recent project   打开最近的 project 列表</li><li>open project window   已打开的 project 列表</li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>ide</category>
      
      <category>idea</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idea</tag>
      
      <tag>jetbrains</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webserver机制.md</title>
    <link href="/2024/04/17/mdstorage/project/sr/%E7%BB%84%E4%BB%B6/webserver%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/04/17/mdstorage/project/sr/%E7%BB%84%E4%BB%B6/webserver%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>webserver 提供引擎侧的管理功能，是管理面的核心组件</p><h2 id="架构决定日志"><a href="#架构决定日志" class="headerlink" title="架构决定日志"></a>架构决定日志</h2><h3 id="v1-5"><a href="#v1-5" class="headerlink" title="v1.5"></a>v1.5</h3><ul><li>主动向 sc&#x2F;sc-core 建立连接通道，接受 sc 侧传入的消息</li><li>提供引擎网关等对象管理功能</li><li>管理引擎各节点状态</li><li>提供插件绑定接口</li></ul><h4 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h4><ul><li>debian 系统或子发行版</li></ul><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="与-sc-core-的通信"><a href="#与-sc-core-的通信" class="headerlink" title="与 sc-core 的通信"></a>与 sc-core 的通信</h3><h3 id="资产过期感知和处理"><a href="#资产过期感知和处理" class="headerlink" title="资产过期感知和处理"></a>资产过期感知和处理</h3><p>1、插件的过期处理<br>        a、action到已绑定的插件过期按原来的处理逻辑<br>2、流量引擎过期处理<br>        a、action到引擎过期按照原逻辑处理即可<br>3、插件绑定时的授权校验<br>        a、在绑定插件时使用插件的序列号调用GetAssetBySn方法看看是否有这个资产的授权即可<br>4、引擎工作节点的过期处理<br>        a、action到工作节点过期，处理方法未知<br>6、引擎本身的授权校验<br>        a、action后查看引擎是否在可运行的资产区或者过期区域即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>sr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node安装.md</title>
    <link href="/2024/04/16/mdstorage/domain/js/node%E5%AE%89%E8%A3%85/"/>
    <url>/2024/04/16/mdstorage/domain/js/node%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="node-安装"><a href="#node-安装" class="headerlink" title="node 安装"></a>node 安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>version=<span class="hljs-string">&quot;20.12.2&quot;</span><br><br><span class="hljs-built_in">mkdir</span> -p /opt/software/ &amp;&amp; <span class="hljs-built_in">cd</span> /opt/software/<br><span class="hljs-comment">#wget https://nodejs.org/dist/v$&#123;version&#125;/node-v$&#123;version&#125;-linux-x64.tar.gz</span><br>wget https://mirrors.aliyun.com/nodejs-release/v<span class="hljs-variable">$&#123;version&#125;</span>/node-v<span class="hljs-variable">$&#123;version&#125;</span>-linux-x64.tar.gz<br>tar xzvf node-v<span class="hljs-variable">$&#123;version&#125;</span>-linux-x64.tar.gz<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mv</span> node-v<span class="hljs-variable">$&#123;version&#125;</span>-linux-x64 /usr/local/node<br><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF &gt;&gt; ~/.bashrc</span><br><span class="hljs-string">export NODE_HOME=/usr/local/node</span><br><span class="hljs-string">export PATH=\$PATH:\$NODE_HOME/bin</span><br><span class="hljs-string">EOF</span><br><span class="hljs-built_in">source</span> ~/.bashrc<br><br><span class="hljs-comment"># npm config set registry https://registry.npmmirror.com/ 设置淘宝镜像</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安装</tag>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sr部署.md</title>
    <link href="/2024/04/13/mdstorage/sr%E9%83%A8%E7%BD%B2/"/>
    <url>/2024/04/13/mdstorage/sr%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="sc-部署"><a href="#sc-部署" class="headerlink" title="sc 部署"></a>sc 部署</h2><h3 id="打包平台下载-sc-包"><a href="#打包平台下载-sc-包" class="headerlink" title="打包平台下载 sc 包"></a>打包平台下载 sc 包</h3><p>打包平台 <code>http://172.16.86.52/</code></p><h3 id="sc-包放到-中解压"><a href="#sc-包放到-中解压" class="headerlink" title="sc 包放到 ~ 中解压"></a>sc 包放到 <code>~</code> 中解压</h3><h3 id="执行-sc-安装"><a href="#执行-sc-安装" class="headerlink" title="执行 sc 安装"></a>执行 sc 安装</h3><p>script -&gt; 填写 config -&gt; install.sh</p><p>(校验不通过，需要修改 check.sh 的内容)</p><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p><code>80 443</code></p><h2 id="授权获取"><a href="#授权获取" class="headerlink" title="授权获取"></a>授权获取</h2><p>授权获取方式：<br><a href="http://192.192.101.126/#/login">http://192.192.101.126/#/login</a><br>账号：<a href="mailto:&#x79;&#x61;&#110;&#102;&#97;&#x40;&#111;&#117;&#x72;&#x79;&#117;&#110;&#x2e;&#99;&#111;&#109;&#x2e;&#x63;&#x6e;">&#x79;&#x61;&#110;&#102;&#97;&#x40;&#111;&#117;&#x72;&#x79;&#117;&#110;&#x2e;&#99;&#111;&#109;&#x2e;&#x63;&#x6e;</a> 密码：Aa123456<br>操作方式：授权管理目录“石犀研发部-开发组“-【更新】替换成自己的授权申请文件即可</p><h2 id="se-部署"><a href="#se-部署" class="headerlink" title="se 部署"></a>se 部署</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="debian12-需要安装一些库"><a href="#debian12-需要安装一些库" class="headerlink" title="debian12 需要安装一些库"></a>debian12 需要安装一些库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt install -y libpcre3 <br><br><br>这目录下的所有库拷贝出来 http://119.91.145.27:12800/repo/lib/libcrypto.so.1.1 示例：<br>wget --http-user=team  --http-passwd=xdmybl  http://119.91.145.27:12800/repo/lib/libldap_r-2.4.so.2<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ball_url=http://172.16.86.52/api/v1/pack/download/last/278<br>expose_ip=192.168.122.203<br><br>wget <span class="hljs-variable">$ball_url</span> -O sc.tar.gz<br>tar zxvf sc.tar.gz<br>root=`<span class="hljs-built_in">realpath</span> SC_v*`<br>check_path=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;root&#125;</span>/sc/script/check.sh&quot;</span><br>config_file=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;root&#125;</span>/sc/script/config&quot;</span><br><br>sed -i <span class="hljs-string">&#x27;/^main$/s/^/#/&#x27;</span> <span class="hljs-variable">$&#123;check_path&#125;</span><br>sed -i <span class="hljs-string">&#x27;s/^addr=&quot;&quot;/addr=&quot;192.168.122.203&quot;/&#x27;</span> <span class="hljs-variable">$&#123;config_file&#125;</span><br><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;root&#125;</span>/sc/script/&quot;</span> &amp;&amp; ./install.sh<br></code></pre></td></tr></table></figure><p>resource check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&quot;</span> &gt; ~/SC_v1.6.x.linux-x86_64/check.sh<br><br><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF &gt; /opt/installer/config/resource_check_config.yaml</span><br><span class="hljs-string">osKernelArch:</span><br><span class="hljs-string">  type: in</span><br><span class="hljs-string">  options:</span><br><span class="hljs-string">  - &quot;ubuntu 20.04、5.4、amd64&quot;</span><br><span class="hljs-string">  - &quot;ubuntu 20.04、5.15、amd64&quot;  </span><br><span class="hljs-string">  - &quot;centos 7、3.10、amd64&quot;</span><br><span class="hljs-string">nproc:</span><br><span class="hljs-string">  type: range</span><br><span class="hljs-string">  minimum: 2</span><br><span class="hljs-string">  standard: 4</span><br><span class="hljs-string">memory:</span><br><span class="hljs-string">  type: range</span><br><span class="hljs-string">  minimum: 2</span><br><span class="hljs-string">  standard: 4</span><br><span class="hljs-string">disk:</span><br><span class="hljs-string">  type: range</span><br><span class="hljs-string">  minimum: 1</span><br><span class="hljs-string">  standard: 10</span><br><span class="hljs-string">EOF</span><br>systemctl restart installer<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">cd</span> /data/repo/se/origin/release<br><br><span class="hljs-built_in">mkdir</span> <span class="hljs-built_in">test</span><br>ball_name=`<span class="hljs-built_in">ls</span> SEv*.tar.gz`<br>tar zxvf <span class="hljs-variable">$ball_name</span> -C <span class="hljs-built_in">test</span>/<br><span class="hljs-built_in">cd</span> <span class="hljs-built_in">test</span><br><br>sed -i <span class="hljs-string">&#x27;/ubuntu 20.04、5.4、amd64/a\  - &quot;ubuntu 20.04、5.15、amd64&quot;&#x27;</span> resource_check_config.yaml<br>sed -i <span class="hljs-string">&#x27;/disk:/,/standard:/s/minimum: 40/minimum: 20/&#x27;</span> resource_check_config.yaml<br><br>tar vczf <span class="hljs-variable">$ball_name</span> ./*<br><span class="hljs-built_in">cd</span> ..<br><span class="hljs-built_in">rm</span> <span class="hljs-variable">$ball_name</span> <br><span class="hljs-built_in">mv</span> <span class="hljs-built_in">test</span>/<span class="hljs-variable">$ball_name</span> .<br><span class="hljs-built_in">rm</span> <span class="hljs-built_in">test</span> -rf<br></code></pre></td></tr></table></figure><h2 id="查看-引擎节点-crd"><a href="#查看-引擎节点-crd" class="headerlink" title="查看 引擎节点 crd"></a>查看 引擎节点 crd</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">source</span> /opt/public/.util.sh<br>import_env_helper <br>k8s_helper get ha -oyaml<br><br></code></pre></td></tr></table></figure><h2 id="mysql-连接"><a href="#mysql-连接" class="headerlink" title="mysql 连接"></a>mysql 连接</h2><p>修改 &#x2F;opt&#x2F;mysql&#x2F;config&#x2F;my.cnf 将监听地址改为 0.0.0.0<br>systemctl restart mysqld</p><h2 id="流量引擎安装"><a href="#流量引擎安装" class="headerlink" title="流量引擎安装"></a>流量引擎安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">url=http://172.16.86.52/api/v1/pack/download/last/266<br>wget <span class="hljs-variable">$&#123;url&#125;</span> -O se.tar.gz<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>sr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s组件编译.md</title>
    <link href="/2024/04/12/mdstorage/domain/k8s/k8s%E7%BB%84%E4%BB%B6%E7%BC%96%E8%AF%91/"/>
    <url>/2024/04/12/mdstorage/domain/k8s/k8s%E7%BB%84%E4%BB%B6%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="拉取仓库"><a href="#拉取仓库" class="headerlink" title="拉取仓库"></a>拉取仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/kubernetes/kubernetes.git<br></code></pre></td></tr></table></figure><h3 id="检查-golang-版本"><a href="#检查-golang-版本" class="headerlink" title="检查 golang 版本"></a>检查 golang 版本</h3><p>kubernetes 需要按照指示的 golang 版本编译</p><h3 id="执行编译"><a href="#执行编译" class="headerlink" title="执行编译"></a>执行编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># linux 全量编译</span><br>KUBE_BUILD_PLATFORMS=linux/amd64 make <br><br><span class="hljs-comment"># 单独编译 apiserver</span><br>make kube-apiserver<br></code></pre></td></tr></table></figure><h3 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出"></a>结果输出</h3><p>_output 目录下</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>k8s</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>grpc-go资料.md</title>
    <link href="/2024/04/12/mdstorage/domain/network/%E5%8D%8F%E8%AE%AE/grpc-go%E8%B5%84%E6%96%99/"/>
    <url>/2024/04/12/mdstorage/domain/network/%E5%8D%8F%E8%AE%AE/grpc-go%E8%B5%84%E6%96%99/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="函数整理"><a href="#函数整理" class="headerlink" title="函数整理"></a>函数整理</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><h4 id="NewClient-Dial"><a href="#NewClient-Dial" class="headerlink" title="NewClient &#x2F; Dial"></a>NewClient &#x2F; Dial</h4><h4 id="ClientConn"><a href="#ClientConn" class="headerlink" title="ClientConn"></a>ClientConn</h4><h4 id="ClientStream"><a href="#ClientStream" class="headerlink" title="ClientStream"></a>ClientStream</h4><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><h2 id="NewClient"><a href="#NewClient" class="headerlink" title="NewClient"></a>NewClient</h2><h3 id="1-ClientConn"><a href="#1-ClientConn" class="headerlink" title="1. ClientConn"></a>1. <strong>ClientConn</strong></h3><p>这是 gRPC 客户端的核心数据结构之一。<code>ClientConn</code> 表示到 gRPC 服务器的连接，用于发起 RPC 调用。对于流式 RPC，<code>ClientConn</code> 管理底层的 HTTP&#x2F;2 连接，它支持多路复用，允许在同一个连接上并行发送多个请求和响应。</p><h3 id="2-Stream"><a href="#2-Stream" class="headerlink" title="2. Stream"></a>2. <strong>Stream</strong></h3><p>这是双向流通信的基本抽象。在 gRPC 中，<code>Stream</code> 接口定义了发送和接收消息的基本操作。具体到 Go 实现，你可能会看到 <code>ClientStream</code> 和 <code>ServerStream</code> 接口，它们分别用于客户端和服务器端的流操作。</p><ul><li><strong>ClientStream</strong> 提供方法如 <code>SendMsg</code> 和 <code>RecvMsg</code>，这些方法用于发送和接收消息。</li><li><strong>ServerStream</strong> 同样提供了发送和接收消息的方法，还包括了一些服务端特有的上下文管理功能。</li></ul><h3 id="3-http2Client"><a href="#3-http2Client" class="headerlink" title="3. http2Client"></a>3. <strong>http2Client</strong></h3><p>这个内部组件是 gRPC 客户端用来处理 HTTP&#x2F;2 协议细节的实现。它负责管理底层的 HTTP&#x2F;2 帧，包括流控制、错误处理、和帧的发送与接收。</p><h3 id="4-transport"><a href="#4-transport" class="headerlink" title="4. transport"></a>4. <strong>transport</strong></h3><p><code>transport</code> 包中定义了 gRPC 的网络传输层。这是一个关键的组件，因为它直接处理所有通过网络发送和接收的数据。在这个包中，你会找到实现如 <code>Stream</code> 接口的 <code>http2Client</code> 和 <code>http2Server</code>，它们封装了 HTTP&#x2F;2 的流操作。</p><ul><li><strong>Transport</strong> 接口定义了通用的发送和接收操作，适用于客户端和服务端。</li><li><strong>http2Transport</strong> 类则是这些接口的具体实现，特别关注 HTTP&#x2F;2 的性能和特性。</li></ul><h3 id="5-codec"><a href="#5-codec" class="headerlink" title="5. codec"></a>5. <strong>codec</strong></h3><p>在 gRPC 中，<code>codec</code> 用于序列化和反序列化传输的消息。它在客户端和服务端之间的数据转换中起到了桥梁作用。默认情况下，gRPC 使用 Protocol Buffers，但也支持插入自定义编解码器。</p><h3 id="6-Interceptor"><a href="#6-Interceptor" class="headerlink" title="6. Interceptor"></a>6. <strong>Interceptor</strong></h3><p>拦截器在 gRPC 的流处理中扮演重要角色。它们允许开发者注入自定义逻辑，如日志记录、认证、监控等，而不需要修改实际的业务逻辑。对于流式 RPC，可以使用流拦截器来处理或修改进出的消息。</p><ul><li><strong>UnaryInterceptor</strong> 和 <strong>StreamInterceptor</strong> 是两种类型的拦截器，分别用于单向和双向流的 RPC 调用。</li></ul><h2 id="Http2Client-newHTTP2Client"><a href="#Http2Client-newHTTP2Client" class="headerlink" title="Http2Client newHTTP2Client"></a>Http2Client newHTTP2Client</h2><h3 id="1-初始化和连接管理"><a href="#1-初始化和连接管理" class="headerlink" title="1. 初始化和连接管理"></a>1. <strong>初始化和连接管理</strong></h3><ul><li><strong>连接上下文的创建</strong>：为给定的地址创建一个带取消功能的上下文，用于管理连接的生命周期。</li><li><strong>错误处理</strong>：在连接建立过程中遇到错误时，能够及时取消上下文和清理资源。</li></ul><h3 id="2-地址解析和拨号"><a href="#2-地址解析和拨号" class="headerlink" title="2. 地址解析和拨号"></a>2. <strong>地址解析和拨号</strong></h3><ul><li><strong>地址数据的处理</strong>：处理 <code>resolver.Address</code> 提供的信息，特别是其中的 <code>Attributes</code>，这些属性可以在连接过程中传递给拨号器和凭证握手器。</li><li><strong>拨号</strong>：使用提供的拨号器和代理设置建立网络连接。</li></ul><h3 id="3-连接监控"><a href="#3-连接监控" class="headerlink" title="3. 连接监控"></a>3. <strong>连接监控</strong></h3><ul><li><strong>连接监控</strong>：启动一个协程来监控连接上下文的取消或超时，一旦上下文被取消，立即关闭网络连接。</li></ul><h3 id="4-安全和身份验证"><a href="#4-安全和身份验证" class="headerlink" title="4. 安全和身份验证"></a>4. <strong>安全和身份验证</strong></h3><ul><li><strong>客户端握手</strong>：如果提供了传输凭证（如 TLS），执行客户端握手，验证服务器身份并建立安全连接。</li><li><strong>RPC 凭证</strong>：处理每个 RPC 请求可能需要的凭证。</li></ul><h3 id="5-HTTP-2-特定配置"><a href="#5-HTTP-2-特定配置" class="headerlink" title="5. HTTP&#x2F;2 特定配置"></a>5. <strong>HTTP&#x2F;2 特定配置</strong></h3><ul><li><strong>初始化 HTTP&#x2F;2 客户端</strong>：创建 <code>http2Client</code> 实例，配置其内部数据结构如流控制、帧处理器等。</li><li><strong>流量控制</strong>：配置和验证 HTTP&#x2F;2 的流量控制参数，如连接和流的窗口大小。</li><li><strong>Keepalive 参数</strong>：设置 TCP 连接的 Keepalive 参数，确保连接的活性。</li></ul><h3 id="6-帧处理和流量控制"><a href="#6-帧处理和流量控制" class="headerlink" title="6. 帧处理和流量控制"></a>6. <strong>帧处理和流量控制</strong></h3><ul><li><strong>帧处理器</strong>：初始化用于处理 HTTP&#x2F;2 帧的帧处理器（framer），配置读写缓冲区大小和头部大小限制。</li><li><strong>连接预设</strong>：向服务器发送 HTTP&#x2F;2 连接预设，并设置初始 HTTP&#x2F;2 设置。</li></ul><h3 id="7-事件和统计处理"><a href="#7-事件和统计处理" class="headerlink" title="7. 事件和统计处理"></a>7. <strong>事件和统计处理</strong></h3><ul><li><strong>事件和统计</strong>：注册连接到 channelz（用于监视和调试 gRPC 连接）并启动统计处理程序，标记连接和处理连接事件。</li></ul><h3 id="8-错误和流程控制"><a href="#8-错误和流程控制" class="headerlink" title="8. 错误和流程控制"></a>8. <strong>错误和流程控制</strong></h3><ul><li><strong>错误处理</strong>：任何在连接建立或配置过程中出现的错误都将导致连接关闭并返回错误。</li><li><strong>消息接收循环</strong>：启动一个协程来读取服务器发送的消息，处理服务器预设响应或任何首先出现的错误。</li></ul><h3 id="9-连接流程的终结"><a href="#9-连接流程的终结" class="headerlink" title="9. 连接流程的终结"></a>9. <strong>连接流程的终结</strong></h3><ul><li><strong>写入客户端预设</strong>：确保成功写入客户端预设到服务器。</li><li><strong>设置初始化</strong>：发送必要的 HTTP&#x2F;2 设置帧，如窗口大小和头部大小限制。</li><li><strong>流量控制窗口更新</strong>：如果需要，更新连接级别的流控制窗口。</li></ul><h2 id="NewServer-ServerOption"><a href="#NewServer-ServerOption" class="headerlink" title="NewServer ServerOption"></a>NewServer ServerOption</h2><h3 id="1-Keepalive-Time"><a href="#1-Keepalive-Time" class="headerlink" title="1. Keepalive Time"></a>1. <strong>Keepalive Time</strong></h3><p>设置 <code>keepaliveTime</code> 为 10 秒意味着，如果在这段时间内没有任何数据传输，客户端将发送一个 keepalive 探测。这个时间间隔不是特别短，也不是特别长，适中的设置有助于在保持连接活跃与减少不必要的网络流量之间取得平衡。</p><h3 id="2-Keepalive-Timeout"><a href="#2-Keepalive-Timeout" class="headerlink" title="2. Keepalive Timeout"></a>2. <strong>Keepalive Timeout</strong></h3><p><code>keepaliveTimeout</code> 设置为 1 秒，这意味着客户端在发送 keepalive 探测后，如果在 1 秒内没有收到响应，则认为连接已失效。这个超时时间相对较短，可能不太适合网络延迟较大的环境，因为它可能导致误判网络延迟为连接问题。</p><h3 id="3-Keepalive-MinTime"><a href="#3-Keepalive-MinTime" class="headerlink" title="3. Keepalive MinTime"></a>3. <strong>Keepalive MinTime</strong></h3><p><code>keepaliveMinTime</code> 设置为 8 秒（0.8 * <code>keepaliveTime</code>），这是服务器强制客户端在发送新的 keepalive 探测前必须等待的最小时间间隔。这个设置的目的是防止客户端过于频繁地发送探测，从而影响服务器性能。这种策略适用于防止服务器资源被客户端的频繁 keepalive 消息耗尽。</p><h3 id="4-PermitWithoutStream"><a href="#4-PermitWithoutStream" class="headerlink" title="4. PermitWithoutStream"></a>4. <strong>PermitWithoutStream</strong></h3><p>在服务器和客户端的 keepalive 配置中，都将 <code>PermitWithoutStream</code> 设置为 <code>true</code>，这允许即使在没有活动流的情况下也可以发送 keepalive 消息。这种配置对于长连接服务很有用，尤其是当连接上不频繁有数据传输，但双方仍需要知道连接的活跃状态时。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>MaxConcurrentNum                  = <span class="hljs-number">4</span> * <span class="hljs-number">1024</span><br>ConnectTimeout                    = <span class="hljs-number">10</span><br>RWBufSize                         = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span><br>BufPoolSize                       = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span><br>InitialWindowSize                 = <span class="hljs-number">256</span> * <span class="hljs-number">1024</span><br>InitialConnWindowSize             = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span><br>KeepaliveHeartbeatInterval        = <span class="hljs-number">5</span><br>KeepaliveHeartbeatIntervalTimeout = KeepaliveHeartbeatInterval<br>KeepaliveMinTime                  = <span class="hljs-number">4</span><br>)<br><br><br><br>kp1 := grpc.KeepaliveParams(keepalive.ServerParameters&#123;<br>Time:    KeepaliveHeartbeatInterval,<br>Timeout: KeepaliveHeartbeatIntervalTimeout,<br>&#125;)<br>kp2 := grpc.KeepaliveEnforcementPolicy(keepalive.EnforcementPolicy&#123;<br>MinTime:             KeepaliveMinTime,<br>PermitWithoutStream: <span class="hljs-literal">true</span>,<br>&#125;)<br><br>opts := []grpc.ServerOption&#123;<br>grpc.MaxRecvMsgSize(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>), <span class="hljs-comment">// 设置最大接收消息大小</span><br>grpc.MaxSendMsgSize(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>), <span class="hljs-comment">// 设置最大发送消息大小</span><br>grpc.StreamInterceptor(streamInterceptor),<br>grpc.Creds(s.options.Creds),<br>grpc.MaxConcurrentStreams(MaxConcurrentNum),<br>grpc.ConnectionTimeout(ConnectTimeout),<br>grpc.WriteBufferSize(RWBufSize),<br>grpc.ReadBufferSize(RWBufSize),<br>grpc.InitialWindowSize(InitialWindowSize),<br>grpc.InitialConnWindowSize(InitialConnWindowSize),<br>grpc.SharedWriteBuffer(<span class="hljs-literal">true</span>),<br>kp1,<br>kp2,<br>&#125;<br>grpcServer := grpc.NewServer(opts...)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>network</category>
      
      <category>协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>grpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>apiserver问题和解决.md</title>
    <link href="/2024/04/10/mdstorage/domain/k8s/apiserver%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3/"/>
    <url>/2024/04/10/mdstorage/domain/k8s/apiserver%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="apiserver-cr-的-size-由什么决定？"><a href="#apiserver-cr-的-size-由什么决定？" class="headerlink" title="apiserver cr 的 size 由什么决定？"></a>apiserver cr 的 size 由什么决定？</h3><p><code>kube-apiserver</code> 的参数主要集中在API行为的配置、认证授权、日志记录、以及与其他组件的交互等方面。</p><p>对于控制请求大小，Kubernetes 主要依靠的是请求超时设置、客户端请求限速（Rate Limiting）、以及其他API服务器的高级配置，但没有直接限制请求体大小的参数。这种控制机制更多地依赖于整体架构设计和在Ingress或API网关层面的配置，而不是单个<code>kube-apiserver</code>的参数。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>k8s</category>
      
    </categories>
    
    
    <tags>
      
      <tag>apiserver</tag>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ipvs.md</title>
    <link href="/2024/04/10/mdstorage/domain/%E9%AB%98%E5%8F%AF%E7%94%A8/ipvs/"/>
    <url>/2024/04/10/mdstorage/domain/%E9%AB%98%E5%8F%AF%E7%94%A8/ipvs/</url>
    
    <content type="html"><![CDATA[<h2 id="1-VS-DR-模式"><a href="#1-VS-DR-模式" class="headerlink" title="1 VS&#x2F;DR 模式"></a>1 VS&#x2F;DR 模式</h2><p>参考链接 <code>http://zh.linuxvirtualserver.org/node/28</code></p><p>描述的是使用虚拟服务器&#x2F;直接路由（VS&#x2F;DR）模式的网络体系结构。在这种模式下，负载均衡的实现依赖于一个调度器（通常是一个专用设备或服务器，负责流量的分发）和多个实际的后端服务器（组成服务器组，用于处理请求）。下面是对这段描述的逐句解读：</p><ol><li><p><strong>调度器和服务器组都必须在物理上有一个网卡通过不分段的局域网相连</strong>：这意味着调度器和所有的后端服务器都需要连接到同一个局域网（LAN）中，并且这个网络应该是未分段的，即它们之间的通信不应该通过路由器进行路由。这通常通过直接连接到同一个交换机或高速HUB来实现。</p></li><li><p><strong>即通过交换机或者高速的HUB相连，中间没有隔有路由器</strong>：进一步强调了调度器和服务器之间连接的物理特性，明确指出不能有路由器介入，因为路由器会分段网络，从而干扰直接路由模式的工作原理。</p></li><li><p><strong>VIP地址为调度器和服务器组共享</strong>：VIP（Virtual IP）地址是设置在调度器上的IP地址，用于接收外部对虚拟服务的请求。在VS&#x2F;DR模式中，这个VIP也被配置在每个后端服务器上，但方式有所不同。</p></li><li><p><strong>调度器配置的VIP地址是对外可见的，用于接收虚拟服务的请求报文</strong>：调度器使用VIP地址来接收来自客户端的所有请求。对外界来说，这个VIP地址代表了负载均衡服务的入口点。</p></li><li><p><strong>所有的服务器把VIP地址配置在各自的Non-ARP网络设备上，它对外面是不可见的</strong>：在后端服务器上，VIP地址被配置为一个“非ARP响应”地址。这意味着虽然服务器上配置了VIP，但它不会对网络上的ARP请求（用于解析IP地址到物理MAC地址的协议请求）回应VIP的MAC地址，从而使得VIP对外不可见，仅在内部使用。</p></li><li><p><strong>只是用于处理目标地址为VIP的网络请求</strong>：虽然后端服务器对于外部ARP请求不响应VIP地址，它们仍然会处理目的IP地址为VIP的数据包。这是通过直接路由模式实现的，调度器将外部请求直接转发到合适的后端服务器，而服务器知道如何处理发往VIP的请求，因为它们被配置为接收这些请求。</p></li></ol><p>VS&#x2F;DR模式通过共享VIP地址，并在调度器和服务器间使用直接路由的方式，实现了对外提供一个单一访问点的负载均衡服务。调度器负责接收所有外部请求并将它们分发到后端服务器，而后端服务器处理这些请求，但对外界隐藏它们的存在，确保整个过程的透明性和高效性。</p><p>在VS&#x2F;DR（Virtual Server via Direct Routing）模式下，调度器和服务器组都必须通过一个物理网卡连接到未分段的局域网中，这种设计有几个关键原因：</p><h3 id="1-高效的数据传输"><a href="#1-高效的数据传输" class="headerlink" title="1. 高效的数据传输"></a>1. 高效的数据传输</h3><p>通过直接在局域网内路由数据包，可以最小化延迟和增加数据传输的效率。如果介入了路由器或网络被分段，那么数据包在到达最终目的地之前需要经过额外的跳转，这会增加处理请求的时间。</p><h3 id="2-简化的网络配置"><a href="#2-简化的网络配置" class="headerlink" title="2. 简化的网络配置"></a>2. 简化的网络配置</h3><p>在一个未分段的局域网中，所有设备都处于同一个广播域内。这简化了网络配置，因为调度器和服务器可以直接通信，无需通过路由器或其他网络设备。这也意味着所有服务器都可以直接使用VIP地址接收流量，而无需复杂的路由规则来指导数据包的流向。</p><h3 id="3-减少ARP问题"><a href="#3-减少ARP问题" class="headerlink" title="3. 减少ARP问题"></a>3. 减少ARP问题</h3><p>在VS&#x2F;DR模式下，调度器使用VIP接收外部请求，但后端服务器配置为不对外广播VIP的ARP应答，以避免引起ARP冲突。如果网络被分段，且通过路由器连接，就无法有效控制ARP广播，可能导致网络混乱。在一个统一的局域网内，更容易管理和控制ARP行为，确保只有调度器响应VIP的ARP请求。</p><h3 id="4-保持高可用性"><a href="#4-保持高可用性" class="headerlink" title="4. 保持高可用性"></a>4. 保持高可用性</h3><p>通过将所有服务器连接到同一个局域网，可以更容易地监控服务器状态并进行健康检查。这对于维持服务的高可用性至关重要。如果服务器分布在不同的网络段，监控和维护的复杂度将大大增加。</p><h3 id="5-支持透明处理请求"><a href="#5-支持透明处理请求" class="headerlink" title="5. 支持透明处理请求"></a>5. 支持透明处理请求</h3><p>在VS&#x2F;DR模式下，后端服务器处理请求后直接将响应返回给客户端，而不是通过调度器。这要求客户端到服务器的路径和服务器到客户端的路径是直接的，即所谓的“直接路由”。这种设计确保了高效处理请求并减少了调度器的负载。</p><p>综上所述，将调度器和服务器组通过未分段的局域网连接是为了确保数据传输的高效性、简化网络配置、减少网络协议（如ARP）可能导致的问题、保持服务的高可用性，以及支持高效直接的请求处理流程。这是VS&#x2F;DR模式设计的核心部分，旨在提供高性能和高可用性的负载均衡解决方案。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>高可用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lvs</tag>
      
      <tag>ipvs</tag>
      
      <tag>高可用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器.md</title>
    <link href="/2024/04/09/mdstorage/domain/%E8%99%9A%E6%8B%9F%E5%8C%96/docker/"/>
    <url>/2024/04/09/mdstorage/domain/%E8%99%9A%E6%8B%9F%E5%8C%96/docker/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>参考链接：<code>https://u.sb/debian-install-docker/</code></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><h4 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h4><ul><li>–rm     运行后自动删除，常用于测试</li><li>–net&#x3D;host     使用宿主机网络拓扑</li><li>-e $env_opt&#x3D;$value      设置环境变量</li><li>-d          后台运行，避免退出</li><li>-it          开启交互式命令行</li><li>-v $host_dir:$container_dir         挂载卷</li><li>-p  $host_port:$container_port       端口映射</li><li>-name $name   为容器起名</li><li>-dns $addr    指定 dns 地址</li><li>–privileged     赋予 root 权限</li><li>–cap-add SYS_ADMIN    赋予更高权限</li></ul><h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><p>背景是 docker 源国内访问不了，使用代理访问 docker 源</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment">#sudo mkdir /etc/systemd/system/docker.service.d &amp;&amp; cd $_</span><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mkdir</span> /tmp/temp &amp;&amp; <span class="hljs-built_in">cd</span> <span class="hljs-variable">$_</span><br><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF &gt; proxy.conf</span><br><span class="hljs-string">[Service] </span><br><span class="hljs-string">Environment=&quot;HTTP_PROXY=http://127.0.0.1:7890&quot; </span><br><span class="hljs-string">Environment=&quot;HTTPS_PROXY=http://127.0.0.1:7890&quot;</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text"><br>xiaoy@debian12:/etc/docker$ cat ~/.docker/config.json <br>&#123;<br> &quot;proxies&quot;:<br> &#123;<br>   &quot;default&quot;:<br>   &#123;<br>     &quot;httpProxy&quot;: &quot;http://172.17.0.1:7890&quot;,<br>     &quot;httpsProxy&quot;: &quot;http://172.17.0.1:7890&quot;,<br>     &quot;noProxy&quot;: &quot;localhost,127.0.0.1,192.168.30.1/16,*.ouryun.cn&quot;<br>   &#125;<br> &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><p><code>docker create</code> 命令用于创建一个新的容器，但并不会自动启动该容器。这个命令允许你在不启动容器的情况下定义容器的配置和资源，这样你可以稍后使用 <code>docker start</code> 命令来启动容器。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]<br></code></pre></td></tr></table></figure><ul><li><strong>IMAGE</strong>: 要基于哪个镜像创建容器。</li><li><strong>COMMAND</strong>: 容器启动时要执行的命令（可选）。</li><li><strong>[ARG…]</strong>: 传递给命令的参数（可选）。</li></ul><h4 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h4><p>以下是一些常用的 <code>docker create</code> 选项：</p><ul><li><strong>-a, –attach</strong>: 附加到 STDIN, STDOUT, STDERR。</li><li><strong>–add-host</strong>: 添加自定义主机名到 IP 映射（例如 <code>--add-host=hostname:IP</code>）。</li><li><strong>–name</strong>: 指定容器的名称。</li><li><strong>-e, –env</strong>: 设置环境变量（例如 <code>-e &quot;MY_VAR=my_value&quot;</code>）。</li><li><strong>-p, –publish</strong>: 映射主机的端口到容器的端口（例如 <code>-p 8080:80</code>）。</li><li><strong>-v, –volume</strong>: 挂载主机目录或数据卷到容器（例如 <code>-v /host/path:/container/path</code>）。</li><li><strong>–network</strong>: 指定容器连接的网络（默认是 <code>bridge</code> 网络）。</li><li><strong>–restart</strong>: 设置容器的重启策略（例如 <code>--restart=always</code>）。</li><li><strong>–cpus</strong>: 限制容器使用的 CPU 数量。</li><li><strong>–memory</strong>: 限制容器使用的内存（例如 <code>--memory=512m</code>）。</li><li><strong>–entrypoint</strong>: 覆盖镜像的默认入口点。</li><li><strong>–workdir</strong>: 设置容器内的工作目录。</li><li><strong>–hostname</strong>: 设置容器的主机名。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ol><li><p><strong>创建一个简单的容器</strong>：</p><p>创建一个基于 <code>ubuntu</code> 镜像的容器，但不启动它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker create ubuntu<br></code></pre></td></tr></table></figure><p>这个命令会返回一个容器 ID，可以用于后续的操作。</p></li><li><p><strong>创建一个指定名称的容器</strong>：</p><p>创建一个名为 <code>my_container</code> 的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker create --name my_container ubuntu<br></code></pre></td></tr></table></figure></li><li><p><strong>创建容器并设置环境变量和端口映射</strong>：</p><p>创建一个容器，设置环境变量并将主机的 8080 端口映射到容器的 80 端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker create --name my_web_server -e <span class="hljs-string">&quot;ENV=production&quot;</span> -p 8080:80 nginx<br></code></pre></td></tr></table></figure></li><li><p><strong>创建容器并挂载卷</strong>：</p><p>创建一个容器，并将主机目录挂载到容器内：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker create --name my_data_container -v /host/data:/container/data ubuntu<br></code></pre></td></tr></table></figure></li><li><p><strong>创建容器并指定网络</strong>：</p><p>创建一个容器，并将其连接到指定的 Docker 网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker create --name my_networked_container --network my_network alpine<br></code></pre></td></tr></table></figure></li></ol><h3 id="与-docker-run-的区别"><a href="#与-docker-run-的区别" class="headerlink" title="与 docker run 的区别"></a>与 <code>docker run</code> 的区别</h3><p><code>docker create</code> 只创建容器，不启动它，而 <code>docker run</code> 同时创建并启动容器。<code>docker create</code> 适用于你需要预先配置容器，然后稍后根据需要启动它的场景。</p><h4 id="典型的使用场景"><a href="#典型的使用场景" class="headerlink" title="典型的使用场景"></a>典型的使用场景</h4><ul><li><strong>预配置容器</strong>：你可以先创建容器，然后在需要时启动它们，而无需每次都重新创建。</li><li><strong>批量启动容器</strong>：在批量启动容器之前，可以先批量创建容器，然后根据需要分别启动它们。</li><li><strong>资源预分配</strong>：在实际启动容器之前，你可以通过创建容器来预先分配资源（如网络、卷等），以确保环境准备就绪。</li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安装</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>借用.md</title>
    <link href="/2024/04/08/mdstorage/domain/rust/%E5%80%9F%E7%94%A8/"/>
    <url>/2024/04/08/mdstorage/domain/rust/%E5%80%9F%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="借用"><a href="#借用" class="headerlink" title="借用"></a>借用</h2><p>Rust 中的借用（borrowing）是一种使得程序能够通过引用访问数据，而不取得数据的所有权的机制。这对于 Rust 的内存安全特性至关重要。借用分为两种：不可变借用和可变借用。以下是两种借用的简单示例：</p><h3 id="不可变借用"><a href="#不可变借用" class="headerlink" title="不可变借用"></a>不可变借用</h3><p>不可变借用允许你读取数据但不能修改它。你可以有多个不可变引用指向同一数据，因为它们都不会改变数据。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-comment">// 不可变借用</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = <span class="hljs-title function_ invoke__">calculate_length</span>(&amp;s);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s, len);<br>&#125;<br><br><span class="hljs-comment">// `s` 是对 `String` 的不可变引用</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>    <span class="hljs-comment">// s 在这里离开作用域，但因为它并不拥有所引用的数据，</span><br>    <span class="hljs-comment">// 所以什么也不会发生</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>calculate_length</code> 函数通过不可变引用接受一个字符串。它可以读取字符串的长度，但不能修改字符串本身。</p><h3 id="可变借用"><a href="#可变借用" class="headerlink" title="可变借用"></a>可变借用</h3><p>与不可变借用不同，可变借用允许你修改数据。在任何给定时刻，你只能拥有一个数据的可变引用（这防止了数据竞争），除非使用特定的并发类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-comment">// 可变借用</span><br>    <span class="hljs-title function_ invoke__">change</span>(&amp;<span class="hljs-keyword">mut</span> s);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Changed string is &#x27;&#123;&#125;&#x27;.&quot;</span>, s);<br>&#125;<br><br><span class="hljs-comment">// `s` 是对 `String` 的可变引用</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">change</span>(s: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">String</span>) &#123;<br>    s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;, world&quot;</span>);<br>    <span class="hljs-comment">// s 在这里离开作用域并释放借用，但不会释放数据本身，</span><br>    <span class="hljs-comment">// 因为它并不拥有数据</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>change</code> 函数通过可变引用接受一个字符串，并修改它。需要注意的是，<code>s</code> 在 <code>main</code> 函数中被声明为可变的（<code>mut s</code>），因为我们需要通过引用修改它。</p><p>Rust 的这种借用系统能够在编译时防止数据竞争、悬垂引用和其他内存安全问题，是 Rust 内存安全保证的核心部分。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>管理面HA改造答疑.md</title>
    <link href="/2024/04/07/mdstorage/project/sr/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0/%E7%AE%A1%E7%90%86%E9%9D%A2HA%E6%94%B9%E9%80%A0%E7%AD%94%E7%96%91/"/>
    <url>/2024/04/07/mdstorage/project/sr/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0/%E7%AE%A1%E7%90%86%E9%9D%A2HA%E6%94%B9%E9%80%A0%E7%AD%94%E7%96%91/</url>
    
    <content type="html"><![CDATA[<h2 id="Keepalived-概述"><a href="#Keepalived-概述" class="headerlink" title="Keepalived 概述"></a>Keepalived 概述</h2><p>Keepalived 为 Linux 系统提供了负载均衡和高可用能力。负载均衡的能力来自 Linux 内核中的 LVS 项目模块 IPVS（IP Virtual Server）。</p><p>Keepalived 运行在 Linux 系统中，它会启动内核中的 LVS 服务来创建虚拟服务器。比如我们在两台服务器上都启动了一个 Keepalived 服务，然后 LVS 会虚拟化出来一个 IP（VIP），但是只有一个 Keepalived 会接管这个 VIP，就是说客户端的请求只会到 Master Keepalived 节点上。这样流量就只会到一台 keepalived 上了，然后 keepalived 可以配置几台真实的服务 IP 地址和端口，通过负载调度算法将流量分摊到这些服务上。对于另外一台 Backup Keepalived 节点，它是待机状态，没有流量接入的。</p><p>Keepalived 使用 C 语言编写的开源软件项目，项目的目的主要是简化 LVS 项目的配置并增强 LVS 的稳定性。简单来说，Keepalived 就是对 LVS 的扩展增强。管理面没有 LVS,所以管理面 HA 其实存在的意义不大。</p><pre><code class=" mermaid">---title: 部署视图---graph TD;    subgraph LAN[&quot;局域网&quot;]        switch[(&quot;交换机&quot;)]    end    subgraph Internet[&quot;互联网&quot;]        userDevice1((&quot;用户设备1&quot;))        userDevice2((&quot;用户设备2&quot;))        router[(&quot;路由器&quot;)]        userDevice1 --&gt; router        userDevice2 --&gt; router        router --&gt; switch    end    subgraph Servers[&quot;服务器集群&quot;]        master[(&quot;主服务器&quot;)]        backup1[(&quot;备份服务器1&quot;)]        backup2[(&quot;备份服务器2&quot;)]        switch --&gt; master        switch --&gt; backup1        switch --&gt; backup2    end    VIP((&quot;虚拟IP&quot;)) -.-&gt; master    master -. &quot;故障转移&quot; .-&gt; backup1    master -. &quot;故障转移&quot; .-&gt; backup2    classDef default fill:#1E90FF,stroke:#333,stroke-width:2px;    classDef network fill:#708090,stroke:#333,stroke-width:2px;    class LAN,Internet,Servers network;</code></pre><ul><li><strong>用户</strong>通过互联网访问服务，请求先到达路由器，然后通过交换机转发。</li><li><strong>主服务器</strong>拥有虚拟IP（VIP），作为对外服务的唯一入口点。</li><li><strong>备份服务器</strong>准备在主服务器发生故障时接管VIP，保证服务的持续可用性。</li><li><strong>虚拟IP（VIP）</strong>指向主服务器，但在需要时可以快速迁移到备份服务器。</li><li>故障转移的逻辑被表示为从主服务器指向备份服务器的箭头。</li></ul><pre><code class=" mermaid">---title: 故障转移视图---graph TD;    subgraph Internet[&quot;互联网&quot;]        userDevice1((&quot;用户设备1&quot;))        userDevice2((&quot;用户设备2&quot;))        router[(&quot;路由器&quot;)]        userDevice1 --&gt;|请求服务| VIP        userDevice2 --&gt;|请求服务| VIP    end    subgraph LAN[&quot;局域网&quot;]        switch[(&quot;交换机&quot;)]        VIP((&quot;虚拟IP&quot;)) --&gt; switch    end    subgraph Servers[&quot;服务器集群&quot;]        master[(&quot;主服务器&quot;)]        backup1[(&quot;备份服务器1&quot;)]        backup2[(&quot;备份服务器2&quot;)]        switch --&gt; master        switch --&gt; backup1        switch --&gt; backup2    end    VIP -. &quot;当前指向&quot; .-&gt; master    master -. &quot;故障时转移至&quot; .-&gt; backup1    backup1 -. &quot;故障时转移至&quot; .-&gt; backup2    classDef default fill:#1E90FF,stroke:#333,stroke-width:2px;    classDef network fill:#708090,stroke:#333,stroke-width:2px;    class Internet,LAN,Servers network;</code></pre><h3 id="Keepalived-在传统高可用架构下的位置"><a href="#Keepalived-在传统高可用架构下的位置" class="headerlink" title="Keepalived 在传统高可用架构下的位置"></a>Keepalived 在传统高可用架构下的位置</h3><pre><code class=" mermaid">---title: 传统高可用架构部署视图---graph TD;    subgraph Internet[&quot;互联网&quot;]        userDevice1((&quot;用户设备1&quot;))        userDevice2((&quot;用户设备2&quot;))        userDevice1 --&gt;|请求服务| VIP        userDevice2 --&gt;|请求服务| VIP    end    subgraph LAN[&quot;局域网&quot;]        switch[(&quot;交换机&quot;)]        VIP((&quot;虚拟IP&quot;)) --&gt; switch    end    subgraph LB_Cluster[&quot;负载均衡器集群(LVS)&quot;]        LVS_Master[(&quot;LVS 主节点&quot;)]        LVS_Backup1[(&quot;LVS 备份节点1&quot;)]        LVS_Backup2[(&quot;LVS 备份节点2&quot;)]        switch --&gt; LVS_Master        switch ----&gt; LVS_Backup1        switch ----&gt; LVS_Backup2    end    subgraph Keepalived_Cluster[&quot;Keepalived 集群&quot;]        Keepalived_Master[(&quot;Keepalived 主&quot;)]        Keepalived_Backup1[(&quot;Keepalived 备份1&quot;)]        Keepalived_Backup2[(&quot;Keepalived 备份2&quot;)]        LVS_Master --&gt; Keepalived_Master        LVS_Backup --&gt; Keepalived_Backup1        LVS_Backup --&gt; Keepalived_Backup2    end    subgraph Backend_Servers[&quot;后端服务器&quot;]        server1[(&quot;服务器1&quot;)]        server2[(&quot;服务器2&quot;)]        server3[(&quot;服务器3&quot;)]        LVS_Master --&gt; server1        LVS_Master --&gt; server2        LVS_Master --&gt; server3    end    VIP -. &quot;当前指向&quot; .-&gt; LVS_Master    LVS_Master -. &quot;故障时转移至&quot; .-&gt; LVS_Backup    Keepalived_Master -. &quot;管理&quot; .-&gt; LVS_Master    Keepalived_Backup1 -. &quot;备用管理&quot; .-&gt; LVS_Backup    Keepalived_Backup2 -. &quot;备用管理&quot; .-&gt; LVS_Backup    classDef default fill:#1E90FF,stroke:#333,stroke-width:2px;    classDef network fill:#708090,stroke:#333,stroke-width:2px;    class Internet,LAN,LB_Cluster,Keepalived_Cluster,Backend_Servers network;</code></pre><ul><li><strong>用户设备</strong>通过互联网向虚拟IP（VIP）发送服务请求。</li><li><strong>虚拟IP（VIP）</strong>由Keepalived管理，并指向LVS的主节点。</li><li><strong>LVS的主节点</strong>和备份节点构成了负载均衡器集群，负责将请求分发到后端服务器。</li><li><strong>Keepalived集群</strong>包括主节点和备份节点，用于管理LVS集群的高可用性，确保在LVS主节点发生故障时能够将VIP快速迁移到备份节点。</li><li><strong>后端服务器</strong>接收来自LVS主节点的请求，并处理这些请求。</li></ul><h2 id="改造前引擎高可用机制数据流向"><a href="#改造前引擎高可用机制数据流向" class="headerlink" title="改造前引擎高可用机制数据流向"></a>改造前引擎高可用机制数据流向</h2><pre><code class=" mermaid">---title: 改造前引擎高可用机制数据流向---graph TD;    subgraph Internet[&quot;互联网&quot;]        userDevice1((&quot;客户设备1&quot;))        userDevice2((&quot;客户设备2&quot;))        router_public[(&quot;公网路由器|防火墙&quot;)]        userDevice1 --&gt;|访问总控| router_public        userDevice2 --&gt;|访问总控| router_public    end    subgraph PublicNetwork[&quot;公网可访问网络&quot;]        switch_public[(&quot;公网交换机&quot;)]        router_public --&gt; switch_public    end    subgraph SC[总控]        sc[(sc)]        sv[(sv)]        switch_public --&gt; sc    end    subgraph DataCenter[&quot;数据中心网络&quot;]        router_datacenter[(&quot;数据中心路由器|防火墙&quot;)]        switch_datacenter[(&quot;数据中心交换机&quot;)]        router_datacenter --&gt; switch_datacenter    end    subgraph SEM[管理面]        VIP((虚拟IP))        subgraph SEMNode1[管理面节点1]            other_comp1[(管理面组件)]        end        subgraph SEMNode2[管理面节点2]            other_comp2[(管理面组件)]        end        subgraph SEMNode3[管理面节点3]            other_comp3[(管理面组件)]        end        subgraph KeepalivedSEM[管理面Keepalived]            keepalived_master_SEM[(&quot;Keepalived 主&quot;)]            keepalived_backup_SEM[(&quot;Keepalived 备份&quot;)]            keepalived_master_SEM --&gt; keepalived_backup_SEM            keepalived_backup_SEM -.-&gt; keepalived_master_SEM        end        other_comp1 &lt;--&gt;|服务搭建等管理工作| keepalived_master_SEM        VIP -.-&gt; other_comp1 -. &quot;故障转移&quot; .-&gt; keepalived_backup_SEM    end    subgraph SES[调度集群]        VIP_SES((业务VIP表))        subgraph SES_LVS[调度LVS]            LVS_SES_Master[(&quot;LVS 主节点&quot;)]            lvs_policy((策略管理))            LVS_SES_Backup[(&quot;LVS 备份节点&quot;)]            LVS_SES_Master --&gt;|调度请求| LVS_SES_Backup            LVS_SES_Backup -.-&gt;|故障转移| LVS_SES_Master            LVS_SES_Master -.-&gt; lvs_policy        end        subgraph KeepalivedSES[调度Keepalived]            keepalived_master_SES[(&quot;Keepalived 主&quot;)]            keepalived_backup_SES[(&quot;Keepalived 备份&quot;)]            keepalived_master_SES --&gt; keepalived_backup_SES            keepalived_backup_SES -.-&gt; keepalived_master_SES        end        VIP_SES -.-&gt; LVS_SES_Master        LVS_SES_Master --&gt; keepalived_master_SES    end    subgraph SEW[工作集群]        subgraph Backend_Servers1[&quot;工作节点集群&quot;]            envoy1[(&quot;Envoy&quot;)]            polycuber1[(&quot;Polycuber&quot;)]        end        subgraph Backend_Servers2[&quot;工作节点集群&quot;]            envoy2[(&quot;Envoy&quot;)]            polycuber2[(&quot;Polycuber&quot;)]        end        subgraph Backend_Servers3[&quot;工作节点集群&quot;]            envoy3[(&quot;Envoy&quot;)]            polycuber3[(&quot;Polycuber&quot;)]        end    end    subgraph UserServer[业务服务集群]        subgraph ServerCluster1[&quot;业务服务集群1&quot;]node1[(node)]node2[(node)]        end        subgraph ServerCluster2[&quot;业务服务集群2&quot;]node3[(node)]        end        subgraph ServerCluster3[&quot;业务服务集群3&quot;]node4[(node)]        end    end    subgraph UserSpace[&quot;用户|服务访问流量&quot;]    user1((用户访问))    frontend((前端业务))    end    other_comp1 --&gt; |管理| SES    other_comp1 ---&gt; |管理| SEW    LVS_SES_Master --业务流量转发--&gt; envoy1 &amp; envoy2 &amp; envoy3    user1 &amp; frontend --&gt; VIP_SES    envoy1 --&gt;|反向代理| node1 &amp; node2 &amp; node3    envoy2 --&gt;|重定向| node4    envoy3 &lt;--&gt;direct_response[直接响应]     switch_public --&gt;|接受来自SC的流量| router_datacenter    switch_datacenter --&gt; VIP    classDef network fill:#bbf,stroke:#333,stroke-width:2px;    class Internet,PublicNetwork,DataCenter network;        class Internet internet    class PublicNetwork publicNet;    class DataCenter dataCenter;    class SEM management;    class SES scheduling;    class SEW workCluster;    class UserServer userService;    class UserSpace userAccess;classDef internet fill:#bde0fe,stroke:#333,stroke-width:2px;    classDef publicNet fill:#fed7b2,stroke:#333,stroke-width:2px;    classDef dataCenter fill:#d4a5a5,stroke:#333,stroke-width:4px;    classDef management fill:#fbcfe8,stroke:#333,stroke-width:2px;    classDef scheduling fill:#fef08a,stroke:#333,stroke-width:2px;    classDef workCluster fill:#bbf7d0,stroke:#333,stroke-width:2px;    classDef userService fill:#d9f99d,stroke:#333,stroke-width:2px;    classDef userAccess fill:#a7f3d0,stroke:#333,stroke-width:2px;    classDef flowLine stroke:#2563eb,stroke-width:2px,stroke-dasharray: 5, 5;    linkStyle 3,4,17,18,29,30 stroke:#db2777,stroke-width:12px;    linkStyle 19,20,21,22,23,24,25,26 stroke:#2563eb,stroke-width:2px,stroke-width:8px ;</code></pre><h2 id="改造后引擎高可用机制数据流向"><a href="#改造后引擎高可用机制数据流向" class="headerlink" title="改造后引擎高可用机制数据流向"></a>改造后引擎高可用机制数据流向</h2><pre><code class=" mermaid">---title: 改造后引擎高可用机制数据流向---graph TD;    subgraph Internet[&quot;互联网&quot;]        userDevice1((&quot;客户设备1&quot;))        userDevice2((&quot;客户设备2&quot;))        router_public[(&quot;公网路由器|防火墙&quot;)]        userDevice1 --&gt;|访问总控| router_public        userDevice2 --&gt;|访问总控| router_public    end    subgraph PublicNetwork[&quot;公网可访问网络&quot;]        switch_public[(&quot;公网交换机&quot;)]        router_public --&gt; switch_public    end    subgraph SC[总控]        sc_m_nic((管理口))        sc[(sc)]        sv[(sv)]        sc_core[(sc-core)]        switch_public &lt;-.-&gt; sc_m_nic --&gt; sc_core        sc &amp; sv -.-&gt; sc_core    end    subgraph DataCenter[&quot;数据中心网络&quot;]        router_datacenter[(&quot;数据中心路由器|防火墙&quot;)]        switch_datacenter[(&quot;数据中心交换机&quot;)]        router_datacenter &lt;-.-&gt; switch_datacenter    end    subgraph SEM[管理面]        subgraph SEMNode1[管理面节点1]            m_nic1((管理口))            other_comp1[(管理面组件流量入口)]            controller1[(管理面组件)]            apiserver_node1[apiserver]            m_nic1 &lt;-.-&gt; other_comp1            other_comp1 --&gt; controller1 --&gt; apiserver_node1        end        subgraph SEMNode2[管理面节点2]            m_nic2((管理口))            other_comp2[(管理面组件流量入口)]            controller2[(管理面组件)]            apiserver_node2[apiserver]            m_nic2 &lt;-.-&gt; other_comp2            other_comp2 --&gt; controller2 --&gt; apiserver_node2        end        subgraph SEMNode3[管理面节点3]            m_nic3((管理口))            other_comp3[(管理面组件流量入口)]            controller3[(管理面组件)]            apiserver_node3[apiserver]            m_nic3 &lt;-.-&gt; other_comp3            other_comp3 --&gt; controller3 --&gt; apiserver_node3        end        subgraph Apiserver[Apiserver集群]            apiserver1[(Apiserver)]            apiserver2[(Apiserver)]            apiserver3[(Apiserver)]        end        apiserver_node1 -.- apiserver1        apiserver_node2 -.- apiserver2        apiserver_node3 -.- apiserver3    end    subgraph SES[调度集群]        VIP_SES((业务VIP表))        subgraph SES_LVS[调度LVS]            subgraph SESNode1                ses_m_nic1((管理口))                ses_d_nic1((业务口))                LVS_SES_Master[(&quot;LVS 主节点&quot;)]                lvs_policy((策略管理))                ses_m_nic1 -.- lvs_policy            end            subgraph SESNode2                ses_m_nic2((管理口))                ses_d_nic2((业务口))                LVS_SES_Backup[(&quot;LVS 备份节点&quot;)]            end                        LVS_SES_Master --&gt;|调度请求| LVS_SES_Backup            LVS_SES_Backup -.-&gt;|故障转移| LVS_SES_Master            LVS_SES_Master -.-&gt; lvs_policy        end        subgraph KeepalivedSES[调度Keepalived]            keepalived_master_SES[(&quot;Keepalived 主&quot;)]            keepalived_backup_SES[(&quot;Keepalived 备份&quot;)]            keepalived_master_SES --&gt; keepalived_backup_SES            keepalived_backup_SES -.-&gt; keepalived_master_SES        end        VIP_SES -.- ses_d_nic1 --&gt; LVS_SES_Master        LVS_SES_Master --&gt; keepalived_master_SES    end    subgraph SEW[工作集群]        subgraph Backend_Servers1[&quot;工作节点集群&quot;]            sew_m_nic1((管理口))            sew_d_nic1((业务口))            envoy1[(&quot;Envoy&quot;)]            polycuber1[(&quot;Polycuber&quot;)]            sew_m_nic1 &amp; sew_d_nic1 -.- envoy1        end        subgraph Backend_Servers2[&quot;工作节点集群&quot;]            sew_m_nic2((管理口))            sew_d_nic2((业务口))            envoy2[(&quot;Envoy&quot;)]            polycuber2[(&quot;Polycuber&quot;)]            sew_m_nic2 &amp; sew_d_nic2 -.- envoy2        end        subgraph Backend_Servers3[&quot;工作节点集群&quot;]            sew_m_nic3((管理口))            sew_d_nic3((业务口))            envoy3[(&quot;Envoy&quot;)]            polycuber3[(&quot;Polycuber&quot;)]            sew_m_nic3 &amp; sew_d_nic3 -.- envoy3        end    end    subgraph UserServer[业务服务集群]        subgraph ServerCluster1[&quot;业务服务集群1&quot;]node1[(node)]node2[(node)]        end        subgraph ServerCluster2[&quot;业务服务集群2&quot;]node3[(node)]        end        subgraph ServerCluster3[&quot;业务服务集群3&quot;]node4[(node)]        end    end    subgraph UserSpace[&quot;用户|服务访问流量&quot;]    user1((用户访问))    frontend((前端业务))    end    ses_m_nic1 &amp; SEW ---&gt; Apiserver    m_nic1 &amp; m_nic2 &amp; m_nic3 &lt;-.-&gt; switch_datacenter    LVS_SES_Master --业务流量转发--&gt; sew_d_nic1 &amp; sew_d_nic2 &amp; sew_d_nic3    user1 &amp; frontend --&gt; VIP_SES    envoy1 --&gt;|反向代理| node1 &amp; node2 &amp; node3    envoy2 --&gt;|重定向| node4    envoy3 &lt;--&gt; direct_response[直接响应]     router_datacenter &lt;-.-&gt;|放通dst为sc的流| switch_public    classDef network fill:#bbf,stroke:#333,stroke-width:2px;    class Internet,PublicNetwork,DataCenter network;        class Internet internet    class PublicNetwork publicNet;    class DataCenter dataCenter;    class SEM management;    class SES scheduling;    class SEW workCluster;    class UserServer userService;    class UserSpace userAccess;classDef internet fill:#bde0fe,stroke:#333,stroke-width:2px;    classDef publicNet fill:#fed7b2,stroke:#333,stroke-width:2px;    classDef dataCenter fill:#d4a5a5,stroke:#333,stroke-width:4px;    classDef management fill:#fbcfe8,stroke:#333,stroke-width:2px;    classDef scheduling fill:#fef08a,stroke:#333,stroke-width:2px;    classDef workCluster fill:#bbf7d0,stroke:#333,stroke-width:2px;    classDef userService fill:#d9f99d,stroke:#333,stroke-width:2px;    classDef userAccess fill:#a7f3d0,stroke:#333,stroke-width:2px;    classDef flowLine stroke:#2563eb,stroke-width:2px,stroke-dasharray: 5, 5;    linkStyle 0 stroke:#db2777,stroke-width:12px;    linkStyle 0 stroke:#2563eb,stroke-width:2px,stroke-width:8px;    linkStyle 0 stroke:#db2777,stroke-width:12px,color:red;</code></pre><ul><li><strong>用户设备</strong>通过互联网访问总控。它们首先连接到<strong>公网路由器</strong>，然后通过<strong>公网交换机</strong>到达总控节点。</li><li><strong>总控节点</strong>被部署在一个公网可访问的网络内，允许来自互联网的访问。</li><li><strong>数据中心网络</strong>内包括引擎集群（管理面、调度集群、工作集群），它们通过<strong>数据中心路由器</strong>和<strong>数据中心交换机</strong>连接。</li><li><strong>管理面集群</strong>中的节点通过Keepalived实现高可用性，使用虚拟IP（VIP）为入口点。</li><li>VIP用于路由请求到<strong>调度集群</strong>，然后调度集群将任务分配给<strong>工作集群</strong>进行处理。</li></ul><h2 id="改造后物理架构"><a href="#改造后物理架构" class="headerlink" title="改造后物理架构"></a>改造后物理架构</h2><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/sr_mmrefactor_before.png" alt="通信链路改造前静态拓扑"></p><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/sr_mmrefactor_after_network.png" alt="通信链路改造后静态拓扑"></p><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/sr_mmrefactor_sem1.png" alt="a"></p><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/sr_mmrefactor_ses.png" alt="sr_mmrefactor_ses"></p><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/sr_mmrefactor_sew.png" alt="通信链路改造-工作节点故障转移"></p><h2 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h2><h3 id="云服务场景"><a href="#云服务场景" class="headerlink" title="云服务场景"></a>云服务场景</h3><p>公有云服务中一般 VIP 需要单独开，给服务部署带来更多要求。</p><h3 id="灾难恢复"><a href="#灾难恢复" class="headerlink" title="灾难恢复"></a>灾难恢复</h3><p>Keepalived主要设计用于单个数据中心或地理位置相近的网络中的高可用性。网络波动大、延时波动大的情况下，Keepalived 会出现频繁切主现象。</p><h3 id="监控日志管理"><a href="#监控日志管理" class="headerlink" title="监控日志管理"></a>监控日志管理</h3><p>虽然Keepalived提供基本的日志记录功能，但在复杂系统中，集成更先进的监控和日志分析通常是必需的，团队中没有修改 Keepalived 代码能力。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>Vrrp 协议本身是未加密的通信，并且可能在用户网络中与已有的组播冲突 （224.0.0.18）</p><h3 id="功能限制"><a href="#功能限制" class="headerlink" title="功能限制"></a>功能限制</h3><p>Keepalived 是做服务器层面高可用，不可能在此基础上做应用高可用。</p><h3 id="复杂"><a href="#复杂" class="headerlink" title="复杂"></a>复杂</h3><p>对于一些简单的高可用性需求，Keepalived的功能和配置可能显得过于复杂，特别是在没有负载均衡需求时。 </p><h3 id="技术栈不匹配"><a href="#技术栈不匹配" class="headerlink" title="技术栈不匹配"></a>技术栈不匹配</h3><p>Keepalived 使用 ANSI C 编写，引擎管理面使用 Golang，技术栈上不匹配，后期不能维护</p><h3 id="Web界面适配困难"><a href="#Web界面适配困难" class="headerlink" title="Web界面适配困难"></a>Web界面适配困难</h3><p>只提供文本文件进行配置。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://keepalived-doc.readthedocs.io/zh-cn/latest/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1.html">https://keepalived-doc.readthedocs.io/zh-cn/latest/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1.html</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>sr</tag>
      
      <tag>ha</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>awk.md</title>
    <link href="/2024/03/29/mdstorage/domain/linux/awk/"/>
    <url>/2024/03/29/mdstorage/domain/linux/awk/</url>
    
    <content type="html"><![CDATA[<h2 id="处理文件"><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h2><p><code>awk &#39;&#39; $file_path</code></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">extract_hosts_to_cluster_info</span></span>() &#123;<br><span class="hljs-built_in">local</span> hosts_file=<span class="hljs-variable">$1</span><br><span class="hljs-built_in">local</span> cluster_info=$(awk <span class="hljs-string">&#x27;/^\s*[^#]/ &amp;&amp; $2 ~ /.srhino.svc.local$/ &amp;&amp; $2 !~ /^s/ &amp;&amp; $2 !~ /^localhost/ &#123;sub(/\.srhino\.svc\.local$/, &quot;&quot;, $2); print $2&quot;=http://&quot;$1&quot;:2380&quot;&#125;&#x27;</span> <span class="hljs-variable">$&#123;hosts_file&#125;</span> | <span class="hljs-built_in">paste</span> -sd,)<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$cluster_info</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>awk</strong></p><ul><li><code>awk</code> 是一个强大的文本处理工具，用于模式扫描和处理。</li><li>使用 <code>/^\s*[^#]/</code> 来选择那些不以 <code>#</code> 开头的行，忽略了空白行和注释行。</li><li><code>$2 ~ /.srhino.svc.local$/</code> 确保第二个字段以 <code>.srhino.svc.local</code> 结尾。</li><li><code>$2 !~ /^s/</code> 确保第二个字段不是以 <code>s</code> 开头的。</li><li><code>$2 !~ /^localhost/</code> 排除任何以 <code>localhost</code> 开头的字段。</li><li><code>&#123;sub(/\.srhino\.svc\.local$/, &quot;&quot;, $2); print $2&quot;=http://&quot;$1&quot;:2380&quot;&#125;</code> 首先用 <code>sub()</code> 函数删除字段中的 <code>.srhino.svc.local</code> 后缀，然后打印修改后的第二个字段和第一个字段（IP 地址）的组合，格式为 <code>&lt;hostname&gt;=http://&lt;ip&gt;:2380</code>。</li></ul><p><strong>paste</strong></p><ul><li><code>paste</code> 命令用于合并文件或标准输入的行。</li><li><code>-s</code> 选项将所有输入行合并为单行。</li><li><code>-d,</code> 设定字段间的分隔符为逗号 <code>,</code>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>awk</tag>
      
      <tag>paste</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>etcdctl常用指令.md</title>
    <link href="/2024/03/28/mdstorage/domain/k8s/etcdctl%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2024/03/28/mdstorage/domain/k8s/etcdctl%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看指定 endpoint 状态信息</span><br>./etcdctl endpoint status --endpoints=192.168.122.26:2379  -wtable<br><br><span class="hljs-comment"># 查看 cluster 所有 集群状态信息</span><br>./etcdctl endpoint status --endpoints=192.168.122.26:2379 --cluster  -wtable<br><br>ETCDCTL_API=3 etcdctl --endpoints=http://192.168.122.124:2379 endpoint status --cluster --write-out=table<br><br><span class="hljs-comment"># 查看 集群成员信息</span><br>./etcdctl member list --endpoints=192.168.122.26:2379 -wtable<br></code></pre></td></tr></table></figure><h2 id="如果-member-add-失败后-启动参数需要加上-force-new-cluster"><a href="#如果-member-add-失败后-启动参数需要加上-force-new-cluster" class="headerlink" title="如果 member add 失败后, 启动参数需要加上 -force-new-cluster"></a>如果 member add 失败后, 启动参数需要加上 -force-new-cluster</h2><ol><li>先删除 data&#x2F;member 目录</li><li>重启 etcd 启动参数需要加上 -force-new-cluster<br><a href="https://loverhythm1990.github.io/2022/06/08/etcd-force-newcluster/#force-new-cluster">https://loverhythm1990.github.io/2022/06/08/etcd-force-newcluster/#force-new-cluster</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>k8s</category>
      
    </categories>
    
    
    <tags>
      
      <tag>etcd</tag>
      
      <tag>etcdctl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mermaid时序图.md</title>
    <link href="/2024/03/28/mdstorage/domain/%E6%96%87%E6%A1%A3/mermaid%E6%97%B6%E5%BA%8F%E5%9B%BE/"/>
    <url>/2024/03/28/mdstorage/domain/%E6%96%87%E6%A1%A3/mermaid%E6%97%B6%E5%BA%8F%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>时序图用于表示复杂的时序逻辑演示</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Text">sequenceDiagram<br>participant node1<br>participant node2<br><br>node1-&gt;&gt;node2: 实线表示发送消息<br>node2--&gt;&gt;node1: 虚线表示响应<br><br>%% todo alt ，par 语法<br><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagramparticipant node1participant node2node1-&gt;&gt;node2: 实线表示发送消息node2--&gt;&gt;node1: 虚线表示响应%% todo alt ，par 语法</code></pre><h2 id="时序图风格示例参考"><a href="#时序图风格示例参考" class="headerlink" title="时序图风格示例参考"></a>时序图风格示例参考</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Text">sequenceDiagram<br>participant manager as Manager<br>    participant node1 as node1<br>    participant node2 as node2<br>    participant node3 as node3<br><br><br>manager-&gt;&gt;node1: 建立集群<br>activate node1<br>    node1-&gt;&gt;node1: new cluster node1<br>    node1--&gt;&gt;manager: <br>    deactivate node1<br>    <br>    manager-&gt;&gt;node2: 新增节点2<br>    activate node2<br>    Note over node1,node2: 环境变量中 cluster: node1,node2<br>    node2-&gt;&gt;node1: member add node2<br>    node1--&gt;&gt;node2: <br>    node2-&gt;&gt;node2: node2 start （existing cluster, cluster: node1,node2）<br>    node2--&gt;&gt;manager: <br>    deactivate node2<br>    <br>    manager-&gt;&gt;node3: 新增节点3<br>    activate node3<br>    Note over node1,node3: 环境变量中 cluster: node1,node2,node3<br>    alt request endpoints<br>    node3-&gt;&gt;node1: member add node3<br>    node1--&gt;&gt;node3: <br>    else<br>    node3-&gt;&gt;node2: member add node3<br>    node2--&gt;&gt;node3: <br>    end<br>    node3-&gt;&gt;node3: node3 start（existing cluster, cluster: node1,node2,node3）<br>    node3--&gt;&gt;manager: 响应<br>deactivate node3<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagramparticipant manager as Manager    participant node1 as node1    participant node2 as node2    participant node3 as node3manager-&gt;&gt;node1: 建立集群activate node1    node1-&gt;&gt;node1: new cluster node1    node1--&gt;&gt;manager:     deactivate node1        manager-&gt;&gt;node2: 新增节点2    activate node2    Note over node1,node2: 环境变量中 cluster: node1,node2    node2-&gt;&gt;node1: member add node2    node1--&gt;&gt;node2:     node2-&gt;&gt;node2: node2 start （existing cluster, cluster: node1,node2）    node2--&gt;&gt;manager:     deactivate node2        manager-&gt;&gt;node3: 新增节点3    activate node3    Note over node1,node3: 环境变量中 cluster: node1,node2,node3    alt request endpoints    node3-&gt;&gt;node1: member add node3    node1--&gt;&gt;node3:     else    node3-&gt;&gt;node2: member add node3    node2--&gt;&gt;node3:     end    node3-&gt;&gt;node3: node3 start（existing cluster, cluster: node1,node2,node3）    node3--&gt;&gt;manager: 响应deactivate node3</code></pre>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mermaid</tag>
      
      <tag>时序图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gomodule技巧.md</title>
    <link href="/2024/03/27/mdstorage/domain/golang/gomodule%E6%8A%80%E5%B7%A7/"/>
    <url>/2024/03/27/mdstorage/domain/golang/gomodule%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="replace-将本地目录映射为-package"><a href="#replace-将本地目录映射为-package" class="headerlink" title="replace 将本地目录映射为 package"></a>replace 将本地目录映射为 package</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">replace (<br><span class="hljs-keyword">go</span>.etcd.io/etcd/api/v3 =&gt; ./api<br><span class="hljs-keyword">go</span>.etcd.io/etcd/client/pkg/v3 =&gt; ./client/pkg<br><span class="hljs-keyword">go</span>.etcd.io/etcd/client/v2 =&gt; ./client/internal/v2<br><span class="hljs-keyword">go</span>.etcd.io/etcd/client/v3 =&gt; ./client/v3<br><span class="hljs-keyword">go</span>.etcd.io/etcd/etcdctl/v3 =&gt; ./etcdctl<br><span class="hljs-keyword">go</span>.etcd.io/etcd/etcdutl/v3 =&gt; ./etcdutl<br><span class="hljs-keyword">go</span>.etcd.io/etcd/pkg/v3 =&gt; ./pkg<br><span class="hljs-keyword">go</span>.etcd.io/etcd/server/v3 =&gt; ./server<br><span class="hljs-keyword">go</span>.etcd.io/etcd/tests/v3 =&gt; ./tests<br>) <br></code></pre></td></tr></table></figure><p>替换指令用于将依赖库<code>go.etcd.io/etcd</code>的不同部分替换为本地目录中的相应路径。例如，当项目需要<code>go.etcd.io/etcd/api/v3</code>这个模块时，Go工具链会从本地的<code>./api</code>目录而不是远程仓库加载它。</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>方便迭代</li><li>代码存放路径与导包路径无关（前提是功能独立且封装良好）</li><li>大型项目中适用</li><li>重构项目时适用</li></ul><h3 id="go-mod-download"><a href="#go-mod-download" class="headerlink" title="go mod download"></a>go mod download</h3><p><code>go mod download</code> 是 Go 工具链中与模块管理相关的命令。它的主要作用是下载依赖项并将它们存储在本地模块缓存中。以下是 <code>go mod download</code> 的详细解释：</p><h3 id="go-mod-download-命令概述"><a href="#go-mod-download-命令概述" class="headerlink" title="go mod download 命令概述"></a><code>go mod download</code> 命令概述</h3><p><code>go mod download</code> 命令用于下载当前模块依赖项的所有模块版本（包括直接和间接依赖）并将它们存储在本地模块缓存中。这些模块会被存储在 Go 的模块缓存目录下，通常位于 <code>$GOPATH/pkg/mod</code> 或 <code>$HOME/go/pkg/mod</code>。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><p><strong>下载所有依赖</strong>:</p><ul><li>当你在开发项目时，使用 <code>go mod download</code> 可以提前下载并缓存所有依赖模块，确保后续的编译或构建过程不再需要联网下载依赖。</li></ul></li><li><p><strong>离线构建</strong>:</p><ul><li>你可以在有网络的环境下执行 <code>go mod download</code>，然后在没有网络的环境下进行构建。因为所有的依赖已经被下载并存储在本地缓存中。</li></ul></li><li><p><strong>模块缓存管理</strong>:</p><ul><li><code>go mod download</code> 会下载所有依赖模块到本地缓存中，即使这些依赖还没有被实际使用。这可以帮助开发者提前解决依赖问题。</li></ul></li></ol><h3 id="命令选项和用法"><a href="#命令选项和用法" class="headerlink" title="命令选项和用法"></a>命令选项和用法</h3><ul><li><p><strong>下载当前模块所有依赖</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go mod download<br></code></pre></td></tr></table></figure><p>这个命令会根据当前模块的 <code>go.mod</code> 文件，下载该模块所有的依赖项，包括直接和间接依赖。</p></li><li><p><strong>下载特定模块</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go mod download &lt;module&gt;<br></code></pre></td></tr></table></figure><p>如果你只想下载特定的模块或版本，可以在命令后面加上模块路径和可选的版本号。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go mod download github.com/some/module@v1.2.3<br></code></pre></td></tr></table></figure><p>这个命令会下载 <code>github.com/some/module</code> 模块的 <code>v1.2.3</code> 版本并将其存储到本地缓存中。</p></li><li><p><strong>只解析不下载</strong>:</p><p>如果你只想解析 <code>go.mod</code> 文件但不实际下载依赖项，可以使用 <code>-json</code> 标志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go mod download -json<br></code></pre></td></tr></table></figure><p>这会输出所有依赖的详细信息（包括模块名、版本、是否在本地缓存中等），但不会下载任何模块。</p></li></ul><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><ol><li><p><strong>读取 <code>go.mod</code> 文件</strong>:</p><ul><li><code>go mod download</code> 首先读取项目根目录中的 <code>go.mod</code> 文件，获取该模块的依赖列表。</li></ul></li><li><p><strong>解析依赖树</strong>:</p><ul><li>它解析依赖树，确定哪些模块和版本需要下载。这包括直接依赖和间接依赖（即你的依赖项所依赖的模块）。</li></ul></li><li><p><strong>下载模块</strong>:</p><ul><li>对于每个模块，<code>go mod download</code> 会尝试从模块代理或版本控制系统（如 GitHub）下载模块的源码包，并将其解压存储到本地缓存中。</li></ul></li><li><p><strong>更新本地缓存</strong>:</p><ul><li>下载完成后，模块的源码包和构建缓存会被存储在 <code>$GOPATH/pkg/mod</code> 或 <code>$HOME/go/pkg/mod</code> 目录下。</li></ul></li></ol><h3 id="关联命令"><a href="#关联命令" class="headerlink" title="关联命令"></a>关联命令</h3><ul><li><p><strong><code>go mod tidy</code></strong>:</p><ul><li>这个命令会移除 <code>go.mod</code> 文件中未使用的依赖，并下载缺失的依赖项。它确保 <code>go.mod</code> 和 <code>go.sum</code> 文件的依赖记录是最小且正确的。</li></ul></li><li><p><strong><code>go mod vendor</code></strong>:</p><ul><li>这个命令会将所有依赖的源码复制到 <code>vendor</code> 目录中，这样可以保证构建过程只依赖本地的 <code>vendor</code> 目录，而不依赖网络或模块缓存。</li></ul></li><li><p><strong><code>go mod verify</code></strong>:</p><ul><li>这个命令会验证本地模块缓存中的模块是否匹配 <code>go.sum</code> 文件中的校验和，确保依赖的模块未被篡改。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>go mod download</code> 是 Go 模块管理中一个重要的工具，它帮助开发者预先下载所有依赖模块，以便离线构建或在网络不稳定的环境中工作。通过缓存机制，它还加快了编译和构建的速度，确保每次构建都能使用正确版本的依赖。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>etcd集群安装卸载.md</title>
    <link href="/2024/03/27/mdstorage/domain/k8s/etcd%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD/"/>
    <url>/2024/03/27/mdstorage/domain/k8s/etcd%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="集群安装脚本"><a href="#集群安装脚本" class="headerlink" title="集群安装脚本"></a>集群安装脚本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 函数：创建必要的目录结构</span><br><span class="hljs-function"><span class="hljs-title">create_directories</span></span>() &#123;<br><span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br>&#125;<br><br><span class="hljs-comment"># 创建etcd配置文件</span><br><span class="hljs-function"><span class="hljs-title">create_etcd_config</span></span>() &#123;<br>  <span class="hljs-built_in">local</span> config_file=<span class="hljs-variable">$1</span><br>  <span class="hljs-built_in">local</span> node_name=<span class="hljs-variable">$2</span><br>  <span class="hljs-built_in">local</span> data_dir=<span class="hljs-variable">$3</span><br>  <span class="hljs-built_in">local</span> wal_dir=<span class="hljs-variable">$4</span><br>  <span class="hljs-built_in">local</span> client_url=<span class="hljs-variable">$5</span><br>  <span class="hljs-built_in">local</span> peer_url=<span class="hljs-variable">$6</span><br><span class="hljs-built_in">local</span> cluster_token=<span class="hljs-variable">$7</span><br><span class="hljs-built_in">local</span> cluster=<span class="hljs-variable">$8</span><br><span class="hljs-built_in">local</span> new_opt=<span class="hljs-variable">$&#123;9&#125;</span><br>  <br>  <span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF &gt; &quot;$config_file&quot;</span><br><span class="hljs-string">ETCD_OPTS=&quot;--name $node_name \\</span><br><span class="hljs-string">--max-request-bytes 10485760 \\</span><br><span class="hljs-string">--data-dir $data_dir \\</span><br><span class="hljs-string">--wal-dir $wal_dir \\</span><br><span class="hljs-string">--advertise-client-urls $client_url \\</span><br><span class="hljs-string">--listen-client-urls $client_url \\</span><br><span class="hljs-string">--listen-peer-urls $peer_url \\</span><br><span class="hljs-string">--initial-advertise-peer-urls $peer_url \\</span><br><span class="hljs-string">--initial-cluster-token $&#123;cluster_token&#125; \\</span><br><span class="hljs-string">--initial-cluster $&#123;cluster&#125; \\</span><br><span class="hljs-string">--initial-cluster-state $&#123;new_opt&#125;&quot;</span><br><span class="hljs-string">EOF</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">reload_and_start_etcd</span></span>() &#123;<br>  systemctl daemon-reload<br>  systemctl start etcd<br>&#125;<br><br><span class="hljs-comment"># 函数：配置并启动etcd服务</span><br><span class="hljs-function"><span class="hljs-title">create_etcd_service</span></span>() &#123;<br>  <span class="hljs-built_in">local</span> service_file=<span class="hljs-variable">$1</span><br>  <span class="hljs-built_in">local</span> config_path=<span class="hljs-variable">$2</span><br>  <span class="hljs-built_in">local</span> etcd_executable=<span class="hljs-variable">$3</span><br>  <br>  <span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF &gt; &quot;$service_file&quot;</span><br><span class="hljs-string">[Unit]</span><br><span class="hljs-string">Description=Etcd For Kubernetes</span><br><span class="hljs-string">Wants=network-online.target</span><br><span class="hljs-string">After=network.target network-online.target</span><br><span class="hljs-string"></span><br><span class="hljs-string">[Service]</span><br><span class="hljs-string">EnvironmentFile=$config_path</span><br><span class="hljs-string">ExecStart=$etcd_executable \$ETCD_OPTS</span><br><span class="hljs-string">Restart=always</span><br><span class="hljs-string"></span><br><span class="hljs-string">[Install]</span><br><span class="hljs-string">WantedBy=multi-user.target</span><br><span class="hljs-string">EOF</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">get_etcd_from_local</span></span>() &#123;<br>  <span class="hljs-built_in">local</span> source_path=<span class="hljs-variable">$1</span><br>  <span class="hljs-built_in">local</span> target_dir=<span class="hljs-variable">$2</span><br><br>  <span class="hljs-keyword">if</span> [ ! -f <span class="hljs-string">&quot;<span class="hljs-variable">$source_path</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Source etcd binary does not exist at <span class="hljs-variable">$&#123;source_path&#125;</span>.&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br>  <span class="hljs-keyword">fi</span><br><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Copying etcd binary from <span class="hljs-variable">$&#123;source_path&#125;</span> to <span class="hljs-variable">$&#123;target_dir&#125;</span>...&quot;</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">cp</span> <span class="hljs-string">&quot;<span class="hljs-variable">$source_path</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;target_dir&#125;</span>/etcd&quot;</span>; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">chmod</span> +x <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;target_dir&#125;</span>/etcd&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Successfully copied and prepared etcd binary.&quot;</span><br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Failed to copy etcd binary from <span class="hljs-variable">$&#123;source_path&#125;</span>.&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br>  <span class="hljs-keyword">fi</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">get_etcd_from_remote</span></span>() &#123;<br>  <span class="hljs-built_in">local</span> bin_dir=<span class="hljs-variable">$1</span><br>  <span class="hljs-built_in">local</span> ftpserver=<span class="hljs-variable">$2</span><br>  <span class="hljs-built_in">local</span> http_user=<span class="hljs-variable">$3</span><br>  <span class="hljs-built_in">local</span> http_passwd=<span class="hljs-variable">$4</span><br><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Downloading etcd binary from <span class="hljs-variable">$&#123;ftpserver&#125;</span>...&quot;</span><br>  <span class="hljs-keyword">if</span> wget -P <span class="hljs-string">&quot;<span class="hljs-variable">$bin_dir</span>&quot;</span> --http-user=<span class="hljs-string">&quot;<span class="hljs-variable">$http_user</span>&quot;</span> --http-passwd=<span class="hljs-string">&quot;<span class="hljs-variable">$http_passwd</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;ftpserver&#125;</span>/repo/kubernetes/etcd&quot;</span>; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">chmod</span> +x <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;bin_dir&#125;</span>/etcd&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Successfully downloaded and prepared etcd binary.&quot;</span><br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Failed to download etcd binary from <span class="hljs-variable">$&#123;ftpserver&#125;</span>.&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br>  <span class="hljs-keyword">fi</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">get_etcd</span></span>() &#123;<br>  <span class="hljs-built_in">local</span> option=<span class="hljs-variable">$1</span><br>  <span class="hljs-built_in">local</span> target_dir=<span class="hljs-variable">$2</span><br>  <span class="hljs-built_in">local</span> source_path_or_url=<span class="hljs-variable">$3</span><br>  <span class="hljs-built_in">local</span> http_user=<span class="hljs-variable">$4</span> <span class="hljs-comment"># 仅 remote 时需要</span><br>  <span class="hljs-built_in">local</span> http_passwd=<span class="hljs-variable">$5</span> <span class="hljs-comment"># 仅 remote 时需要</span><br><br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$option</span>&quot;</span> <span class="hljs-keyword">in</span><br>    <span class="hljs-string">&quot;local&quot;</span>)<br>      get_etcd_from_local <span class="hljs-string">&quot;<span class="hljs-variable">$source_path_or_url</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$target_dir</span>&quot;</span><br>      ;;<br>    <span class="hljs-string">&quot;remote&quot;</span>)<br>      get_etcd_from_remote <span class="hljs-string">&quot;<span class="hljs-variable">$target_dir</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$source_path_or_url</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$http_user</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$http_passwd</span>&quot;</span><br>      ;;<br>    *)<br>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Invalid option: <span class="hljs-variable">$option</span>. Please choose &#x27;local&#x27; or &#x27;remote&#x27;.&quot;</span><br>      <span class="hljs-built_in">exit</span> 1<br>      ;;<br>  <span class="hljs-keyword">esac</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">list_etcd_members</span></span>() &#123;<br>  <span class="hljs-built_in">local</span> server_url=<span class="hljs-variable">$1</span><br><br>  <span class="hljs-comment"># todo --user --cert --key </span><br>  curl -X POST <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;server_url&#125;</span>/v3/cluster/member/list&quot;</span> \<br>    -H <span class="hljs-string">&quot;Content-Type: application/json&quot;</span> \<br>    -d <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">add_etcd_member_by_curl</span></span>() &#123;<br>  <span class="hljs-built_in">local</span> server_url=<span class="hljs-variable">$1</span><br>  <span class="hljs-built_in">local</span> peer_url=<span class="hljs-variable">$2</span><br><br>  <span class="hljs-comment"># 构造请求体</span><br>  <span class="hljs-built_in">local</span> data=$(<span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">  &quot;peerURLs&quot;: [&quot;$peer_url&quot;]</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">EOF</span><br>)<br><br>  <span class="hljs-comment"># 发送请求</span><br>  curl -X POST <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;server_url&#125;</span>/v3/cluster/member/add&quot;</span> \<br>       -H <span class="hljs-string">&quot;Content-Type: application/json&quot;</span> \<br>       -d <span class="hljs-string">&quot;<span class="hljs-variable">$data</span>&quot;</span><br>&#125;<br><br><br><span class="hljs-comment"># 主函数：安装etcd集群节点</span><br><span class="hljs-function"><span class="hljs-title">install_etcd_cluster_node</span></span>() &#123;<br>  <span class="hljs-built_in">local</span> node_name=<span class="hljs-variable">$1</span><br>  <span class="hljs-built_in">local</span> node_ip=<span class="hljs-variable">$2</span><br>  <span class="hljs-built_in">local</span> cluster_ips=<span class="hljs-variable">$3</span><br><span class="hljs-built_in">local</span> new_opt=<span class="hljs-variable">$4</span><br><br>  <span class="hljs-built_in">local</span> data_dir=<span class="hljs-string">&quot;/opt/k8s/data&quot;</span><br>  <span class="hljs-built_in">local</span> wal_dir=<span class="hljs-string">&quot;/opt/k8s/wal&quot;</span><br>  <span class="hljs-built_in">local</span> bin_dir=<span class="hljs-string">&quot;/opt/k8s/bin&quot;</span><br>  <span class="hljs-built_in">local</span> work_dir=<span class="hljs-string">&quot;/opt/k8s/work&quot;</span><br>  <span class="hljs-built_in">local</span> ftpserver=<span class="hljs-string">&quot;http://119.91.145.27:12800&quot;</span><br>  <span class="hljs-built_in">local</span> http_user=<span class="hljs-string">&quot;team&quot;</span><br>  <span class="hljs-built_in">local</span> http_passwd=<span class="hljs-string">&quot;xdmybl&quot;</span><br>  <span class="hljs-built_in">local</span> config_file=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;work_dir&#125;</span>/etcd.conf&quot;</span><br>  <span class="hljs-built_in">local</span> service_file=<span class="hljs-string">&quot;/lib/systemd/system/etcd.service&quot;</span><br>  <span class="hljs-built_in">local</span> etcd_executable=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;bin_dir&#125;</span>/etcd&quot;</span><br><span class="hljs-built_in">local</span> etcd_src_path=<span class="hljs-string">&quot;/opt/etcd&quot;</span><br><span class="hljs-built_in">local</span> cluster_gs=<span class="hljs-string">&quot;cluster_token1&quot;</span><br><br><span class="hljs-built_in">local</span> client_url=<span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;node_ip&#125;</span>:2379&quot;</span><br><span class="hljs-built_in">local</span> listen_peer_url=<span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;node_ip&#125;</span>:2380&quot;</span><br><br>  <span class="hljs-comment"># 创建所需目录</span><br>  create_directories <span class="hljs-string">&quot;<span class="hljs-variable">$data_dir</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$wal_dir</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$bin_dir</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$work_dir</span>&quot;</span><br><br>  create_etcd_config <span class="hljs-string">&quot;<span class="hljs-variable">$config_file</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$node_name</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$data_dir</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$wal_dir</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$client_url</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;listen_peer_url&#125;</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;cluster_gs&#125;</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;cluster_ips&#125;</span>&quot;</span> <span class="hljs-variable">$&#123;new_opt&#125;</span><br><br>  create_etcd_service <span class="hljs-string">&quot;<span class="hljs-variable">$service_file</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$config_file</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$etcd_executable</span>&quot;</span><br>  <span class="hljs-comment"># 下载etcd二进制文件</span><br>get_etcd <span class="hljs-string">&quot;local&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$bin_dir</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$etcd_src_path</span>&quot;</span><br>  reload_and_start_etcd<br>  <span class="hljs-comment"># 配置并启动etcd服务</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">extract_hosts_to_cluster_info</span></span>() &#123;<br>                <span class="hljs-built_in">local</span> hosts_file=<span class="hljs-variable">$1</span><br>                <span class="hljs-built_in">local</span> cluster_info=$(awk <span class="hljs-string">&#x27;/^\s*[^#]/ &amp;&amp; $2 ~ /.srhino.svc.local$/ &amp;&amp; $2 !~ /^s/ &amp;&amp; $2 !~ /^localhost/ &#123;sub(/\.srhino\.svc\.local$/, &quot;&quot;, $2); print $2&quot;=http://&quot;$1&quot;:2380&quot;&#125;&#x27;</span> <span class="hljs-variable">$&#123;hosts_file&#125;</span> | <span class="hljs-built_in">paste</span> -sd,)<br>                <span class="hljs-built_in">echo</span> <span class="hljs-variable">$cluster_info</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="安装三节点（建立三节点），适用于创建集群时，直接声明集群三节点"><a href="#安装三节点（建立三节点），适用于创建集群时，直接声明集群三节点" class="headerlink" title="安装三节点（建立三节点），适用于创建集群时，直接声明集群三节点"></a>安装三节点（建立三节点），适用于创建集群时，直接声明集群三节点</h3><h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><pre><code class=" mermaid">sequenceDiagram    participant Manager as Manager    participant Node1 as node1    participant Node2 as node2    participant Node3 as node3    par 建立新集群        Manager-&gt;&gt;Node1: new cluster: node1, node2, node3        Manager-&gt;&gt;Node2: new cluster: node1, node2, node3        Manager-&gt;&gt;Node3: new cluster: node1, node2, node3    and 相应节点响应        Node1--&gt;&gt;Manager: 响应        Node2--&gt;&gt;Manager: 响应        Node3--&gt;&gt;Manager: 响应    end    Note over Manager,Node3: etcd 初始集群建立完成</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 并发执行三节点安装</span><br>ssh -n root@192.168.122.26 <span class="hljs-string">&quot;cd /opt &amp;&amp; ./install_cluster.sh&quot;</span> &amp;<br>ssh -n root@192.168.122.35 <span class="hljs-string">&quot;cd /opt &amp;&amp; ./install_cluster.sh&quot;</span> &amp;<br>ssh -n root@192.168.122.238 <span class="hljs-string">&quot;cd /opt &amp;&amp; ./install_cluster.sh&quot;</span> &amp;<br><br><span class="hljs-built_in">wait</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">source</span> ./install_cluster_lib.sh <br><span class="hljs-comment"># first node param</span><br><span class="hljs-comment">#local_ip=&quot;ouryun.node2.com&quot;</span><br>local_ip=<span class="hljs-string">&quot;192.168.122.26&quot;</span><br>local_host=<span class="hljs-string">&quot;node1&quot;</span><br><span class="hljs-comment"># 三节点都需要是 new</span><br>new_opt=<span class="hljs-string">&quot;new&quot;</span><br><span class="hljs-comment"># 这里包含集群信息</span><br>cluster_info=<span class="hljs-string">&quot;node1=http://192.168.122.26:2380,node2=http://192.168.122.35:2380,node3=http://192.168.122.237:2380&quot;</span><br><br><span class="hljs-comment"># 使用示例</span><br><span class="hljs-comment"># install_etcd_cluster_node &quot;node1&quot; &quot;192.168.1.1&quot; &quot;node1=http://192.168.1.1:2380,node2=http://192.168.1.2:2380,node3=http://192.168.1.3:2380&quot;</span><br>install_etcd_cluster_node <span class="hljs-variable">$local_host</span> <span class="hljs-variable">$local_ip</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;cluster_info&#125;</span>&quot;</span>  <span class="hljs-variable">$&#123;new_opt&#125;</span><br></code></pre></td></tr></table></figure><h3 id="安装三节点（先创建一个节点的集群，再加入-node2-，再加入-node3），适用于往已有集群加入新节点"><a href="#安装三节点（先创建一个节点的集群，再加入-node2-，再加入-node3），适用于往已有集群加入新节点" class="headerlink" title="安装三节点（先创建一个节点的集群，再加入 node2 ，再加入 node3），适用于往已有集群加入新节点"></a>安装三节点（先创建一个节点的集群，再加入 node2 ，再加入 node3），适用于往已有集群加入新节点</h3><h4 id="时序图-1"><a href="#时序图-1" class="headerlink" title="时序图"></a>时序图</h4><pre><code class=" mermaid">sequenceDiagramparticipant manager as Manager    participant Node1 as node1    participant Node2 as node2    participant Node3 as node3manager-&gt;&gt;Node1: 建立集群activate Node1    Node1-&gt;&gt;Node1: new cluster node1    Node1--&gt;&gt;manager:     deactivate Node1        manager-&gt;&gt;Node2: 新增节点2    activate Node2    Note over Node1,Node2: 环境变量中 cluster: node1,node2    Node2-&gt;&gt;Node1: member add node2    Node1--&gt;&gt;Node2:     Node2-&gt;&gt;Node2: node2 start （existing cluster, cluster: node1,node2）    Node2--&gt;&gt;manager:     deactivate Node2        manager-&gt;&gt;Node3: 新增节点3    activate Node3    Note over Node1,Node3: 环境变量中 cluster: node1,node2,node3    alt request endpoints    Node3-&gt;&gt;Node1: member add node3    Node1--&gt;&gt;Node3:     else    Node3-&gt;&gt;Node2: member add node3    Node2--&gt;&gt;Node3:     end    Node3-&gt;&gt;Node3: node3 start（existing cluster, cluster: node1,node2,node3）    Node3--&gt;&gt;manager: 响应deactivate Node3</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># install_etcd_first.sh</span><br><span class="hljs-comment">#!/bin/bash</span><br><br><span class="hljs-built_in">source</span> ./install_cluster_lib.sh <br><span class="hljs-comment"># first node param</span><br>local_ip=<span class="hljs-string">&quot;192.168.122.26&quot;</span><br>local_host=<span class="hljs-string">&quot;node1&quot;</span><br>new_opt=<span class="hljs-string">&quot;new&quot;</span><br><span class="hljs-comment"># 这里包含集群信息</span><br>existing_node_info=<span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-comment"># 使用示例</span><br><span class="hljs-comment"># install_etcd_cluster_node &quot;node1&quot; &quot;192.168.1.1&quot; &quot;node1=http://192.168.1.1:2380,node2=http://192.168.1.2:2380,node3=http://192.168.1.3:2380&quot;</span><br><br>install_etcd_cluster_node <span class="hljs-variable">$local_host</span> <span class="hljs-variable">$local_ip</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;local_host&#125;</span>=http://<span class="hljs-variable">$&#123;local_ip&#125;</span>:2380&quot;</span> <span class="hljs-variable">$&#123;new_opt&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># install_etcd_other.sh</span><br><br><span class="hljs-comment"># other node param</span><br><br><span class="hljs-built_in">source</span> ./install_cluster_lib.sh <br><br>local_ip=<span class="hljs-string">&quot;192.168.122.35&quot;</span><br>local_host=<span class="hljs-string">&quot;node2&quot;</span><br>new_opt=<span class="hljs-string">&quot;existing&quot;</span><br>existing_node_info=<span class="hljs-string">&quot;node1=http://192.168.122.26:2380&quot;</span><br><br><span class="hljs-comment"># 使用示例</span><br><span class="hljs-comment"># install_etcd_cluster_node &quot;node1&quot; &quot;192.168.1.1&quot; &quot;node1=http://192.168.1.1:2380,node2=http://192.168.1.2:2380,node3=http://192.168.1.3:2380&quot;</span><br>install_etcd_cluster_node <span class="hljs-variable">$local_host</span> <span class="hljs-variable">$local_ip</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;existing_node_info&#125;</span>,<span class="hljs-variable">$&#123;local_host&#125;</span>=http://<span class="hljs-variable">$&#123;local_ip&#125;</span>:2380&quot;</span> <span class="hljs-variable">$&#123;new_opt&#125;</span><br></code></pre></td></tr></table></figure><h3 id="新增集群节点"><a href="#新增集群节点" class="headerlink" title="新增集群节点"></a>新增集群节点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># member_add_by_etcdctl.sh</span><br><span class="hljs-comment"># 新增集群</span><br><span class="hljs-function"><span class="hljs-title">member_add_by_etcdctl</span></span>() &#123;<br>  <span class="hljs-built_in">local</span> new_member_name=<span class="hljs-variable">$1</span><br>  <span class="hljs-built_in">local</span> new_member_peer_url=<span class="hljs-variable">$2</span><br>  <span class="hljs-built_in">local</span> existing_member_client_urls=<span class="hljs-variable">$3</span><br><br>  <span class="hljs-comment"># 设置ETCDCTL_API版本，确保使用v3 API</span><br>  <span class="hljs-built_in">export</span> ETCDCTL_API=3<br><br>  <span class="hljs-comment"># 添加新成员到集群</span><br>  etcdctl --endpoints=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;existing_member_client_urls&#125;</span>&quot;</span> \<br>    member add <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;new_member_name&#125;</span>&quot;</span> \<br>    --peer-urls=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;new_member_peer_url&#125;</span>&quot;</span><br><br>  <span class="hljs-comment"># 检查命令执行的退出状态</span><br>  <span class="hljs-keyword">if</span> [ $? -eq 0 ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Member <span class="hljs-variable">$&#123;new_member_name&#125;</span> successfully added to the cluster.&quot;</span><br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Failed to add member <span class="hljs-variable">$&#123;new_member_name&#125;</span> to the cluster.&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br>  <span class="hljs-keyword">fi</span><br>&#125;<br><br><span class="hljs-comment"># member_id=&quot;node2&quot;</span><br><span class="hljs-comment"># member_url=&quot;http://192.168.122.35:2380&quot;</span><br><span class="hljs-comment"># access_endpoint_url=&quot;http://192.168.122.26:2379&quot;</span><br><br><span class="hljs-comment"># # 新增集群成员</span><br><span class="hljs-comment"># member_add &quot;node2&quot; &quot;http://192.168.122.35:2380&quot; &quot;http://192.168.122.26:2379&quot;</span><br>member_id=<span class="hljs-string">&quot;node3&quot;</span><br>member_url=<span class="hljs-string">&quot;http://192.168.122.237:2380&quot;</span><br>access_endpoint_url=<span class="hljs-string">&quot;http://192.168.122.26:2379&quot;</span><br><br><span class="hljs-comment"># 新增集群成员</span><br>member_add_by_etcdctl <span class="hljs-variable">$&#123;member_id&#125;</span> <span class="hljs-variable">$&#123;member_url&#125;</span> <span class="hljs-variable">$&#123;access_endpoint_url&#125;</span><br></code></pre></td></tr></table></figure><h2 id="卸载-etcd"><a href="#卸载-etcd" class="headerlink" title="卸载 etcd"></a>卸载 etcd</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># uninstall_etcd.sh</span><br><br><span class="hljs-comment">#!/bin/bash</span><br><br><span class="hljs-comment"># 停止etcd服务</span><br><span class="hljs-function"><span class="hljs-title">stop_etcd_service</span></span>() &#123;<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Stopping etcd service...&quot;</span><br>  systemctl stop etcd<br>&#125;<br><br><span class="hljs-comment"># 禁用etcd服务</span><br><span class="hljs-function"><span class="hljs-title">disable_etcd_service</span></span>() &#123;<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Disabling etcd service...&quot;</span><br>  systemctl <span class="hljs-built_in">disable</span> etcd<br>&#125;<br><br><span class="hljs-comment"># 删除etcd服务文件</span><br><span class="hljs-function"><span class="hljs-title">remove_etcd_service_file</span></span>() &#123;<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Removing etcd service file...&quot;</span><br>  <span class="hljs-built_in">rm</span> -f /lib/systemd/system/etcd.service<br>&#125;<br><br><span class="hljs-comment"># 重新加载systemd守护进程</span><br><span class="hljs-function"><span class="hljs-title">reload_systemd</span></span>() &#123;<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Reloading systemd daemon...&quot;</span><br>  systemctl daemon-reload<br>&#125;<br><br><span class="hljs-comment"># 删除etcd二进制文件和数据目录</span><br><span class="hljs-function"><span class="hljs-title">cleanup_etcd_files</span></span>() &#123;<br>  <span class="hljs-built_in">local</span> bin_dir=<span class="hljs-string">&quot;/opt/k8s/bin&quot;</span><br>  <span class="hljs-built_in">local</span> data_dir=<span class="hljs-string">&quot;/opt/k8s/data&quot;</span><br>  <span class="hljs-built_in">local</span> wal_dir=<span class="hljs-string">&quot;/opt/k8s/wal&quot;</span><br>  <span class="hljs-built_in">local</span> work_dir=<span class="hljs-string">&quot;/opt/k8s/work&quot;</span><br><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Cleaning up etcd binary and data directories...&quot;</span><br>  <span class="hljs-built_in">rm</span> -f <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;bin_dir&#125;</span>/etcd&quot;</span><br>  <span class="hljs-built_in">rm</span> -rf <span class="hljs-string">&quot;<span class="hljs-variable">$data_dir</span>&quot;</span><br>  <span class="hljs-built_in">rm</span> -rf <span class="hljs-string">&quot;<span class="hljs-variable">$wal_dir</span>&quot;</span><br>  <span class="hljs-built_in">rm</span> -rf <span class="hljs-string">&quot;<span class="hljs-variable">$work_dir</span>&quot;</span><br>&#125;<br><br><span class="hljs-comment"># 卸载etcd的主函数</span><br><span class="hljs-function"><span class="hljs-title">uninstall_etcd</span></span>() &#123;<br>  stop_etcd_service<br>  disable_etcd_service<br>  remove_etcd_service_file<br>  reload_systemd<br>  cleanup_etcd_files<br>  <br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;etcd has been successfully uninstalled.&quot;</span><br>&#125;<br><br><span class="hljs-comment"># 执行卸载</span><br>uninstall_etcd<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>k8s</category>
      
    </categories>
    
    
    <tags>
      
      <tag>etcd</tag>
      
      <tag>cluster</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>case语法.md</title>
    <link href="/2024/03/27/mdstorage/domain/shell/case%E8%AF%AD%E6%B3%95/"/>
    <url>/2024/03/27/mdstorage/domain/shell/case%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">case</span> 值 <span class="hljs-keyword">in</span><br>模式1)<br>    command1<br>    command2<br>    command3<br>    ;;<br>模式2）<br>    command1<br>    command2<br>    command3<br>    ;;<br>*)<br>    command1<br>    command2<br>    command3<br>    ;;<br><span class="hljs-keyword">esac</span><br><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">get_etcd</span></span>() &#123;<br>  <span class="hljs-built_in">local</span> option=<span class="hljs-variable">$1</span><br>  <span class="hljs-built_in">local</span> target_dir=<span class="hljs-variable">$2</span><br>  <span class="hljs-built_in">local</span> source_path_or_url=<span class="hljs-variable">$3</span><br>  <span class="hljs-built_in">local</span> http_user=<span class="hljs-variable">$4</span> <span class="hljs-comment"># 仅 remote 时需要</span><br>  <span class="hljs-built_in">local</span> http_passwd=<span class="hljs-variable">$5</span> <span class="hljs-comment"># 仅 remote 时需要</span><br><br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$option</span>&quot;</span> <span class="hljs-keyword">in</span><br>    <span class="hljs-string">&quot;local&quot;</span>)<br>      get_etcd_from_local <span class="hljs-string">&quot;<span class="hljs-variable">$source_path_or_url</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$target_dir</span>&quot;</span><br>      ;;<br>    <span class="hljs-string">&quot;remote&quot;</span>)<br>      get_etcd_from_remote <span class="hljs-string">&quot;<span class="hljs-variable">$target_dir</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$source_path_or_url</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$http_user</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$http_passwd</span>&quot;</span><br>      ;;<br>    *)<br>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Invalid option: <span class="hljs-variable">$option</span>. Please choose &#x27;local&#x27; or &#x27;remote&#x27;.&quot;</span><br>      <span class="hljs-built_in">exit</span> 1<br>      ;;<br>  <span class="hljs-keyword">esac</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
      <tag>bash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sudo-edit.md</title>
    <link href="/2024/03/27/mdstorage/domain/ide/emacs/sudo-edit/"/>
    <url>/2024/03/27/mdstorage/domain/ide/emacs/sudo-edit/</url>
    
    <content type="html"><![CDATA[<h2 id="sudo-edit-插件"><a href="#sudo-edit-插件" class="headerlink" title="sudo-edit 插件"></a>sudo-edit 插件</h2><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>以 sudo 打开本地文件</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>M-x package-install RET sudo-edit</code></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>打开文件 <code>M-x sudo-edit</code> 输入密码即可，如果不出现密码输入是正则匹配出问题，修改 init.el 配置，<code>(setq tramp-password-prompt-regexp &quot;^.*\\(\\(?:adgangskode\\|contrase\\(?:\\(?:ny\\|ñ\\)a\\)\\|decryption key\\|encryption key\\|geslo\\|h\\(?:\\(?:asł\\|esl\\)o\\)\\|iphasiwedi\\|jelszó\\|l\\(?:ozinka\\|ösenord\\)\\|m\\(?:ot de passe\\|ật khẩu\\)\\|p\\(?:a\\(?:rola\\|s\\(?:ahitza\\|s\\(?: phrase\\|code\\|ord\\|phrase\\|wor[dt]\\)\\|vorto\\)\\)\\|in\\)\\|s\\(?:alasana\\|enha\\|laptažodis\\)\\|wachtwoord\\|лозинка\\|пароль\\|ססמה\\|كلمة السر\\|गुप्तशब्द\\|शब्दकूट\\|গুপ্তশব্দ\\|পাসওয়ার্ড\\|ਪਾਸਵਰਡ\\|પાસવર્ડ\\|ପ୍ରବେଶ ସଙ୍କେତ\\|கடவுச்சொல்\\|సంకేతపదము\\|ಗುಪ್ತಪದ\\|അടയാളവാക്ക്\\|රහස්පදය\\|ពាក្យសម្ងាត់\\|パスワード\\|密[码碼]\\|암호\\)\\).*[:：]\0? *&quot;)</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>ide</category>
      
      <category>emacs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>plugin</tag>
      
      <tag>emacs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打开远程文件.md</title>
    <link href="/2024/03/27/mdstorage/domain/ide/emacs/%E6%89%93%E5%BC%80%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6/"/>
    <url>/2024/03/27/mdstorage/domain/ide/emacs/%E6%89%93%E5%BC%80%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><code>https://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html</code></p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>ide</category>
      
      <category>emacs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>emacs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>client-go连接apiserver.md</title>
    <link href="/2024/03/22/mdstorage/domain/k8s/client-go%E8%BF%9E%E6%8E%A5apiserver/"/>
    <url>/2024/03/22/mdstorage/domain/k8s/client-go%E8%BF%9E%E6%8E%A5apiserver/</url>
    
    <content type="html"><![CDATA[<h2 id="token-连接"><a href="#token-连接" class="headerlink" title="token 连接"></a>token 连接</h2><h2 id="apiserver-静态-token-进行连接"><a href="#apiserver-静态-token-进行连接" class="headerlink" title="apiserver 静态 token 进行连接"></a>apiserver 静态 token 进行连接</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>metav1 <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><span class="hljs-string">&quot;k8s.io/client-go/kubernetes&quot;</span><br><span class="hljs-string">&quot;k8s.io/client-go/rest&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span> &#123;<br>config := &amp;rest.Config&#123;<br><span class="hljs-comment">// 指定API服务器的地址</span><br>Host: <span class="hljs-string">&quot;https://192.168.122.127:6443&quot;</span>,<br><span class="hljs-comment">// 指定用于身份验证的Bearer Token</span><br>BearerToken: <span class="hljs-string">&quot;a1232123131231231231231231233112&quot;</span>,   <span class="hljs-comment">// cluster-admin token</span><br><span class="hljs-comment">// 忽略SSL证书验证，仅在测试环境下使用</span><br>TLSClientConfig: rest.TLSClientConfig&#123;Insecure: <span class="hljs-literal">true</span>&#125;,<br>&#125;<br><br><span class="hljs-comment">// 使用配置创建Kubernetes客户端</span><br>clientset, err := kubernetes.NewForConfig(config)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-comment">// 使用clientset进行操作，例如列出所有命名空间</span><br>namespaces, err := clientset.CoreV1().Namespaces().List(context.TODO(), metav1.ListOptions&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">for</span> _, ns := <span class="hljs-keyword">range</span> namespaces.Items &#123;<br>fmt.Println(ns.Name)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>k8s</category>
      
    </categories>
    
    
    <tags>
      
      <tag>apiserver</tag>
      
      <tag>client-go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强制用户登出.md</title>
    <link href="/2024/03/22/mdstorage/domain/linux/%E5%BC%BA%E5%88%B6%E7%94%A8%E6%88%B7%E7%99%BB%E5%87%BA/"/>
    <url>/2024/03/22/mdstorage/domain/linux/%E5%BC%BA%E5%88%B6%E7%94%A8%E6%88%B7%E7%99%BB%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>rdp 时、用户不登出、rdp 远程无法建立</p><h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">loginctl list-sessions<br><br><span class="hljs-built_in">sudo</span> loginctl terminate-session <span class="hljs-variable">$SESSION_ID</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>desktop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件说明文档.md</title>
    <link href="/2024/03/20/mdstorage/project/cToRust/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/"/>
    <url>/2024/03/20/mdstorage/project/cToRust/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="软件说明文档"><a href="#软件说明文档" class="headerlink" title="软件说明文档"></a>软件说明文档</h1><h2 id="软件名"><a href="#软件名" class="headerlink" title="软件名"></a>软件名</h2><p><code>cust</code> </p><p>C程序转换器</p><h2 id="功能摘要"><a href="#功能摘要" class="headerlink" title="功能摘要"></a>功能摘要</h2><ol><li>提供命令行工具将目标 C&#x2F;C++ 语言源码，转换为相应 Rust 语言代码</li></ol><h2 id="软件分类"><a href="#软件分类" class="headerlink" title="软件分类"></a>软件分类</h2><p>linux CLI 工具</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>C: 指 C&#x2F;C++ 语言，后面简化称为 C</p><p>src code: 源语言，指待转换的语言，本次的指 C</p><p>AST: 抽象语法树</p><p>IR: Intermediate Representation 中间表示，与语言无关，硬件无关，容易进行优化，多级表示，丰简由人，这适合在 C to Rust 应用中使用。</p><h2 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h2><p>对于如军工、医疗、航天、核能领域，需要一种运行效率、内存安全、稳定性方面有严格要求的语言进行应用程序实现，当已有的 C&#x2F;C++ 程序满足不了这些要求时，就需要将现有的 C&#x2F;C++ 程序、工具库转换为可用的 Rust 程序。<code>cust</code>即可适用于此场景。</p><h2 id="开源许可证类型"><a href="#开源许可证类型" class="headerlink" title="开源许可证类型"></a>开源许可证类型</h2><p>GPL v3</p><h2 id="作品概述"><a href="#作品概述" class="headerlink" title="作品概述"></a>作品概述</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>目标：C&#x2F;C++ 程序转换为 Rust 程序</li></ul><h3 id="作品特点"><a href="#作品特点" class="headerlink" title="作品特点"></a>作品特点</h3><ul><li><p>结合编译原理和现有的 AI 大模型各自优势，将 C&#x2F;C++ 程序转换为可用的 Rust 程序</p></li><li><p>利用编译原理，src code （本次工具中为 C）转换 AST ， AST 再成与 IR （中间语言的形式），再将 IR 语言转换为 Rust 语言，这样做的好处是可以利用这一思路最大程度复用代码，如 src code -&gt;  IR 这部分代码可复用于转换为其他目标语言，而 IR  -&gt; Rust code 部分代码可复用到不同的 src code -&gt; Rust code。</p><p>同时，C to Rust 中采用 IR 的方式有诸多优势：</p><ul><li><strong>硬件无关</strong>：IR 设计成独立于任何特定的硬件或指令集架构（ISA），适用于多种硬件平台，也就是说转义出来的目标语言天然跨平台。</li><li><strong>容易进行优化</strong>：IR 通常设计得使得对代码进行分析和优化变得更加容易，开发路径也相对简单，易进行迭代开发。</li><li><strong>多级表示</strong>：可使用多级别的 IR，每个级别提供不同的抽象程度。</li></ul></li></ul><h3 id="运行环境和运行步骤"><a href="#运行环境和运行步骤" class="headerlink" title="运行环境和运行步骤"></a>运行环境和运行步骤</h3><h4 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h4><p>clang llvm 环境，支持 Linux ，不支持 windows</p><p>rust cargo 环境</p><h4 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h4><p>clang llvm 环境，支持 Linux ，不支持 windows</p><p>使用 ai 优化需要能连上通义的接口（外网）</p><h3 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h3><ul><li><p>完全使用语义解析进行 C To Rust 转换</p></li><li><p>采用语义解析 C To Rust、将上下文和结果输入到 AI 大模型进行语义检查和最后的优化。 </p></li><li><p>C 语言代码排错</p><ul><li><strong>语法错误</strong>：这是编程中最常见的错误类型，如缺少分号、括号不匹配、错误的关键字使用等。如果代码中存在语法错误，编译器将无法正确理解代码，从而无法继续编译过程。</li><li><strong>类型错误</strong>：类型错误发生在对变量或表达式进行了不允许或预期之外的操作时，例如将整数类型赋值给字符类型变量，或对字符串执行数学运算。</li><li><strong>声明和定义错误</strong>：包括变量或函数未声明、重复声明、缺少必要的头文件导入等。</li><li><strong>作用域问题</strong>：尝试访问仅在另一个作用域中定义的变量或函数时，会发生作用域错误。</li><li><strong>链接错误</strong>：如果代码中存在对未定义或未实现的外部函数或变量的引用，进行完整编译过程时会被识别为链接错误。</li><li><strong>警告</strong>：警告不会阻止代码的编译，但它们指出了可能导致运行时错误的代码实践，如可能的变量未初始化、未使用的变量、潜在的类型转换问题等</li><li><strong>内存访问错误</strong>：会静态检测到潜在的内存访问问题，如数组越界访问、解引用空指针等，尽管许多此类错误需要运行时检查来发现。</li><li><strong>优化建议</strong>：提出代码优化的建议，以改善性能或减少内存消耗，虽然这通常不会影响编译过程的成功与否。</li><li><strong>标准遵从性</strong>：会检查代码是否遵循了选定的 C 语言标准（如 C99、C11 等），包括对废弃特性的使用警告等。</li></ul></li><li><p>支持文件输入和字符串输入代码</p><ul><li><p>–file file_path 输入文件输入代码</p></li><li><p>–code “” 字符串输入代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">./cust -c <span class="hljs-string">&quot;<span class="hljs-subst">$(cat &lt;&lt;EOF</span></span><br><span class="hljs-subst"><span class="hljs-string">#include &lt;iostream&gt;</span></span><br><span class="hljs-subst"><span class="hljs-string">#include &lt;cstdarg&gt;</span></span><br><span class="hljs-subst"><span class="hljs-string"></span></span><br><span class="hljs-subst"><span class="hljs-string">void print_values(int n, ...)</span> &#123;</span><br><span class="hljs-string">    va_list vl;</span><br><span class="hljs-string">    va_start(vl, n);</span><br><span class="hljs-string">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="hljs-string">        int value = va_arg(vl, int);</span><br><span class="hljs-string">        std::cout &lt;&lt; &quot;</span>Value: <span class="hljs-string">&quot; &lt;&lt; value &lt;&lt; &quot;</span>\\n<span class="hljs-string">&quot;;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    va_end(vl);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">int main() &#123;</span><br><span class="hljs-string">    print_values(3, 10, 20, 30);</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">EOF</span><br><span class="hljs-string">)&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>支持输出到 stdout 和文件</p></li><li><p>-o stdout | dst_file_path 输出定向到标准输出或目标文件中</p></li></ul><h3 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h3><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><pre><code class=" mermaid">graph TB;符号表src[字符流]:::no_borderan1[词法分析器]an2[语法分析]an3[语义分析]code_gen1[中间代码生成器]code_opt[语言无关代码优化器]code_gen2[代码生成器]code_gen3[机器相关代码优化器]dst[目标语言]:::no_bordersrc --&gt; an1 --&gt;|符号流| an2 --&gt;|语法树| an3 --&gt;|语法树| code_gen1 --&gt;|中间表示形式| code_opt --&gt;|中间表示形式| code_gen2 --&gt;|目标机器语言| code_gen3 --&gt; dstclassDef no_border fill:transparent, stroke:transparent ;</code></pre><h5 id="解析对象和流程"><a href="#解析对象和流程" class="headerlink" title="解析对象和流程"></a>解析对象和流程</h5><pre><code class=" mermaid">---title: 解析对象和流程---graph TB;src[用户输入]:::no_border    subgraph Cust[cust 程序]        an1[获取用户输入 file is-ai-opt output]        an2[检查C代码正确性]        an3[语法、语义、词法分析]        code_gen1[中间代码生成器]        code_opt[中间代码优化器]        code_gen2[Rust 代码生成器]        code_gen3[Rust 代码优化器]        code_opt2[ai 优化]        dst[Rust 代码输出]:::no_borderend    src --&gt; an1 --&gt;|获取待解析的C代码| an2 --&gt;|待解析的C代码| an3 --&gt;|语法树 AST| code_gen1 --&gt;|中间表示形式 IR| code_opt --&gt;|中间表示形式 IR| code_gen2 --&gt;|Rust 语言| code_gen3 --&gt; dst    an1 &amp; an2 &amp; an3 &amp; code_gen1 &amp; code_opt &amp; code_gen2 &amp; code_gen3 ---&gt; code_opt2 ---&gt; dstclassDef no_border fill:transparent, stroke:transparent ;</code></pre><h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><pre><code class=" mermaid">sequenceDiagram    participant UserInput as 用户输入    participant CustProgram as cust 程序    participant CCheck as 检查C代码正确性    participant Analysis as 语法、语义、词法分析    participant IRGen as 中间代码生成器    participant IROpt as 中间代码优化器    participant RustCodeGen as Rust 代码生成器    participant RustOpt as Rust 代码优化器    participant AIOpt as ai 优化    participant RustOutput as Rust 代码输出    UserInput-&gt;&gt;CustProgram: 获取用户输入    CustProgram-&gt;&gt;CCheck: 获取待解析的C代码    CCheck-&gt;&gt;Analysis: 待解析的C代码    Analysis-&gt;&gt;IRGen: 语法树 AST    IRGen-&gt;&gt;IROpt: 中间表示形式 IR    IROpt-&gt;&gt;RustCodeGen: 中间表示形式 IR    RustCodeGen-&gt;&gt;RustOpt: Rust 语言    RustOpt-&gt;&gt;AIOpt: Rust 代码    AIOpt-&gt;&gt;RustOutput: 优化后的Rust代码</code></pre><h4 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h4><ul><li>字符输入</li></ul><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/image-20240326225550130.png" alt="image-20240326225550130"></p><ul><li>代码文件输入</li></ul><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/image-20240326225753595.png" alt="image-20240326225753595"></p><ul><li>输出<ul><li>代码检查</li><li>转换代码</li><li>AI 优化代码</li></ul></li></ul><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/image-20240326225616707.png" alt="image-20240326225616707"></p><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/image-20240326225824678.png" alt="image-20240326225824678"></p><h4 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h4><p><code>clang libclang llvm</code></p><p>Rust crate <code> clang clang-sys syn</code> </p><p>llvm IR</p><h4 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h4><ul><li>代码输入</li><li>clang-sys 词法、语法、语义解析</li><li>clang AST 建立</li><li>IR 结构生成器</li><li>Rust 翻译规则生成</li><li>Rust 代码生成</li><li>Rust 代码优化</li><li>AI 检查、优化</li></ul><h4 id="部署要求"><a href="#部署要求" class="headerlink" title="部署要求"></a>部署要求</h4><p>llvm clang 库安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ubuntu22.04</span><br><span class="hljs-built_in">sudo</span> apt-get update<br><span class="hljs-built_in">sudo</span> apt-get install llvm clang<br></code></pre></td></tr></table></figure><p>Rust cargo 基础开发环境、能访问外网拉取 crate。</p><p>如果使用 ai 优化功能，需要能连接通义千问。本项目代码中内置 api key</p><h2 id="问题、解决思路"><a href="#问题、解决思路" class="headerlink" title="问题、解决思路"></a>问题、解决思路</h2><ul><li>入参 int n … 语法翻译问题<ul><li>通过 <code>AST</code> 中解析出参数中是否有此语法，如果有，则在 IR 中做出记录，在 IR to Rust 中将其转换为 <code>Vec&lt;T&gt;</code> , 并在之后的 Function body 逻辑处理中，将 C 中对 n 的处理，转换为 Rust 对 Vec<T> n  的处理。在上下文中记录此函数声明和此参数上下文。</li></ul></li><li>获取 for 循环中的 condition 的 operator 思路<ul><li><strong>计算左操作数的偏移量（<code>left_offset</code>）</strong>：<ul><li>首先，获取左操作数实体（<code>entity.get_child(0)</code>），假设为二元操作的第一个子实体。</li><li>使用 <code>.map</code> 遍历左操作数的子实体（这里实际上只有一个），获取每个子实体的源代码范围（<code>get_range()</code>），然后对这个范围内的标记（<code>tokenize()</code>）进行计数（<code>.len()</code>），以确定左操作数占用了多少个标记。</li><li>通过 <code>.fold</code> 将这些标记数量累加起来，得到 <code>left_offset</code>，即左操作数结束的位置（以标记计数为单位）。</li></ul></li><li><strong>获取整个二元操作的标记</strong>：<ul><li>通过 <code>entity.get_range().and_then(|r| Some(r.tokenize()))</code> 获取表示整个二元操作的 <code>Entity</code> 的源代码范围，并将这个范围内的内容分割成标记。</li></ul></li><li><strong>提取操作符</strong>：<ul><li>使用左操作数的偏移量 <code>left_offset</code> 作为索引，从整个二元操作的标记列表中提取操作符。因为左操作数后面紧跟的标记应该就是操作符本身。</li></ul></li><li><strong>返回操作符的拼写</strong>：<ul><li>通过 <code>get_spelling()</code> 方法获取操作符标记的文本表示，然后将其作为 <code>Some</code> 值返回。</li></ul></li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h3><ol><li><strong>创新性结合</strong>: 利用编译原理和现有的AI技术的优势，提供一个高效且可靠的C&#x2F;C++到Rust的代码转换工具。</li><li><strong>高度复用设计</strong>: 通过先将C代码转换为中间表示（IR），然后再将IR转换为Rust代码的策略，增强了代码的可复用性，同时也支持将IR转换为其他目标语言。</li><li><strong>硬件和平台无关</strong>: IR设计独立于任何特定的硬件或指令集，使得转换出来的Rust代码能够跨平台使用。</li><li><strong>易于优化</strong>: IR层面的设计便于代码分析和优化，有助于生成性能更高、内存使用更优的Rust代码。同时后期迭代可以有多级的IR，做到职责单一、程序便于维护迭代。</li><li><strong>支持广泛的错误排查和优化</strong>: 包括语法错误、类型错误、声明和定义错误、作用域问题、链接错误、内存访问错误等，以及提供代码优化建议。</li><li><strong>灵活的输入输出</strong>: 支持文件输入和字符串输入，以及输出到标准输出或文件，提高了工具的使用灵活性。</li><li><strong>开源许可</strong>: 采用GPL v3开源许可证，促进了社区的贡献和软件的持续改进。</li></ol><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p><strong>我的演讲结束，谢谢大家，具体的实现可以看源码 和 演示视频</strong></p>]]></content>
    
    
    <categories>
      
      <category>project</category>
      
      <category>cToRust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件说明</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>etcd和apiserver生命周期管理.md</title>
    <link href="/2024/03/19/mdstorage/domain/k8s/etcd%E5%92%8Capiserver%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/"/>
    <url>/2024/03/19/mdstorage/domain/k8s/etcd%E5%92%8Capiserver%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="etcd-安装脚本"><a href="#etcd-安装脚本" class="headerlink" title="etcd 安装脚本"></a>etcd 安装脚本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> -ex<br><br><br>ftpserver=http://119.91.145.27:12800<br><span class="hljs-built_in">mkdir</span> -p /opt/k8s/wal /opt/k8s/data /opt/k8s/bin /opt/k8s/work<br><br><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF &gt; /opt/k8s/work/etcd.conf</span><br><span class="hljs-string">ETCD_OPTS=&quot;--name node1 \\</span><br><span class="hljs-string">--max-request-bytes 10485760 \\</span><br><span class="hljs-string">--data-dir /opt/k8s/data \\</span><br><span class="hljs-string">--wal-dir /opt/k8s/wal \\</span><br><span class="hljs-string">--advertise-client-urls http://127.0.0.1:2379 \\</span><br><span class="hljs-string">--listen-client-urls http://127.0.0.1:2379 \\</span><br><span class="hljs-string">--listen-peer-urls http://127.0.0.1:2380&quot;</span><br><span class="hljs-string">EOF</span><br><br><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF &gt; /lib/systemd/system/etcd.service</span><br><span class="hljs-string">[Unit]</span><br><span class="hljs-string">Description=Etcd For Kubernetes</span><br><span class="hljs-string">Wants=network-online.target</span><br><span class="hljs-string">After=network.target network-online.target</span><br><span class="hljs-string"></span><br><span class="hljs-string">[Service]</span><br><span class="hljs-string">EnvironmentFile=/opt/k8s/work/etcd.conf</span><br><span class="hljs-string">ExecStart=/opt/k8s/bin/etcd $ETCD_OPTS</span><br><span class="hljs-string">Restart=always</span><br><span class="hljs-string"></span><br><span class="hljs-string">[Install]</span><br><span class="hljs-string">WantedBy=multi-user.target</span><br><span class="hljs-string">EOF</span><br><br>wget -P /opt/k8s/bin/ --http-user=team  --http-passwd=xdmybl <span class="hljs-variable">$&#123;ftpserver&#125;</span>/repo/kubernetes/etcd<br><span class="hljs-built_in">chmod</span> +x /opt/k8s/bin/etcd<br>systemctl daemon-reload<br>systemctl start etcd<br></code></pre></td></tr></table></figure><h2 id="apiserver-安装脚本"><a href="#apiserver-安装脚本" class="headerlink" title="apiserver 安装脚本"></a>apiserver 安装脚本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 安装 apiserver 的脚本(包括 etcd 的安装)</span><br><span class="hljs-comment"># 单台机器架构 ( 单节点 etcd 单台 apiserver )</span><br><br><span class="hljs-comment"># 判断是否存在 etcd, 没有则安装</span><br>unit_name=etcd<br><span class="hljs-keyword">if</span>  systemctl list-unit-files | grep -q <span class="hljs-string">&quot;^<span class="hljs-variable">$unit_name</span>&quot;</span> ; <span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$unit_name</span> exists&quot;</span><br><span class="hljs-keyword">else</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$unit_name</span> does not exist&quot;</span><br>  ./install_etcd.sh<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 假设 etcd 是监听 127.0.0.1:2379 2380</span><br><br><span class="hljs-comment"># 需要填apiserver 的监听地址</span><br>LOCALIP=127.0.0.1<br><br><br><span class="hljs-comment">#------------------------------------------------------------</span><br><span class="hljs-comment"># wget</span><br>ftp_server=http://119.91.145.27:12800<br><br><span class="hljs-built_in">mkdir</span> -p /opt/k8s &amp;&amp; <span class="hljs-built_in">cd</span> /opt/k8s<br>wget --http-user=team  --http-passwd=xdmybl <span class="hljs-variable">$&#123;ftp_server&#125;</span>/kubernetes/kube-apiserver<br>wget --http-user=team  --http-passwd=xdmybl <span class="hljs-variable">$&#123;ftp_server&#125;</span>/kubernetes/kubectl<br><span class="hljs-built_in">chmod</span> +x kubectl &amp;&amp; <span class="hljs-built_in">chmod</span> +x kube-apiserver<br><span class="hljs-comment"># 链接</span><br><span class="hljs-built_in">ln</span> -s <span class="hljs-variable">$&#123;PWD&#125;</span>/kubectl /usr/local/bin/<br><span class="hljs-comment"># 需要空格</span><br><span class="hljs-built_in">cat</span> &gt;&gt; /etc/profile &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string"></span><br><span class="hljs-string">alias k=&quot;kubectl&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">EOF</span><br><span class="hljs-comment">#------------------------------------------------------------</span><br><br><span class="hljs-comment"># 生成 证书</span><br><span class="hljs-comment">#------------------------------------------------------------</span><br><span class="hljs-comment"># 获取 cfssl 在 ./bin目录下</span><br>ftp_server=http://119.91.145.27:12800<br><br><span class="hljs-built_in">mkdir</span> -p /opt/k8s/work &amp;&amp; <span class="hljs-built_in">cd</span> /opt/k8s<br>wget --http-user=team  --http-passwd=xdmybl  <span class="hljs-variable">$&#123;ftp_server&#125;</span>/kubernetes/cfssl/cfssl_linux-amd64<br>wget --http-user=team  --http-passwd=xdmybl  <span class="hljs-variable">$&#123;ftp_server&#125;</span>/kubernetes/cfssl/cfssljson_linux-amd64<br><span class="hljs-built_in">mv</span> cfssl_linux-amd64 cfssl &amp;&amp; <span class="hljs-built_in">chmod</span> +x cfssl<br><span class="hljs-built_in">mv</span> cfssljson_linux-amd64 cfssljson &amp;&amp; <span class="hljs-built_in">chmod</span> +x cfssljson<br><span class="hljs-built_in">ln</span> -s <span class="hljs-variable">$&#123;PWD&#125;</span>/cfssl /usr/local/bin<br><span class="hljs-built_in">ln</span> -s <span class="hljs-variable">$&#123;PWD&#125;</span>/cfssljson /usr/local/bin<br><br><span class="hljs-comment"># 创建 logs 目录</span><br><span class="hljs-built_in">mkdir</span> -p /opt/k8s/logs<br><br><span class="hljs-built_in">cd</span> work<br><span class="hljs-comment"># 需要</span><br><span class="hljs-comment"># ca-csr.json</span><br><span class="hljs-comment"># ca-config.json</span><br><span class="hljs-comment"># server-csr.json</span><br><span class="hljs-comment"># admin-csr.json 用于生成 kubectl admin 用户 kubeconfig</span><br><br><span class="hljs-comment"># 生成 ca-csr.json</span><br><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF &gt;&gt; ca-csr.json</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">  &quot;CN&quot;: &quot;kubernetes&quot;,</span><br><span class="hljs-string">  &quot;hosts&quot;: [</span><br><span class="hljs-string">    &quot;$LOCALIP&quot;,</span><br><span class="hljs-string">    &quot;kubernetes&quot;,</span><br><span class="hljs-string">    &quot;kubernetes.default&quot;,</span><br><span class="hljs-string">    &quot;kubernetes.default.svc&quot;,</span><br><span class="hljs-string">    &quot;kubernetes.default.svc.cluster&quot;,</span><br><span class="hljs-string">    &quot;kubernetes.default.svc.cluster.local.&quot;</span><br><span class="hljs-string">  ],</span><br><span class="hljs-string">  &quot;key&quot;: &#123;</span><br><span class="hljs-string">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="hljs-string">    &quot;size&quot;: 2048</span><br><span class="hljs-string">  &#125;,</span><br><span class="hljs-string">  &quot;names&quot;: [</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;C&quot;: &quot;CN&quot;,</span><br><span class="hljs-string">      &quot;ST&quot;: &quot;Shanghai&quot;,</span><br><span class="hljs-string">      &quot;L&quot;: &quot;Shanghai&quot;,</span><br><span class="hljs-string">      &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="hljs-string">      &quot;OU&quot;: &quot;System&quot;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  ]</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">EOF</span><br><br><span class="hljs-comment"># ca-config.json</span><br><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF &gt;&gt; ca-config.json</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">  &quot;signing&quot;: &#123;</span><br><span class="hljs-string">    &quot;default&quot;: &#123;</span><br><span class="hljs-string">      &quot;expiry&quot;: &quot;87600h&quot;</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &quot;profiles&quot;: &#123;</span><br><span class="hljs-string">      &quot;kubernetes&quot;: &#123;</span><br><span class="hljs-string">         &quot;expiry&quot;: &quot;87600h&quot;,</span><br><span class="hljs-string">         &quot;usages&quot;: [</span><br><span class="hljs-string">            &quot;signing&quot;,</span><br><span class="hljs-string">            &quot;key encipherment&quot;,</span><br><span class="hljs-string">            &quot;server auth&quot;,</span><br><span class="hljs-string">            &quot;client auth&quot;</span><br><span class="hljs-string">        ]</span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">EOF</span><br><br><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF &gt; server-csr.json</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">  &quot;CN&quot;: &quot;kubernetes&quot;,</span><br><span class="hljs-string">  &quot;hosts&quot;: [</span><br><span class="hljs-string">    &quot;$LOCALIP&quot;,</span><br><span class="hljs-string">    &quot;kubernetes&quot;,</span><br><span class="hljs-string">    &quot;kubernetes.default&quot;,</span><br><span class="hljs-string">    &quot;kubernetes.default.svc&quot;,</span><br><span class="hljs-string">    &quot;kubernetes.default.svc.cluster&quot;,</span><br><span class="hljs-string">    &quot;kubernetes.default.svc.cluster.local.&quot;</span><br><span class="hljs-string">  ],</span><br><span class="hljs-string">  &quot;key&quot;: &#123;</span><br><span class="hljs-string">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="hljs-string">    &quot;size&quot;: 2048</span><br><span class="hljs-string">  &#125;,</span><br><span class="hljs-string">  &quot;names&quot;: [</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;C&quot;: &quot;CN&quot;,</span><br><span class="hljs-string">      &quot;ST&quot;: &quot;Shanghai&quot;,</span><br><span class="hljs-string">      &quot;L&quot;: &quot;Shanghai&quot;,</span><br><span class="hljs-string">      &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="hljs-string">      &quot;OU&quot;: &quot;System&quot;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  ]</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">EOF</span><br><br><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF &gt; admin-csr.json</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">  &quot;CN&quot;: &quot;admin&quot;,</span><br><span class="hljs-string">  &quot;hosts&quot;: [</span><br><span class="hljs-string">    &quot;$LOCALIP&quot;,</span><br><span class="hljs-string">    &quot;kubernetes&quot;,</span><br><span class="hljs-string">    &quot;kubernetes.default&quot;,</span><br><span class="hljs-string">    &quot;kubernetes.default.svc&quot;,</span><br><span class="hljs-string">    &quot;kubernetes.default.svc.cluster&quot;,</span><br><span class="hljs-string">    &quot;kubernetes.default.svc.cluster.local.&quot;</span><br><span class="hljs-string">  ],</span><br><span class="hljs-string">  &quot;key&quot;: &#123;</span><br><span class="hljs-string">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="hljs-string">    &quot;size&quot;: 2048</span><br><span class="hljs-string">  &#125;,</span><br><span class="hljs-string">  &quot;names&quot;: [</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;C&quot;: &quot;CN&quot;,</span><br><span class="hljs-string">      &quot;O&quot;: &quot;system:masters&quot;,</span><br><span class="hljs-string">      &quot;OU&quot;: &quot;System&quot;,</span><br><span class="hljs-string">      &quot;L&quot;: &quot;Shanghai&quot;,</span><br><span class="hljs-string">      &quot;ST&quot;: &quot;Shanghai&quot;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  ]</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">EOF</span><br><br><span class="hljs-comment"># 签发 ca</span><br>cfssl gencert -initca ca-csr.json | cfssljson -bare ca -<br><span class="hljs-comment"># 签发 apiserver 证书</span><br>cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes server-csr.json | cfssljson -bare server<br><span class="hljs-comment"># 签发 admin 用户证书，绑定用户角色，供 kubectl KUBECONFIG 使用</span><br>cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin<br><br><span class="hljs-comment"># token</span><br><span class="hljs-built_in">cat</span> &gt; token.csv &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">c47ffb939f5ca36231d9e3121a252940,jane,1</span><br><span class="hljs-string">a1232123131231231231231231233112,cluster-admin,2,system:masters</span><br><span class="hljs-string">b4564546555565444564564544545645,admin,3,system:masters</span><br><span class="hljs-string">EOF</span><br><br><span class="hljs-comment"># apiserver bootstrap</span><br><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF &gt; kube-apiserver.conf</span><br><span class="hljs-string">KUBE_APISERVER_OPTS=&quot;--logtostderr=false \\</span><br><span class="hljs-string">--v=5 \\</span><br><span class="hljs-string">--etcd-servers=http://127.0.0.1:2379 \\</span><br><span class="hljs-string">--bind-address=$LOCALIP \\</span><br><span class="hljs-string">--secure-port=6443 \\</span><br><span class="hljs-string">--advertise-address=$LOCALIP \\</span><br><span class="hljs-string">--allow-privileged=true \\</span><br><span class="hljs-string">--enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,ResourceQuota,NodeRestriction \\</span><br><span class="hljs-string">--authorization-mode=RBAC,Node \\</span><br><span class="hljs-string">--enable-bootstrap-token-auth=true \\</span><br><span class="hljs-string">--token-auth-file=/opt/k8s/work/token.csv \\</span><br><span class="hljs-string">--service-node-port-range=30000-32767 \\</span><br><span class="hljs-string">--kubelet-client-certificate=/opt/k8s/work/server.pem \\</span><br><span class="hljs-string">--kubelet-client-key=/opt/k8s/work/server-key.pem \\</span><br><span class="hljs-string">--tls-cert-file=/opt/k8s/work/server.pem  \\</span><br><span class="hljs-string">--tls-private-key-file=/opt/k8s/work/server-key.pem \\</span><br><span class="hljs-string">--client-ca-file=/opt/k8s/work/ca.pem \\</span><br><span class="hljs-string">--service-account-key-file=/opt/k8s/work/ca-key.pem \\</span><br><span class="hljs-string">--service-account-issuer=api \\</span><br><span class="hljs-string">--service-account-signing-key-file=/opt/k8s/work/server-key.pem \\</span><br><span class="hljs-string">--requestheader-client-ca-file=/opt/k8s/work/ca.pem \\</span><br><span class="hljs-string">--proxy-client-cert-file=/opt/k8s/work/server.pem \\</span><br><span class="hljs-string">--proxy-client-key-file=/opt/k8s/work/server-key.pem \\</span><br><span class="hljs-string">--requestheader-allowed-names=kubernetes \\</span><br><span class="hljs-string">--requestheader-extra-headers-prefix=X-Remote-Extra- \\</span><br><span class="hljs-string">--requestheader-group-headers=X-Remote-Group \\</span><br><span class="hljs-string">--requestheader-username-headers=X-Remote-User \\</span><br><span class="hljs-string">--enable-aggregator-routing=true \\</span><br><span class="hljs-string">--audit-log-maxage=30 \\</span><br><span class="hljs-string">--audit-log-maxbackup=3 \\</span><br><span class="hljs-string">--audit-log-maxsize=100 \\</span><br><span class="hljs-string">--audit-log-path=/opt/k8s/logs/k8s-audit.log&quot;</span><br><span class="hljs-string">EOF</span><br><br><span class="hljs-comment">#------------------------------------------------------------</span><br><br><span class="hljs-comment"># 生成 service</span><br><span class="hljs-comment">#------------------------------------------------------------</span><br><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF &gt; /lib/systemd/system/kube-apiserver.service</span><br><span class="hljs-string">[Unit]</span><br><span class="hljs-string">Description=Kubernetes API Server</span><br><span class="hljs-string">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="hljs-string"></span><br><span class="hljs-string">[Service]</span><br><span class="hljs-string">EnvironmentFile=/opt/k8s/work/kube-apiserver.conf</span><br><span class="hljs-string">ExecStart=/opt/k8s/kube-apiserver \$KUBE_APISERVER_OPTS</span><br><span class="hljs-string">Restart=on-failure</span><br><span class="hljs-string"></span><br><span class="hljs-string">[Install]</span><br><span class="hljs-string">WantedBy=multi-user.target</span><br><span class="hljs-string">EOF</span><br><br>systemctl daemon-reload<br>systemctl start kube-apiserver.service<br><span class="hljs-comment">#------------------------------------------------------------</span><br><br><span class="hljs-comment"># 生成 kubeconfig</span><br><span class="hljs-comment">#------------------------------------------------------------</span><br><span class="hljs-built_in">mkdir</span> -p /root/.kube/ &amp;&amp; <span class="hljs-built_in">cd</span> /root/.kube<br><span class="hljs-comment"># 生成 kubectl 的 kubeconfig</span><br><br><br>kubectl config set-cluster kubernetes \<br>    --certificate-authority=/opt/k8s/work/ca.pem \<br>    --embed-certs=<span class="hljs-literal">true</span> \<br>    --server=https://<span class="hljs-variable">$&#123;LOCALIP&#125;</span>:6443 \<br>    --kubeconfig=config<br>    <br>kubectl config set-credentials cluster-admin \<br>    --client-certificate=/opt/k8s/work/admin.pem \<br>    --client-key=/opt/k8s/work/admin-key.pem \<br>    --embed-certs=<span class="hljs-literal">true</span> \<br>    --kubeconfig=config<br><br>kubectl config set-context default \<br>    --cluster=kubernetes \<br>    --user=cluster-admin \<br>    --kubeconfig=config<br><br>kubectl config use-context default --kubeconfig=config<br>kubectl get ns<br><span class="hljs-comment">#------------------------------------------------------------</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>k8s</category>
      
    </categories>
    
    
    <tags>
      
      <tag>apiserver</tag>
      
      <tag>etcd</tag>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信链路改造后管理面HA相关.md</title>
    <link href="/2024/03/18/mdstorage/project/sr/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0%E5%90%8E%E7%AE%A1%E7%90%86%E9%9D%A2HA%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/03/18/mdstorage/project/sr/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0%E5%90%8E%E7%AE%A1%E7%90%86%E9%9D%A2HA%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h2><h3 id="引擎集群内信息同步"><a href="#引擎集群内信息同步" class="headerlink" title="引擎集群内信息同步"></a>引擎集群内信息同步</h3><h4 id="Host-机制"><a href="#Host-机制" class="headerlink" title="Host 机制"></a>Host 机制</h4><p>使用 <code>/etc/hosts</code> 对集群 host 进行维护</p><p>（安装时由引擎安装所填充）</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span> localhost<br><br><span class="hljs-number">192.168.0.1</span> ouryun_m_node_1 ouryun_m <br><span class="hljs-number">192.168.0.2</span> ouryun_m_node_2 ouryun_m <br><span class="hljs-number">192.168.0.3</span> ouryun_m_node_3 ouryun_m <br></code></pre></td></tr></table></figure><p>kubernetes 的客户端会依据 ouryun_m 自动找到 Apiserver 服务端</p><h4 id="Etcd-集群机制"><a href="#Etcd-集群机制" class="headerlink" title="Etcd 集群机制"></a>Etcd 集群机制</h4><ul><li>etcd 通过 Hostname 进行集群组建</li><li>组建好的 etcd 集群会内部通信，保证集群内部数据一致性</li></ul><h4 id="Apiserver-机制"><a href="#Apiserver-机制" class="headerlink" title="Apiserver 机制"></a>Apiserver 机制</h4><ul><li>Apiserver 连接本地的 etcd，利用 etcd 的数据一致性保证 Apiserver 之间的数据一致</li><li>向引擎所有节点的组件提供服务，并提供认证鉴权</li><li>Apiserver 签发证书时不需要关注自己的 ip ，而是为多个 hostname 申请即可，提高了灵活性和可维护性（为后续引擎修改 ip 做铺垫）</li></ul><h4 id="引擎集群内部组件通过-Apiserver-进行组件间信息同步（operator-开发模型）"><a href="#引擎集群内部组件通过-Apiserver-进行组件间信息同步（operator-开发模型）" class="headerlink" title="引擎集群内部组件通过 Apiserver 进行组件间信息同步（operator 开发模型）"></a>引擎集群内部组件通过 Apiserver 进行组件间信息同步（operator 开发模型）</h4><p>Apiserver 的客户端 client-go 已提供通过 hostname 进行集群的服务发现机制，确保了客户端总是可以找到提供特定服务的 Apiserver。</p><pre><code class=" mermaid">---title: 通信链路改造后管理面HA相关---graph TB    subgraph Sc[总控]sc_core[sc core]sc[sc]    endsubgraph Se    subgraph M_Group[管理面集群]    subgraph M_Node1[管理节点]        webserver1[webserver]        apiserver1[Apiserver]        etcd1[Etcd]        webserver1 --&gt;|127.0.0.1| apiserver1 --&gt;|127.0.0.1| etcd1    end    subgraph M_Node2[管理节点]    webserver2[webserver]    apiserver2[Apiserver]    etcd2[Etcd]    webserver2 --&gt;|127.0.0.1| apiserver2 --&gt;|127.0.0.1| etcd2    end    subgraph M_Node3[管理节点]    webserver3[webserver]    apiserver3[Apiserver]    etcd3[Etcd]    webserver3 --&gt;|127.0.0.1| apiserver3 --&gt;|127.0.0.1| etcd3    end        etcd1 &amp; etcd2 &lt;--&gt; etcd3    etcd2 &lt;---&gt; etcd1    end    subgraph S_Group[调度节点集群]    webserver4[webserver]    webserver5[webserver]    end    subgraph W_Group[工作节点集群]    webserver6[webserver]    webserver7[webserver]    webserver8[webserver]    endwebserver4 &amp; webserver5 &amp; webserver6 &amp; webserver7 &amp; webserver8 ---&gt;|host: ouryun_m| apiserver1%%webserver4 --&gt; webserver1endsc &lt;--&gt;sc_corewebserver1 &amp; webserver2 &amp; webserver3 &amp; webserver4 &amp; webserver5 &amp; webserver6 &amp; webserver7 &amp; webserver8 ====&gt;|channel| sc_corestyle Sc fill:#87CEFAstyle Se fill:#708090    linkStyle 9,10,11,12,13 stroke:#FFA07A,stroke-width:2px,color:green;    linkStyle 6,7,8 stroke:#FFD700,stroke-width:3px,color:green;    linkStyle 1,3,5 stroke:#32CD32,stroke-width:2px,color:yellow;linkStyle 14,15,16,17,18,19,20,21,22 stroke:#FF6347,stroke-width:8px,color:green;</code></pre><h3 id="总控-引擎通信"><a href="#总控-引擎通信" class="headerlink" title="总控-引擎通信"></a>总控-引擎通信</h3><h4 id="总控-管理面通信"><a href="#总控-管理面通信" class="headerlink" title="总控-管理面通信"></a>总控-管理面通信</h4><h5 id="webserver-服务注册机制"><a href="#webserver-服务注册机制" class="headerlink" title="webserver 服务注册机制"></a>webserver 服务注册机制</h5><p>webserver 启动时会向 sc-core 注册本组件信息，其中包括本节点角色(M)、引擎序列号、引擎节点ID 等信息</p><h5 id="sc-core-负载均衡机制"><a href="#sc-core-负载均衡机制" class="headerlink" title="sc-core 负载均衡机制"></a>sc-core 负载均衡机制</h5><p>sc-core 在转发总控到引擎管理面流量时，指定对应引擎和节点角色，可以通过已注册的引擎的 webserver 负载均衡一个可用的引擎管理面中的 webserver 进行处理。</p><h4 id="总控-任意节点-webserver-通信"><a href="#总控-任意节点-webserver-通信" class="headerlink" title="总控-任意节点 webserver 通信"></a>总控-任意节点 webserver 通信</h4><p>sc-core 在转发总控到任意引擎节点时，指定对应引擎和节点ID，可以通过注册信息，转发到指定节点的 webserver 中进行处理。</p><h2 id="物理架构"><a href="#物理架构" class="headerlink" title="物理架构"></a>物理架构</h2><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><h3 id="引擎-webserver-sc-core-注册流程"><a href="#引擎-webserver-sc-core-注册流程" class="headerlink" title="引擎 webserver -&gt; sc-core 注册流程"></a>引擎 webserver -&gt; sc-core 注册流程</h3><h3 id="引擎安装-webserver-流程"><a href="#引擎安装-webserver-流程" class="headerlink" title="引擎安装 webserver 流程"></a>引擎安装 webserver 流程</h3><ul><li>修改 hosts</li><li>安装 webserver</li><li>配置启动参数</li><li>apiserver、etcd 安装逻辑</li></ul><h3 id="sc-向管理面-webserver-通信"><a href="#sc-向管理面-webserver-通信" class="headerlink" title="sc 向管理面 webserver 通信"></a>sc 向管理面 webserver 通信</h3><h3 id="调度节点、工作节点组件访问管理面组件"><a href="#调度节点、工作节点组件访问管理面组件" class="headerlink" title="调度节点、工作节点组件访问管理面组件"></a>调度节点、工作节点组件访问管理面组件</h3><h2 id="异常场景"><a href="#异常场景" class="headerlink" title="异常场景"></a>异常场景</h2>]]></content>
    
    
    
    <tags>
      
      <tag>通信链路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cust相关问题和解决思路.md</title>
    <link href="/2024/03/15/mdstorage/project/cToRust/cust%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/"/>
    <url>/2024/03/15/mdstorage/project/cToRust/cust%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="C-调用标准库函数进行一系列操作"><a href="#C-调用标准库函数进行一系列操作" class="headerlink" title="C 调用标准库函数进行一系列操作"></a>C 调用标准库函数进行一系列操作</h2><h3 id="问题、解决思路"><a href="#问题、解决思路" class="headerlink" title="问题、解决思路"></a>问题、解决思路</h3><ul><li>入参 int n … 语法翻译问题<ul><li>通过 <code>AST</code> 中解析出参数中是否有此语法，如果有，则在 IR 中做出记录，在 IR to Rust 中将其转换为 <code>Vec&lt;T&gt;</code> , 并在之后的 Function body 逻辑处理中，将 C 中对 n 的处理，转换为 Rust 对 Vec<T> n  的处理。</li></ul></li><li>获取 for 循环中的 condition 的 operator 思路<ul><li><strong>计算左操作数的偏移量（<code>left_offset</code>）</strong>：<ul><li>首先，获取左操作数实体（<code>entity.get_child(0)</code>），假设为二元操作的第一个子实体。</li><li>使用 <code>.map</code> 遍历左操作数的子实体（这里实际上只有一个），获取每个子实体的源代码范围（<code>get_range()</code>），然后对这个范围内的标记（<code>tokenize()</code>）进行计数（<code>.len()</code>），以确定左操作数占用了多少个标记。</li><li>通过 <code>.fold</code> 将这些标记数量累加起来，得到 <code>left_offset</code>，即左操作数结束的位置（以标记计数为单位）。</li></ul></li><li><strong>获取整个二元操作的标记</strong>：<ul><li>通过 <code>entity.get_range().and_then(|r| Some(r.tokenize()))</code> 获取表示整个二元操作的 <code>Entity</code> 的源代码范围，并将这个范围内的内容分割成标记。</li></ul></li><li><strong>提取操作符</strong>：<ul><li>使用左操作数的偏移量 <code>left_offset</code> 作为索引，从整个二元操作的标记列表中提取操作符。因为左操作数后面紧跟的标记应该就是操作符本身。</li></ul></li><li><strong>返回操作符的拼写</strong>：<ul><li>通过 <code>get_spelling()</code> 方法获取操作符标记的文本表示，然后将其作为 <code>Some</code> 值返回。</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>project</category>
      
      <category>cToRust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cust转换规则关系.md</title>
    <link href="/2024/03/12/mdstorage/project/cToRust/cust%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99%E5%85%B3%E7%B3%BB/"/>
    <url>/2024/03/12/mdstorage/project/cToRust/cust%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>这个示例涉及到几个关键的编程概念在 C 和 Rust 之间的转换，包括函数定义、传入参数、循环控制、标准输入输出和主函数。让我们详细解析每个部分：</p><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><h4 id="返回值类型"><a href="#返回值类型" class="headerlink" title="返回值类型"></a>返回值类型</h4><ul><li><strong>C</strong>: 使用 <code>void</code> 关键字表示没有返回值的函数。如 <code>void print_values(int n, ...)</code></li><li><strong>Rust</strong>: Rust 中没有返回值的函数隐式返回 <code>()</code>，这通常在函数签名中省略。如 <code>fn print_values(args: Vec&lt;i32&gt;)</code></li></ul><h3 id="传入参数"><a href="#传入参数" class="headerlink" title="传入参数"></a>传入参数</h3><h4 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h4><ul><li><strong>C</strong>: 使用 <code>...</code> 和配合 <code>va_list</code> 处理变长参数。</li><li><strong>Rust</strong>: Rust 不直接支持 C 风格的变长参数。可以使用 <code>Vec&lt;T&gt;</code> 或其他集合类型来处理不定数量的参数。</li></ul><h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><ul><li><strong>C</strong>: 通过初始化变量、条件和增量在 <code>for</code> 循环的括号内定义循环逻辑。</li><li><strong>Rust</strong>: Rust 的 <code>for</code> 循环与 C 不同，它用于遍历迭代器。在本例中，遍历一个 <code>Vec&lt;i32&gt;</code> 的每个元素。</li></ul><h3 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h3><h4 id="打印到控制台"><a href="#打印到控制台" class="headerlink" title="打印到控制台"></a>打印到控制台</h4><ul><li><strong>C</strong>: 使用 <code>printf</code> 函数进行格式化输出。</li><li><strong>Rust</strong>: 使用 <code>println!</code> 宏进行格式化输出。Rust 的宏提供了额外的类型安全性和方便的格式化选项。</li></ul><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><h4 id="主函数返回值"><a href="#主函数返回值" class="headerlink" title="主函数返回值"></a>主函数返回值</h4><ul><li><strong>C</strong>: <code>main</code> 函数返回 <code>int</code> 类型，<code>0</code> 通常表示成功。</li><li><strong>Rust</strong>: <code>main</code> 函数没有返回值，对于错误处理，可以使用 <code>Result</code> 类型，或者在异常情况下调用 <code>panic!</code> 宏。</li></ul><h3 id="示例代码解析"><a href="#示例代码解析" class="headerlink" title="示例代码解析"></a>示例代码解析</h3><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C 代码"></a>C 代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdarg&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_values</span><span class="hljs-params">(<span class="hljs-type">int</span> n, ...)</span> &#123;<br>    va_list vl;<br>    va_start(vl, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> value = va_arg(vl, <span class="hljs-type">int</span>);<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    va_end(vl);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    print_values(<span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段 C 代码定义了一个 <code>print_values</code> 函数，使用 C 语言的变长参数列表功能来接收并打印任意数量的整数值。</p><h4 id="Rust-转换"><a href="#Rust-转换" class="headerlink" title="Rust 转换"></a>Rust 转换</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_values</span>(args: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">value</span> <span class="hljs-keyword">in</span> args &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Value: &#123;&#125;&quot;</span>, value);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">print_values</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Rust 中，由于不支持 C 风格的变长参数，所以采用 <code>Vec&lt;i32&gt;</code> 来代替。这种方式更安全、更符合 Rust 的设计理念。<code>print_values</code> 函数遍历整数向量，并使用 <code>println!</code> 宏打印每个值。</p><p>通过这种方式，我们不仅转换了代码，还提高了类型安全性，并利用了 Rust 强大的迭代器和宏系统。</p><h2 id="parse-str-quote-parse-quote"><a href="#parse-str-quote-parse-quote" class="headerlink" title="parse_str quote! parse_quote!"></a>parse_str quote! parse_quote!</h2><p><code>syn::parse_str</code>、<code>quote!</code> 和 <code>parse_quote!</code> 都是 Rust 编程中用于宏和代码生成的强大工具，它们在 <code>proc-macro</code> 开发和代码生成中扮演着不同的角色。下面是它们之间的主要区别和联系：</p><h3 id="syn-parse-str"><a href="#syn-parse-str" class="headerlink" title="syn::parse_str"></a><code>syn::parse_str</code></h3><ul><li><strong>用途</strong>：<code>syn::parse_str</code> 用于将字符串解析为 Rust 语法树节点。它是 <code>syn</code> 库提供的函数，可以解析任何合法的 Rust 代码字符串到指定的数据类型，如 <code>Expr</code>、<code>ItemFn</code>、<code>Type</code> 等。</li><li><strong>场景</strong>：当你有一个 Rust 代码的字符串表示，并且需要将这个字符串转换成一个可操作的语法树节点时，使用 <code>syn::parse_str</code>。这对于分析和转换代码特别有用。</li></ul><h3 id="quote"><a href="#quote" class="headerlink" title="quote!"></a><code>quote!</code></h3><ul><li><strong>用途</strong>：<code>quote!</code> 宏用于将 Rust 代码转换为 <code>TokenStream</code>。它是 <code>quote</code> crate 的一部分，能够让你以近乎正常的 Rust 语法编写代码片段，并将其转换为 <code>TokenStream</code>，这在宏的输出和代码生成时非常有用。</li><li><strong>场景</strong>：在编写宏或生成 Rust 代码时，使用 <code>quote!</code> 宏可以方便地生成代码。通过 <code>quote!</code>，你可以轻松地将变量插入到代码模板中，并生成编译器能够理解的 <code>TokenStream</code>。</li></ul><h3 id="parse-quote"><a href="#parse-quote" class="headerlink" title="parse_quote!"></a><code>parse_quote!</code></h3><ul><li><strong>用途</strong>：<code>parse_quote!</code> 宏结合了 <code>quote!</code> 和 <code>syn::parse</code> 的功能。它允许你编写 Rust 代码片段，并将其直接解析为指定的语法树节点类型，如 <code>Expr</code>、<code>Item</code> 等。</li><li><strong>场景</strong>：当你需要生成特定的语法树节点，并且这些节点需要在编译时进行进一步处理或分析时，<code>parse_quote!</code> 非常有用。它让你能够编写可读的 Rust 代码片段，并直接转换成可操作的语法树结构。</li></ul><h3 id="关系和使用建议"><a href="#关系和使用建议" class="headerlink" title="关系和使用建议"></a>关系和使用建议</h3><ul><li>使用 <code>quote!</code> 时，你是从 Rust 代码到 <code>TokenStream</code> 的转换过程中编写代码片段。</li><li>使用 <code>syn::parse_str</code> 或 <code>parse_quote!</code> 时，你是从字符串或 <code>TokenStream</code> 转换到具体的语法树节点。</li><li><code>quote!</code> 常用于宏的输出和代码生成，而 <code>syn::parse_str</code> 和 <code>parse_quote!</code> 常用于分析和转换这些生成的代码。</li><li><code>parse_quote!</code> 提供了一个方便的方式，结合了 <code>quote!</code> 生成代码和 <code>syn::parse</code> 解析代码的功能，使得从代码片段到语法树节点的转换更加直接和简洁。</li></ul><p>总之，根据你的具体需求选择合适的工具：如果你需要生成代码，使用 <code>quote!</code>；如果你需要将代码字符串转换为语法树节点进行分析或操作，使用 <code>syn::parse_str</code>；如果你希望编写代码片段并直接解析为语法树节点，使用 <code>parse_quote!</code>。</p><p>是的，在使用 <code>syn</code> 和 <code>quote</code> 库进行 Rust 宏编程和代码生成时，<code>syn</code> 的类型如 <code>Expr</code>、<code>Type</code> 等可以与 <code>TokenStream</code> 进行互相转换。这种转换能力是实现宏和代码生成逻辑中的核心功能，它允许开发者在 Rust 语法树节点和 <code>TokenStream</code> 之间自由转换，以便进行进一步的处理或生成代码。</p><h3 id="从-syn-类型到-TokenStream"><a href="#从-syn-类型到-TokenStream" class="headerlink" title="从 syn 类型到 TokenStream"></a>从 <code>syn</code> 类型到 <code>TokenStream</code></h3><p>当你有一个 <code>syn</code> 类型的实例（比如一个表达式 <code>Expr</code> 或一个类型 <code>Type</code>），你可以使用 <code>quote!</code> 宏将其转换为 <code>TokenStream</code>。<code>quote!</code> 宏能够接受 <code>syn</code> 类型的变量，并通过插值（<code>#var</code> 语法）将它们包含在生成的代码中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> syn::&#123;Expr, parse_str&#125;;<br><span class="hljs-keyword">use</span> quote::quote;<br><span class="hljs-keyword">use</span> proc_macro2::TokenStream;<br><br><span class="hljs-comment">// 假设有一个 syn 的 Expr</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">expr</span>: Expr = <span class="hljs-title function_ invoke__">parse_str</span>(<span class="hljs-string">&quot;42&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br><br><span class="hljs-comment">// 使用 quote! 将 Expr 转换为 TokenStream</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">tokens</span>: TokenStream = quote! &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">value</span> = #expr;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="从-TokenStream-到-syn-类型"><a href="#从-TokenStream-到-syn-类型" class="headerlink" title="从 TokenStream 到 syn 类型"></a>从 <code>TokenStream</code> 到 <code>syn</code> 类型</h3><p>反过来，如果你有一个 <code>TokenStream</code> 并希望将其解析为 <code>syn</code> 类型的语法树节点，你可以使用 <code>syn::parse</code> 函数或其变体（比如 <code>parse_str</code>，如果你是从字符串开始的）来实现。这通常在宏的输入处理过程中使用，宏接收的 <code>TokenStream</code> 需要被解析为具体的语法结构以便分析或修改。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> syn::&#123;Expr, parse2&#125;;<br><span class="hljs-keyword">use</span> quote::quote;<br><br><span class="hljs-comment">// 创建一个 TokenStream</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">tokens</span> = quote! &#123; <span class="hljs-number">42</span> &#125;;<br><br><span class="hljs-comment">// 将 TokenStream 解析为 syn 的 Expr</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">expr</span>: Expr = <span class="hljs-title function_ invoke__">parse2</span>(tokens).<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>这种转换过程在编写宏和进行复杂的代码生成时非常有用，特别是需要对输入的 Rust 代码进行详细分析或需要生成特定的 Rust 代码片段时。</li><li>转换过程中可能会遇到错误，特别是从 <code>TokenStream</code> 解析到 <code>syn</code> 类型时，如果 <code>TokenStream</code> 中的代码不符合预期的 Rust 语法，<code>parse</code> 函数会返回一个错误。因此，错误处理是这一过程中不可或缺的部分。</li><li>使用 <code>quote!</code> 时保持代码的可读性和清晰性是很重要的，特别是当涉及到复杂的代码生成逻辑时。利用 <code>quote!</code> 宏的能力来插入变量和表达式，可以使生成的代码更加灵活和动态。</li></ul><p>结合 <code>syn</code> 和 <code>quote</code> 的能力，开发者可以在 Rust 宏和代码生成中实现复杂而强大的逻辑。</p>]]></content>
    
    
    <categories>
      
      <category>project</category>
      
      <category>cToRust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cargo.md</title>
    <link href="/2024/03/11/mdstorage/cargo/"/>
    <url>/2024/03/11/mdstorage/cargo/</url>
    
    <content type="html"><![CDATA[<h2 id="cargo-概述"><a href="#cargo-概述" class="headerlink" title="cargo 概述"></a>cargo 概述</h2><p><code>https://doc.rust-lang.org/cargo/</code></p><p>Cargo 是 Rust 包管理器。 Cargo 下载 Rust 包的依赖项，编译您的包，制作可分发的包，并将它们上传到 Rust 社区的包注册表 crates.io。您可以在 GitHub 上为本书做出贡献。</p>]]></content>
    
    
    
    <tags>
      
      <tag>cargo</tag>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github_action.md</title>
    <link href="/2024/03/07/mdstorage/domain/CICD/github_action/"/>
    <url>/2024/03/07/mdstorage/domain/CICD/github_action/</url>
    
    <content type="html"><![CDATA[<p><strong>文章概述</strong></p><ul><li>标题：GitHub Actions 入门指南：自动化您的工作流程</li><li>作者：John Doe</li><li>发布日期：2023年12月30日</li><li>链接地址：<a href="https://www.example.com/github-actions-tutorial">GitHub Actions Tutorial</a></li><li>摘要：本教程旨在为读者提供一个全面的 GitHub Actions 指南，帮助他们理解如何使用这个强大的自动化工具来优化他们的软件开发流程。无论是自动化测试、部署还是其他常见的开发任务，本文将一一涵盖。</li></ul><p><strong>技术背景与原理</strong></p><ul><li><strong>技术背景</strong>：GitHub Actions 是一种 CI&#x2F;CD（持续集成与持续部署）工具，允许开发者自动化各种软件开发过程中的任务，如代码测试、构建和部署。</li><li><strong>关键技术</strong>：本教程的核心是 GitHub Actions 的工作流程文件（YAML 格式），它们定义了一系列的自动化步骤，类似于配方，每个步骤类似于配方中的一个步骤，按照特定顺序执行。</li></ul><p><strong>详细步骤</strong></p><ul><li><strong>逐步指南</strong>：<ol><li><strong>创建工作流程文件</strong>：在仓库中的 <code>.github/workflows</code> 目录下创建一个新的 YAML 文件。</li><li><strong>配置工作流程</strong>：定义工作流程的触发条件，如 <code>on: push</code> 表示每次推送时触发。</li><li><strong>添加作业</strong>：定义作业和运行环境，例如 <code>runs-on: ubuntu-latest</code>。</li><li><strong>定义步骤</strong>：编写执行的具体步骤，如检出代码、运行脚本等。</li></ol></li><li><strong>截图和示例</strong>：（此处放置一个基本的 GitHub Actions 配置文件的截图或代码片段）</li></ul><p><strong>问题解决与常见问题</strong></p><ul><li><strong>问题解决</strong>：解决执行失败的一般步骤，如检查日志、修改配置文件。</li><li><strong>常见问题</strong>：<ul><li>Q: 如何触发工作流程？</li><li>A: 通过 GitHub 事件，如 push、pull request 来触发。</li><li>Q: 工作流程失败怎么办？</li><li>A: 查看 GitHub Actions 日志以诊断问题。</li></ul></li></ul><p><strong>附加资源</strong></p><ul><li><a href="https://docs.github.com/en/actions">GitHub Actions 官方文档</a></li><li><a href="https://www.continuousdelivery.com/">CI&#x2F;CD 最佳实践</a></li><li><a href="https://yamlvalidator.com/">在线 YAML 格式验证工具</a></li></ul><p><strong>总结</strong></p><p>本教程提供了 GitHub Actions 的基础知识和操作指南，帮助读者理解如何利用这一强大的自动化工具优化他们的开发流程。通过学习如何创建和配置工作流程，读者可以提高软件开发的效率和质量。后续步骤包括深入探索更高级的特性和集成其他开发工具，以实现更复杂的自动化需求。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>CICD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>工作流</tag>
      
      <tag>CI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL相关资料.md</title>
    <link href="/2024/03/07/mdstorage/domain/db/PostgreSQL%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/"/>
    <url>/2024/03/07/mdstorage/domain/db/PostgreSQL%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/</url>
    
    <content type="html"><![CDATA[<h2 id="PostgreSQL-资料之一"><a href="#PostgreSQL-资料之一" class="headerlink" title="PostgreSQL 资料之一"></a>PostgreSQL 资料之一</h2><p><strong>文章概述</strong></p><ul><li>文章标题：PostgreSQL正在吞噬数据库世界</li><li>作者：未明确标注</li><li>发布日期：未提供</li><li>链接地址：<a href="https://zhuanlan.zhihu.com/p/685247647">https://zhuanlan.zhihu.com/p/685247647</a></li><li>文章主题简介：文章探讨了PostgreSQL不仅作为一个关系型数据库，而是作为一个数据管理的抽象框架，如何通过其可扩展性和生态系统的发展，逐渐成为数据库领域的主流实践，特别是在OLAP领域的表现和对大数据处理的影响。</li></ul><p><strong>主要观点</strong></p><ul><li>观点一：PostgreSQL的生态系统和可扩展性使其在数据库领域占据主导地位。</li><li>观点二：PostgreSQL通过扩展插件，如ParadeDB和DuckDB，大幅提升了其在OLAP领域的性能。</li><li>观点三：随着硬件的发展和数据库软件的进步，大数据时代的假设正在被挑战，PostgreSQL的适用场景越来越广泛。</li></ul><p><strong>支持论据</strong></p><ul><li>观点一的支持论据：文章提到PostgreSQL不仅是一个数据库，更是一个数据管理框架，通过其丰富的扩展插件支持，能够覆盖数据库领域的多个细分领域，如时序数据库、地理空间数据库等。</li><li>观点二的支持论据：通过引入ParadeDB和DuckDB等扩展，PostgreSQL在OLAP性能上达到了与专用OLAP数据库相媲美的水平，这些扩展插件极大地提升了PostgreSQL在数据分析领域的竞争力。</li><li>观点三的支持论据：随着硬件性能的提升和存储成本的降低，以及数据库软件技术的进步，大数据处理不再是少数场景的需求，PostgreSQL的适用性因此得到了极大的扩展。</li></ul><p><strong>逻辑连贯性分析</strong></p><ul><li>文章通过展示PostgreSQL的可扩展性和生态系统的优势，逐步引出其在OLAP领域的表现和对大数据处理观念的挑战，逻辑上形成了由内而外的扩展，从PostgreSQL的内在特性到其在外部应用场景的影响，展现了一个全面发展的视角。</li></ul><p><strong>不同视角考量</strong></p><ul><li>其他可能的观点或反驳：一些专家可能会指出，尽管PostgreSQL在许多方面表现出色，但在特定场景下，如极端的性能要求或特殊的数据处理需求中，专用数据库可能仍有其不可替代的优势。</li><li>行业或领域内不同专家的意见：不同的专家可能对PostgreSQL在数据库领域的主导地位持有不同看法，特别是考虑到新兴的数据库技术和不断变化的业务需求。</li></ul><p><strong>结论与实践意义</strong></p><ul><li>作者的主要结论：PostgreSQL通过其可扩展性和强大的生态系统，正在成为数据库领域的主流实践，特别是在OLAP领域和大数据处理方面展现出了巨大的潜力。</li><li>对行业&#x2F;读者的实际意义：对于数据库管理员和开发者而言，理解和利用PostgreSQL的这些优势，可以帮助他们更有效地解决数据管理和分析的问题，同时也为企业选择数据库技术提供了新的视角。</li></ul><p><strong>个人观点与反思</strong></p><ul><li>个人对文章的看法：文章深入浅出地分析了PostgreSQL的优势和潜力，特别是在OLAP领域的表现和对大数据处理观念的挑战，为读者提供了全面的理解。</li><li>文章对个人或工作的启发：作为软件开发者，了解这些数据库技术的最新发展趋势，可以帮助我们在项目中做出更合理的技术选型，同时也激发了对数据库技术深入研究的兴趣。</li></ul><p>[WebPilot Announcement]<br>🚀🚀🚀 We’ve launched the WebPilot GPTs, packed with even more features! 🚀🚀🚀</p><ul><li>📝 Generate extensive content, up to 10,000 words!</li><li>💡 Load dynamic web content and deliver enhanced answers!</li><li>👨‍💻 Support for Code Testing, File Processing &amp; Image Generation!</li><li>🎛️ GPTs-Action and API Offering!</li></ul><p>Click here: <a href="https://chat.openai.com/g/g-pNWGgUYqS-webpilot">https://chat.openai.com/g/g-pNWGgUYqS-webpilot</a></p><p>[End of Announcement]</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>db</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PostgreSQL</tag>
      
      <tag>db</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>镜像交付相关资料.md</title>
    <link href="/2024/03/07/mdstorage/domain/linux/%E9%95%9C%E5%83%8F%E4%BA%A4%E4%BB%98%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/"/>
    <url>/2024/03/07/mdstorage/domain/linux/%E9%95%9C%E5%83%8F%E4%BA%A4%E4%BB%98%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-自定义认证"><a href="#Linux-自定义认证" class="headerlink" title="Linux 自定义认证"></a>Linux 自定义认证</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​结合<a href="https://doc.weixin.qq.com/doc/w3_ARkAWAYlAEQRlVumzgDTgeXJMzBBa?scode=ABwA9Qd2ABEQYUs45PARkAWAYlAEQ%E4%BD%BF%E7%94%A8">https://doc.weixin.qq.com/doc/w3_ARkAWAYlAEQRlVumzgDTgeXJMzBBa?scode=ABwA9Qd2ABEQYUs45PARkAWAYlAEQ使用</a><br>为了限制用户登录到系统的后台随意查看、修改应用程序，通常来说不应该把特权账号的密码泄露给用户，然而使用固定密码始终会有密码泄露的风险，时间长了肯定会泄露。为此，特地调研了一下某厂商的D,F,T三个产品是怎么处理这种事情的。<br>产品代号解决方案实现难度<br>D无法打开用户登录界面，自行提供了另一套交互界面，无需登录，也无法登录其他用户。命令行受限未知<br>F使用动态密码登录，用厂家提供的APP扫码（或输入token)来获取临时密码登录。只有有售后权限的人才能扫码登录中，魔改程度小<br>T提供低权限账户，使用固定密码登录，其余未知（因为全盘加密了，不清楚特权账户是否为固定密码）中，魔改程度小<br>因为技术栈不统一，三个产品的防护各有不同，这里F产品使用的方法是一种简单有效的办法，所以考虑预研一下，看看效果。</p><p>pam demo<br>F产品的实现原理是自己编写了一个linux PAM模块，然后在配置文件中加载这段逻辑，就可以实现扩展linux登录时的验证。<br>这里先写个pam demo验证一下机制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;security/pam_appl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;security/pam_modules.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;security/pam_ext.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br>PAM_EXTERN <span class="hljs-type">int</span> <span class="hljs-title function_">pam_sm_authenticate</span><span class="hljs-params">(<span class="hljs-type">pam_handle_t</span> *pamh, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv)</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *username;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *password;<br>    <span class="hljs-type">int</span> pam_err;<br><br>    pam_err = pam_get_user(pamh, &amp;username, <span class="hljs-string">&quot;Username: &quot;</span>);<br>    <span class="hljs-keyword">if</span> (pam_err != PAM_SUCCESS || username == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> PAM_AUTH_ERR;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取用户输入的密码</span><br>    pam_err = pam_get_authtok(pamh, PAM_AUTHTOK, &amp;password, <span class="hljs-string">&quot;Password: &quot;</span>);<br>    <span class="hljs-keyword">if</span> (pam_err != PAM_SUCCESS || password == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> PAM_AUTH_ERR;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查密码是否为预期的值（例如，&quot;123&quot;）</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(password, <span class="hljs-string">&quot;123&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> PAM_SUCCESS; <span class="hljs-comment">// 密码验证成功</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> PAM_AUTH_ERR; <span class="hljs-comment">// 密码验证失败</span><br>    &#125;<br>&#125;<br><br>PAM_EXTERN <span class="hljs-type">int</span> <span class="hljs-title function_">pam_sm_setcred</span><span class="hljs-params">(<span class="hljs-type">pam_handle_t</span> *pamh, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv)</span> &#123;<br>    <span class="hljs-comment">// 在这里实现设置凭据（credential）的逻辑，如果不需要，可以留空</span><br>    <span class="hljs-keyword">return</span> PAM_SUCCESS;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>将代码保存为custom_auth.c 编译并修改sudo的pam配置文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"># 编译<br>gcc -fPIC -shared -o custom_auth.so custom_auth.c -lpam<br># 拷贝到正确的位置<br>cp custom_auth.so /usr/lib/x86_64-linux-gnu/security/<br># -rw-r--r-- root:root 不需要执行权限<br>chmod -x /usr/lib/x86_64-linux-gnu/security/custom_auth.so<br><br># 增加测试用户<br>sudo useradd -m testuser<br>sudo usermod -aG sudo testuser<br># 将密码改为和用户名相同<br>passwd testuser<br><br># 修改sudo的PAM配置,在第一行增加 auth  sufficient  custom_auth.so<br>vim /etc/pam.d/sudo<br>su testuser<br><br># 此时输入testuser或者<span class="hljs-number">123</span>都能成功，其他的密码则失败<br>sudo -k cat /etc/passwd <br><br></code></pre></td></tr></table></figure><h2 id="qrcode-demo"><a href="#qrcode-demo" class="headerlink" title="qrcode demo"></a>qrcode demo</h2><p>​使用二维码输入token不仅方便，还能减少输错的可能，这里是一个简单的验证控制台输出二维码的例子，效果如图（还有多余的边框到时候再修修），能够在控制台、ssh等任意字符界面正常显示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;qrencode.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> margin;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">writeANSI_margin</span><span class="hljs-params">(FILE* fp, <span class="hljs-type">int</span> realwidth, <span class="hljs-type">char</span>* buffer,</span><br><span class="hljs-params">                             <span class="hljs-type">const</span> <span class="hljs-type">char</span>* white, <span class="hljs-type">int</span> white_s)</span> &#123;<br>  <span class="hljs-type">int</span> y;<br><br>  <span class="hljs-built_in">strncpy</span>(buffer, white, (<span class="hljs-type">size_t</span>)white_s);<br>  <span class="hljs-built_in">memset</span>(buffer + white_s, <span class="hljs-string">&#x27; &#x27;</span>, (<span class="hljs-type">size_t</span>)realwidth * <span class="hljs-number">2</span>);<br>  <span class="hljs-built_in">strcpy</span>(buffer + white_s + realwidth * <span class="hljs-number">2</span>,<br>         <span class="hljs-string">&quot;\033[0m\n&quot;</span>);  <span class="hljs-comment">// reset to default colors</span><br>  <span class="hljs-keyword">for</span> (y = <span class="hljs-number">0</span>; y &lt; margin; y++) &#123;<br>    <span class="hljs-built_in">fputs</span>(buffer, fp);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">writeANSI</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg,FILE* fp,  <span class="hljs-type">int</span> size)</span> &#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *white, *black;<br>  <span class="hljs-type">char</span>* buffer;<br>  <span class="hljs-type">int</span> white_s, black_s, buffer_s;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *row, *p;<br>  <span class="hljs-type">int</span> x, y;<br>  <span class="hljs-type">int</span> realwidth;<br>  <span class="hljs-type">int</span> last;<br>  QRcode* qrcode =<br>      QRcode_encodeString(msg, <span class="hljs-number">0</span>, QR_ECLEVEL_L, QR_MODE_8, <span class="hljs-number">1</span>);<br>  <br>  <span class="hljs-keyword">if</span> (qrcode == <span class="hljs-literal">NULL</span>) &#123;<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;cannot parse msg to qrcode&quot;</span>);<br>  <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  white = <span class="hljs-string">&quot;\033[47m&quot;</span>;<br>  white_s = <span class="hljs-number">5</span>;<br>  black = <span class="hljs-string">&quot;\033[40m&quot;</span>;<br>  black_s = <span class="hljs-number">5</span>;<br><br>  realwidth = (qrcode-&gt;width + margin * <span class="hljs-number">2</span>) * size;<br>  buffer_s = (realwidth * white_s) * <span class="hljs-number">2</span>;<br>  buffer = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>((<span class="hljs-type">size_t</span>)buffer_s);<br>  <span class="hljs-keyword">if</span> (buffer == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Failed to allocate memory.\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>  &#125;<br><br>  <span class="hljs-comment">/* top margin */</span><br>  writeANSI_margin(fp, realwidth, buffer, white, white_s);<br><br>  <span class="hljs-comment">/* data */</span><br>  p = qrcode-&gt;data;<br>  <span class="hljs-keyword">for</span> (y = <span class="hljs-number">0</span>; y &lt; qrcode-&gt;width; y++) &#123;<br>    row = (p + (y * qrcode-&gt;width));<br><br>    <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, (<span class="hljs-type">size_t</span>)buffer_s);<br>    <span class="hljs-built_in">strncpy</span>(buffer, white, (<span class="hljs-type">size_t</span>)white_s);<br>    <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; x &lt; margin; x++) &#123;<br>      <span class="hljs-built_in">strncat</span>(buffer, <span class="hljs-string">&quot;  &quot;</span>, <span class="hljs-number">2</span>);<br>    &#125;<br>    last = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; x &lt; qrcode-&gt;width; x++) &#123;<br>      <span class="hljs-keyword">if</span> (*(row + x) &amp; <span class="hljs-number">0x1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (last != <span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-built_in">strncat</span>(buffer, black, (<span class="hljs-type">size_t</span>)black_s);<br>          last = <span class="hljs-number">1</span>;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (last != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">strncat</span>(buffer, white, (<span class="hljs-type">size_t</span>)white_s);<br>        last = <span class="hljs-number">0</span>;<br>      &#125;<br>      <span class="hljs-built_in">strncat</span>(buffer, <span class="hljs-string">&quot;  &quot;</span>, <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (last != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">strncat</span>(buffer, white, (<span class="hljs-type">size_t</span>)white_s);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; x &lt; margin; x++) &#123;<br>      <span class="hljs-built_in">strncat</span>(buffer, <span class="hljs-string">&quot;  &quot;</span>, <span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-built_in">strncat</span>(buffer, <span class="hljs-string">&quot;\033[0m\n&quot;</span>, <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">fputs</span>(buffer, fp);<br>  &#125;<br><br>  <span class="hljs-comment">/* bottom margin */</span><br>  writeANSI_margin(fp, realwidth, buffer, white, white_s);<br><br>  <span class="hljs-built_in">free</span>(buffer);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <br>&#123; <br>margin = <span class="hljs-number">1</span>;<br>writeANSI(<span class="hljs-string">&quot;token:shrino.ouyrun.cn&quot;</span>,<span class="hljs-built_in">stdout</span>, <span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：<br>先安装动态库 apt install libqrencode-dev<br>gcc qrtest.c -lqrencode</p><p>C&#x2F;S demo<br>实现实现随机生成6位数数字密码，然后用RSA加密，将加密后的信息放到二维码，然后售后人员通过将二维码上传到服务器后（这里可以是用手机APP扫码，也可以是拍屏手动处理），服务器用RSA解密后，将结果返回给用户。</p><p>随机密码生成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">generateRandomPassword</span><span class="hljs-params">()</span> &#123;<br>    srand(time(<span class="hljs-literal">NULL</span>));<br>    <span class="hljs-keyword">return</span> rand() % <span class="hljs-number">1000000</span>; <span class="hljs-comment">// 生成0到999999之间的随机数</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>加密部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;openssl/rsa.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;openssl/pem.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">rsaEncryptPassword</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* password, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* publicKeyPath, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* encryptedPath)</span> &#123;<br>    FILE* publicKeyFile = fopen(publicKeyPath, <span class="hljs-string">&quot;rb&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!publicKeyFile) &#123;<br>        perror(<span class="hljs-string">&quot;Failed to open public key file&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    RSA* rsa = PEM_read_RSA_PUBKEY(publicKeyFile, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (!rsa) &#123;<br>        perror(<span class="hljs-string">&quot;Failed to read public key&quot;</span>);<br>        fclose(publicKeyFile);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    fclose(publicKeyFile);<br><br>    <span class="hljs-type">int</span> passwordLen = <span class="hljs-built_in">strlen</span>(password);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> encrypted[<span class="hljs-number">256</span>]; <span class="hljs-comment">// 要根据RSA密钥的长度来设置</span><br>    <span class="hljs-type">int</span> encryptedLen = RSA_public_encrypt(passwordLen, (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)password, encrypted, rsa, RSA_PKCS1_PADDING);<br><br>    <span class="hljs-keyword">if</span> (encryptedLen == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;RSA encryption failed&quot;</span>);<br>        RSA_free(rsa);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    FILE* encryptedFile = fopen(encryptedPath, <span class="hljs-string">&quot;wb&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!encryptedFile) &#123;<br>        perror(<span class="hljs-string">&quot;Failed to open encrypted file&quot;</span>);<br>        RSA_free(rsa);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    fwrite(encrypted, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>), encryptedLen, encryptedFile);<br>    fclose(encryptedFile);<br><br>    RSA_free(rsa);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        rsaEncryptPassword(<span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;public_key.pem&quot;</span>, <span class="hljs-string">&quot;test_encrypt_out&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="安装开发库"><a href="#安装开发库" class="headerlink" title="安装开发库"></a>安装开发库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装开发库</span><br>apt install libssl-dev <br><span class="hljs-comment"># 生成密钥对（这里用1024位</span><br>openssl genrsa -out private_key.pem 1024<br>openssl rsa -pubout -<span class="hljs-keyword">in</span> private_key.pem -out public_key.pem<br><span class="hljs-comment"># 编译</span><br>gcc rsa_enc.c -o rsa_enc -lssl -lcrypto<br></code></pre></td></tr></table></figure><p>生成二维码部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;qrencode.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> margin = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">writeANSI_margin</span><span class="hljs-params">(FILE* fp, <span class="hljs-type">int</span> realwidth, <span class="hljs-type">char</span>* buffer,</span><br><span class="hljs-params">                             <span class="hljs-type">const</span> <span class="hljs-type">char</span>* white, <span class="hljs-type">int</span> white_s)</span> &#123;<br>  <span class="hljs-type">int</span> y;<br><br>  <span class="hljs-built_in">strncpy</span>(buffer, white, (<span class="hljs-type">size_t</span>)white_s);<br>  <span class="hljs-built_in">memset</span>(buffer + white_s, <span class="hljs-string">&#x27; &#x27;</span>, (<span class="hljs-type">size_t</span>)realwidth * <span class="hljs-number">2</span>);<br>  <span class="hljs-built_in">strcpy</span>(buffer + white_s + realwidth * <span class="hljs-number">2</span>,<br>         <span class="hljs-string">&quot;\033[0m\n&quot;</span>);  <span class="hljs-comment">// reset to default colors</span><br>  <span class="hljs-keyword">for</span> (y = <span class="hljs-number">0</span>; y &lt; margin; y++) &#123;<br>    <span class="hljs-built_in">fputs</span>(buffer, fp);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">writeANSI</span><span class="hljs-params">(QRcode* qrcode,FILE* fp,  <span class="hljs-type">int</span> size)</span> &#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *white, *black;<br>  <span class="hljs-type">char</span>* buffer;<br>  <span class="hljs-type">int</span> white_s, black_s, buffer_s;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *row, *p;<br>  <span class="hljs-type">int</span> x, y;<br>  <span class="hljs-type">int</span> realwidth;<br>  <span class="hljs-type">int</span> last;<br>  <br>  <span class="hljs-keyword">if</span> (qrcode == <span class="hljs-literal">NULL</span>) &#123;<br>  <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  white = <span class="hljs-string">&quot;\033[47m&quot;</span>;<br>  white_s = <span class="hljs-number">5</span>;<br>  black = <span class="hljs-string">&quot;\033[40m&quot;</span>;<br>  black_s = <span class="hljs-number">5</span>;<br><br>  realwidth = (qrcode-&gt;width + margin * <span class="hljs-number">2</span>) * size;<br>  buffer_s = (realwidth * white_s) * <span class="hljs-number">2</span>;<br>  buffer = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>((<span class="hljs-type">size_t</span>)buffer_s);<br>  <span class="hljs-keyword">if</span> (buffer == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Failed to allocate memory.\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>  &#125;<br><br>  <span class="hljs-comment">/* top margin */</span><br>  writeANSI_margin(fp, realwidth, buffer, white, white_s);<br><br>  <span class="hljs-comment">/* data */</span><br>  p = qrcode-&gt;data;<br>  <span class="hljs-keyword">for</span> (y = <span class="hljs-number">0</span>; y &lt; qrcode-&gt;width; y++) &#123;<br>    row = (p + (y * qrcode-&gt;width));<br><br>    <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, (<span class="hljs-type">size_t</span>)buffer_s);<br>    <span class="hljs-built_in">strncpy</span>(buffer, white, (<span class="hljs-type">size_t</span>)white_s);<br>    <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; x &lt; margin; x++) &#123;<br>      <span class="hljs-built_in">strncat</span>(buffer, <span class="hljs-string">&quot;  &quot;</span>, <span class="hljs-number">2</span>);<br>    &#125;<br>    last = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; x &lt; qrcode-&gt;width; x++) &#123;<br>      <span class="hljs-keyword">if</span> (*(row + x) &amp; <span class="hljs-number">0x1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (last != <span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-built_in">strncat</span>(buffer, black, (<span class="hljs-type">size_t</span>)black_s);<br>          last = <span class="hljs-number">1</span>;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (last != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">strncat</span>(buffer, white, (<span class="hljs-type">size_t</span>)white_s);<br>        last = <span class="hljs-number">0</span>;<br>      &#125;<br>      <span class="hljs-built_in">strncat</span>(buffer, <span class="hljs-string">&quot;  &quot;</span>, <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (last != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">strncat</span>(buffer, white, (<span class="hljs-type">size_t</span>)white_s);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; x &lt; margin; x++) &#123;<br>      <span class="hljs-built_in">strncat</span>(buffer, <span class="hljs-string">&quot;  &quot;</span>, <span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-built_in">strncat</span>(buffer, <span class="hljs-string">&quot;\033[0m\n&quot;</span>, <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">fputs</span>(buffer, fp);<br>  &#125;<br><br>  <span class="hljs-comment">/* bottom margin */</span><br>  writeANSI_margin(fp, realwidth, buffer, white, white_s);<br><br>  <span class="hljs-built_in">free</span>(buffer);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">generateQRCode</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* encryptedPath)</span> &#123;<br>    FILE* encryptedFile = fopen(encryptedPath, <span class="hljs-string">&quot;rb&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!encryptedFile) &#123;<br>        perror(<span class="hljs-string">&quot;Failed to open encrypted file&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    fseek(encryptedFile, <span class="hljs-number">0</span>, SEEK_END);<br>    <span class="hljs-type">long</span> encryptedFileSize = ftell(encryptedFile);<br>    rewind(encryptedFile);<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* encryptedData = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(encryptedFileSize);<br>    <span class="hljs-keyword">if</span> (!encryptedData) &#123;<br>        perror(<span class="hljs-string">&quot;Memory allocation failed&quot;</span>);<br>        fclose(encryptedFile);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    fread(encryptedData, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>), encryptedFileSize, encryptedFile);<br>    fclose(encryptedFile);<br><br>    QRcode* qrcode = QRcode_encodeData(encryptedFileSize, encryptedData, <span class="hljs-number">0</span>,QR_ECLEVEL_L);<br>    <span class="hljs-keyword">if</span> (!qrcode) &#123;<br>        perror(<span class="hljs-string">&quot;QRcode encoding failed&quot;</span>);<br>        <span class="hljs-built_in">free</span>(encryptedData);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>writeANSI(qrcode,<span class="hljs-built_in">stdout</span>,<span class="hljs-number">5</span>);<br>   <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>generateQRCode(<span class="hljs-string">&quot;test_encrypt_out&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>服务端解码部分（未验证）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c">package main<br><br><span class="hljs-title function_">import</span> <span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-string">&quot;fmt&quot;</span></span><br><span class="hljs-params"><span class="hljs-string">&quot;io/ioutil&quot;</span></span><br><span class="hljs-params"><span class="hljs-string">&quot;net/http&quot;</span></span><br><span class="hljs-params"><span class="hljs-string">&quot;strings&quot;</span></span><br><span class="hljs-params"></span><br><span class="hljs-params"><span class="hljs-string">&quot;github.com/rsc/qr&quot;</span></span><br><span class="hljs-params"><span class="hljs-string">&quot;github.com/rsc/qr/handy&quot;</span></span><br><span class="hljs-params">)</span><br><br>func <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/process_qr_code&quot;</span>, func(w http.ResponseWriter, r *http.Request) &#123;<br><span class="hljs-comment">// 读取上传的二维码图片</span><br>file, _, err := r.FormFile(<span class="hljs-string">&quot;qr_code&quot;</span>)<br><span class="hljs-keyword">if</span> err != nil &#123;<br>http.Error(w, <span class="hljs-string">&quot;Failed to read QR code file&quot;</span>, http.StatusBadRequest)<br><span class="hljs-keyword">return</span><br>&#125;<br>defer file.Close()<br><br><span class="hljs-comment">// 解析二维码</span><br>img, _, err := handy.Decode(file)<br><span class="hljs-keyword">if</span> err != nil &#123;<br>http.Error(w, <span class="hljs-string">&quot;Failed to decode QR code&quot;</span>, http.StatusInternalServerError)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 从解析的二维码中提取加密数据</span><br>encodedData := img.Content<br>encryptedData := strings.TrimSpace(encodedData)<br><br><br>        <span class="hljs-comment">// 加载RSA私钥</span><br>        privateKeyPEM, err := ioutil.ReadFile(<span class="hljs-string">&quot;private_key.pem&quot;</span>)<br>        <span class="hljs-keyword">if</span> err != nil &#123;<br>            http.Error(w, <span class="hljs-string">&quot;Failed to read private key&quot;</span>, http.StatusInternalServerError)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        privateKeyBlock, _ := pem.Decode(privateKeyPEM)<br>        <span class="hljs-keyword">if</span> privateKeyBlock == nil &#123;<br>            http.Error(w, <span class="hljs-string">&quot;Failed to decode private key&quot;</span>, http.StatusInternalServerError)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        privateKey, err := x509.ParsePKCS1PrivateKey(privateKeyBlock.Bytes)<br>        <span class="hljs-keyword">if</span> err != nil &#123;<br>            http.Error(w, <span class="hljs-string">&quot;Failed to parse private key&quot;</span>, http.StatusInternalServerError)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        <span class="hljs-comment">// 解密数据</span><br>        decryptedData, err := rsa.DecryptPKCS1v15(nil, privateKey, encryptedData)<br>        <span class="hljs-keyword">if</span> err != nil &#123;<br>            http.Error(w, <span class="hljs-string">&quot;Failed to decrypt data&quot;</span>, http.StatusInternalServerError)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><span class="hljs-comment">// 返回解密后的数据</span><br>w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/plain&quot;</span>)<br>fmt.Fprintf(w, <span class="hljs-string">&quot;Decrypted Data: %s&quot;</span>, decryptedData)<br>&#125;)<br><br>http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, nil)<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>参考资料<br>Linux下PAM模块学习总结 - 散尽浮华 - 博客园 <code>https://www.cnblogs.com/kevingrace/p/8671964.html</code></p><p>Linux PAM开发示例二:登录系统时使用自己的PAM模块进行密码认证-CSDN博客</p><h1 id="软件保护"><a href="#软件保护" class="headerlink" title="软件保护"></a>软件保护</h1><p>软件保护目的：防止软件被未授权下载、复制、安装、运行、转让、出租、修改、破解</p><p>软件保护从来都是多方面实现的，不能仅靠软件自身。这里从4个维度讨论一下各个层面可以做的事情。<br><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/image-20240307114725324.png" alt="image-20240307114725324"></p><p>软件授权通常出现在商业软件中，其可以对软件的安装、运行做出限制，例如未授权的用户使用该软件（或者该软件的某些功能）。<br>后台隐藏通常在TOB产品的系统级别产品中，通过WEBUI&#x2F;GUI等隐藏实现细节，常常伴随着系统后台信息隐藏、（售后）角色认证等机制，它防范的是用户进入软件的运行基座——操作系统。而原本操作系统的一些基础功能（如时间日期修改、IP地址修改），则通过UI来提供给用户。<br>售后支持是在软件出现问题时，由特定的售后人员去通过网络直连、远程桌面、线下操作等方式。网络直连通常发生在一些内置了对应模块的软件中，它允许售后人员直接连接到软件的控制台，可以看到用户的配置和软件的信息等。线下操作的形式有多种，简单的可以通过用户界面操作，有些特殊的操作则需要进入系统后台操作，这时，前面提到的”后台隐藏“必须要留下售后人员的入口。<br>加密是一种简单而有效的保护方式，加密的级别有很多，例如文件加密、数据库加密、磁盘加密。加密的算法一般是防护的关键，需要用各种手段降低算法被探测的可能，而密钥的存储比密钥的强度更重要。</p><p>下面讨论一下各个部分的方案细节<br>对于在线使用的软件，让用户自行输入用户名是一种简单有效的机制，而对于允许离线使用的软件，需要收集软件的运行环境信息生成一个和环境相关的ID，这个ID通常成为机器码，收集的信息通常是硬件信息。然而，在虚拟化环境、docker环境下，情况可能略有不同，由于虚拟化环境的硬件信息不准确、容易发生变更，而docker就更加没有硬件信息，所以很多厂商都会采用一种叫授权服务器的东西（例如深信服VLS）来应对，这个后文再讨论。<br>软件厂商通过非对称或者对称加密技术，针对用户提供的ID来提供一段经过加密的序列号&#x2F;授权文件，软件通过特定的算法校验ID和序列号&#x2F;授权文件之间的对应关系。以某个厂商的序列号为例：软件通过计算网卡MAC地址的CRC32得到ID，用户提供ID后，厂商通过DES算法和固定密钥将ID变为一串序列号，这串序列号可以由用户手动输入软件中，软件通过DES算法和代码内置的固定密钥解密序列号，得到的信息和ID比较。<br>为了避免用户进入操作系统后台，通常厂商不会提供系统的特权账号密码，然而特权账号的密码在公司里面很多人都知道，例如研发员工、技术支持员工，这其中存在很多泄密的可能。所以有些厂商会修改操作系统的认证机制，实现自定义的认证逻辑，例如扫码登录、动态密码等。这里以linux系统为例，linux系统有一种叫PAM（Pluggable Authentication Modules)的东西，可以简单理解为认证插件，我们可以用c语言来实现对应的接口，然后把代码编译后以动态链接库的形式放到特定目录，修改配置文件即可，不需要修改操作系统的源代码。<br>相应的，我们虽然阻止了用户对系统后台的访问权限，但是也要给技术支持&#x2F;售后等留下入口。首先是软硬件的信息收集，平常我们可以进入系统后台，手动查看、拷贝日志文件，查看环境信息，在高度封闭系统后，这些信息通常会通过一个界面，允许用户&#x2F;技术支持来采集，有必要的时候，再通过售后系统获取系统的登录口令，进入后台手动操作。<br>有些软件会通过全盘加密的方式阻止用户将磁盘挂载到其他系统进行解析，常规的实现是用LUKS来全盘加密，然后在开机阶段去特定的位置获取密钥，大大增加了破解的难度。</p><h1 id="设计文档"><a href="#设计文档" class="headerlink" title="设计文档"></a>设计文档</h1><p>版本修订记录:</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>日期</td><td>版本</td><td>修订人</td><td>修改内容</td><td>备注</td></tr><tr><td>2023-11-1</td><td>0.1</td><td>岑思华</td><td>方案定型，文档基本完成</td><td></td></tr><tr><td>2023-11-6</td><td>0.2</td><td>岑思华</td><td>补充打包项目代码设计</td><td>Makefile</td></tr><tr><td>2023-11-7</td><td>0.3</td><td>岑思华</td><td>补充对其他模块影响；调整项目结构设计</td><td>已评审</td></tr><tr><td>2023-11-9</td><td>0.4</td><td>岑思华</td><td>1.微调；2. 确定磁盘显示方案</td><td></td></tr><tr><td>2023-11-14</td><td>0.5</td><td>岑思华</td><td></td><td></td></tr><tr><td>2023-11-15</td><td>0.6</td><td>袁菘壑</td><td>添加5.2.1.2章节</td><td></td></tr><tr><td>2023-11-22</td><td>0.7</td><td>岑思华</td><td>添加5.2.5章节</td><td></td></tr><tr><td>2023-12</td><td>0.8</td><td>吴松达</td><td>补充7.2.5的mongo动态配置实现</td><td></td></tr></tbody></table><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="1-项目背景"><a href="#1-项目背景" class="headerlink" title="1 项目背景"></a>1 项目背景</h2><p>安装包交付背景下，操作系统由用户提供，用户拥有最高权限，能够随意对软件进行查看、修改、复制等，极大的增加了反破解的难度。</p><p>镜像交付是友商广泛使用的一种做法，它除了体积比较大之外，能够提供比安装包交付更加标准、便捷的过程。</p><h2 id="2-项目目标"><a href="#2-项目目标" class="headerlink" title="2 项目目标"></a>2 项目目标</h2><p>提供镜像交付，将操作系统和石犀软件作为一个交付整体，不再让用户提供操作系统。</p><p>适配主流的虚拟化平台的交付。</p><p>闭环镜像交付各个环节可能需要解决的技术问题</p><p>TUI部分的设计在另一篇文档里面 <a href="https://doc.weixin.qq.com/doc/w3_AcwAzgacAIciuwXMHlQRMqme1AmWW?scode=ABwA9Qd2ABEOAPeCbsAcwAzgacAIc">TUI模块设计说明书</a></p><h2 id="3-名词解释"><a href="#3-名词解释" class="headerlink" title="3 名词解释"></a>3 名词解释</h2><p><strong>镜像：</strong>本文泛指ISO镜像文件、OVA镜像文件、QCOW2镜像文件</p><p><strong>ISO映像：</strong>即符合ISO 9660标准的文件系统，这个标准定义了目录结构、文件名规则、目录深度、文件属性等一系列东西。对于本文而言，ISO映像包含用于安装的引导程序、操作系统本身、其他附加应用，是一个文件。</p><p><strong>ISO镜像：</strong>和ISO映像是一个概念。</p><p><strong>系统安装：</strong>本文的系统安装指的是，将ISO文件挂载成虚拟DVD设备来引导操作系统的安装。</p><p><strong>镜像导入：</strong>将特定格式的镜像文件上传到虚拟化平台称为镜像导入，不同的平台使用不同格式的文件，例如OVA。</p><p><strong>VMDK：</strong> 是一种文件格式，用来作为虚拟磁盘的容器，最初是由vmware开发使用，后来发布OVF标准后，成为开放格式，为大多数虚拟化平台所支持。</p><p><strong>QCOW2：</strong>即qcow的第二个版本,和vmdk类似，qcow也是一种虚拟磁盘容器。qcow目前有三个版本，国内大部分公有云支持的都是qcow2格式。</p><p><strong>OVF文件：</strong>一种用于打包虚拟机配置信息（如CPU，内存，磁盘，网卡)的文件，它也是一种比较主流的规范，大多数虚拟化平台都支持。</p><p><strong>OVA：</strong>一种打包格式，和tar是同一种标准，相当于tar包改了后缀名。里面包含至少两个文件：ovf和vmdk，还有一个可选的mf文件（存储其他文件的哈希值）</p><p><strong>分区扩容：</strong>指在现有的分区上扩大分区空间，虽然虚拟磁盘可以调整大小，但是调整后的大小并不会直接反应到分区上，需要对分区进行扩容以适配新的磁盘大小。</p><p><strong>关机扩容：</strong>即分区扩容需要关机或者重启，扩容才能生效。</p><p><strong>开机扩容：</strong>即热扩容，分区扩容不需要重启就能生效。</p><p><strong>包：</strong>包原本指将总控和引擎的二进制、配置、依赖等压缩在一起的一个可用于安装、升级的包。在本文中将其含义进一步泛化，将镜像文件也归类到包的范畴，会以镜像包指代镜像。</p><p><strong>精简置备：</strong>精简置备是一种动态分配存储空间的技术，它允许在创建时仅分配必要的存储空间，而不是预先分配整个空间。这意味着虚拟磁盘的实际大小可以根据需要动态地增长，直到达到预设的上限。精简置备技术可以有效地提高存储利用率，因为它可以避免为未来可能用不上的空间预留存储容量。</p><p><strong>厚置备：</strong>厚置备是一种静态分配存储空间的技术，它会在虚拟磁盘创建时立即分配整个设定空间。这意味着虚拟磁盘会占用所分配的空间，即使实际上并没有使用全部空间。厚置备会提供更高的性能，因为存储空间已经被预先分配并保留，但会导致低效的存储利用率。</p><h2 id="4-总体设计"><a href="#4-总体设计" class="headerlink" title="4 总体设计"></a>4 总体设计</h2><h3 id="4-1-概要设计"><a href="#4-1-概要设计" class="headerlink" title="4.1 概要设计"></a>4.1 概要设计</h3><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="4-1-1-实现的功能"><a href="#4-1-1-实现的功能" class="headerlink" title="4.1.1 实现的功能"></a>4.1.1 实现的功能</h4><p>概要描述该模块要实现的功能。列出要实现的功能点及子功能点，并对每一个功能点进行详细说明。功能点之间的层级和关联关系要明晰。这里仅描述功能，不需要涉及实现方案、功能取舍等问题。</p><ol><li><p>实现自动化镜像制作</p></li><li><p>镜像按照需求的描述，统一各项系统设置，安装过程自动化</p><ol><li><p>按照需求进行分区</p></li><li><p>按照需求定制grub引导</p></li></ol></li><li><p>实现分区的关机扩容</p></li></ol><h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h4 id="4-1-2-设计的性能指标"><a href="#4-1-2-设计的性能指标" class="headerlink" title="4.1.2 设计的性能指标"></a>4.1.2 设计的性能指标</h4><p>无</p><h4 id="4-2-覆盖范围"><a href="#4-2-覆盖范围" class="headerlink" title="4.2 覆盖范围"></a>4.2 覆盖范围</h4><p>描述本次项目覆盖的范围，为了降低风险，建议项目上线前做好灰度范围控制</p><ol><li><p>打包平台-出包流程</p></li><li><p>总控安装、部署、升级</p></li></ol><h2 id="5-详细设计"><a href="#5-详细设计" class="headerlink" title="5 详细设计"></a>5 详细设计</h2><h3 id="5-1-设计图"><a href="#5-1-设计图" class="headerlink" title="5.1 设计图"></a>5.1 设计图</h3><p><strong>出包过程图</strong></p><p>本图描述有哪些包，这些包的内容是从哪来的。</p><p><img src="/../../../../home/xiaoy/media/image1.png" alt="图标 描述已自动生成"></p><p><strong>镜像制作(image-builder)项目结构设计</strong></p><p><strong>安装部署流程</strong></p><p>本图提供安装部署的流程对比，左边是没有做这块需求的时候的逻辑，右边是有了镜像交付之后的逻辑.</p><p><img src="/../../../../home/xiaoy/media/image2.png" alt="图标 描述已自动生成"></p><p><strong>镜像生命周期</strong></p><p>安装前包括打包的部分、将包上传到网盘、客户下载包、导入包</p><p>安装中主要是导入进度条跑完之后，镜像的安装只需要调整配置，进度条即是上传的进度</p><p><img src="/../../../../home/xiaoy/media/image3.png" alt="图标 描述已自动生成"></p><h3 id="5-2-各模块详细设计"><a href="#5-2-各模块详细设计" class="headerlink" title="5.2 各模块详细设计"></a>5.2 各模块详细设计</h3><p>对各个模块进行详细阐述，数据之间的关联关系, 使用的何种算法, 明确的接口定义(包含输入&#x2F;输出&#x2F;异常&#x2F;错误码), 尽量明确到代码层级，达到设计文档交给第三个人也可以按照文档要求进行代码开发</p><h4 id="5-2-1-基ISO镜像详细设计"><a href="#5-2-1-基ISO镜像详细设计" class="headerlink" title="5.2.1 基ISO镜像详细设计"></a>5.2.1 基ISO镜像详细设计</h4><p><strong>需求回顾</strong></p><ol><li><p>禁用snap包管理器</p></li><li><p>禁用系统自动更新</p></li><li><p>系统参数预定义（含账户、分区、语言等）</p></li></ol><p><del>由于基镜像难以自动化制作，所以基镜像需要尽可能做到少更新，里面不包含总控应用，总控由打包流程集成到基镜像中作为正式镜像。</del></p><p>后续引擎也需要考虑镜像交付，所以基镜像既是总控的基镜像，也是引擎的基镜像。不管是总控还是引擎，都应该能够顺利的在该镜像里面安装，不会出现系统版本、内核版本问题，不会出现底层依赖缺失问题。</p><p>目前的设计仅考虑Legacy BIOS模式即可，不需要考虑UEFI模式。</p><p><strong>方案一</strong>：使用cubic+seed制作</p><p><strong>方案二</strong>：使用xorrios+cloud-init制作</p><p>方案一在ubuntu20.04不可行，故使用方案二</p><h5 id="5-2-1-1-使用cubic制作基镜像流程"><a href="#5-2-1-1-使用cubic制作基镜像流程" class="headerlink" title="5.2.1.1 使用cubic制作基镜像流程"></a>5.2.1.1 使用cubic制作基镜像流程</h5><ol><li><p>下载一个官方的ISO镜像，这里使用ubuntu 20.04.6</p></li><li><p>用cubic打开官方ISO镜像</p></li><li><p>定制发行版名字</p></li><li><p>进入chroot环境，通过命令行进行定制</p><ol><li><p>删除不需要的包管理器（snap）</p></li><li><p><del>关闭系统自动更新（unattended-upgrades）</del>(可以在preseed里搞定)</p></li></ol></li><li><p>选择内核（如果有多个）</p></li><li><p>编写preseed文件，设定参数</p><ol><li><p>定制网络配置</p></li><li><p>定制磁盘分区</p></li><li><p>定制语言及键盘</p></li><li><p>定制用户名密码、主机名</p></li><li><p>定制预装的软件（ssh server)</p></li><li><p>定制GRUB密码</p></li></ol></li><li><p>修改&#x2F;isolinux&#x2F;txt.cfg，指向preseed文件</p></li></ol><p><strong>preseed文件详细设计</strong></p><p><strong>参考资料</strong></p><p><a href="https://blog.csdn.net/m0_37579176/article/details/112492277">【精选】使用 “Cubic” 制作自定义 “ubuntu” 系统镜像_cubic制作镜像_此木子的博客-CSDN博客</a></p><p><a href="https://github.com/sexibytes/packer-sexigraf/blob/master/preseed.cfg">https://github.com/sexibytes/packer-sexigraf/blob/master/preseed.cfg</a></p><p><a href="https://askubuntu.com/questions/1228909/preseed-config-using-cubic-is-ignored-during-installation">18.04 - Preseed config (using cubic) is ignored during installation - Ask Ubuntu</a></p><p><a href="https://gist.github.com/styblope/2cf93a41662608f924de71fd0e91e0d1">https://gist.github.com/styblope/2cf93a41662608f924de71fd0e91e0d1</a></p><p><a href="https://www.debian.org/releases/bullseye/amd64/apbs04.en.html">B.4.Contents of the preconfiguration file (for bullseye)</a></p><p><a href="https://developer.aliyun.com/article/1234791">使用preseed一键安装Ubuntu Server 1604-阿里云开发者社区</a></p><p><a href="https://zhangguanzhang.github.io/2019/08/06/preseed/">ubuntu preseed无人应答安装 · zhangguanzhang&#39;s Blog</a></p><p><a href="https://sysin.org/blog/disable-ubuntu-auto-update/">https://sysin.org/blog/disable-ubuntu-auto-update/</a></p><p><a href="https://github.com/covertsh/ubuntu-autoinstall-generator/tree/main">GitHub - covertsh&#x2F;ubuntu-autoinstall-generator: Generate a fully-automated Ubuntu ISO for unattended installations.</a></p><h5 id="5-2-1-2-使用xorriso制作基镜像流程"><a href="#5-2-1-2-使用xorriso制作基镜像流程" class="headerlink" title="5.2.1.2 使用xorriso制作基镜像流程"></a>5.2.1.2 使用xorriso制作基镜像流程</h5><ol><li><p>下载一个官方的ISO镜像，这里使用ubuntu 20.04.6</p></li><li><p>使用xorriso解压镜像文件</p></li><li><p>通过unsquash将解压出来的文件filesystem.squashfs进行反编译</p></li><li><p>通过chroot操作解压出来的filesystem.squashfs文件系统，对应安装后的ubuntu根目录，执行完毕后，将squashfs文件重新打包成filesystem.squashfs文件，放入解压的镜像目录中。</p></li><li><p>ubuntu20.04及其之后都使用cloud-init方式实现自动化安装，将自动安装参数autoinstall ds&#x3D;nocloud;s&#x3D;&#x2F;cdrom&#x2F;cloud_init&#x2F;添加到isolinux&#x2F;txt.cfg文件中quiet之前，然后将必要的文件user-data, meta-data复制到制定文件路径 &#x2F;cloud_init目录下。在user-data和meta-data中即可开启自动安装设置，不设置即走默认的安装设置。</p><ol><li><p>定制网络配置 &#x2F;&#x2F; 已完成</p></li><li><p>前置资源检查 &#x2F;&#x2F; 如何告诉用户？</p></li><li><p>定制磁盘分区 &#x2F;&#x2F; 已完成</p></li><li><p>定制语言及键盘 &#x2F;&#x2F; 已完成</p></li><li><p>定制用户名密码、主机名 &#x2F;&#x2F; 已完成</p></li><li><p>定制预装的软件（ssh server) &#x2F;&#x2F; 已完成</p></li><li><p>定制GRUB密码 &#x2F;&#x2F; 已完成</p></li><li><p>修改grub菜单选项</p></li></ol></li><li><p>镜像修改完成之后，通过xorriso再将文件打包成iso镜像。</p></li></ol><p><strong>user-data文件配置</strong></p><p><strong>制作镜像shell脚本(大概流程，实现与此不同)</strong></p><p>参考资料</p><p><a href="https://cloudinit.readthedocs.io/en/latest/reference/datasources/nocloud.html">ubuntu nocloud-init文档</a></p><p><a href="https://netplan.readthedocs.io/en/stable/netplan-yaml/#properties-for-device-type-ethernets">网络配置</a></p><p><a href="https://curtin.readthedocs.io/en/latest/topics/storage.html#lvm-partition-command">curtin设置文件系统分区</a></p><p><a href="https://www.gnu.org/software/grub/manual/grub/html_node/Authentication-and-authorisation.html">grub密码设置文档</a></p><p><a href="https://michlstechblog.info/blog/linux-disable-assignment-of-new-names-for-network-interfaces/">网卡名称兼容</a></p><h4 id="5-2-2-扩容脚本详细设计"><a href="#5-2-2-扩容脚本详细设计" class="headerlink" title="5.2.2 扩容脚本详细设计"></a>5.2.2 扩容脚本详细设计</h4><p><strong>目的</strong></p><p>镜像交付下的磁盘是已经分好区的，是确定的大小，而客户有不同的目的，需要的磁盘空间是不确定的。脚本的目的是自动调整文件系统的配置，跟踪物理磁盘的容量变化（只增不减）。</p><h5 id="5-2-2-1-可选方案"><a href="#5-2-2-1-可选方案" class="headerlink" title="5.2.2.1 可选方案"></a>5.2.2.1 可选方案</h5><p><strong>方案一 单磁盘设计</strong></p><p>思路: 监控特定的硬盘&#x2F;dev&#x2F;sda的物理容量是否发生变化, 变化后则调整数据分区大小</p><p>特点: 适用于虚拟化环境和带RAID卡的物理机环境，只能关机扩容。</p><p>要求: 以虚拟机为例, 编辑虚拟机的磁盘配置,调大磁盘大小即可。以物理机为例，插入一块新的硬盘，然后在BIOS里面调整RAID配置。</p><p><strong>方案二 多磁盘设计</strong></p><p>思路: 监控新增的磁盘，如果识别到多了一块没使用的硬盘，则将其容量增加到数据分区</p><p>特点：适用于虚拟化环境和不带RAID卡（或者RAID处于IT模式）的物理机环境，可以开机扩容</p><p>要求：以虚拟机为例，增加一个块任意大小的虚拟磁盘即可。以物理机为例，插入一个新的硬盘即可。</p><p>本节中，假定<strong>方案二</strong>更常见，并以此做进一步设计。</p><h5 id="5-2-2-2-检测原理"><a href="#5-2-2-2-检测原理" class="headerlink" title="5.2.2.2 检测原理"></a>5.2.2.2 检测原理</h5><p>考虑关机扩容，那么假设有一个脚本，它在开机后执行</p><p>基于单磁盘方案（<strong>方案一</strong>）：</p><ol><li><p>关机，修改硬盘大小</p></li><li><p>使用pvresize 调整pv大小</p></li><li><p>使用lvextend扩容lv到当前vg大小</p></li><li><p>使用resize2fs调整ext4分区大小</p></li></ol><p>基于多磁盘方案（<strong>方案二</strong>）：</p><p>遍历磁盘列表，如果发现有没有登记过的磁盘，则将其添加到vg中，然后再调整lv</p><p>手动操作过程：</p><ol><li><p>添加一块磁盘</p></li><li><p>人肉判断哪个盘是新加的盘</p></li><li><p>用pvcreate将该盘添加到pv</p></li><li><p>用vgextend将pv添加到vg</p></li><li><p>用lvextend将lv扩容到当前vg的大小</p></li><li><p>用resize2fs将lv的容量应用到ext4分区大小</p></li></ol><p><img src="/../../../../home/xiaoy/media/image4.png" alt="图标 描述已自动生成"></p><h5 id="5-2-2-3-开机运行实现"><a href="#5-2-2-3-开机运行实现" class="headerlink" title="5.2.2.3 开机运行实现"></a>5.2.2.3 开机运行实现</h5><p>方案一：systemd</p><p>方案二：init.d</p><p>方案二在centos系统用的比较多，本文采用的首选方案为方案一</p><h4 id="5-2-3-打包模块详细设计"><a href="#5-2-3-打包模块详细设计" class="headerlink" title="5.2.3 打包模块详细设计"></a>5.2.3 打包模块详细设计</h4><h5 id="5-2-3-1-ISO镜像打包方案"><a href="#5-2-3-1-ISO镜像打包方案" class="headerlink" title="5.2.3.1 ISO镜像打包方案"></a>5.2.3.1 ISO镜像打包方案</h5><p>概述</p><p>在基ISO镜像的基础上，按照总控安装的流程，将二进制文件、配置文件、依赖的库拷贝到安装后的目录。基ISO镜像的制作使用了cubic，但cubic是一个图形化工具，不利于自动化，为此我们需要使用到命令行工具来达成目的。</p><p>相关工具</p><ul><li><p>xorriso 用于解包和打包ISO</p></li><li><p>unsquashfs 用于展开casper压缩文件</p></li><li><p>mksquashfs 用于将文件系统压缩成casper</p></li><li><p>fakeroot 用于实现chroot，切换根目录，方便进行apt安装等操作</p></li></ul><p>关键步骤实现</p><ul><li><p>文件拷贝</p></li><li><p>系统初始化</p></li></ul><p>ISO挂载</p><p>ISO解除挂载</p><p>切换根目录</p><h5 id="5-2-3-2-OVA镜像打包方案"><a href="#5-2-3-2-OVA镜像打包方案" class="headerlink" title="5.2.3.2 OVA镜像打包方案"></a>5.2.3.2 OVA镜像打包方案</h5><p><img src="/../../../../home/xiaoy/media/image5.png" alt="图标 描述已自动生成"></p><p>如图，如果采用官方ISO镜像来制作OVA，那么制作出来的是基OVA镜像，它需要一次制作，不断更新。在无法实现制作石犀ISO的背景下，是比较合适的路。</p><p>无论前面的方案如何，最终制作OVA时，都需要一个VMDK文件（虚拟磁盘文件），这个文件的创建有两条路走，一条是使用vmware来操作一遍安装流程，一条是用命令创建一个空的vmdk文件，并通过某种方式挂载到文件系统中，然后通过某种方式来将系统安装到vmdk上。 前者实现简单，但是存在难以自动化的问题，后者实现不确定性比较大，但是是理论上可以自动化的方案。</p><p>综合多方考虑，取两种方案，分别为图中蓝色和绿色两种。绿色是比较理想的情况，它意味着ISO镜像的方案比较成熟，可以很好的支撑其他类型镜像的制作。蓝色是妥协的情况，这里着重说一下。</p><p>蓝色的制作步骤为：</p><ol><li><p>获取官方ISO镜像</p></li><li><p>手工操作vmware，创建虚拟机，然后安装该镜像</p></li><li><p>安装完成后，不要重启，直接关机，避免进入系统</p></li><li><p>此时得到的vmdk可以认为是基OVA，下面步骤要实现自动化，否则全手操效率极低</p></li><li><p>将基OVA拷贝，挂载到其他系统</p><ol><li><p>ovftool将ova里的vmdk转化为可读写的vmdk</p></li><li><p>guestmount挂载vmdk里的文件系统到某个目录</p></li></ol></li><li><p>将一些定制化的内容放到该磁盘中（这一步可以前移到基镜像）</p></li><li><p>将总控安装到该磁盘中</p><ol><li><p>文件校验</p></li><li><p>拷贝二进制、配置到&#x2F;$挂载目录&#x2F;opt&#x2F;xxx（不含systemd)</p></li><li><p>拷贝systemd配置到&#x2F;$挂载目录&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;</p></li><li><p>chroot + 依赖安装 + 添加自启动</p></li><li><p>初始化mysql,mongo</p></li></ol></li><li><p>解除挂载，将vmdk和ovf封装成ova</p></li></ol><p>相关工具</p><ul><li><p>guestmount</p></li><li><p>ovftool</p></li></ul><p>ovftool解包</p><p>ovftool打包</p><p>OVA挂载</p><p>OVA解除挂载</p><p>参考资料</p><p><a href="https://dev.to/otomato_io/how-to-create-custom-debian-based-iso-4g37">How to Create Custom Debian BasedISO - DEV Community</a></p><p><a href="https://github.com/covertsh/ubuntu-autoinstall-generator/blob/main/ubuntu-autoinstall-generator.sh">https://github.com/covertsh/ubuntu-autoinstall-generator/blob/main/ubuntu-autoinstall-generator.sh</a></p><p><a href="http://zenki2001cn.github.io/Wiki/Debian/iso%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%E5%88%B6%E4%BD%9C.html">iso镜像文件制作</a></p><h5 id="5-2-3-3-main-sh脚本设计"><a href="#5-2-3-3-main-sh脚本设计" class="headerlink" title="5.2.3.3 main.sh脚本设计"></a>5.2.3.3 main.sh脚本设计</h5><p>单纯的文件拷贝，可以由main.sh的各个函数完成，而有些需要在切换root后执行的命令，则作为单独的文件，在guest-install目录管理，将其拷贝到挂载路径后，在切换root后执行对应的脚本</p><p><img src="/../../../../home/xiaoy/media/image6.png" alt="图标 描述已自动生成"></p><h5 id="5-2-3-4-Makefile设计"><a href="#5-2-3-4-Makefile设计" class="headerlink" title="5.2.3.4 Makefile设计"></a>5.2.3.4 Makefile设计</h5><p>调用<a href="http://main.sh/">main.sh</a> 传递解压后的总控包，基镜像，以及目标镜像作为参数 。目标镜像就是不同的target</p><p><strong>target依赖关系图</strong></p><ul><li><p>ubuntu-iso-20-official是官方镜像，使用Ubuntu 20.04.6</p></li><li><p>srhino-package是打包平台出的tar.gz包</p></li></ul><p>红色部分是识别到的难以自动化的步骤，故而ubuntu-ova-m1这个分支当前不具有可行性，导致整个iso分支暂时失去了价值。目前计划仅实现绿色路径的target</p><p><img src="/../../../../home/xiaoy/media/image7.png" alt="图标 描述已自动生成"></p><h4 id="5-2-4-磁盘分区详细设计"><a href="#5-2-4-磁盘分区详细设计" class="headerlink" title="5.2.4 磁盘分区详细设计"></a>5.2.4 磁盘分区详细设计</h4><h5 id="5-2-4-1-初始分区大小规划"><a href="#5-2-4-1-初始分区大小规划" class="headerlink" title="5.2.4.1 初始分区大小规划"></a>5.2.4.1 初始分区大小规划</h5><p>[TABLE]</p><h5 id="5-2-4-2-LVM设计"><a href="#5-2-4-2-LVM设计" class="headerlink" title="5.2.4.2. LVM设计"></a>5.2.4.2. LVM设计</h5><p>将系统盘分为3个VG+1个普通分区，普通分区是&#x2F;boot分区，使用ext3或ext4文件系统</p><p>3个VG分别和5.2.4.1中描述的分区大小一一对应，每个VG划分一个LV</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>VG(卷组)</td><td>PV(物理卷)</td><td>Size</td></tr><tr><td>vg_root</td><td>&#x2F;dev&#x2F;sdaX</td><td>28G</td></tr><tr><td>vg_app</td><td>&#x2F;dev&#x2F;sdaX</td><td>10G</td></tr><tr><td>vg_data</td><td>&#x2F;dev&#x2F;sdaX &#x2F;dev&#x2F;sdbX …</td><td>60G+n</td></tr></tbody></table><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>LV(逻辑卷)</td><td>VG(卷组)</td></tr><tr><td>lv_root</td><td>vg_root</td></tr><tr><td>lv_app</td><td>vg_app</td></tr><tr><td>lv_data</td><td>vg_data</td></tr></tbody></table><h5 id="5-2-4-3-软链接"><a href="#5-2-4-3-软链接" class="headerlink" title="5.2.4.3. 软链接"></a>5.2.4.3. 软链接</h5><p>在当前版本的镜像里面，创建好以下的软连接，将占用空间比较大的，且非固定大小的目录都链接到数据分区，如：数据库文件、用户上传的文件。</p><p>软连接目前仅用于兼容原有设计，后续需要将各个程序的路径改为目的地所在的路径</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>软链接</td><td>目的地</td><td>说明</td></tr><tr><td>&#x2F;opt&#x2F;mongodb&#x2F;data</td><td>&#x2F;data&#x2F;mongodb&#x2F;data</td><td>mongodb数据存储目录</td></tr><tr><td><del>&#x2F;opt&#x2F;mongodb&#x2F;log&#x2F;</del></td><td><del>&#x2F;data&#x2F;mongodb&#x2F;log</del></td><td><del>mongo日志（有轮转）</del></td></tr><tr><td>&#x2F;opt&#x2F;etcd&#x2F;data</td><td>&#x2F;data&#x2F;etcd&#x2F;data</td><td>etcd数据</td></tr><tr><td>&#x2F;opt&#x2F;etcd&#x2F;wal</td><td>&#x2F;data&#x2F;etcd&#x2F;wal</td><td>etcd预写</td></tr><tr><td>&#x2F;opt&#x2F;nsq&#x2F;data</td><td>&#x2F;data&#x2F;nsq&#x2F;data</td><td>mq数据</td></tr><tr><td>&#x2F;opt&#x2F;redis&#x2F;data</td><td>&#x2F;data&#x2F;redis&#x2F;data</td><td>redis数据</td></tr><tr><td>&#x2F;opt&#x2F;sv&#x2F;cache</td><td>&#x2F;data&#x2F;sv&#x2F;cache</td><td>可视化数据</td></tr><tr><td>&#x2F;opt&#x2F;mysql&#x2F;data</td><td>&#x2F;data&#x2F;mysql&#x2F;data</td><td>mysql数据</td></tr><tr><td>&#x2F;opt&#x2F;repo</td><td>&#x2F;data&#x2F;repo</td><td>插件包&#x2F;原始包</td></tr><tr><td>&#x2F;opt&#x2F;sc&#x2F;data</td><td>&#x2F;data&#x2F;sc&#x2F;data</td><td>备份目录</td></tr><tr><td>&#x2F;opt&#x2F;data</td><td>&#x2F;data&#x2F;installer&#x2F;data</td><td>引擎的证书</td></tr><tr><td>&#x2F;opt&#x2F;installer&#x2F;data</td><td></td><td></td></tr><tr><td>&#x2F;opt&#x2F;os&#x2F;data</td><td>&#x2F;data&#x2F;os&#x2F;data</td><td>系统定制程序的数据</td></tr></tbody></table><h5 id="5-2-4-4-OEM分区文件"><a href="#5-2-4-4-OEM分区文件" class="headerlink" title="5.2.4.4. OEM分区文件"></a>5.2.4.4. OEM分区文件</h5><p>文件格式为INI格式</p><p>位于&#x2F;oem&#x2F;info，权限设计为rw——-</p><p>文件内容的管理目前为手动更新，其托管在git上，集成到基镜像中</p><p>注：关于SP版本，原设计是专注于系统内部程序补丁版本，现在既然把TUI和扩容集成进来，未来SP版本也会受到TUI和扩容脚本的版本影响。</p><h4 id="5-2-5-预处理脚本详细设计"><a href="#5-2-5-预处理脚本详细设计" class="headerlink" title="5.2.5 预处理脚本详细设计"></a>5.2.5 预处理脚本详细设计</h4><p>当前总控打出的包感觉格式不统一，在统一规范未实现之前，本项目通过一个脚本来修正一些不合理的文件、配置、布局。镜像制作程序会按照预处理后的格式进行编码，为了不出现维护问题，以后的打包脚本应该满足下面的规范，满足后通知镜像这边，镜像这边再移除相应的逻辑。</p><h5 id="5-2-5-1-统一systemd文件"><a href="#5-2-5-1-统一systemd文件" class="headerlink" title="5.2.5.1 统一systemd文件"></a>5.2.5.1 统一systemd文件</h5><p><strong>原则：</strong></p><ul><li><p>在总控通过systemd托管的程序，其service文件都要放到systemd子目录下</p></li><li><p>service文件必须是LF换行符</p></li></ul><p><strong>当前实现：</strong></p><ul><li><p>api-gov&#x2F;hack&#x2F;*.service -&gt; api-gov&#x2F;systemd&#x2F;</p></li><li><p>sv&#x2F;hack&#x2F;sv.service -&gt; sv&#x2F;systemd&#x2F;sv.service</p></li><li><p>将nsq&#x2F;systemd&#x2F;nsqlookupd.service的换行符改为LF</p></li></ul><h5 id="5-2-5-2-统一配置文件层级"><a href="#5-2-5-2-统一配置文件层级" class="headerlink" title="5.2.5.2 统一配置文件层级"></a>5.2.5.2 统一配置文件层级</h5><p><strong>原则：</strong></p><ul><li><p>在总控运行的程序，其配置文件在config子目录下</p></li><li><p>职责分明，依赖的处理应该由安装&#x2F;升级阶段解决</p></li></ul><p><strong>当前实现：</strong></p><ul><li><p>删除mysql&#x2F;template目录</p></li><li><p>移除mysqld.service的`ExecStartPre&#x3D;&#x2F;opt&#x2F;mysql&#x2F;bin&#x2F;mysql-systemd-start pre`</p></li><li><p>删除etcd&#x2F;work目录</p></li><li><p>修改etcd.service的`EnvironmentFile&#x3D;&#x2F;opt&#x2F;etcd&#x2F;config&#x2F;etcd.conf`PI</p></li><li><p>将redis&#x2F;etc改为redis&#x2F;confg</p></li><li><p>修改redis.service的`ExecStart&#x3D;&#x2F;opt&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;opt&#x2F;redis&#x2F;config&#x2F;redis-stack.conf`</p></li><li><p>&#x2F;etc&#x2F;mysql&#x2F;my.cnf从拷贝改为创建链接到&#x2F;opt&#x2F;mysql&#x2F;config&#x2F;my.cnf</p></li></ul><p><strong>暂时仅限于镜像：</strong></p><p>有些东西暂时要求不了，仅放镜像这边，后面再看情况(2023-11-23)</p><ul><li><p>删除mongod.service的`ExecStartPre&#x3D;ln -sf ……..`</p></li><li><p>删除mongod.service的`Environment&#x3D;”LD_LIBRARY_PATH&#x3D;…`</p></li></ul><h5 id="5-2-5-3-统一data目录"><a href="#5-2-5-3-统一data目录" class="headerlink" title="5.2.5.3 统一data目录"></a>5.2.5.3 统一data目录</h5><p>TODO</p><h3 id="5-3-功能实现"><a href="#5-3-功能实现" class="headerlink" title="5.3 功能实现"></a>5.3 功能实现</h3><h4 id="5-3-1-镜像制作相关实现"><a href="#5-3-1-镜像制作相关实现" class="headerlink" title="5.3.1 镜像制作相关实现"></a>5.3.1 镜像制作相关实现</h4><h5 id="5-3-1-1-系统定制相关说明"><a href="#5-3-1-1-系统定制相关说明" class="headerlink" title="5.3.1.1 系统定制相关说明"></a>5.3.1.1 系统定制相关说明</h5><ul><li>root用户密码设置</li></ul><p>cloud-init不支持直接使用在identity中设置的root用户，需要手动修改root用户的相关权限</p><p>首先解锁root用户后，设置相关密码</p><p>密码使用openssl passwd -6 -stdin &lt;&lt;&lt; 123.com生成</p><ul><li>关闭swap文件</li></ul><p>&nbsp;</p><ul><li>关闭第一次开机sshinit信息</li></ul><p>&nbsp;</p><ul><li>禁用系统自动更新</li></ul><h5 id="5-3-1-2-grub定制相关说明"><a href="#5-3-1-2-grub定制相关说明" class="headerlink" title="5.3.1.2 grub定制相关说明"></a>5.3.1.2 grub定制相关说明</h5><ul><li>设置重启后进入grub界面</li></ul><p>通过设置grub菜单选择超时时间，重启默认进入grub，即使没有多个启动选项</p><ul><li>开启grub菜单编辑密码保护</li></ul><p>&nbsp;</p><ul><li>修改grub菜单显示样式</li></ul><h5 id="5-3-1-3-内核启动参数定制说明"><a href="#5-3-1-3-内核启动参数定制说明" class="headerlink" title="5.3.1.3 内核启动参数定制说明"></a>5.3.1.3 内核启动参数定制说明</h5><ul><li>设置网卡默认名称</li></ul><p>网卡名称通常分为两类(en卓和eth)，这里全部默认为eth0</p><h5 id="5-3-1-4-离线apt仓库制作"><a href="#5-3-1-4-离线apt仓库制作" class="headerlink" title="5.3.1.4 离线apt仓库制作"></a>5.3.1.4 离线apt仓库制作</h5><ol><li><p>生成gpg密钥，用于离线apt仓库的签名。</p></li><li><p>制作离线仓库包</p></li><li><p>基础镜像添加离线源</p></li><li><p>使用echo输入密码</p></li><li><p>打包deb依赖到离线仓库</p></li></ol><h5 id="5-3-1-5-容器初始化数据库"><a href="#5-3-1-5-容器初始化数据库" class="headerlink" title="5.3.1.5 容器初始化数据库"></a>5.3.1.5 容器初始化数据库</h5><ol><li>利用docker实现</li></ol><p>需要编写dockerFile 将文件映射到docker中，利用docker中的应用运行来初始化相关数据文件。优点: 不需要手动维护相关系统资源。缺点：打包需要引入docker组件，和一个dockerFile文件。</p><ol start="2"><li>利用linux自带的命名空间实现</li></ol><p>通过unshare来隔离主机中的各个命名空间实现资源隔离，为docker的实现原理，但是需要手动管理相关的隔离资源。优点：不需要引入第三方依赖，直接在squashfs文件中运行，不需要做数据文件拷贝。缺点：在使用上可能会出现一些问题需要手动解决。</p><ol start="3"><li>使用systemd-nspawn实现</li></ol><p>暂未调研</p><h5 id="5-3-1-6-关闭cloud-init服务的ssh输出"><a href="#5-3-1-6-关闭cloud-init服务的ssh输出" class="headerlink" title="5.3.1.6 关闭cloud-init服务的ssh输出"></a>5.3.1.6 关闭cloud-init服务的ssh输出</h5><h5 id="5-3-1-7-系统启动信息输出服务"><a href="#5-3-1-7-系统启动信息输出服务" class="headerlink" title="5.3.1.7 系统启动信息输出服务"></a>5.3.1.7 系统启动信息输出服务</h5><p>系统启动信息输出是操作系统开机时输出的系统相关的信息，主要为用户了解当前的开机情况，其中包含系统基础信息输出，以及石犀组件状态在开机过程中的输出。</p><ol><li><p>ubuntu的开机过程主要托管到了systemd服务中，我们包含的cpu、lvm、内存、网卡信息以及总控组件的相关状态输出</p></li><li><p>该服务不阻塞系统的正常启动，仅仅只是为了添加系统启动的一个输出画面，该服务在TUI服务启动之前完成，避免将console信息输出到TUI界面上造成混乱。</p></li></ol><ul><li>实现</li></ul><p>通过读取config&#x2F;srhino_service获取当前总控所在机器的所有组件信息，然后进行服务状态输出。后续总控升级时添加了组件也需要将组件信息新增到这个配置文件。</p><h5 id="5-3-1-8-添加服务状态菜单选项"><a href="#5-3-1-8-添加服务状态菜单选项" class="headerlink" title="5.3.1.8 添加服务状态菜单选项"></a>5.3.1.8 添加服务状态菜单选项</h5><p>将原来TUI第五个技术支持选项修改为服务状态选项，能够获取当前总控的各个组件的对应状态，在组件的右边如果是绿色则表示该组件是正常的，如果是红色则表示该组件是不正常的。</p><ul><li>实现</li></ul><p>在TUI的菜单中显示组件状态，依然使用config&#x2F;srhino_serivce文件中的配置信息。且考虑到组件可能是动态变化的，这里的TUI使用动态行高来展示组件状态。</p><h5 id="5-3-1-9-系统硬件信息展示"><a href="#5-3-1-9-系统硬件信息展示" class="headerlink" title="5.3.1.9 系统硬件信息展示"></a>5.3.1.9 系统硬件信息展示</h5><p>在命令行选项里面，新增了一个hardware_info的命令，该命令能够展示当前系统的cpu，memory，disk的相关使用情况，该命令依赖于free, df命令。</p><ul><li>实现</li></ul><p>获取系统硬件信息的时候，主要通过df和free命令获取相关内存信息和分区信息。</p><ol><li><p>内存信息的使用为free -h中的used这一栏，目前没有展示剩余可用内存。</p></li><li><p>磁盘主要展示石犀自定义的三个分区相关使用情况(&#x2F; , &#x2F;data, &#x2F;opt)</p></li><li><p>cpu的使用率为间隔一秒读取&#x2F;proc&#x2F;cpuinfo计算得到。目前仅仅只有当前cpu使用率。</p></li></ol><h4 id="5-3-2-iso自动化制作ova文件"><a href="#5-3-2-iso自动化制作ova文件" class="headerlink" title="5.3.2 iso自动化制作ova文件"></a>5.3.2 iso自动化制作ova文件</h4><h5 id="5-3-2-1-虚拟机的相关配置"><a href="#5-3-2-1-虚拟机的相关配置" class="headerlink" title="5.3.2.1 虚拟机的相关配置"></a>5.3.2.1 虚拟机的相关配置</h5><p>这个是srhino.vmx配置文件，通常用来描述一个虚拟机的配置，这里用于ovftool导出时，导出对应的虚拟机配置。</p><h5 id="5-3-2-2-qemu启动参数"><a href="#5-3-2-2-qemu启动参数" class="headerlink" title="5.3.2.2 qemu启动参数"></a>5.3.2.2 qemu启动参数</h5><p>通过qemu挂载iso镜像之后启动镜像安装到指定vmdk磁盘</p><p>然后通过ovftool导出ova磁盘文件</p><p>5.3.2.3 镜像启动失败备用方案</p><h2 id="6-自测"><a href="#6-自测" class="headerlink" title="6 自测"></a>6 自测</h2><p>当前工程下自己需要自测的模块以及自测方法</p><h3 id="6-1-自测模块"><a href="#6-1-自测模块" class="headerlink" title="6.1 自测模块"></a>6.1 自测模块</h3><p>包含当前设计的模块与依赖的周边组件&#x2F;模块</p><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="6-2-自测方式"><a href="#6-2-自测方式" class="headerlink" title="6.2 自测方式"></a>6.2 自测方式</h3><p>进行测试验证的方法, 使用的工具, 请求的参数, 预期响应的结果</p><ul><li><p>扩容脚本自测方式</p><ul><li><p>增加一块SATA磁盘，10GB</p></li><li><p>增加一块IDE&#x2F;SCSI&#x2F;NVME磁盘，10GB</p></li><li><p>增加一块virtio磁盘，10GB</p></li><li><p>误调系统盘大小测试</p></li></ul></li><li><p>ISO镜像自测方式</p><ul><li><p>在vmware平台安装测试，需要提前准备ESXI6.5环境</p></li><li><p>在HCI平台安装测试</p></li></ul></li><li><p>OVA镜像自测方式</p><ul><li><p>参考部署文档，在不同平台测试</p></li><li><p>需要测试引擎安装</p></li></ul></li><li><p>分区自测方式</p><ul><li>人肉判断，使用命令lsblk， df等</li></ul></li><li><p><del>单元测试</del></p></li></ul><h2 id="7-风险评估及对其它模块-系统影响"><a href="#7-风险评估及对其它模块-系统影响" class="headerlink" title="7 风险评估及对其它模块&#x2F;系统影响"></a>7 风险评估及对其它模块&#x2F;系统影响</h2><p>实现当前设计存在什么已知风险</p><ul><li><p>分区后，可能会存在遗漏的其他模块仍在使用系统分区（根分区），在清理策略不起效的情况下，可能会导致OS异常</p></li><li><p>软连接可能有遗漏或者被应用程序误删导致有些大数据使用到了应用分区的空间</p></li><li><p>OVA和ISO镜像可能会比较大，估计大小为3~4GB，由于公司没有私有网盘，可能会对实施造成一些影响</p></li></ul><h3 id="7-1-已知的或可预知的风险"><a href="#7-1-已知的或可预知的风险" class="headerlink" title="7.1 已知的或可预知的风险"></a>7.1 已知的或可预知的风险</h3><p>在这里加上已经知道的或可能会发生的风险，包括技术、业务等方面。最好针对每个风险，列出相应的应对措施。</p><h4 id="7-1-1-商城的生产地址可能不可用"><a href="#7-1-1-商城的生产地址可能不可用" class="headerlink" title="7.1.1 商城的生产地址可能不可用"></a>7.1.1 商城的生产地址可能不可用</h4><p>总控的配置项[shopCenter]下的两个地址，一个用于获取数据，一个用于上报数据。这里的风险是生产的总控不一定可用</p><h4 id="7-1-2-CPU指令集检查"><a href="#7-1-2-CPU指令集检查" class="headerlink" title="7.1.2 CPU指令集检查"></a>7.1.2 CPU指令集检查</h4><p>总控依赖AVX指令，需要检查CPU指令集。</p><p>ISO要在正式安装系统前，进行检查。</p><p><img src="/../../../../home/xiaoy/media/image8.png" alt="descript"></p><p>OVA目前还不确定检查后在哪提示，<del>而且没有AVX好像也装不了ESXI。</del></p><h4 id="7-1-3-总控WEBUI修改IP长时间不能落地"><a href="#7-1-3-总控WEBUI修改IP长时间不能落地" class="headerlink" title="7.1.3 总控WEBUI修改IP长时间不能落地"></a>7.1.3 总控WEBUI修改IP长时间不能落地</h4><p>当前TUI设计成配合WEBUI使用，但是WEBUI的需求都还没完全定下来，只知道1.4.0要做，在WEB界面修改IP实现以前，镜像也还有持久化修改IP的需求，目前的设想是通过一个脚本来代替WEBUI的操作。</p><p>不论是用于代替的脚本还是未来的WEB界面，在安装引擎之前都需要通过他们来设置IP，以便持久化和修改对应应用的配置，否则无法安装引擎。</p><p>脚本路径为&#x2F;user&#x2F;sbin&#x2F;quickstart_network_set</p><h3 id="7-2-与其它模块-系统可能的影响"><a href="#7-2-与其它模块-系统可能的影响" class="headerlink" title="7.2 与其它模块&#x2F;系统可能的影响"></a>7.2 与其它模块&#x2F;系统可能的影响</h3><p>在详细设计中描述了该模块与其它模块的依赖关系。在这里描述这些依赖关系可能带来的影响。包括本模块对其它模块可能造成的影响以及其它模块可能给本模块造成的影响两个方面。</p><h4 id="7-2-1-对总控监控体系的影响"><a href="#7-2-1-对总控监控体系的影响" class="headerlink" title="7.2.1 对总控监控体系的影响"></a>7.2.1 对总控监控体系的影响</h4><p>UI目录：</p><ul><li><p>系统管理-运行状态-硬盘</p></li><li><p>系统管理-日志管理-系统日志配置</p></li></ul><p><strong>描述：</strong></p><p>分区之后，原有磁盘空间使用率不能适应分区后的实际情况，也就是说显示的不准确，并且这块会被清理策略依赖，会产生进一步的影响。</p><p>原因：</p><p>分区之后，本质上是相当于将一个硬盘分为多个硬盘，但是UI显示上还是按照一个硬盘来显示。</p><p><strong>解决方案：</strong></p><p>方案1. 调整UI，将硬盘改为系统盘+数据盘双显。系统盘涵括根分区、应用分区和启动分区</p><p>方案2. 调整算法，显示数据盘的使用率</p><p>方案3. 调整算法，显示为（硬盘1使用+硬盘2使用+….+硬盘n使用)&#x2F;（硬盘1+硬盘2+….+硬盘n)</p><p>方案4. 调整UI，每个盘（分区）分别显示</p><p><strong>优缺点：</strong></p><p>方案1. 优点：适配实现，能够减少对用户的误导，数据盘允许磁盘使用率低达1%；缺点：需要调整UI，清理策略UI文案也需要区分系统盘和数据盘。</p><p>方案2. 优点：实现简单，允许磁盘使用率低达1%；缺点：如果哪天需要显示硬盘的具体容量，这里显示的数据盘容量会引起用户的困惑（容量小于分区前的磁盘），另外，如果哪个应用不小心把数据写到数据盘，并且还写满了，界面上也无法反应出来。</p><p>方案3. 优点：相比其他方案相对中庸，没有明显的优点；缺点：磁盘使用率误导性强，无法反映用户最关心的指标，数据区满了也不会显示100%，数据区空了显示的可能是20%</p><p>放哪4. 优点：显示的最为精确，能够发现任意分区使用率过高，对排查问题比较友好；缺点：暴露系统细节、用户认知不便，不知道这些分区是什么</p><p><strong>结论</strong>：</p><ul><li><p>选择方案2：显示数据盘的使用率</p></li><li><p>双机主从同步等未来场景不受分区影响</p></li></ul><h4 id="7-2-2-对文件目录规范的影响"><a href="#7-2-2-对文件目录规范的影响" class="headerlink" title="7.2.2 对文件目录规范的影响"></a>7.2.2 对文件目录规范的影响</h4><p>原本各个应用的文件目录规范为：</p><ol><li><p>每个应用一个文件夹，称为应用文件夹</p></li><li><p>应用文件夹下放置bin,config,data等多个目录，用于存储二进制、配置、数据等</p></li></ol><p>这种方式对于数据分类存储不利，直接限制了分区的使用，调整后的目录规范为：</p><p>原有规范基本不变，将data目录调整到数据分区</p><p>调整前：${应用目录}&#x2F;${应用名}&#x2F;data</p><p>调整后：${数据目录}&#x2F;${应用名}&#x2F;data</p><ol start="3"><li><del>用户上传的文件，在tmp目录暂存后，移动到合适的位置</del></li></ol><p>调整前：&#x2F;tmp&#x2F;${tmpdir}&#x2F;uploadxxx</p><p>调整后：&#x2F;data&#x2F;${tmpdir}&#x2F;uploadxxx</p><p><del>另一个可选调整是，应用目录使用专有标识，不再使用opt（待评审确定）<br>调整前：${应用目录} &#x3D;&#x3D; &#x2F;opt</del></p><p><del>调整后：${应用目录} &#x3D;&#x3D; &#x2F;srhino</del></p><p><del>这样做的好处是，做清理类操作时，可以直接rm -rf &#x2F;srhino&#x2F;* 而不用小心翼翼的删除每个opt下的文件。但是清理这个需求理论上不应该出现在客户的场景里，特别是镜像交付的场景，唯一有用的场景可能是内部自测的时候，意义不太明确。</del></p><p>上面说的都是理论上的场景，实际考察发现原有目录规范并不是每个应用都能遵守的，并且出于过渡期的考量，不会马上切到新的规范</p><p>当前版本设计的是按照【5.2.4.3 软链接】描述，在制作镜像的时候，会将对应的软连接创建好。这样做有一些要求，主要是升级和重装的时候会有影响，在下面两节会有详细描述。</p><p>结论：</p><p>不需要&#x2F;srhino,,需要一个规范文档</p><h4 id="7-2-3-对升级的影响"><a href="#7-2-3-对升级的影响" class="headerlink" title="7.2.3 对升级的影响"></a>7.2.3 对升级的影响</h4><p>导入过程：</p><ul><li><p>浏览器&gt;&gt;&gt;&gt;&#x2F;tmp&#x2F;${tmpdir}&#x2F;xxx.tar.gz</p></li><li><p>&#x2F;tmp&#x2F;${tmpdir}&#x2F;xxx.tar.gz &gt;&gt;&gt; sc &gt;&gt;&gt; 校验 &gt;&gt; 解压 &gt;&gt;&gt; &#x2F;opt&#x2F;repo</p></li></ul><p>升级过程：</p><ul><li><p>启动&#x2F;opt&#x2F;repo&#x2F;sc&#x2F;sc&#x2F;bin&#x2F;sc (简称sc_new)，接管tcp listener socket</p></li><li><p>sc_new 拷贝&#x2F;opt&#x2F;repo&#x2F;部分文件到&#x2F;opt&#x2F;对应的程序下，替换二进制和配置</p></li><li><p>sc_new 执行&#x2F;opt&#x2F;sc&#x2F;hack&#x2F;seeder，这里会涉及数据迁移等各种复杂处理</p></li></ul><p>要求：</p><p><strong>整体约束：</strong></p><p>升级过程执行流比较不确定，需要确保过程中不会删除&#x2F;opt下的目录，否则可能会导致软链接失效。</p><p><strong>升级前约束：</strong></p><p>升级前，检查&#x2F;oem&#x2F;info文件，如果不存在，则判定为软件部署</p><p>如果文件存在，则检查OS.os-release和OS.os-patch，当前版本仅判断os-release是否为srhino focal即可，以后如果有其他类型的系统，则需要在升级前匹配好。</p><p><strong>系统升级包：</strong></p><p>在操作系统也归我们管后，对于操作系统的安全更新也需要通过升级包的方式发布。系统更新主要是系统软件的更新，理论上来说应该是把对应的deb包打包，并且制作升级脚本即可。对于系统升级而言，需要更新&#x2F;oem&#x2F;info文件的SP版本</p><p><strong>升级包和安装包分离：</strong></p><p>目前升级包和安装包都是同一个包，经了解，该包用作升级用途时，是不需要安装脚本（install.sh)的，所以我认为应该将两个包分离开来，对外以后不发布安装包，仅发布镜像和升级包，升级包里面不包含安装脚本和卸载脚本。</p><p>结论：</p><p>分离</p><p>添加版本标识提升兼容性</p><h4 id="7-2-4-对重装的影响"><a href="#7-2-4-对重装的影响" class="headerlink" title="7.2.4 对重装的影响"></a>7.2.4 对重装的影响</h4><p>重装应该仅发生在公司内部，外部要么用镜像重新部署，要么用升级包升级。</p><p>卸载脚本删的比较彻底，软链接是一定会被删除的，所以要调整的是安装脚本，安装脚本需要</p><p>在启动各个进程之前，先把解压后的一些文件夹挪到&#x2F;data目录(不存在则创建），然后创建好对应的软连接</p><h4 id="7-2-5-mongodb的动态配置"><a href="#7-2-5-mongodb的动态配置" class="headerlink" title="7.2.5 mongodb的动态配置"></a>7.2.5 mongodb的动态配置</h4><h5 id="7-2-5-1-mongodb使用的机器资源限制"><a href="#7-2-5-1-mongodb使用的机器资源限制" class="headerlink" title="7.2.5.1 mongodb使用的机器资源限制"></a>7.2.5.1 mongodb使用的机器资源限制</h5><p><strong>CPU资源限制</strong></p><ul><li><p>根据 CPU 核心数量（CPU_NUM）计算核心最大利用率：</p><ul><li><p><strong>CPU_NUM ≤ 1</strong>：每核最大利用率 20%</p></li><li><p><strong>1 &lt; CPU_NUM &lt; 4</strong>：每核最大利用率 40%</p></li><li><p><strong>4 ≤ CPU_NUM &lt; 8</strong>：每核最大利用率 60%</p></li><li><p><strong>8 ≤ CPU_NUM &lt; 10</strong>：每核最大利用率 80%</p></li><li><p><strong>10 ≤ CPU_NUM &lt; 32</strong>：每核最大利用率 85%</p></li><li><p><strong>CPU_NUM ≥ 32</strong>：每核最大利用率 90%</p></li></ul></li></ul><p><strong>内存资源限制</strong></p><ul><li>MongoDB 限制为使用最多机器实际内存的 30%。</li></ul><h5 id="7-2-5-2-实现MongoDB-机器资源限制的方法"><a href="#7-2-5-2-实现MongoDB-机器资源限制的方法" class="headerlink" title="7.2.5.2 实现MongoDB 机器资源限制的方法"></a>7.2.5.2 实现MongoDB 机器资源限制的方法</h5><ul><li><p>CPU使用率限制：利用 systemd 配置的 CPUQuota 参数来限制 CPU 总使用率。</p></li><li><p>内存使用率限制：通过 systemd 配置中的 MemoryLimit（旧版）和 MemoryMax（新版）参数设置 MongoDB 内存使用上限。使用mongod的启动参数wiredTigerCacheSizeGB，来限制mongodb的缓冲区大小。</p></li><li><p>Mongodb缓冲区大小限制：使用 MongoDB 启动参数 wiredTigerCacheSizeGB 来限制缓冲区大小。</p></li></ul><h5 id="7-2-5-3-mongodb的service文件内容计算"><a href="#7-2-5-3-mongodb的service文件内容计算" class="headerlink" title="7.2.5.3 mongodb的service文件内容计算"></a>7.2.5.3 mongodb的service文件内容计算</h5><p><strong>目标：</strong>根据当前机器资源信息生成 mongod.service 文件。</p><p><strong>内容包括：</strong></p><ul><li><p>计算出CPU 和内存使用的限制配置。</p></li><li><p>计算出MongoDB 启动参数，如 wiredTigerCacheSizeGB，以控制缓冲区大小。</p></li></ul><p><strong>具体实现：</strong></p><ol><li><p><strong>CPU使用率的计算：</strong></p><ol><li><p><del>使用 grep -c “processor” &#x2F;proc&#x2F;cpuinfo 命令得到当前CPU的核心数，并给 cpu_num 赋值</del></p></li><li><p>使用 nproc 命令得到当前CPU的核心数，并给 cpu_num 赋值</p></li><li><p>判断CPU的核心数所对应的核心使用率，并给quotient赋值</p></li><li><p>计算出CPUQuota的值：cpu_quota&#x3D;$((${cpu_num} * $quotient))</p></li></ol></li><li><p><strong>内存限制计算：</strong></p><ol><li>根据&#x2F;proc&#x2F;meminfo文件中的MemTotal字段的值得到总内存，并计算出总内存30%的大小：$(($(awk ‘&#x2F;MemTotal&#x2F; {print $2}’ &#x2F;proc&#x2F;meminfo) * 30 &#x2F; 100))，并赋值给mongodb_limit_mem</li></ol></li><li><p><strong>mongo缓冲区大小计算：</strong></p><ol><li><p>将mongodb_limit_mem由原来的KB转换成以GB为单位，并向上取整</p></li><li><p>具体实现：</p><ol><li><p>1 GB &#x3D; 1048576 KB</p></li><li><p>让KB的值加上1048575，让它达到下一个GB的阈值，或达到当前GB的最大值</p></li><li><p>再让KB的值除以1048576，利用计算自动向下取整的机制得到KB转换成GB然后向上取整的值</p></li><li><p>mongodb_limit_mem_GB&#x3D;$(( (mongodb_limit_mem + 1048575) &#x2F; 1048576 ))</p></li></ol></li></ol></li><li><p><strong>将计算好的值填入mongodb的模板service中并得到最终的service文件内容</strong></p></li></ol><p><strong>mongo的service模板：</strong></p><h5 id="-4"><a href="#-4" class="headerlink" title=""></a></h5><h5 id="7-2-5-4-动态配置的实现"><a href="#7-2-5-4-动态配置的实现" class="headerlink" title="7.2.5.4 动态配置的实现"></a>7.2.5.4 动态配置的实现</h5><p><strong>概要</strong>：</p><ol><li><p>在mongodb启动的时候设置一个前置执行脚本</p></li><li><p>前置脚本的作用使根据当前机器环境生成mongo的service内容，并与当前被配置到systemd的service内容比较，如果有差异，则更新systemd上的service内容，并调用systemd的配置重载操作，如果没有差异，则不作操作。</p></li></ol><p><strong>具体实现：</strong></p><h2 id="8-附件及参考资料"><a href="#8-附件及参考资料" class="headerlink" title="8 附件及参考资料"></a>8 附件及参考资料</h2><p>填写文档相关的附件或参考资料。</p><p>【企微文档】研发参与流程</p><p><a href="https://doc.weixin.qq.com/sheet/e3_AYEAsQYMALY1HrUK7yXQsqdy4wf7K?scode=ABwA9Qd2ABEY9IZnbYAYEAsQYMALY&tab=819xxa">研发参与流程</a></p><p><a href="https://doc.weixin.qq.com/doc/w3_ARkAWAYlAEQthA0ZiCxTuOexfXksQ?scode=ABwA9Qd2ABEpJroZxqARkAWAYlAEQ">ubuntu server 20.04 安装流程</a></p><p><a href="https://doc.weixin.qq.com/doc/w3_ARkAWAYlAEQAyAAmu0ZTH29vNPcWA?scode=ABwA9Qd2ABE4iZqsuzARkAWAYlAEQ">基于官方镜像制作基OVA过程</a></p><p><a href="https://doc.weixin.qq.com/mind/m4_ARkAWAYlAEQwHM912uWR3e72MrE63?scode=ABwA9Qd2ABEbo5nbAUARkAWAYlAEQ">CPU指令集调研</a></p><p><a href="https://doc.weixin.qq.com/doc/w3_AcwAzgacAIcdOkk7yyKQeOwsSOL0X?scode=ABwA9Qd2ABELAP25QwAcwAzgacAIc">LVM介绍及使用</a></p><p><a href="https://doc.weixin.qq.com/doc/w3_ARkAWAYlAEQJVecguFrTkaXWFm2Jg?scode=ABwA9Qd2ABE9IioVr6ARkAWAYlAEQ">软件保护需求文档</a></p><p><a href="https://doc.weixin.qq.com/doc/w3_ARkAWAYlAEQk8xh84ZXSBmbtHNEYm?scode=ABwA9Qd2ABEJpM0tXrARkAWAYlAEQ">镜像交付培训资料</a></p><h3 id="8-1-详细修改历史"><a href="#8-1-详细修改历史" class="headerlink" title="8.1 详细修改历史"></a>8.1 详细修改历史</h3><p>2023-11-6，岑思华：</p><ul><li><p>增加5.2.3.3-5.2.3.5 三个小章节，描述打包项目的代码设计</p></li><li><p>增加7.2.1-7.2.3 三个小章节，描述对其他模块产生的影响</p></li><li><p>增加5.2.4.2一节，描述关于LVM的设计</p></li></ul><p>2023-11-7， 岑思华:</p><ul><li><p>将保留分区显式的挂载为&#x2F;oem，存储一些oem信息</p></li><li><p>继续完善7.2部分的内容</p></li><li><p>修改项目结构，去掉install.sh和init.sh，增加main.sh，补充main.sh的细节</p></li></ul><p>2023-11-9，岑思华</p><ul><li><p>补充扩容脚本的目的</p></li><li><p>补充附件及参考资料</p></li><li><p>产品和技术部沟通后，确定磁盘百分比显示采用方案2（显示数据盘占用）</p></li></ul><p>2023-11-14，岑思华</p><ul><li><p>补充mongodb配置文件的风险</p></li><li><p>细化ova构建细节</p></li></ul><p>2023-11-15，岑思华</p><ul><li>更新7.2.5的新方案与结论</li></ul><p>2023-11-15，袁菘壑</p><ul><li>新增5.2.1.2章节</li></ul><p>2023-11-18，沙汉路</p><ul><li>增加LVM相关参考资料</li></ul><p>2023-11-20，岑思华</p><ul><li>更新5.2.3.2关于ova文件的处理方案：ovftool</li></ul><p>2023-11-22，岑思华</p><ul><li><p>将数据分区从固定的60G改为使用剩余所有空间（60G+）</p></li><li><p>增加5.2.5章节</p></li></ul><p>2023-11-29 袁菘壑</p><ul><li>增加5.3功能实现章节 包含5.3.1镜像制作的相关实现</li></ul><p>2023-11-30，岑思华</p><ul><li>更新5.2.4.4, 设定oem文件的管理位置和管理方式</li></ul><p>2023-12-7，吴松达</p><ul><li>增加7.2.5，增加mongodb动态配置的实现</li></ul><p>2023-12-7，袁菘壑</p><ul><li>增加5.3.1.5，增加容器初始化数据库实现</li></ul><p>2023-12-8，岑思华</p><ul><li><p>更新基镜像的需求说明</p></li><li><p>增加oem文件SP版本的含义备注</p></li><li><p>增加7.1.3章节</p></li></ul><p>2023-12-11，岑思华</p><ul><li>更新关于ISO镜像的UEFI补充说明，不支持UEFI</li></ul><p>2023-12-12，袁菘壑</p><ul><li><p>更新关于grub密码兼容问题，在5.3.1.2章</p></li><li><p>更新gpg禁用ui输入密码，在5.3.1.4章</p></li><li><p>添加grub静默启动，在5.3.1.3章</p></li><li><p>删除ssh初始化打印脚本，在5.3.1.6章</p></li><li><p>修改7.1.3脚本路径</p></li></ul><p>2023-12-14，岑思华</p><ul><li><p>&#x2F;user&#x2F;sbin&#x2F;quickstart_network_set.sh改为&#x2F;user&#x2F;sbin&#x2F;quickstart_network_set</p></li><li><p>grub密码易混淆的小写L和数字1，改为大写L</p></li></ul><p>2024-01-02，袁菘壑</p><ul><li>添加iso制作ova流程，在5.3.2章</li></ul><p>2024-01-03，袁菘壑</p><ul><li>增加镜像启动不了后的备用方案</li></ul><p>2024-01-15，袁菘壑</p><ul><li>新增5.3.1.7到5.3.1.9节</li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>镜像交付</tag>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题清单.md</title>
    <link href="/2024/03/07/mdstorage/domain/%E6%8B%9B%E8%81%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B8%85%E5%8D%95/"/>
    <url>/2024/03/07/mdstorage/domain/%E6%8B%9B%E8%81%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B8%85%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux-系统"><a href="#Linux-系统" class="headerlink" title="Linux 系统"></a>Linux 系统</h2><h3 id="详细描述-Linux-系统中，写入一个文件的过程"><a href="#详细描述-Linux-系统中，写入一个文件的过程" class="headerlink" title="详细描述 Linux 系统中，写入一个文件的过程"></a>详细描述 Linux 系统中，写入一个文件的过程</h3><ol><li><strong>用户空间操作</strong>:<ul><li>应用程序通过调用标准库（如 C 语言的 <code>stdio</code> 库）或系统调用（如 <code>write</code>）来请求写入数据到文件。</li><li>如果使用的是标准库函数（如 <code>fwrite</code>），首先这些数据可能会被暂存到应用程序的输出缓冲区中。当缓冲区满或者显式调用刷新（如 <code>fflush</code>）时，标准库会进一步调用相应的系统调用来实际执行写入操作。</li></ul></li><li><strong>系统调用</strong>:<ul><li>当执行写入的系统调用（如 <code>write</code>）时，控制权从用户空间传递到操作系统内核。</li><li>内核接收到这个调用后，会进行必要的权限检查，确认调用进程有权写入指定文件。</li></ul></li><li><strong>虚拟文件系统（VFS）</strong>:<ul><li>Linux 使用虚拟文件系统（VFS）作为所有文件系统类型（如 ext4、xfs、btrfs 等）的抽象层。VFS 负责将通用的文件操作转换为特定文件系统的操作。</li><li>VFS 根据文件描述符找到对应的 inode（索引节点），inode 包含了文件的元数据以及指向文件实际数据块的指针。</li></ul></li><li><strong>文件系统操作</strong>:<ul><li>根据 VFS 和具体文件系统的操作，数据会被写入到文件系统的缓冲区。这一步可能涉及将数据拷贝到内核的页面缓存（page cache）。</li><li>文件系统可能会执行一些优化，如合并连续的写入请求以减少实际的磁盘操作。</li></ul></li><li><strong>写回（Write-back）</strong>:<ul><li>数据首先被写入到缓冲区中，并在一段时间后异步写回到磁盘。这个机制可以提高性能，因为它减少了磁盘 I&#x2F;O 操作的次数。</li><li>系统也可能通过“写穿”（write-through）策略直接写入磁盘，这取决于文件系统的配置和具体操作（如 <code>fsync</code> 系统调用）。</li></ul></li><li><strong>硬件层面</strong>:<ul><li>数据最终通过存储设备的驱动程序写入磁盘。如果使用的是固态硬盘（SSD），数据实际上是写入到 NAND 闪存单元；如果是传统的机械硬盘（HDD），数据则是写入到磁盘的物理扇区。</li></ul></li><li><strong>确认写入完成</strong>:<ul><li>一旦数据成功写入存储设备，相应的系统调用会完成，并将控制权返回给用户空间应用程序，同时返回写入操作的状态。</li></ul></li></ol><h3 id="详细描述访问一个域名到浏览器显示页面的过程"><a href="#详细描述访问一个域名到浏览器显示页面的过程" class="headerlink" title="详细描述访问一个域名到浏览器显示页面的过程"></a>详细描述访问一个域名到浏览器显示页面的过程</h3><ol><li><strong>域名解析</strong>:<ul><li>浏览器首先检查域名是否已在本地缓存中解析过，如果是，则直接使用该 IP 地址。如果没有，浏览器会发起一个 DNS (Domain Name System) 查询来将域名转换成 IP 地址。这可能涉及多级查询，从本地 DNS 服务器到根 DNS 服务器，再到负责该顶级域名（TLD）的服务器，最后是负责该具体域名的名称服务器。</li></ul></li><li><strong>建立连接</strong>:<ul><li>浏览器使用解析得到的 IP 地址尝试与目标服务器建立 TCP 连接。这一过程通常涉及三次握手，确保双方正确建立连接。</li><li>如果网站使用 HTTPS，还需要进行 SSL&#x2F;TLS 握手，以安全地加密之后的通信。</li></ul></li><li><strong>发送 HTTP 请求</strong>:<ul><li>一旦建立了 TCP 连接（和可选的 SSL&#x2F;TLS 加密层），浏览器就会向服务器发送 HTTP 请求。这个请求包括请求行（如 <code>GET / HTTP/1.1</code>），请求头（包括用户代理、接受的内容类型等），以及可选的请求体。</li></ul></li><li><strong>服务器处理请求并响应</strong>:<ul><li>服务器接收到请求后，会根据请求的资源（如网页、图片等）进行处理。这可能涉及到服务器端的脚本或应用程序的执行，如数据库查询或动态内容的生成。</li><li>处理完成后，服务器会将响应数据（如 HTML 页面）以及响应头（状态码、内容类型等）发送回浏览器。</li></ul></li><li><strong>浏览器处理响应</strong>:<ul><li>浏览器接收到服务器的响应数据后，首先会检查状态码。如果是成功的响应（如 200 OK），浏览器会继续解析返回的内容。</li><li>浏览器解析 HTML 内容，并根据需要发起额外的请求来获取嵌入资源（如 CSS 文件、JavaScript 脚本、图片等）。</li></ul></li><li><strong>渲染页面</strong>:<ul><li>浏览器根据 HTML 和 CSS 构建 DOM (Document Object Model) 树和 CSSOM (CSS Object Model) 树，然后将它们合并成渲染树。</li><li>浏览器根据渲染树来布局页面，计算每个元素的尺寸和位置。</li><li>最后，浏览器绘制页面内容到屏幕上。</li></ul></li><li><strong>JavaScript 执行</strong>:<ul><li>如果页面包含 JavaScript，浏览器还会解析和执行脚本。这可能会修改 DOM，触发重新渲染。</li></ul></li></ol><h3 id="详细描述在两个Linux系统中双方发送接受-TCP-请求的过程"><a href="#详细描述在两个Linux系统中双方发送接受-TCP-请求的过程" class="headerlink" title="详细描述在两个Linux系统中双方发送接受 TCP 请求的过程"></a>详细描述在两个Linux系统中双方发送接受 TCP 请求的过程</h3><h4 id="1-TCP-三次握手（建立连接）"><a href="#1-TCP-三次握手（建立连接）" class="headerlink" title="1. TCP 三次握手（建立连接）"></a>1. TCP 三次握手（建立连接）</h4><ol><li><strong>SYN 发送</strong>:<ul><li>主动方（客户端）发送一个 SYN（同步序列编号）报文给被动方（服务器），表示开始建立一个新的连接。这个 SYN 报文包含一个客户端选择的初始序列号（ISN）。</li><li>此时，客户端进入 SYN-SENT 状态。</li></ul></li><li><strong>SYN-ACK 接收</strong>:<ul><li>服务器收到 SYN 报文后，会返回一个 SYN-ACK 报文。这个报文包含服务器自己的初始序列号，以及对客户端 ISN 的确认（客户端 ISN+1）。</li><li>服务器此时进入 SYN-RECEIVED 状态。</li></ul></li><li><strong>ACK 发送</strong>:<ul><li>客户端收到 SYN-ACK 后，发送一个 ACK（确认）报文给服务器，确认号为服务器 ISN+1。</li><li>发送完这个 ACK 报文后，客户端进入 ESTABLISHED 状态。服务器在收到这个 ACK 后也进入 ESTABLISHED 状态。</li><li>此时，TCP 连接建立完成，双方可以开始数据传输。</li></ul></li></ol><h4 id="2-数据传输"><a href="#2-数据传输" class="headerlink" title="2. 数据传输"></a>2. 数据传输</h4><ul><li>一旦 TCP 连接建立，两个 Linux 系统可以开始双向数据传输。应用数据被封装在 TCP 段中，每个 TCP 段都包含序列号和确认号，以确保数据的可靠传输和顺序到达。</li><li>TCP 提供流量控制和拥塞控制机制，确保网络条件变化时调整数据发送速率，优化性能和资源利用。</li></ul><h4 id="3-TCP-四次挥手（断开连接）"><a href="#3-TCP-四次挥手（断开连接）" class="headerlink" title="3. TCP 四次挥手（断开连接）"></a>3. TCP 四次挥手（断开连接）</h4><ol><li><strong>FIN 发送</strong>:<ul><li>当一方（假设为客户端）完成数据发送后，它会发送一个 FIN 报文给服务器，表示没有数据发送了，请求关闭连接。</li><li>客户端进入 FIN-WAIT-1 状态。</li></ul></li><li><strong>ACK 接收</strong>:<ul><li>服务器收到 FIN 报文后，发送一个 ACK 报文作为回应，确认号为客户端的 FIN 序列号+1。</li><li>服务器此时进入 CLOSE-WAIT 状态，客户端收到 ACK 后进入 FIN-WAIT-2 状态。</li></ul></li><li><strong>FIN 发送（服务器端）</strong>:<ul><li>服务器完成其数据发送后，也发送一个 FIN 报文给客户端，请求关闭连接。</li><li>服务器进入 LAST-ACK 状态。</li></ul></li><li><strong>ACK 接收</strong>:<ul><li>客户端收到服务器的 FIN 报文后，发送一个 ACK 报文作为回应，确认号为服务器的 FIN 序列号+1。</li><li>客户端进入 TIME-WAIT 状态，等待足够的时间以确保服务器接收到最终的 ACK 报文，然后关闭连接</li></ul></li></ol><h3 id="一个-tcp-请求的生命周期中进行的系统调用的过程"><a href="#一个-tcp-请求的生命周期中进行的系统调用的过程" class="headerlink" title="一个 tcp 请求的生命周期中进行的系统调用的过程"></a>一个 tcp 请求的生命周期中进行的系统调用的过程</h3><h4 id="1-建立连接"><a href="#1-建立连接" class="headerlink" title="1. 建立连接"></a>1. 建立连接</h4><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><ol><li><strong><code>socket()</code></strong>:<ul><li>调用 <code>socket()</code> 创建一个新的套接字。这是与网络通信的端点，用于发送和接收数据。</li></ul></li><li><strong><code>connect()</code></strong>:<ul><li>使用 <code>connect()</code> 系统调用并指定服务器的地址和端口来尝试建立到服务器的连接。这将启动 TCP 三次握手过程。</li><li>客户端首先发送 SYN 包给服务器，状态变为 SYN-SENT。</li></ul></li></ol><h5 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h5><ol><li><strong><code>socket()</code></strong>:<ul><li>同样调用 <code>socket()</code> 创建一个套接字。</li></ul></li><li><strong><code>bind()</code></strong>:<ul><li>调用 <code>bind()</code> 将套接字绑定到一个本地地址和端口上。这通常是服务器监听客户端连接请求的端口。</li></ul></li><li><strong><code>listen()</code></strong>:<ul><li>通过 <code>listen()</code> 告诉系统该套接字是服务器的监听套接字，准备接受客户端连接请求。</li></ul></li><li><strong><code>accept()</code></strong>:<ul><li>服务器调用 <code>accept()</code> 阻塞等待客户端的连接请求。当接收到客户端的 SYN 请求后，服务器发送 SYN-ACK 响应，并进入 SYN-RECEIVED 状态。一旦客户端回应 ACK，<code>accept()</code> 返回，服务器进入 ESTABLISHED 状态，此时 TCP 连接建立。</li></ul></li></ol><h4 id="2-数据传输-1"><a href="#2-数据传输-1" class="headerlink" title="2. 数据传输"></a>2. 数据传输</h4><ul><li><strong><code>write()</code> &#x2F; <code>send()</code></strong>:<ul><li>在连接建立后，双方可以使用 <code>write()</code> 或 <code>send()</code> 系统调用发送数据。这些调用将应用程序的数据写入 TCP 套接字，由 TCP 协议处理数据的分段、封装和发送。</li></ul></li><li><strong><code>read()</code> &#x2F; <code>recv()</code></strong>:<ul><li>对应地，使用 <code>read()</code> 或 <code>recv()</code> 系统调用来接收从对方发送过来的数据。这些调用从 TCP 套接字读取数据，如果没有可用数据，调用会阻塞，直到有数据到达。</li></ul></li></ul><h4 id="3-断开连接"><a href="#3-断开连接" class="headerlink" title="3. 断开连接"></a>3. 断开连接</h4><h5 id="发起关闭的一方"><a href="#发起关闭的一方" class="headerlink" title="发起关闭的一方"></a>发起关闭的一方</h5><ol><li><code>close()</code> &#x2F; <code>shutdown()</code>:<ul><li>当通信完成，一方（假设为客户端）使用 <code>close()</code> 或 <code>shutdown()</code> 系统调用来关闭套接字。这会导致发送一个 FIN 包给对方，开始 TCP 四次挥手过程。</li></ul></li></ol><h5 id="接收-FIN-的一方"><a href="#接收-FIN-的一方" class="headerlink" title="接收 FIN 的一方"></a>接收 FIN 的一方</h5><ul><li>服务器在接收到客户端的 FIN 包后，内核通知应用程序套接字关闭（如果应用程序阻塞在 <code>read()</code> 调用中，则 <code>read()</code> 返回0，表示EOF）。此时，服务器也可以调用 <code>close()</code> 或 <code>shutdown()</code> 来关闭连接并发送 FIN 包给客户端。</li></ul><h4 id="4-清理"><a href="#4-清理" class="headerlink" title="4. 清理"></a>4. 清理</h4><ul><li>在四次挥手后，当双方都发送并确认 FIN 包，TCP 连接被彻底关闭，操作系统会清理与该连接相关的资源。</li></ul><h3 id="详细描述-Linux系统中-epoll-多路复用机制和关键原理"><a href="#详细描述-Linux系统中-epoll-多路复用机制和关键原理" class="headerlink" title="详细描述 Linux系统中 epoll 多路复用机制和关键原理"></a>详细描述 Linux系统中 epoll 多路复用机制和关键原理</h3><p>在Linux系统中，<code>epoll</code>是一种高效的I&#x2F;O事件通知机制，特别适用于处理大量并发连接的服务器程序。与传统的多路复用机制如<code>select</code>和<code>poll</code>相比，<code>epoll</code>提供了更好的扩展性和性能，主要因为它能够避免<code>select</code>和<code>poll</code>中的一些固有限制和性能瓶颈。</p><h4 id="关键原理和特性"><a href="#关键原理和特性" class="headerlink" title="关键原理和特性"></a>关键原理和特性</h4><ol><li><p><strong>效率与可扩展性</strong>：</p><ul><li><code>epoll</code>通过一种有效的方法管理大量的文件描述符（FD）。它使用一个红黑树（一种自平衡二叉查找树）来存储所有正在监视的FDs，这样查找、添加或删除FDs的操作都可以在对数时间内完成。与之相比，<code>select</code>和<code>poll</code>需要遍历整个FD集合来检查状态，效率随着FD数量的增加而线性下降。</li></ul></li><li><p><strong>事件驱动</strong>：</p><ul><li><code>epoll</code>是基于事件的，它只对活动的FD进行操作。当一个或多个FD状态发生变化时，<code>epoll</code>会将这些活动FD添加到一个就绪列表中，应用程序只需处理这个列表中的FD。这种方式避免了在大量FD中轮询寻找那些状态发生变化的FD，从而大大提高了效率。</li></ul></li><li><p><strong>两种工作模式</strong>：</p><ul><li><code>epoll</code>支持两种工作模式：边缘触发（ET，Edge Triggered）和水平触发（LT，Level Triggered）。<ul><li><strong>水平触发（LT）</strong>：这是默认模式，当FD就绪时，<code>epoll_wait</code>会返回该FD，而且只要这个FD仍然处于就绪状态，<code>epoll_wait</code>会再次报告它。</li><li><strong>边缘触发（ET）</strong>：在这种模式下，只有FD状态从不可用变为可用，或者有更多数据可读写时，<code>epoll_wait</code>才会返回FD。这要求应用程序必须处理所有的数据，直到没有更多可用为止，因为再次状态变化之前，<code>epoll_wait</code>不会再次报告该FD。</li></ul></li></ul></li><li><p><strong>一次注册，多次使用</strong>：</p><ul><li><code>epoll</code>允许应用程序只注册一次FD，除非FD的监听事件发生变化，否则无需重新注册。这与<code>select</code>和<code>poll</code>每次调用时都需要重新构建FD集的方式形成鲜明对比。</li></ul></li></ol><h4 id="使用过程"><a href="#使用过程" class="headerlink" title="使用过程"></a>使用过程</h4><p><code>epoll</code>的使用通常包括以下几个步骤：</p><ol><li><p><strong>创建epoll实例</strong>：</p><ul><li>调用<code>epoll_create</code>函数创建一个epoll实例，它返回一个文件描述符，用于后续所有的<code>epoll</code>操作。</li></ul></li><li><p><strong>注册感兴趣的事件</strong>：</p><ul><li>使用<code>epoll_ctl</code>添加、修改或删除要监控的文件描述符及其对应的事件。这些事件可以是读就绪、写就绪等。</li></ul></li><li><p><strong>等待事件发生</strong>：</p><ul><li>调用<code>epoll_wait</code>等待一个或多个FD上的事件发生。<code>epoll_wait</code>可以指定超时时间，以防在指定时间内没有任何事件发生。</li></ul></li><li><p><strong>处理就绪的事件</strong>：</p><ul><li><code>epoll_wait</code>返回时，会提供一个事件列表，应用程序遍历这个列表，处理所有就绪的事件。</li></ul></li></ol><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>高效</strong>：对于大规模FD集合，<code>epoll</code>提供了优越的性能。</li><li><strong>可扩展</strong>：<code>epoll</code>的性能不会随着FD数量的增加而显著下降。</li><li><strong>灵活</strong>：支持边缘触发和水平触发，适应不同</li></ul><h3 id="描述-epoll-机制中进行网络请求多路复用的主流程"><a href="#描述-epoll-机制中进行网络请求多路复用的主流程" class="headerlink" title="描述 epoll 机制中进行网络请求多路复用的主流程"></a>描述 epoll 机制中进行网络请求多路复用的主流程</h3><p>使用 <code>epoll</code> 机制进行网络请求多路复用涉及到创建 <code>epoll</code> 实例、向 <code>epoll</code> 实例注册感兴趣的事件（如可读、可写事件）、等待事件发生，以及处理发生的事件。这里以一个典型的网络服务器为例，描述使用 <code>epoll</code> 进行网络请求多路复用的主要流程：</p><h3 id="1-创建-epoll-实例"><a href="#1-创建-epoll-实例" class="headerlink" title="1. 创建 epoll 实例"></a>1. 创建 <code>epoll</code> 实例</h3><p>首先，服务器启动时创建一个 <code>epoll</code> 实例，用于后续的事件监听和处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> epfd = epoll_create1(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (epfd == <span class="hljs-number">-1</span>) &#123;<br>    perror(<span class="hljs-string">&quot;epoll_create1&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-注册感兴趣的事件"><a href="#2-注册感兴趣的事件" class="headerlink" title="2. 注册感兴趣的事件"></a>2. 注册感兴趣的事件</h3><p>服务器的监听socket需要注册到 <code>epoll</code> 实例中，以便 <code>epoll</code> 能够通知应用程序有新的连接请求。此外，随着新的客户端连接到服务器，相应的客户端socket也需要注册到 <code>epoll</code> 实例中，以监听这些socket上的可读或可写事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">ev</span>;</span><br>ev.events = EPOLLIN; <span class="hljs-comment">// 表示对应的文件描述符可以读（如：TCP socket的远程关闭，有数据可读）</span><br>ev.data.fd = listen_fd; <span class="hljs-comment">// listen_fd 是监听socket的文件描述符</span><br><span class="hljs-keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, listen_fd, &amp;ev) == <span class="hljs-number">-1</span>) &#123;<br>    perror(<span class="hljs-string">&quot;epoll_ctl: listen_fd&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-等待事件发生"><a href="#3-等待事件发生" class="headerlink" title="3. 等待事件发生"></a>3. 等待事件发生</h3><p>应用程序通过调用 <code>epoll_wait</code> 等待事件的发生。这个调用可以指定超时，以便在没有事件发生时不会无限期地阻塞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EVENTS 10</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">events</span>[<span class="hljs-title">MAX_EVENTS</span>];</span><br><br><span class="hljs-type">int</span> nfds = epoll_wait(epfd, events, MAX_EVENTS, <span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span> (nfds == <span class="hljs-number">-1</span>) &#123;<br>    perror(<span class="hljs-string">&quot;epoll_wait&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-处理就绪的事件"><a href="#4-处理就绪的事件" class="headerlink" title="4. 处理就绪的事件"></a>4. 处理就绪的事件</h3><p>当 <code>epoll_wait</code> 返回后，应用程序遍历事件数组，处理每个就绪的事件。如果事件与监听socket相关（表示有新的连接请求），服务器将接受这个连接，并将新的客户端socket注册到 <code>epoll</code> 实例中。如果事件与客户端socket相关（表示有数据可读或可写），服务器则进行相应的读或写操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; n &lt; nfds; ++n) &#123;<br>    <span class="hljs-keyword">if</span> (events[n].data.fd == listen_fd) &#123;<br>        <span class="hljs-comment">// 处理新的连接请求</span><br>        <span class="hljs-type">int</span> conn_fd = accept(listen_fd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client_addr, &amp;addr_len);<br>        <span class="hljs-keyword">if</span> (conn_fd == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;accept&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>        setnonblocking(conn_fd); <span class="hljs-comment">// 通常设置为非阻塞模式</span><br>        ev.events = EPOLLIN | EPOLLET; <span class="hljs-comment">// 可读事件，边缘触发模式</span><br>        ev.data.fd = conn_fd;<br>        <span class="hljs-keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, conn_fd, &amp;ev) == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;epoll_ctl: conn_fd&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 处理客户端socket的事件（读或写）</span><br>        <span class="hljs-type">int</span> fd = events[n].data.fd;<br>        <span class="hljs-comment">// 进行读或写操作...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过以上流程，服务器能够高效地管理多个网络连接，使用单个线程或进程即可同时处理多个网络I&#x2F;O操作，大大提高了网络应用程序的性能和吞吐量。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>招聘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mermaid流程图写作文档.md</title>
    <link href="/2024/03/07/mdstorage/domain/%E6%96%87%E6%A1%A3/mermaid%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%86%99%E4%BD%9C%E6%96%87%E6%A1%A3/"/>
    <url>/2024/03/07/mdstorage/domain/%E6%96%87%E6%A1%A3/mermaid%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%86%99%E4%BD%9C%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Mermaid 是一个强大的、基于文本的图表绘制工具，它允许用户通过简单的文本描述来生成复杂的图表。这种方式使得图表的创建和维护变得更加容易和高效，尤其是在需要将图表版本控制或与文档集成时。Mermaid 减少了使用传统图形编辑工具的需要，使非设计师也能快速绘制出看起来专业的图表。</p><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ul><li><strong>易于学习和使用：</strong> Mermaid 的语法简单直观，用户可以通过学习几个基本的语法规则来快速开始绘图。</li><li><strong>文本到图形：</strong> 通过编写和解析文本描述，Mermaid 自动生成图表。这使得图表易于在版本控制系统中管理，并可以像代码一样被审查。</li><li><strong>广泛的图表类型支持：</strong> Mermaid 支持多种图表类型，包括流程图、序列图、类图、状态图、甘特图以及实体关系图等，几乎涵盖了所有文档和报告中常见的图表需求。</li><li><strong>集成方便：</strong> 它可以被集成到多种平台和工具中，例如 Markdown 编辑器、Confluence、GitHub、GitLab 等，很多支持 Markdown 的平台已经内置了对 Mermaid 的支持。</li></ul><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>Mermaid 的语法主要由图表声明（定义图表的类型和方向）、节点定义（定义图表中的元素）和连接符（定义节点之间的关系）组成。下面是一个简单的流程图示例的 Mermaid 代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">graph LR<br>    A[Start] --&gt; B&#123;Decision&#125;<br>    B --&gt;|Yes| C[Do Something]<br>    B --&gt;|No| D[Do Something Else]<br>    C --&gt; D[End]<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph LR    A[Start] --&gt; B&#123;Decision&#125;    B --&gt;|Yes| C[Do Something]    B --&gt;|No| D[Do Something Else]    C --&gt; D[End]</code></pre><p>这段代码描述了一个包含开始节点、决策节点和操作节点的简单流程，并指定了它们之间的关系。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>Mermaid 非常适合软件开发、项目管理、系统设计和文档编写等领域，特别是在需要快速创建和更新图表以说明复杂过程和系统的场合。</p><h3 id="怎么开始"><a href="#怎么开始" class="headerlink" title="怎么开始"></a>怎么开始</h3><p>要开始使用 Mermaid，你可以：</p><ul><li>使用支持 Mermaid 的 Markdown 编辑器或平台。</li><li>安装 Mermaid CLI（命令行接口）工具，以在本地环境中生成图表。</li><li>在线使用 Mermaid Live Editor，这是一个官方提供的在线工具，允许用户即时预览他们的 Mermaid 图表代码生成的图形。</li></ul><p>Mermaid 的学习曲线相对平缓，通过阅读其官方文档和在 Mermaid Live Editor 上进行实践，用户可以快速掌握如何绘制基础甚至是复杂的图表。</p><h2 id="mermaid-常用写作工具"><a href="#mermaid-常用写作工具" class="headerlink" title="mermaid 常用写作工具"></a>mermaid 常用写作工具</h2><ul><li><strong>typora</strong></li><li><a href="https://mermaid.live/"><strong>mermaid在线</strong></a></li><li><code>https://mermaid.nodejs.cn/syntax/block.html</code></li></ul><h2 id="mermaid-常用工具库代码风格参考"><a href="#mermaid-常用工具库代码风格参考" class="headerlink" title="mermaid 常用工具库代码风格参考"></a>mermaid 常用工具库代码风格参考</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs text">---<br>title: mermaid 常用工具库代码风格参考<br>---<br>graph TB<br>a[A]<br>b[B]<br>c[C]<br>subgraph MySubGraphTitle<br>comp_a:::Orange<br>comp_a ---&gt; comp_b[B]<br>comp_b ----&gt; comp_c<br>comp_c ---&gt; comp_d<br>comp_d -- D转E --&gt; comp_e<br>end<br><br>subgraph Layer1<br>l_a<br>end<br><br>subgraph Layer2<br>test_no_border:::NoBorder<br>end<br><br><br>    linkStyle 1 stroke:blue,stroke-width:1px,color:black,stroke-dasharray: 5, 5;<br>    linkStyle 3 stroke:red,stroke-width:4px,color:green;<br><br>%% stroke 为边框或线条 stroke: , stroke-width: 宽度 stroke-dasharray: 虚线<br>%% fill 为填充结点的颜色<br>%% color 为结点中文字颜色<br><br>%% fill: <br><br>    style a stroke:#f66,stroke-width:2px;<br>    style b stroke:#66f,stroke-width:4px;<br><br>style Layer1 fill:#FFEBB5<br>classDef Orange fill:#f96<br><br>%% 颜色 transparent 透明<br>classDef NoBorder fill:transparent, stroke:transparent;<br><br>%% 样式测试区<br>%%classDef Orange fill:#f96<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">---title: mermaid 常用工具库代码风格参考---graph TBa[A]b[B]c[C]subgraph MySubGraphTitlecomp_a:::Orangecomp_a ---&gt; comp_b[B]comp_b ----&gt; comp_ccomp_c ---&gt; comp_dcomp_d -- D转E --&gt; comp_eendsubgraph Layer1l_aendsubgraph Layer2test_no_border:::NoBorderend    linkStyle 1 stroke:blue,stroke-width:1px,color:black,stroke-dasharray: 5, 5;    linkStyle 3 stroke:red,stroke-width:4px,color:green;%% stroke 为边框或线条 stroke: , stroke-width: 宽度 stroke-dasharray: 虚线%% fill 为填充结点的颜色%% color 为结点中文字颜色%% fill:     style a stroke:#f66,stroke-width:2px;    style b stroke:#66f,stroke-width:4px;style Layer1 fill:#FFEBB5classDef Orange fill:#f96%% 颜色 transparent 透明classDef NoBorder fill:transparent, stroke:transparent;%% 样式测试区%%classDef Orange fill:#f96</code></pre><h3 id="常用颜色方案"><a href="#常用颜色方案" class="headerlink" title="常用颜色方案"></a>常用颜色方案</h3><ul><li><p>基础色：</p><p> 提供足够对比度，适用于大多数背景和用途。</p><ul><li>蓝色：<code>#1E90FF</code>（道奇蓝），给人以专业和可靠的感觉。</li><li>绿色：<code>#32CD32</code>（酸橙绿），代表增长和繁荣。</li><li>红色：<code>#FF6347</code>（番茄），用于警告或强调。</li><li>黄色：<code>#FFD700</code>（金色），用来吸引注意或表示警告，但比红色更温和。</li><li>灰色：<code>#708090</code>（石板灰），适合背景和非主要元素，提供足够对比而不过于抢眼。</li></ul></li></ul><h3 id="辅助色方案"><a href="#辅助色方案" class="headerlink" title="辅助色方案"></a>辅助色方案</h3><p>辅助色可用于强调、分类或作为基础色的补充：</p><ul><li>浅蓝色：<code>#87CEFA</code>（浅天蓝色），温和且易于观看，适合作为背景或强调信息。</li><li>紫色：<code>#9370DB</code>（中紫色），神秘且优雅，适合创意展示。</li><li>橙色：<code>#FFA07A</code>（浅橙色），活泼且友好，适合吸引注意。</li><li>粉色：<code>#FFC0CB</code>（粉红），温柔且亲切，用于温和强调。</li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
      <tag>mermaid</tag>
      
      <tag>typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rust的AST.md</title>
    <link href="/2024/03/07/mdstorage/project/cToRust/rust%E7%9A%84AST/"/>
    <url>/2024/03/07/mdstorage/project/cToRust/rust%E7%9A%84AST/</url>
    
    <content type="html"><![CDATA[<p><a href="mailto:&#49;&#x31;&#x30;&#x33;&#48;&#x39;&#56;&#x36;&#x30;&#55;&#64;&#x71;&#x71;&#46;&#99;&#x6f;&#x6d;">&#49;&#x31;&#x30;&#x33;&#48;&#x39;&#56;&#x36;&#x30;&#55;&#64;&#x71;&#x71;&#46;&#99;&#x6f;&#x6d;</a></p><h2 id="Rust-输出-AST"><a href="#Rust-输出-AST" class="headerlink" title="Rust 输出 AST"></a>Rust 输出 AST</h2><h3 id="切换为-nightly-版本"><a href="#切换为-nightly-版本" class="headerlink" title="切换为 nightly 版本"></a>切换为 nightly 版本</h3><p><code>rustup override set nightly</code></p><p><code>rustc --version</code></p><h3 id="输出-AST"><a href="#输出-AST" class="headerlink" title="输出 AST"></a>输出 AST</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">rustc -Z <span class="hljs-built_in">help</span><br><br><span class="hljs-comment"># 简略</span><br>rustc +nightly src/main.rs -Z unpretty=ast-tree<br><br><span class="hljs-comment"># 详细</span><br>rustc +nightly src/main.rs -Z unpretty=ast-tree,expanded<br><br></code></pre></td></tr></table></figure><h2 id="Rust-AST-分析"><a href="#Rust-AST-分析" class="headerlink" title="Rust AST 分析"></a>Rust AST 分析</h2><h2 id="Rust-AST-to-Rust-code"><a href="#Rust-AST-to-Rust-code" class="headerlink" title="Rust AST to Rust code"></a>Rust AST to Rust code</h2><h2 id="构建-Rust-程序"><a href="#构建-Rust-程序" class="headerlink" title="构建 Rust 程序"></a>构建 Rust 程序</h2><h3 id="syn-ItemFn"><a href="#syn-ItemFn" class="headerlink" title="syn::ItemFn"></a>syn::ItemFn</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ItemFn</span> &#123;<br>    <span class="hljs-keyword">pub</span> attrs: <span class="hljs-type">Vec</span>&lt;Attribute&gt;,<br>    <span class="hljs-keyword">pub</span> vis: Visibility,<br>    <span class="hljs-keyword">pub</span> sig: Signature,<br>    <span class="hljs-keyword">pub</span> block: <span class="hljs-type">Box</span>&lt;Block&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ItemFn</code> 是 <code>syn</code> 库中用于表示 Rust 函数的结构体。它包含了构成一个函数定义的所有主要部分。以下是对 <code>ItemFn</code> 结构体各字段的详细解释：</p><h3 id="attrs-Vec"><a href="#attrs-Vec" class="headerlink" title="attrs: Vec&lt;Attribute&gt;"></a><code>attrs: Vec&lt;Attribute&gt;</code></h3><ul><li><code>attrs</code> 字段包含了函数上的属性（attributes）。在 Rust 中，属性用于给编译器传递额外的信息，比如 <code>#[derive(Debug)]</code> 或者 <code>#[test]</code>。这些属性可以应用于许多种类的项，包括函数、结构体、枚举等。</li><li>类型为 <code>Vec&lt;Attribute&gt;</code>，意味着一个函数可以有零个或多个属性。</li></ul><h3 id="vis-Visibility"><a href="#vis-Visibility" class="headerlink" title="vis: Visibility"></a><code>vis: Visibility</code></h3><ul><li><code>vis</code> 字段表示函数的可见性（visibility）。Rust 中的可见性关键字有 <code>pub</code>、<code>pub(crate)</code> 等，用于控制项（比如函数、结构体字段等）的访问范围。</li><li><code>Visibility</code> 是一个枚举，包含了不同的可见性级别，例如公开（<code>Public</code>）、私有（<code>Inherited</code>）、受限（具体受限的范围，如在模块内可见）等。</li></ul><h3 id="sig-Signature"><a href="#sig-Signature" class="headerlink" title="sig: Signature"></a><code>sig: Signature</code></h3><ul><li><code>sig</code> 字段包含了函数的签名。函数签名定义了函数的名称、参数、返回类型以及其他如是否 <code>async</code>、是否 <code>unsafe</code> 的信息。</li><li><code>Signature</code> 是一个结构体，包含了函数名称（<code>ident</code> 字段为 <code>Ident</code> 类型）、输入参数列表（<code>inputs</code> 字段为 <code>Punctuated&lt;FnArg, Comma&gt;</code> 类型）、返回类型（<code>output</code> 字段为 <code>ReturnType</code> 类型）、泛型参数等。</li></ul><h3 id="block-Box"><a href="#block-Box" class="headerlink" title="block: Box&lt;Block&gt;"></a><code>block: Box&lt;Block&gt;</code></h3><ul><li><code>block</code> 字段表示函数体，包含了函数的实际代码块。在 Rust 中，函数体由一系列的语句和可能的尾部表达式组成。</li><li>类型为 <code>Box&lt;Block&gt;</code>，这里 <code>Block</code> 是一个结构体，表示由花括号 <code>&#123;&#125;</code> 包围的代码块。<code>Box</code> 是 Rust 的一个智能指针类型，用于在堆上分配内存。这里使用 <code>Box</code> 是因为代码块可能包含大量的数据，使用堆分配可以避免栈溢出，并且可以提高数据结构的整体性能。</li></ul><h2 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h2><p><code>Signature</code> 结构体在 <code>syn</code> 库中代表了 Rust 函数的签名部分。以下是对 <code>Signature</code> 结构体各字段的详细解释：</p><h3 id="constness-Option"><a href="#constness-Option" class="headerlink" title="constness: Option&lt;Const&gt;"></a><code>constness: Option&lt;Const&gt;</code></h3><ul><li><code>constness</code> 字段表示函数是否是一个 <code>const</code> 函数。在 Rust 中，<code>const</code> 函数可以在编译时被求值。</li><li>类型为 <code>Option&lt;Const&gt;</code>，这意味着该字段可以是 <code>None</code>（表示函数不是 <code>const</code>）或 <code>Some(Const)</code>（表示函数是 <code>const</code>）。</li></ul><h3 id="asyncness-Option"><a href="#asyncness-Option" class="headerlink" title="asyncness: Option&lt;Async&gt;"></a><code>asyncness: Option&lt;Async&gt;</code></h3><ul><li><code>asyncness</code> 字段表示函数是否是异步的，即是否使用了 <code>async</code> 关键字。异步函数允许使用 <code>.await</code> 语法进行异步操作。</li><li>类型为 <code>Option&lt;Async&gt;</code>，这意味着该字段可以是 <code>None</code>（表示函数不是异步的）或 <code>Some(Async)</code>（表示函数是异步的）。</li></ul><h3 id="unsafety-Option"><a href="#unsafety-Option" class="headerlink" title="unsafety: Option&lt;Unsafe&gt;"></a><code>unsafety: Option&lt;Unsafe&gt;</code></h3><ul><li><code>unsafety</code> 字段表示函数是否是 <code>unsafe</code> 的。在 Rust 中，<code>unsafe</code> 函数允许执行一些正常情况下被 Rust 安全保证所禁止的操作，如直接操作裸指针。</li><li>类型为 <code>Option&lt;Unsafe&gt;</code>，这意味着该字段可以是 <code>None</code>（表示函数不是 <code>unsafe</code>）或 <code>Some(Unsafe)</code>（表示函数是 <code>unsafe</code> 的）。</li></ul><h3 id="abi-Option"><a href="#abi-Option" class="headerlink" title="abi: Option&lt;Abi&gt;"></a><code>abi: Option&lt;Abi&gt;</code></h3><ul><li><code>abi</code> 字段表示函数的应用二进制接口（Application Binary Interface，ABI）。ABI 定义了如何在不同的二进制模块或不同的编程语言之间调用函数。</li><li>类型为 <code>Option&lt;Abi&gt;</code>，这意味着该字段可以是 <code>None</code>（使用 Rust 默认的 ABI）或 <code>Some(Abi)</code>（使用特定的 ABI，如 <code>&quot;C&quot;</code>）。</li></ul><h3 id="fn-token-Fn"><a href="#fn-token-Fn" class="headerlink" title="fn_token: Fn"></a><code>fn_token: Fn</code></h3><ul><li><code>fn_token</code> 字段是 <code>Fn</code> 类型的 token，表示了 <code>fn</code> 关键字的存在。</li></ul><h3 id="ident-Ident"><a href="#ident-Ident" class="headerlink" title="ident: Ident"></a><code>ident: Ident</code></h3><ul><li><code>ident</code> 字段是 <code>Ident</code> 类型，代表函数的名称。</li></ul><h3 id="generics-Generics"><a href="#generics-Generics" class="headerlink" title="generics: Generics"></a><code>generics: Generics</code></h3><ul><li><code>generics</code> 字段表示函数的泛型参数。这包括泛型类型参数、生命周期参数以及它们的约束。</li><li>类型为 <code>Generics</code>，它包含了函数泛型参数的详细信息。</li></ul><h3 id="paren-token-Paren"><a href="#paren-token-Paren" class="headerlink" title="paren_token: Paren"></a><code>paren_token: Paren</code></h3><ul><li><code>paren_token</code> 字段是 <code>Paren</code> 类型的 token，表示函数参数列表周围的圆括号。</li></ul><h3 id="inputs-Punctuated"><a href="#inputs-Punctuated" class="headerlink" title="inputs: Punctuated&lt;FnArg, Comma&gt;"></a><code>inputs: Punctuated&lt;FnArg, Comma&gt;</code></h3><ul><li><code>inputs</code> 字段表示函数的输入参数列表。</li><li>类型为 <code>Punctuated&lt;FnArg, Comma&gt;</code>，这是一个使用逗号作为分隔符的列表，包含了一个或多个 <code>FnArg</code>（函数参数）。</li></ul><h3 id="variadic-Option"><a href="#variadic-Option" class="headerlink" title="variadic: Option&lt;Variadic&gt;"></a><code>variadic: Option&lt;Variadic&gt;</code></h3><ul><li><code>variadic</code> 字段表示函数是否接受可变数量的参数（即 C 风格的可变参数函数）。</li><li>类型为 <code>Option&lt;Variadic&gt;</code>，这意味着该字段可以是 <code>None</code>（表示函数不接受可变数量的参数）或 <code>Some(Variadic)</code>（表示函数接受可变数量的参数）。</li></ul><h3 id="output-ReturnType"><a href="#output-ReturnType" class="headerlink" title="output: ReturnType"></a><code>output: ReturnType</code></h3><ul><li><code>output</code> 字段表示函数的返回类型。</li><li>类型为 <code>ReturnType</code>，它可以是 <code>ReturnType::Default</code>（对应于没有明确指定返回类型的情况，等同于返回 <code>()</code>）或 <code>ReturnType::Type</code>（包含具体的返回类型）。</li></ul><p><code>Signature</code> 结构体提供了对 Rust 函数签名的全面描述，包括函数的名称、参数、返回类型以及其他与函数行为相关的关键字（如 <code>async</code>、<code>const</code>、<code>unsafe</code>）。通过操作这些字段，你可以解析、构造或修改函数签名的 AST。</p><p>C 转换为 Rust，使用 syn 库进行 Rust 代码构建，将下面 case C转换为Rust中涉及到的变量、函数声明、调用等操作的对应关系完整的解析，给我一个模板让我能按照模板来将 C 程序和 Rust 程序的对应关系呈现出来</p><h2 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs markdown">你是 C Rust 语言领域资深专家，回答我的问题。我在做关于 C 转换为 Rust 的规则整理，其中计划使用 syn 库进行 Rust 代码构建，将下面 case 中 C转换为Rust中涉及到的变量、函数声明、调用等操作的对应关系完整的解析，并给出详细解析<br><br>模板<br><span class="hljs-section">## <span class="hljs-strong">**函数定义**</span>:</span><br><span class="hljs-section">### 返回值类型</span><br><span class="hljs-bullet">   -</span> <span class="hljs-strong">**C**</span>: 使用关键字 <span class="hljs-code">`void`</span> 表示没有返回值的函数。<br><span class="hljs-bullet">   -</span> <span class="hljs-strong">**Rust**</span>: Rust 中没有返回值的函数隐式返回 <span class="hljs-code">`()`</span>，通常省略返回类型。<br><br><span class="hljs-section">### ...</span><br><span class="hljs-bullet">   -</span> ...<br><span class="hljs-bullet">   -</span> ...<br>   <br><span class="hljs-section">## <span class="hljs-strong">**传入参数**</span>:</span><br><span class="hljs-section">### 传入参数格式</span><br><span class="hljs-bullet">   -</span> <span class="hljs-strong">**C**</span>: 参数类型直接写在参数名前面。<br><span class="hljs-bullet">   -</span> <span class="hljs-strong">**Rust**</span>: 参数类型由冒号隔开，格式为 <span class="hljs-code">`param_name: type`</span>。<br><br><span class="hljs-section">### ...</span><br><span class="hljs-bullet">   -</span> ...<br><span class="hljs-bullet">   -</span> ...<br><br><span class="hljs-section">## <span class="hljs-strong">**循环控制**</span>:</span><br><span class="hljs-section">### for 循环写作格式</span><br><span class="hljs-bullet">   -</span> <span class="hljs-strong">**C**</span>: 使用 <span class="hljs-code">`for`</span> 循环，初始化变量，条件和增量在括号内定义。<br><span class="hljs-bullet">   -</span> <span class="hljs-strong">**Rust**</span>: 使用 <span class="hljs-code">`for`</span> 循环遍历一个范围，范围由 <span class="hljs-code">`start..end`</span> 表示。<br>   <br><span class="hljs-section">### ...</span><br><span class="hljs-bullet">   -</span> ...<br><span class="hljs-bullet">   -</span> ...<br>   <br><span class="hljs-section">## <span class="hljs-strong">**常用库**</span>:</span><br><span class="hljs-section">### 标准输入输出</span><br><span class="hljs-bullet">   -</span> <span class="hljs-strong">**C**</span>: 使用 <span class="hljs-code">`printf`</span> 函数。<br><span class="hljs-bullet">   -</span> <span class="hljs-strong">**Rust**</span>: 使用 <span class="hljs-code">`println!`</span> 宏。<br>   <br><span class="hljs-section">### ...</span><br><span class="hljs-bullet">   -</span> ...<br><span class="hljs-bullet">   -</span> ...<br>   <br><span class="hljs-section">## <span class="hljs-strong">**主函数**</span>:</span><br><span class="hljs-section">### 主函数返回值规则</span><br><span class="hljs-bullet">   -</span> <span class="hljs-strong">**C**</span>: 主函数 <span class="hljs-code">`main`</span> 返回 <span class="hljs-code">`int`</span> 类型，表示程序退出状态。<br><span class="hljs-bullet">   -</span> <span class="hljs-strong">**Rust**</span>: 主函数 <span class="hljs-code">`main`</span> 没有返回值，错误处理通常通过 <span class="hljs-code">`Result`</span> 或 <span class="hljs-code">`panic!`</span> 处理。<br><br><span class="hljs-section">### ...</span><br><span class="hljs-bullet">   -</span> ...<br><span class="hljs-bullet">   -</span> ...<br>   <br><span class="hljs-section">## ...</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>project</category>
      
      <category>cToRust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>AST</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>交换机路由器.md</title>
    <link href="/2024/03/06/mdstorage/domain/network/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    <url>/2024/03/06/mdstorage/domain/network/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%B7%AF%E7%94%B1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="LAN-中网关通常存在于路由器中"><a href="#LAN-中网关通常存在于路由器中" class="headerlink" title="LAN 中网关通常存在于路由器中"></a>LAN 中网关通常存在于路由器中</h2><p>一般来说，一个局域网（LAN）上的网关通常存在于路由器中。网关是一个网络连接点，它允许一个网络上的设备访问另一个网络。在大多数家庭和小型企业网络中，网关设备提供了多种功能，包括：</p><ul><li><strong>路由功能</strong>：将数据包从一个网络路由到另一个网络，通常是从局域网（LAN）路由到广域网（WAN），如互联网。</li><li><strong>NAT（网络地址转换）</strong>：允许多个设备共享一个公共 IP 地址进行互联网访问，增强了网络的安全性和效率。</li><li><strong>DHCP（动态主机配置协议）</strong>：自动分配 IP 地址给网络上的设备，简化了网络管理。</li><li><strong>防火墙功能</strong>：提供基本的网络安全防护，防止未经授权的访问。</li></ul><h2 id="路由器、交换机如何参与到-ARP-协议中"><a href="#路由器、交换机如何参与到-ARP-协议中" class="headerlink" title="路由器、交换机如何参与到 ARP 协议中"></a>路由器、交换机如何参与到 ARP 协议中</h2><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机工作在数据链路层（第二层），主要负责转发基于 MAC 地址的帧。在 ARP 协议中，交换机的角色主要包括：</p><ol><li><strong>转发 ARP 请求</strong>：当交换机接收到一个 ARP 请求（一个广播帧），它会将这个请求转发到除了接收该请求的端口之外的所有活动端口。这样做是为了确保局域网内的所有主机都有机会接收到这个 ARP 请求。</li><li><strong>学习 MAC 地址</strong>：虽然交换机不直接参与 ARP 请求的生成或响应，但它们会利用经过的 ARP 流量来学习网络上设备的 MAC 地址。当交换机转发 ARP 请求或响应时，它会在其 MAC 地址表中记录发送方的 MAC 地址和对应的端口号，从而优化未来的帧转发过程。</li><li><strong>不干预 ARP 流程</strong>：交换机不会修改 ARP 请求或响应的内容。它的主要任务是透明地传递这些帧，确保它们到达目的地。</li></ol><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>路由器工作在网络层（第三层），负责在不同网络之间转发数据包。在 ARP 的上下文中，路由器有几种不同的参与方式：</p><ol><li><strong>响应 ARP 请求</strong>：当主机尝试与不同子网的主机通信时，它会发送一个 ARP 请求来查找该目的地的 MAC 地址。在这种情况下，路由器会响应 ARP 请求，提供其自己的 MAC 地址作为目的地（下一跳）。这样，发送方会将数据包发送到路由器，然后路由器将数据包转发到正确的网络。</li><li><strong>生成 ARP 请求</strong>：当路由器需要将数据包转发到其直接连接的网络上的主机，但它不知道该主机的 MAC 地址时，它会生成 ARP 请求。一旦收到 ARP 响应并学习了目标主机的 MAC 地址，路由器就可以将数据包正确地转发给该主机。</li><li><strong>维护 ARP 表</strong>：路由器维护自己的 ARP 表（或 ARP 缓存），其中包含其直接连接的网络上已知主机的 IP 到 MAC 地址映射。这样可以加快后续数据包的转发速度，因为路由器可以直接从 ARP 表中查找到需要的 MAC 地址。</li><li><strong>代理 ARP</strong>：在某些配置中，路由器可能执行代理 ARP 的角色，帮助不在同一子网内的主机相互通信。通过代理 ARP，路由器响应代表另一个不同网络的主机的 ARP 请求，允许两个不同网络的设备通过路由器中继来通信，尽管这种做法在现代网络中较少使用，因为它可能导致网络拓扑和流量管理的复杂性增加。</li></ol>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
      <tag>交换机</tag>
      
      <tag>路由器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见交换机路由器网络拓扑图.md</title>
    <link href="/2024/03/06/mdstorage/domain/network/%E5%B8%B8%E8%A7%81%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E5%9B%BE/"/>
    <url>/2024/03/06/mdstorage/domain/network/%E5%B8%B8%E8%A7%81%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="网络拓扑图"><a href="#网络拓扑图" class="headerlink" title="网络拓扑图"></a>网络拓扑图</h2><pre><code class=" mermaid">graph TD;    subgraph WAN    Internet[互联网]    end    subgraph LAN    Router[路由器] --&gt; |内网接口| Switch1[交换机1]    Router --&gt; |内网接口| Switch2[交换机2]    Switch1 --&gt; PC1[PC 1]    Switch1 --&gt; PC2[PC 2]    Switch2 --&gt; Terminal1[终端设备 1]    Switch2 --&gt; Terminal2[终端设备 2]    Switch1 --&gt; Switch3[交换机3]    Switch3 --&gt; PC3[PC 3]    Switch3 --&gt; Terminal3[终端设备 3]    end    Internet --&gt; |外网接口| Router    classDef router fill:#f9d5e5,stroke:#b84a62,stroke-width:2px;    classDef switch fill:#eef5db,stroke:#d2b48c,stroke-width:2px;    classDef device fill:#d5eaf4,stroke:#6b8ba4,stroke-width:2px;    classDef internet fill:#c2cad0,stroke:#6b7b8b,stroke-width:2px,stroke-dasharray: 5, 5;    class Router router;    class Switch1,Switch2,Switch3 switch;    class PC1,PC2,PC3,Terminal1,Terminal2,Terminal3 device;    class Internet internet;</code></pre>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
      <tag>交换机</tag>
      
      <tag>路由器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网卡命名guize.md</title>
    <link href="/2024/03/05/mdstorage/domain/linux/%E7%BD%91%E5%8D%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"/>
    <url>/2024/03/05/mdstorage/domain/linux/%E7%BD%91%E5%8D%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h2 id="eth0-和-enp1s0"><a href="#eth0-和-enp1s0" class="headerlink" title="eth0 和 enp1s0"></a>eth0 和 enp1s0</h2><p><code>eth0</code>和<code>enp1s0</code>这两种命名方式代表了Linux系统中网络接口（网卡）的两种不同命名规则。它们的区别主要源于网络接口的命名方案，即传统命名方案与预测网络接口名称（Predictable Network Interface Names）。</p><h3 id="传统命名方案（eth0）"><a href="#传统命名方案（eth0）" class="headerlink" title="传统命名方案（eth0）"></a>传统命名方案（<code>eth0</code>）</h3><ul><li><strong>命名方式</strong>：在传统的命名方案中，以太网接口通常被命名为<code>eth0</code>、<code>eth1</code>等。这种命名方式简单直观，易于理解。</li><li><strong>特点</strong>：命名是基于内核检测到的接口顺序，但这会导致一个问题：网络接口的名称在系统重启或添加新的网卡时可能会变化，因为它们是根据发现的顺序命名的。这种不可预测性可能会导致配置错误。</li></ul><h3 id="预测网络接口名称（enp1s0）"><a href="#预测网络接口名称（enp1s0）" class="headerlink" title="预测网络接口名称（enp1s0）"></a>预测网络接口名称（<code>enp1s0</code>）</h3><ul><li><p>命名方式</p><p>：为了解决传统命名方案的不可预测性问题，引入了预测网络接口名称。这种命名方式试图提供一种更一致、可预测的方法来命名网络接口。例如，</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">e<span class="hljs-symbol">np1</span>s<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>代表的是：</p><ul><li><code>en</code>：Ethernet</li><li><code>p1</code>：PCI bus 1</li><li><code>s0</code>：slot 0</li></ul></li><li><p><strong>特点</strong>：这种命名规则基于硬件的物理位置（如PCI插槽位置）来命名网络接口，因此即使在系统重启或硬件更改的情况下，网络接口的名称也保持不变，从而提高了配置的一致性和稳定性。</p></li></ul><h3 id="转变的原因"><a href="#转变的原因" class="headerlink" title="转变的原因"></a>转变的原因</h3><p>转向预测网络接口名称的主要原因是为了解决设备命名的不一致性和不可预测性，尤其是在具有多个网络接口的系统中。这有助于系统管理员更准确地识别和配置网络接口，尤其是在自动化部署和维护大规模系统时。</p><p>系统可以配置为使用任一种命名方案，而且某些Linux发行版允许用户通过修改udev规则等方法来自定义网络接口的命名方式。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运行时系统语言.md</title>
    <link href="/2024/02/29/mdstorage/domain/C%E8%AF%AD%E8%A8%80/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B3%BB%E7%BB%9F%E8%AF%AD%E8%A8%80/"/>
    <url>/2024/02/29/mdstorage/domain/C%E8%AF%AD%E8%A8%80/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B3%BB%E7%BB%9F%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="运行时系统语言"><a href="#运行时系统语言" class="headerlink" title="运行时系统语言"></a>运行时系统语言</h2><p>“有运行时的语言”（或具有运行时系统的语言）指的是那些在程序执行期间依赖于某种形式的运行时环境（Runtime Environment, RE）或运行时库（Runtime Library）的编程语言。这个运行时环境提供了一系列服务或功能，如内存管理（包括垃圾回收）、类型安全检查、异常处理、动态类型和反射等，从而支持程序的执行。</p><h3 id="运行时环境的作用"><a href="#运行时环境的作用" class="headerlink" title="运行时环境的作用"></a>运行时环境的作用</h3><p>运行时环境的主要作用包括但不限于：</p><ul><li><strong>内存管理</strong>：自动管理程序的内存分配和回收，例如通过垃圾回收机制减少内存泄漏。</li><li><strong>类型检查</strong>：动态语言通常在运行时执行类型检查，以确保类型安全。</li><li><strong>异常处理</strong>：处理程序执行中的异常情况，如运行时错误和异常捕获。</li><li><strong>动态特性支持</strong>：提供反射、动态绑定等动态特性，允许程序在运行时查询和修改类型信息。</li></ul><h3 id="有运行时与无运行时的语言"><a href="#有运行时与无运行时的语言" class="headerlink" title="有运行时与无运行时的语言"></a>有运行时与无运行时的语言</h3><ul><li><strong>有运行时的语言</strong>：如 Java、C#、Python、Ruby 和 JavaScript 等，它们依赖于虚拟机（如 JVM 和 .NET CLR）或解释器来执行程序。这些环境提供了丰富的运行时服务，使得开发者可以更加专注于业务逻辑的实现，而不是底层的资源管理。</li><li><strong>无运行时的语言</strong>：理论上，所有的编程语言在执行时都需要某种形式的运行时支持，但像 C 和 Rust 这样的语言被认为是“无运行时”或“几乎无运行时”的，因为它们不需要重量级的运行时环境。它们直接编译为机器码，运行时开销非常小，内存管理等责任主要由程序员手动管理。</li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>虽然“无运行时”这个词可能会让人误以为完全没有运行时支持，但实际上这些语言的标准库仍然提供了一定的运行时功能，只是相比那些“有运行时”的语言，这些功能更加基础和有限。例如，Rust 的运行时支持相对非常小，主要关注性能和内存安全，而避免了垃圾收集等运行时特性。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信链路改造sc、webserver链路改造设计.md</title>
    <link href="/2024/02/29/mdstorage/project/sr/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0sc%E3%80%81webserver%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/02/29/mdstorage/project/sr/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0sc%E3%80%81webserver%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><h3 id="现状分析"><a href="#现状分析" class="headerlink" title="现状分析"></a>现状分析</h3><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><h3 id="困难点"><a href="#困难点" class="headerlink" title="困难点"></a>困难点</h3><h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><h2 id="异常场景"><a href="#异常场景" class="headerlink" title="异常场景"></a>异常场景</h2><h3 id="1-网络异常"><a href="#1-网络异常" class="headerlink" title="1. 网络异常"></a>1. 网络异常</h3><ul><li><strong>原因</strong>：客户端A&#x2F;B或sc-core网络不稳定，导致消息传输失败。</li><li><strong>解决方案</strong>：实现重试机制和超时控制，确保消息能够在网络恢复后成功传输。</li></ul><h3 id="2-客户端注册失败"><a href="#2-客户端注册失败" class="headerlink" title="2. 客户端注册失败"></a>2. 客户端注册失败</h3><ul><li><strong>原因</strong>：客户端信息错误、sc-core服务不可用或达到连接数上限。</li><li><strong>解决方案</strong>：检查客户端信息的正确性，确保sc-core服务运行正常，并考虑扩展服务能力以支持更多客户端。</li></ul><h3 id="3-消息转发失败"><a href="#3-消息转发失败" class="headerlink" title="3. 消息转发失败"></a>3. 消息转发失败</h3><ul><li><strong>原因</strong>：目标客户端不在线、sc-core内部错误或消息格式不兼容。</li><li><strong>解决方案</strong>：在sc-core中实现客户端在线状态检测，对内部错误进行异常捕获处理，并确保消息格式的统一和兼容性。</li></ul><h3 id="4-响应超时"><a href="#4-响应超时" class="headerlink" title="4. 响应超时"></a>4. 响应超时</h3><ul><li><strong>原因</strong>：B处理请求耗时过长或sc-core到B的网络延迟。</li><li><strong>解决方案</strong>：优化B处理逻辑的性能，提高响应速度，并在A端实现超时重试机制。</li></ul><h3 id="5-数据一致性问题"><a href="#5-数据一致性问题" class="headerlink" title="5. 数据一致性问题"></a>5. 数据一致性问题</h3><ul><li><strong>原因</strong>：在分布式环境下，客户端状态更新可能不同步。</li><li><strong>解决方案</strong>：实现客户端心跳机制，定期同步客户端状态，确保sc-core持有的客户端信息准确。</li></ul><h3 id="6-安全性问题"><a href="#6-安全性问题" class="headerlink" title="6. 安全性问题"></a>6. 安全性问题</h3><ul><li><strong>原因</strong>：传输数据未加密，存在被截获的风险。</li><li><strong>解决方案</strong>：使用TLS加密gRPC通信，确保数据传输的安全性。</li></ul><h3 id="7-资源竞争和泄漏"><a href="#7-资源竞争和泄漏" class="headerlink" title="7. 资源竞争和泄漏"></a>7. 资源竞争和泄漏</h3><ul><li><strong>原因</strong>：并发处理不当导致的资源竞争或未正确释放资源导致的内存泄漏。</li><li><strong>解决方案</strong>：使用锁或其他并发控制机制管理资源访问，确保goroutine安全；及时释放不再使用的资源，避免内存泄漏。</li></ul><h3 id="8-服务降级与熔断"><a href="#8-服务降级与熔断" class="headerlink" title="8. 服务降级与熔断"></a>8. 服务降级与熔断</h3><ul><li><strong>原因</strong>：sc-core负载过高，无法处理更多请求。</li><li><strong>解决方案</strong>：实现服务降级策略，在系统负载过高时，暂时拒绝非关键请求；使用熔断机制，防止系统完全不可用。</li></ul><h3 id="9-服务发现问题"><a href="#9-服务发现问题" class="headerlink" title="9. 服务发现问题"></a>9. 服务发现问题</h3><ul><li><strong>原因</strong>：客户端或服务端在动态环境下IP变化，导致无法正常通信。</li><li><strong>解决方案</strong>：引入服务注册与发现机制，客户端和服务端动态注册自己的地址信息，保证通信地址的实时更新。</li></ul><h1 id="项目概述-1"><a href="#项目概述-1" class="headerlink" title="项目概述"></a>项目概述</h1><h2 id="现状分析-1"><a href="#现状分析-1" class="headerlink" title="现状分析"></a>现状分析</h2><h3 id="总控、引擎、插件跨节点通信链路"><a href="#总控、引擎、插件跨节点通信链路" class="headerlink" title="总控、引擎、插件跨节点通信链路"></a>总控、引擎、插件跨节点通信链路</h3><pre><code class=" mermaid">graph LRsubgraph Sc[总控]scsv[可视化 sv]installer-manager[引擎安装 manager]endsubgraph Se[流量引擎]        subgraph Sem[流量引擎 管理节点]            installer-agent[引擎安装 agent]            webserver[Webserver]            admin_dam[admin Dam]            apiserver[Apiserver]            admin_ha[admin HA]nexus_m[Nexus]global_plugin_server[global-plugin-server]        end        subgraph Sew[流量引擎 工作节点]            data_dam[data Dam]            nexus_w[Nexus]            envoy[Envoy]        end                subgraph Ses[流量引擎 调度节点]        nexus_s[Nexus]        data_ha[Data HA]        endendinstaller-manager --&gt;|vip/nodeIP:8099|installer-agentinstaller-manager --&gt;|vip:6898|admin_hasv --&gt;|vip:1234|admin_damsv --&gt;|vip:8899|admin_damsv --&gt;|vip:8299|webserversc --&gt;|vip:8229|webserverinstaller-agent --&gt;|nodeIP:8098|installer-managerdata_dam --&gt;|nodeIp:4150|svdata_ha --&gt;|nodeIp:6443| apiserverwebserver --&gt;|nodeIp:9001|data_damwebserver --&gt;|nodeIp:8000| nexus_m &amp; nexus_s &amp; nexus_wenvoy --&gt;|vip:7878 7978| global_plugin_server%%installer-agent --&gt;|vip:6443|apiserver</code></pre><p>结论： 可以看出来现有的通信链路有两个不符合设计要求的点 1. 通信建立连接方向为总控端到引擎端  2. 通信链路不规则，各个组件缺乏管制，随意建立链接。</p><p>缺点很明显，1 会导致与实际客户部署场景不吻合 2 会导致后期运维困难、系统维护困难、系统开发成本提高等。</p><h2 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h2><h3 id="改造后总控引擎通信链路（不算引擎内部）"><a href="#改造后总控引擎通信链路（不算引擎内部）" class="headerlink" title="改造后总控引擎通信链路（不算引擎内部）"></a>改造后总控引擎通信链路（不算引擎内部）</h3><pre><code class=" mermaid">graph LRsubgraph Sc[总控]sc[sc]core[core *:20111]sv[可视化 sv]installer-manager[引擎安装 manager]endsubgraph Se[流量引擎]        subgraph Sem[流量引擎 管理节点]            %%installer-agent[引擎安装 agent]            webserver[Webserver]            admin_dam[admin Dam]            apiserver[Apiserver]            admin_ha[admin HA]nexus_m[Nexus]global_plugin_server[global-plugin-server]        end        subgraph Sew[流量引擎 工作节点]            data_dam[data Dam]            nexus_w[Nexus]            envoy[Envoy]        end                subgraph Ses[流量引擎 调度节点]        nexus_s[Nexus]        endend%%installer-manager --&gt;|vip/nodeIP:8099|installer-agent%%installer-manager --&gt;|vip:6898|admin_ha%%sv --&gt;|vip:1234|admin_dam%%sv --&gt;|vip:8899|admin_dam%%sv --&gt;|vip:8299|webserver%%sc --&gt;|vip:8229|webserversc --&gt; corewebserver --&gt; coresv --&gt; core%%admin_dam ---&gt; webserveradmin_dam ---&gt; |*:29120| svinstaller-manager --&gt; core%%admin_ha ---&gt; webserver%%installer-agent ---&gt; coreinstaller-manager --&gt;|nodeIp:22 |Se%%installer-agent --&gt;|nodeIP:8098|installer-manager%%data_dam --&gt;|nodeIp:4150|sv%%data_dam --&gt;|nodeIp:9001|webserver%%webserver --&gt;|nodeIp:8000| nexus_m &amp; nexus_s &amp; nexus_w%%envoy --&gt;|vip:7878 7978| global_plugin_server%%installer-agent --&gt;|vip:6443|apiserver</code></pre><h3 id="改造后总控引擎通信链路（算引擎内部）"><a href="#改造后总控引擎通信链路（算引擎内部）" class="headerlink" title="改造后总控引擎通信链路（算引擎内部）"></a>改造后总控引擎通信链路（算引擎内部）</h3><pre><code class=" mermaid">graph LRsubgraph Sc[总控]sc[sc]core[core *:20111]sv[可视化 sv]installer-manager[引擎安装 manager]endsubgraph Se[流量引擎]        subgraph Sem[流量引擎 管理节点]            %%installer-agent[引擎安装 agent]            webserver[Webserver]            admin_dam[admin Dam]            apiserver[Apiserver]            admin_ha[admin HA]nexus_m[Nexus]global_plugin_server[global-plugin-server]        end        subgraph Sew[流量引擎 工作节点]            data_dam[data Dam]            nexus_w[Nexus]            envoy[Envoy]        end                subgraph Ses[流量引擎 调度节点]        nexus_s[Nexus]        data_ha[Data HA]        endend%%installer-manager --&gt;|vip/nodeIP:8099|installer-agent%%installer-manager --&gt;|vip:6898|admin_ha%%sv --&gt;|vip:1234|admin_dam%%sv --&gt;|vip:8899|admin_dam%%sv --&gt;|vip:8299|webserver%%sc --&gt;|vip:8229|webserversc --&gt; corewebserver --&gt; coresv --&gt; coreadmin_dam ---&gt;|*:29120| svinstaller-manager --&gt; coreadmin_ha ---&gt; webserver%%installer-agent ---&gt; coredata_ha --&gt;|nodeIp:6443| apiserver%%installer-agent --&gt;|nodeIP:8098|installer-manager%%data_dam --&gt;|nodeIp:4150|sv%%data_dam --&gt;|nodeIp:9001|webserverwebserver --&gt;|nodeIp:8000| nexus_m &amp; nexus_s &amp; nexus_wenvoy --&gt;|vip:7878 7978| global_plugin_serverinstaller-manager --&gt;|nodeIp:22 |Se%%installer-agent --&gt;|vip:6443|apiserver    linkStyle 0,1 stroke-width:8px;    </code></pre><h2 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h2><h3 id="建立连接反转"><a href="#建立连接反转" class="headerlink" title="建立连接反转"></a>建立连接反转</h3><p>（本次改动不涉及 可视化数据传输的流，这是考虑到可视化的数据流过大，经过一次转发消耗的资源比较大）</p><p>在 core 参与的框架中，完成组件之间通信有两步：</p><ol><li>与 core 建立通信</li><li>发送&#x2F;接收、处理请求</li></ol><p>图表标识</p><ul><li>红线表示需要完成 1 2 步编码</li><li>紫线表示不需要实现</li><li>橙色表示需要实现 2 步</li></ul><h4 id="sc-到-webserver"><a href="#sc-到-webserver" class="headerlink" title="sc 到 webserver"></a>sc 到 webserver</h4><pre><code class=" mermaid">graph LRsubgraph Sc[总控]        subgraph ScApi[总控API]            client[SCClient]            subgraph Client                conn_ctx[引擎连接管理]                gw_obj[引擎服务搭建]                node_ctx[引擎节点管理]                auth_ctx[引擎授权管理]                ha_ctx[调度策略管理]            end        end        subgraph Core            core_conn_ctx[各组件连接上下文管理]            subgraph Stream                Agent            end        endendsubgraph Serouter[Webserver]subgraph Router            gw[网关、虚拟服务对象等接口]            node_manage[引擎节点状态接口]            auth_manage[引擎授权管理接口]            ha_manage[调度策略管理接口]endend router --&gt; Agentclient --&gt; Agentrouter --&gt; Routerclient --&gt; Client &amp; core_conn_ctx    linkStyle 0,1,2,3,4 stroke:red,stroke-width:8px,color:black;    </code></pre><h2 id="多管理面节点主备切换场景–方案改造后流程图"><a href="#多管理面节点主备切换场景–方案改造后流程图" class="headerlink" title="多管理面节点主备切换场景–方案改造后流程图"></a>多管理面节点主备切换场景–方案改造后流程图</h2><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0%E5%A4%9A%E8%8A%82%E7%82%B9%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91.png" alt="通信链路改造多节点主备切换程序逻辑"> </p><h3 id="主备切换场景–异常情况"><a href="#主备切换场景–异常情况" class="headerlink" title="主备切换场景–异常情况"></a>主备切换场景–异常情况</h3><ul><li>HA 出现问题，主节点状态异常后未能及时完成主备切换操作</li><li>HA –&gt; webserver 这条链路出现问题，不能及时通知 webserver 主备切换信息，导致引擎失联，会在界面中显现</li><li>webserver –&gt; sc-core 被告之主备切换后未能主动连接 sc-core ，或是链路出现问题，同样表现为引擎失联</li><li>sc-core 不能正确处理 webserver 断线、新 webserver 重连场景，导致引擎链路出现问题，可能表现为引擎失联</li></ul><h2 id="通信链路规整"><a href="#通信链路规整" class="headerlink" title="通信链路规整"></a>通信链路规整</h2><p>todo</p>]]></content>
    
    
    
    <tags>
      
      <tag>通信链路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cToRust.md</title>
    <link href="/2024/02/28/mdstorage/project/cToRust/cToRust/"/>
    <url>/2024/02/28/mdstorage/project/cToRust/cToRust/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-number">1</span> 赛题背景<br><span class="hljs-variable">vivo</span>蓝河操作系统是面向通用人工智能时代自研的下一代智慧操作系统，创新性地使用<span class="hljs-variable">Rust</span>语言编写操作系统，得益于<span class="hljs-variable">vivo</span>蓝心大模型的智慧赋能，实现了自主、可控、先进、安全的智慧解决方案。<br><br><span class="hljs-built_in">C</span><span class="hljs-operator">/</span><span class="hljs-built_in">C</span><span class="hljs-operator">++</span>代码编写的系统大约<span class="hljs-number">70</span><span class="hljs-operator">%</span>的严重安全漏洞和内存使用不当相关，而<span class="hljs-variable">Rust</span>语言一系列安全特性，可以在编译阶段发现内存相关安全漏洞，用<span class="hljs-variable">Rust</span>语言编写更安全的操作系统，已经成为行业趋势。国内自主研发的操作系统和自主可控的软件生态都还不成熟，通过代码转译技术，提升开发者对新操作系统的适配效率，促进国产操作系统软件生态发展成熟。<br><br><span class="hljs-number">2</span> 赛题介绍<br>本赛题要求参赛者设计并实现一个具有与蓝河系统<span class="hljs-operator">/</span>应用相关的代码转译能力的工具程序。可选方向有两个：<br><br>（<span class="hljs-number">1</span>）底层代码转译：底层的<span class="hljs-built_in">C</span><span class="hljs-operator">/</span><span class="hljs-built_in">C</span><span class="hljs-operator">++</span>代码转<span class="hljs-variable">Rust</span>代码工具。如给定<span class="hljs-built_in">C</span>语言库，自动转译成<span class="hljs-variable">Rust</span>语言库。<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><code>https://topminisite.com/blog/tutorial-migrating-from-c-to-rust</code></p><h2 id="评分细则"><a href="#评分细则" class="headerlink" title="评分细则"></a>评分细则</h2><p>赛前准备了很多用例，到时候就根据程序跑过的用例数量多少来评分。</p><p>还有写下文档表明思路。</p><h2 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h2><p><code>https://github.com/abrance/cust</code></p>]]></content>
    
    
    <categories>
      
      <category>project</category>
      
      <category>cToRust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>C</tag>
      
      <tag>vivo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cust思路.md</title>
    <link href="/2024/02/28/mdstorage/project/cToRust/cust%E6%80%9D%E8%B7%AF/"/>
    <url>/2024/02/28/mdstorage/project/cToRust/cust%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><p>词法分析、语法分析、语义分析、代码生成</p><p>C 语言编译原理</p><pre><code class=" mermaid">graph TB    src:::no_border;    prc4:::no_border;    lib:::no_border;src[源程序] --&gt; process[预处理器] --&gt; |经过预处理的源程序| prc3[编译器] --&gt;|目标汇编程序| 汇编器 --&gt;|可重定位机器代码| linker[链接器/加载器] --&gt; prc4[目标机器代码]  lib[库文件 可重定向对象文件] --&gt; linkerclassDef no_border fill:transparent, stroke:transparent ;</code></pre><pre><code class=" mermaid">graph TB;符号表src[字符流]:::no_borderan1[词法分析器]an2[语法分析]an3[语义分析]code_gen1[中间代码生成器]code_opt[机器无关代码优化器]code_gen2[代码生成器]code_gen3[机器相关代码优化器]dst[目标机器语言]:::no_bordersrc --&gt; an1 --&gt;|符号流| an2 --&gt;|语法树| an3 --&gt;|语法树| code_gen1 --&gt;|中间表示形式| code_opt --&gt;|中间表示形式| code_gen2 --&gt;|目标机器语言| code_gen3 --&gt; dstclassDef no_border fill:transparent, stroke:transparent ;</code></pre><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>C 词法分析</li><li>C 语法分析</li><li>C 语义分析</li><li>C to Rust 中间代码生成</li><li>Rust 代码生成器</li><li>Rust 代码优化器</li><li>Rust 语言代码</li></ul><h2 id="步骤设计和说明"><a href="#步骤设计和说明" class="headerlink" title="步骤设计和说明"></a>步骤设计和说明</h2><h3 id="1-C-词法分析"><a href="#1-C-词法分析" class="headerlink" title="1. C 词法分析"></a>1. C 词法分析</h3><ul><li><strong>目的</strong>：将源代码字符串分解成一系列的标记（tokens），这些标记代表语言的最小语法单位，如关键字、变量名、操作符等。</li><li><strong>在转换中的作用</strong>：这是解析 C 程序的第一步，为后续的语法分析准备标记流。</li></ul><h3 id="2-C-语法分析"><a href="#2-C-语法分析" class="headerlink" title="2. C 语法分析"></a>2. C 语法分析</h3><ul><li><strong>目的</strong>：根据 C 语言的语法规则分析标记流，构建出抽象语法树（AST）。AST 描述了程序的结构，展现了各个部分之间的关系。</li><li><strong>在转换中的作用</strong>：通过构建 AST，可以清晰地理解程序的结构，为后续的语义分析和转换提供基础。</li></ul><h3 id="3-C-语义分析"><a href="#3-C-语义分析" class="headerlink" title="3. C 语义分析"></a>3. C 语义分析</h3><ul><li><strong>目的</strong>：在语法分析的基础上进一步分析，包括类型检查、变量作用域确认、语义错误检测等。</li><li><strong>在转换中的作用</strong>：确保 C 程序在语义上是正确的，为转换成 Rust 代码提供准确的信息。</li></ul><h3 id="4-C-to-Rust-中间代码生成"><a href="#4-C-to-Rust-中间代码生成" class="headerlink" title="4. C to Rust 中间代码生成"></a>4. C to Rust 中间代码生成</h3><ul><li><strong>目的</strong>：将分析过的 C 程序（通常是 AST）转换为一种中间表示（IR），这种 IR 更接近于目标语言（在这里是 Rust）的结构。</li><li><strong>在转换中的作用</strong>：这一步是将 C 程序转换为 Rust 的关键，需要将 C 的特性映射到 Rust 的相应特性上，处理二者之间的差异。</li></ul><h3 id="5-Rust-代码生成器"><a href="#5-Rust-代码生成器" class="headerlink" title="5. Rust 代码生成器"></a>5. Rust 代码生成器</h3><ul><li><strong>目的</strong>：将中间代码转换为 Rust 源代码。这一步涉及到将中间表示中的结构、语句和表达式转换成 Rust 语言的对应项。</li><li><strong>在转换中的作用</strong>：生成可以由 Rust 编译器编译的源代码。</li></ul><h3 id="6-Rust-代码优化器"><a href="#6-Rust-代码优化器" class="headerlink" title="6. Rust 代码优化器"></a>6. Rust 代码优化器</h3><ul><li><strong>目的</strong>：对生成的 Rust 代码进行优化，提高代码的效率和性能。优化可以在多个层面进行，包括但不限于循环优化、死码删除、内联展开等。</li><li><strong>在转换中的作用</strong>：生成的 Rust 代码可能不是最优的，通过优化可以提高其运行时性能和资源利用率。</li></ul><h3 id="7-Rust-语言代码"><a href="#7-Rust-语言代码" class="headerlink" title="7. Rust 语言代码"></a>7. Rust 语言代码</h3><ul><li><strong>目的</strong>：最终产出的是经过优化的、可读性好的 Rust 代码，它应该保持了原始 C 程序的逻辑和功能，同时利用了 Rust 语言的安全和现代并发特性。</li><li><strong>在转换中的作用</strong>：这是转换流程的最终产物，一个可以编译和运行的 Rust 程序。</li></ul><h2 id="C-语法分析器"><a href="#C-语法分析器" class="headerlink" title="C 语法分析器"></a>C 语法分析器</h2><p>解决如何将 C 语言代码生成 AST</p><p>目前使用 clang 工具，解析为 AST 树，和各种符号在文件的范围。如果 clang 中可以直接获取到符号的语义的情况，则使用 clang 工具，如果不行，则取符号在文件的 location ，对其进行计算判断。（例如：for loop condition 对比操作）</p><h2 id="C-AST-to-Rust-AST"><a href="#C-AST-to-Rust-AST" class="headerlink" title="C AST to Rust AST"></a>C AST to Rust AST</h2><p>这里的 AST 不一定指由各自的编译器前端工具生成的 AST, 而是找到 C Rust 语义中联系程度、转换效率最高的一层，便于 AST to AST 的实现。</p><p>如何找到这一层，这一层的实现，即是这个方案最有挑战的部分，需要深入理解 C Rust 的语法和语义，设计一个足够通用且覆盖两门语言特性的 IR. </p><h2 id="Rust-AST-to-Rust-Code"><a href="#Rust-AST-to-Rust-Code" class="headerlink" title="Rust AST to Rust Code"></a>Rust AST to Rust Code</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">如何一步步将<span class="hljs-built_in">C</span>项目迁移到<span class="hljs-variable">Rust</span>项目？ 将 <span class="hljs-built_in">C</span> 项目迁移到 <span class="hljs-variable">Rust</span> 项目涉及几个步骤。以下是有关如何将 <span class="hljs-built_in">C</span> 项目迁移到 <span class="hljs-variable">Rust</span> 项目的分步指南： 了解 <span class="hljs-variable">Rust</span>：开始迁移之前，请确保您充分了解 <span class="hljs-variable">Rust</span> 编程语言、其语法和功能。熟悉 <span class="hljs-variable">Rust</span> 概念，如所有权、借用和生命周期。 分析 <span class="hljs-built_in">C</span> 项目：浏览 <span class="hljs-built_in">C</span> 项目代码库并分析其结构、依赖项和功能。记下项目中使用的任何外部库、系统调用或复杂的 <span class="hljs-built_in">C</span> 功能。 确定项目依赖关系：确定<span class="hljs-built_in">C</span>项目中使用的依赖关系。检查 <span class="hljs-variable">Rust</span> 等效项或替代项是否可用于这些依赖项。 <span class="hljs-variable">Rust</span> 拥有丰富的生态系统，包含许多库和框架，因此很可能会有合适的替代方案可用。 设置新的 <span class="hljs-variable">Rust</span> 项目：使用 <span class="hljs-variable">Cargo</span> 构建系统创建新的 <span class="hljs-variable">Rust</span> 项目。 <span class="hljs-variable">Cargo</span> 提供了项目管理工具以及依赖管理。使用<span class="hljs-variable">cargo</span> <span class="hljs-variable">new</span>命令创建一个新项目：<span class="hljs-type">$cargonewproject_name</span> 将代码转换为 <span class="hljs-variable">Rust</span>：通过了解每个 <span class="hljs-built_in">C</span> 组件的逻辑和功能，开始将 <span class="hljs-built_in">C</span> 代码转换为 <span class="hljs-variable">Rust</span> 代码。从一个简单的模块或文件开始，并将其转换为 <span class="hljs-variable">Rust</span> 等效项。使用 <span class="hljs-variable">Rust</span> 的类型系统、模式匹配和错误处理功能来增强代码的可读性和安全性。 处理内存管理：在<span class="hljs-built_in">C</span>中，您需要使用<span class="hljs-variable">malloc</span>、<span class="hljs-variable">free</span>和其他函数手动管理内存。另一方面，<span class="hljs-variable">Rust</span> 通过其所有权模型和自动内存管理来处理内存安全。将 <span class="hljs-built_in">C</span> 项目中的手动内存管理转换为 <span class="hljs-variable">Rust</span> 的所有权和借用系统。 重写复杂的组件：<span class="hljs-built_in">C</span> 项目的某些部分可能需要用 <span class="hljs-variable">Rust</span> 进行更复杂的重写。分析这些组件并相应地规划它们的转换。利用 <span class="hljs-variable">Rust</span> 的功能（如结构、枚举、特征和模式匹配）以更惯用的方式重写这些组件。 将 <span class="hljs-variable">Rust</span> 与外部 <span class="hljs-built_in">C</span> 代码集成：如果 <span class="hljs-built_in">C</span> 项目与外部 <span class="hljs-built_in">C</span> 库交互，可以使用 <span class="hljs-variable">Rust</span> 的外部函数接口 <span class="hljs-punctuation">(</span><span class="hljs-variable">FFI</span><span class="hljs-punctuation">)</span> 来弥合 <span class="hljs-variable">Rust</span> 和 <span class="hljs-built_in">C</span> 之间的差距。<span class="hljs-variable">Rust</span> 通过使用 <span class="hljs-type">#</span><span class="hljs-punctuation">[</span><span class="hljs-variable">link</span><span class="hljs-punctuation">]</span> 属性提供与 <span class="hljs-built_in">C</span> 的无缝互操作性和外部“<span class="hljs-built_in">C</span>”函数。 测试和验证：在进行迁移时，定期测试和验证 <span class="hljs-variable">Rust</span> 代码。使用单元测试和集成测试来确保正确性并识别迁移过程中引入的任何问题。 优化和改进：初始转换完成后，您可以进一步优化和改进 <span class="hljs-variable">Rust</span> 代码库。利用 <span class="hljs-variable">Rust</span> 的性能特性，例如零成本抽象、并发模型和优化的运行时。 重构和清理：最后，重构代码库以确保它遵循 <span class="hljs-variable">Rust</span> 的最佳实践、习惯用法和风格约定。删除可能从 <span class="hljs-built_in">C</span> 项目中遗留下来的任何冗余或不安全代码。 逐步集成：如果您的项目具有庞大的代码库或复杂的逻辑，那么将 <span class="hljs-variable">Rust</span> 代码逐步集成到现有的 <span class="hljs-built_in">C</span> 项目中可能是有益的，仅首先替换关键组件。这种方法允许您逐步验证迁移并最大限度地降低与完全重写相关的风险。 通过以下步骤，您可以逐步有效地将<span class="hljs-built_in">C</span>项目迁移到<span class="hljs-variable">Rust</span>项目，充分利用<span class="hljs-variable">Rust</span>的安全性、性能和并发特性。<br><br><span class="hljs-built_in">Read</span> <span class="hljs-variable">more</span> <span class="hljs-variable">at</span><span class="hljs-operator">:</span> <span class="hljs-variable">https</span><span class="hljs-operator">://</span><span class="hljs-variable">topminisite</span><span class="hljs-operator">.</span><span class="hljs-variable">com</span><span class="hljs-operator">/</span><span class="hljs-variable">blog</span><span class="hljs-operator">/</span><span class="hljs-variable">tutorial</span><span class="hljs-operator">-</span><span class="hljs-variable">migrating</span><span class="hljs-operator">-</span><span class="hljs-variable">from</span><span class="hljs-operator">-</span><span class="hljs-variable">c</span><span class="hljs-operator">-</span><span class="hljs-variable">to</span><span class="hljs-operator">-</span><span class="hljs-variable">rust</span><br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">与 C 相比，Rust 的异常处理方法是什么？ Rust 的异常处理方法与 C 不同，因为它没有像 C++ 那样传统的、基于运行时的异常。相反，Rust 使用一种更受控制的机制，称为“panics”来处理异常情况。 在 C 中，异常发生在运行时，可以使用 <span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span> 块捕获和处理。然而，在 Rust 中，当程序遇到不可恢复的错误或违反假设（例如越界数组访问）时，就会触发恐慌。当发生恐慌时，Rust 会展开堆栈，运行每个函数的清理代码，直到到达捕获所有恐慌处理程序或程序终止。 Rust 的偏好是尽可能避免恐慌。相反，它鼓励使用 Result 类型来处理可恢复的错误。 Result 类型提供了一种显式传播和处理错误条件的方法，而不需要异常。通过要求开发人员明确地处理错误，Rust 强制执行更可预测的代码流和更好的错误处理实践。 如果开发人员想要捕获并处理 Rust 中的恐慌，他们可以使用 catch_unwind 函数来捕获展开恐慌。然而，在 Rust 中通常不鼓励这样做，因为恐慌是针对应该避免而不是处理的异常情况。<br><br>Read more <span class="hljs-keyword">at</span>: <span class="hljs-keyword">https</span>://topminisite.com/blog/tutorial-migrating-<span class="hljs-built_in">from</span>-c-<span class="hljs-built_in">to</span>-rust<br></code></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"> 与 <span class="hljs-built_in">C</span> 相比，<span class="hljs-variable">Rust</span> 如何处理 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 操作？ 在 <span class="hljs-variable">Rust</span> 中，与 <span class="hljs-built_in">C</span> 相比，处理 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 操作的方式更加安全和惯用。<span class="hljs-variable">Rust</span> 提供了许多抽象和模式来有效地处理 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 操作。以下是一些主要区别： 错误处理：<span class="hljs-variable">Rust</span> 广泛使用 <span class="hljs-variable">Result</span> 类型来处理 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 错误。 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 操作返回 <span class="hljs-variable">Result</span> 类型，指示成功或错误。另一方面，<span class="hljs-built_in">C</span> 通常使用错误代码或异常来进行错误处理。由于缺乏标准化的错误处理模式，<span class="hljs-built_in">C</span> 中的错误处理更容易出错。 安全和内存管理：<span class="hljs-variable">Rust</span> 通过其所有权和借用系统提供内存安全保证。 <span class="hljs-variable">Rust</span> 中的 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 操作在设计上是内存安全的，避免了许多常见的错误，如缓冲区溢出或释放后使用错误。在<span class="hljs-built_in">C</span>中，需要手动内存管理，这使得在<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>操作期间更容易引入与内存相关的错误。 抽象和特征：<span class="hljs-variable">Rust</span> 为 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 操作提供更高级别的抽象，例如 <span class="hljs-variable">std</span><span class="hljs-string">::io</span><span class="hljs-string">::Read</span>、<span class="hljs-variable">std</span><span class="hljs-string">::io</span><span class="hljs-string">::Write</span> 和 <span class="hljs-variable">std</span><span class="hljs-string">::io</span><span class="hljs-string">::Seek</span> 特征。这些特征提供了处理不同类型 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 流的通用方法和模式。在 <span class="hljs-built_in">C</span> 语言中，<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 操作通常使用 <span class="hljs-variable">fread</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span> 和 <span class="hljs-variable">fwrite</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span> 等较低级函数执行。 <span class="hljs-built_in">C</span> 为 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 操作提供的抽象接口较少，需要更多手动实现常见功能。 异步 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>：<span class="hljs-variable">Rust</span> 通过 <span class="hljs-variable">async</span> 和 <span class="hljs-variable">wait</span> 关键字内置了对异步 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 的支持。异步 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 可以在处理 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 操作时实现更好的并发性和可扩展性。 <span class="hljs-built_in">C</span> 本身不支持异步 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>，实现类似的功能需要使用外部库或实现复杂的多线程。 总体而言，与 <span class="hljs-built_in">C</span> 相比，<span class="hljs-variable">Rust</span> 的强类型系统、所有权模型和安全抽象使其更容易、更可靠、更高效地处理 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 操作。<br><br><span class="hljs-built_in">Read</span> <span class="hljs-variable">more</span> <span class="hljs-variable">at</span><span class="hljs-operator">:</span> <span class="hljs-variable">https</span><span class="hljs-operator">://</span><span class="hljs-variable">topminisite</span><span class="hljs-operator">.</span><span class="hljs-variable">com</span><span class="hljs-operator">/</span><span class="hljs-variable">blog</span><span class="hljs-operator">/</span><span class="hljs-variable">tutorial</span><span class="hljs-operator">-</span><span class="hljs-variable">migrating</span><span class="hljs-operator">-</span><span class="hljs-variable">from</span><span class="hljs-operator">-</span><span class="hljs-variable">c</span><span class="hljs-operator">-</span><span class="hljs-variable">to</span><span class="hljs-operator">-</span><span class="hljs-variable">rust</span><br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Rust 迁移的推荐开发环境是什么？ Rust 迁移的推荐开发环境通常取决于个人喜好，但有一些许多开发人员认为富有成效的流行选项。这些包括： Visual Studio Code (VS Code)：一个轻量级、可定制的代码编辑器，具有广泛的 Rust 支持。它提供了各种扩展，例如 Rust Analyzer，提供 linting、自动完成、调试和其他有用的功能。 带有 Rust 插件的 IntelliJ IDEA：集成开发环境 (IDE)，具有代码分析、重构工具和对 Rust 的内置支持等强大功能。 JetBrains 提供了专门为 IDE 设计的 Rust 插件。 Sublime <span class="hljs-type">Text</span>：一个跨平台文本编辑器，具有可用于 Rust 开发的充满活力的插件和包生态系统。 RustEnhanced 包在 Rust 开发人员中很受欢迎。 Emacs：一个高度可扩展的文本编辑器，通过 rust-mode、cargo 和 racer 等插件对 Rust 提供广泛支持。它提供了陡峭的学习曲线，但提供了显着的灵活性和定制性。 Atom：一个多功能且可定制的文本编辑器，能够使用 <span class="hljs-keyword">language</span>-rust、racer 和 linter-rust 等包来增强 Rust 开发。<br><br><span class="hljs-keyword">Read</span> more at: https://topminisite.com/blog/tutorial-migrating-<span class="hljs-keyword">from</span>-c-<span class="hljs-keyword">to</span>-rust<br></code></pre></td></tr></table></figure><h3 id="1-语法分析"><a href="#1-语法分析" class="headerlink" title="1. 语法分析"></a>1. <strong>语法分析</strong></h3><ul><li><strong>词法与语法分析器</strong>：开发或使用现有的词法分析器和语法分析器来解析 C 代码，生成抽象语法树（AST）。这是理解程序结构的基础。</li><li><strong>语言规范</strong>：深入理解 C 和 Rust 的语言规范，确保能够准确地解析和转换各种语法结构。</li></ul><h3 id="2-语义分析"><a href="#2-语义分析" class="headerlink" title="2. 语义分析"></a>2. <strong>语义分析</strong></h3><ul><li><strong>类型系统</strong>：处理 C 和 Rust 之间的类型系统差异，包括但不限于基本类型、结构体、联合体、枚举等的转换。</li><li><strong>内存模型</strong>：理解并转换不同的内存管理模型，包括指针操作、内存分配与释放等。</li></ul><h3 id="3-代码转换逻辑"><a href="#3-代码转换逻辑" class="headerlink" title="3. 代码转换逻辑"></a>3. <strong>代码转换逻辑</strong></h3><ul><li><strong>转换规则</strong>：开发一套详细的代码转换规则，这些规则需要涵盖从基本语法结构到复杂的控制流和数据结构的转换。</li><li><strong>自动化重构</strong>：实现代码的自动化重构，使转换后的 Rust 代码不仅语法正确，还要符合 Rust 的惯用法（idiomatic Rust）。</li></ul><h3 id="4-外部依赖和库函数"><a href="#4-外部依赖和库函数" class="headerlink" title="4. 外部依赖和库函数"></a>4. <strong>外部依赖和库函数</strong></h3><ul><li><strong>库函数映射</strong>：建立 C 标准库函数与 Rust 标准库或第三方 crates 的映射关系。</li><li><strong>系统调用和平台依赖</strong>：处理系统调用和特定平台依赖的代码，可能需要使用 Rust 的 <code>unsafe</code> 代码块。</li></ul><h3 id="5-错误处理和异常"><a href="#5-错误处理和异常" class="headerlink" title="5. 错误处理和异常"></a>5. <strong>错误处理和异常</strong></h3><ul><li><strong>错误转换</strong>：将 C 语言中的错误处理模式转换为 Rust 的 <code>Result</code> 和 <code>Option</code> 类型，以利用 Rust 的错误处理机制。</li><li><strong>异常安全</strong>：确保转换后的代码在面对异常时能够安全地释放资源，避免内存泄露。</li></ul><h3 id="6-测试和验证"><a href="#6-测试和验证" class="headerlink" title="6. 测试和验证"></a>6. <strong>测试和验证</strong></h3><ul><li><strong>自动化测试</strong>：为转换的代码自动生成测试用例，确保转换后的 Rust 代码的行为与原始 C 代码一致。</li><li><strong>回归测试</strong>：建立回归测试套件，用于验证代码转换工具的更新不会引入新的错误。</li></ul><h3 id="7-工具和库的选择"><a href="#7-工具和库的选择" class="headerlink" title="7. 工具和库的选择"></a>7. <strong>工具和库的选择</strong></h3><ul><li><strong>现有工具利用</strong>：调研并利用现有的工具和库，如使用 LLVM 的 Clang 前端进行 C 代码的解析，或寻找现有的 C 到 Rust 的转换工具作为参考。</li></ul><h3 id="8-用户界面和交互"><a href="#8-用户界面和交互" class="headerlink" title="8. 用户界面和交互"></a>8. <strong>用户界面和交互</strong></h3><ul><li><strong>易用性设计</strong>：如果工具面向非专业用户，考虑提供图形界面或命令行界面的友好交互设计，使用户能够轻松地配置转换选项和查看转换结果。</li></ul><h3 id="9-性能优化"><a href="#9-性能优化" class="headerlink" title="9. 性能优化"></a>9. <strong>性能优化</strong></h3><ul><li><strong>转换效率</strong>：优化代码转换过程的性能，确保工具可以高效处理大型代码库。</li></ul><h3 id="10-文档和社区支持"><a href="#10-文档和社区支持" class="headerlink" title="10. 文档和社区支持"></a>10. <strong>文档和社区支持</strong></h3><ul><li><strong>使用文档</strong>：提供详细的使用说明和最佳实践指南。</li><li><strong>社区交流</strong>：建立社区支持机制，收集用户反馈，持续改进工具。</li></ul>]]></content>
    
    
    <categories>
      
      <category>project</category>
      
      <category>cToRust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rust基本语法.md</title>
    <link href="/2024/02/28/mdstorage/project/cToRust/rust%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2024/02/28/mdstorage/project/cToRust/rust%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Rust-语言概述"><a href="#Rust-语言概述" class="headerlink" title="Rust 语言概述"></a>Rust 语言概述</h2><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"># integer<br># <span class="hljs-type">i8</span> <span class="hljs-type">i16</span> <span class="hljs-type">i32</span> <span class="hljs-type">i64</span> <span class="hljs-type">i128</span> <br># <span class="hljs-type">u8</span> <span class="hljs-type">u16</span> <span class="hljs-type">u32</span> <span class="hljs-type">u64</span> <span class="hljs-type">u128</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> : <span class="hljs-type">i8</span> = <span class="hljs-number">2</span>;<br><br># <span class="hljs-type">f32</span> <span class="hljs-type">f64</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> : <span class="hljs-type">f64</span> = <span class="hljs-number">2.0</span>;<br><br># <span class="hljs-literal">true</span> <span class="hljs-literal">false</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">z</span> : <span class="hljs-type">bool</span> = <span class="hljs-literal">true</span>;<br><br># tup<br><span class="hljs-keyword">let</span> <span class="hljs-variable">tup</span> = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">tup_a</span> : (<span class="hljs-type">i32</span>, <span class="hljs-type">f64</span>, <span class="hljs-type">u8</span>) = (<span class="hljs-number">500</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">2</span>);<br><br># <br></code></pre></td></tr></table></figure><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"># <span class="hljs-built_in">print!</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, output);<br><br># <span class="hljs-built_in">format!</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">command</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;clang -Xclang -ast-dump -fsyntax-only &#123;&#125;&quot;</span>, f_path.<span class="hljs-title function_ invoke__">to_string</span>());<br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">func</span>() &#123;<br>    <span class="hljs-comment">// logic</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">func</span>(a: <span class="hljs-type">i8</span>, b: <span class="hljs-type">i8</span>) &#123;<br>    <span class="hljs-comment">// param need type statement</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">func</span>(a: int) <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>project</category>
      
      <category>cToRust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang缓存区溢出攻击.md</title>
    <link href="/2024/02/27/mdstorage/domain/golang/golang%E7%BC%93%E5%AD%98%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/"/>
    <url>/2024/02/27/mdstorage/domain/golang/golang%E7%BC%93%E5%AD%98%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ol><li><strong>缓冲区和内存管理</strong>：在计算机程序中，缓冲区是用来存储数据的临时内存区域。为了高效地管理内存，操作系统和程序会预先分配特定大小的内存给缓冲区。当程序运行时，它们会向这些缓冲区内写入数据。</li><li><strong>溢出原因</strong>：如果程序没有正确地检查写入缓冲区的数据量，就可能发生溢出。这意味着写入的数据超出了缓冲区的边界，覆盖了相邻的内存区域。这个问题尤其在使用如C和C++这类不自动管理内存的编程语言时频繁出现。</li><li><strong>攻击者的利用</strong>：攻击者可以利用缓冲区溢出漏洞来改变程序的执行流程。通过精心构造溢出数据，攻击者可以覆盖内存中的特定位置，比如返回地址，以此来执行恶意代码。这种技术可以用来绕过安全措施，获取系统访问权限。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><code>http://0xdabbad00.com/2015/04/12/looking_for_security_trouble_spots_in_go_code/</code></p><p><code>https://stackoverflow.com/questions/40262971/is-go-vulnerable-for-buffer-overflow</code></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>golang 如果不使用 unsafe 包，或使用 C 的库，否则不会受到缓存区溢出攻击的影响。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>security</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux应用rootless化整理.md</title>
    <link href="/2024/02/27/mdstorage/domain/linux/Linux%E5%BA%94%E7%94%A8rootless%E5%8C%96%E6%95%B4%E7%90%86/"/>
    <url>/2024/02/27/mdstorage/domain/linux/Linux%E5%BA%94%E7%94%A8rootless%E5%8C%96%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>以一个应用为例，描述为一个应用不使用 root 用户在 <code>运行</code> 的生命周期需要进行的操作。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><code>Unix and Linux System Administration Handbook (Evi Nemeth, Garth Snyder, Trent R. Hein etc.) (Z-Library)</code></p><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><h3 id="当软件系统允许使用sudo组用户运行时"><a href="#当软件系统允许使用sudo组用户运行时" class="headerlink" title="当软件系统允许使用sudo组用户运行时"></a>当软件系统允许使用<code>sudo</code>组用户运行时</h3><ul><li><strong>提权能力</strong>：确实，如果软件系统允许使用属于<code>sudo</code>组的用户运行，那么这些用户可以通过<code>sudo</code>命令暂时获得<code>root</code>用户的权限。这意味着他们可以执行通常需要<code>root</code>权限的操作，例如访问受保护的文件、修改系统设置、安装或卸载软件包等。</li><li><strong>安全和控制</strong>：虽然这种方法提供了很大的灵活性和方便性，但也带来了潜在的安全风险。因为<code>sudo</code>允许用户执行任何命令，所以必须谨慎配置<code>/etc/sudoers</code>文件，以限制用户可以执行的命令范围，遵循最小权限原则。</li></ul><h3 id="当软件系统不允许使用sudo组用户运行时"><a href="#当软件系统不允许使用sudo组用户运行时" class="headerlink" title="当软件系统不允许使用sudo组用户运行时"></a>当软件系统不允许使用<code>sudo</code>组用户运行时</h3><ul><li><strong>权限规划</strong>：在这种情况下，确实需要事先规划和整理软件系统运行所需的所有权限。这包括文件访问权限、网络端口使用权限、特定系统资源的访问等。</li><li><strong>安装时授权</strong>：在软件安装过程中，必须确保所有必要的资源和组件都被正确地授予给将要运行软件的用户账户。这可能包括设置文件和目录的所有权和权限、调整系统配置以允许非<code>root</code>用户访问特定的端口或服务等。</li><li><strong>无提权手段</strong>：使用非<code>sudo</code>组用户运行的应用确实没有再次提权的手段。这就要求软件的安装、配置和运行必须在不需要进一步提权的情况下进行。这种方法有助于提高系统的安全性，因为它限制了软件在系统上可能造成的影响范围。</li></ul><p><strong>创建系统用户需用更高权限</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 以创建用户 sysuser 为例，创建 sudo 组用户</span><br><span class="hljs-built_in">sudo</span> useradd -m sysuser <br><span class="hljs-built_in">sudo</span> passwd sysuser  <span class="hljs-comment"># 这里要输入密码</span><br><span class="hljs-built_in">sudo</span> usermod -aG <span class="hljs-built_in">sudo</span> sysuser<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 以创建用户 sysuser 为例，创建非 sudo 组用户</span><br><span class="hljs-built_in">sudo</span> useradd -m sysuser <br><span class="hljs-built_in">sudo</span> passwd sysuser  <span class="hljs-comment"># 这里要输入密码</span><br></code></pre></td></tr></table></figure><h2 id="应用的文件访问"><a href="#应用的文件访问" class="headerlink" title="应用的文件访问"></a>应用的文件访问</h2><p>从文件归属和访问需求角度进行分类</p><h3 id="1-应用程序文件"><a href="#1-应用程序文件" class="headerlink" title="1. 应用程序文件"></a>1. 应用程序文件</h3><ul><li><strong>定义</strong>：这些是应用程序的核心文件，包括可执行文件、库文件等。</li><li><strong>归属</strong>：通常归属于 root 或特定的应用用户。</li><li><strong>访问需求</strong>：这些文件需要执行权限，但通常不需要写权限，以确保应用的完整性和安全性。</li></ul><h3 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2. 配置文件"></a>2. 配置文件</h3><ul><li><strong>定义</strong>：包含应用程序运行所需的配置信息的文件。</li><li><strong>归属</strong>：可能归属于 root、特定的应用用户或配置管理组。</li><li><strong>访问需求</strong>：在应用启动或配置更改时需要读取权限，少数情况下（如通过应用内部功能更新配置）可能需要写权限。</li></ul><h3 id="3-日志文件"><a href="#3-日志文件" class="headerlink" title="3. 日志文件"></a>3. 日志文件</h3><ul><li><strong>定义</strong>：应用程序运行时产生的日志信息存储文件。</li><li><strong>归属</strong>：通常归属于运行应用程序的用户或特定日志用户组。</li><li><strong>访问需求</strong>：需要写权限以记录运行时信息；对于日志审计和故障排查，需要读权限。</li></ul><h3 id="4-数据文件"><a href="#4-数据文件" class="headerlink" title="4. 数据文件"></a>4. 数据文件</h3><ul><li><strong>定义</strong>：应用程序用于存储数据的文件，如数据库文件、用户上传的文件等。</li><li><strong>归属</strong>：归属于特定的数据管理用户或组或应用程序用户。</li><li><strong>访问需求</strong>：根据应用功能，可能需要读、写、创建和删除权限。</li></ul><h3 id="5-临时文件"><a href="#5-临时文件" class="headerlink" title="5. 临时文件"></a>5. 临时文件</h3><ul><li><strong>定义</strong>：应用程序运行时临时创建的文件，用于处理数据、缓存等。</li><li><strong>归属</strong>：归属于运行应用程序的用户。</li><li><strong>访问需求</strong>：通常需要读写权限，运行完毕后可能需要删除权限。</li></ul><h3 id="6-外部设备和资源文件"><a href="#6-外部设备和资源文件" class="headerlink" title="6. 外部设备和资源文件"></a><del>6. 外部设备和资源文件</del></h3><ul><li><del><strong>定义</strong>：应用程序可能需要访问的外部设备（如USB设备）或网络资源（如通过网络共享访问的文件）。</del></li><li><del><strong>归属</strong>：这些文件的归属和权限由外部系统或网络协议定义。</del></li><li><del><strong>访问需求</strong>：根据外部资源的性质，可能需要特定的读写权限。</del></li></ul><h2 id="应用的网络管理"><a href="#应用的网络管理" class="headerlink" title="应用的网络管理"></a>应用的网络管理</h2><h2 id="应用的虚拟化权限管理"><a href="#应用的虚拟化权限管理" class="headerlink" title="应用的虚拟化权限管理"></a>应用的虚拟化权限管理</h2><h3 id="docker-相关"><a href="#docker-相关" class="headerlink" title="docker 相关"></a>docker 相关</h3><p><code>Unix and Linux System Administration Handbook</code> <code>Chapter 25 Containers</code>  Container in practice  中有一个例子讲述关于 docker 权限过高导致的风险以及如何管理有 docker 的 Linux 系统的权限分配方案</p><h2 id="未整理的提权操作"><a href="#未整理的提权操作" class="headerlink" title="未整理的提权操作"></a>未整理的提权操作</h2><ol><li><strong>安装或卸载软件包</strong>：在系统级别安装或卸载软件，特别是使用包管理器（如APT、YUM或Pacman）时。</li><li><strong>修改系统文件</strong>：编辑位于<code>/etc</code>、<code>/var</code>等目录下的配置文件。这些文件通常控制系统的启动、网络配置、安全策略等。</li><li><strong>管理用户和用户组</strong>：创建、修改或删除用户账户和用户组，以及修改用户权限。</li><li><strong>更改文件所有权</strong>：使用<code>chown</code>命令更改文件或目录的所有者，特别是当这些文件属于其他用户或系统用户时。</li><li><strong>配置网络设置</strong>：更改IP地址、路由表、防火墙规则等网络配置。</li><li><strong>管理系统服务</strong>：启动、停止、重启系统服务或守护进程，如Web服务器、数据库服务等。</li><li><strong>监听低编号端口</strong>：通常，只有<code>root</code>用户才能监听1024以下的端口，这些端口被认为是“特权”端口。</li><li><strong>分配受保护的硬件资源</strong>：例如，配置新的硬盘、分区和文件系统，或者直接访问某些硬件设备。</li><li><strong>设置系统时间和日期</strong>：更改系统的当前时间和日期，包括与网络时间协议（NTP）服务器的同步。</li><li><strong>访问日志文件</strong>：查看位于<code>/var/log</code>目录下的系统日志文件，这些文件通常包含重要的系统运行和安全信息。</li><li><strong>修改内核参数</strong>：使用<code>sysctl</code>或直接编辑<code>/proc/sys/</code>目录下的文件来调整内核运行时参数。</li><li><strong>配置定时任务</strong>：为系统级别的定时任务配置<code>cron</code>作业，需要编辑<code>/etc/crontab</code>文件或在<code>/etc/cron.*</code>目录下添加脚本。</li><li><strong>管理持久性存储设备</strong>：格式化和分区硬盘，管理逻辑卷（使用LVM），或者修改文件系统（如使用<code>fsck</code>命令检查和修复文件系统）。</li><li><strong>控制防火墙和安全设置</strong>：配置<code>iptables</code>或<code>firewalld</code>规则，管理SELinux或AppArmor安全策略。</li><li><strong>访问受限日志和数据文件</strong>：某些日志文件和数据文件因包含敏感信息而受到保护，只有<code>root</code>用户才能访问。</li><li><strong>管理虚拟化资源</strong>：创建和管理虚拟机或容器（如使用KVM、Docker等），通常需要更高权限来访问和分配硬件资源。</li><li><strong>备份和恢复操作</strong>：对系统文件进行备份和恢复时，尤其是使用工具直接访问原始设备或进行大范围文件系统操作。</li><li><strong>修改引导加载器配置</strong>：配置GRUB或其他引导加载器的设置，如更改启动参数或管理多重启动设置。</li><li><strong>加载或卸载内核模块</strong>：使用<code>modprobe</code>、<code>insmod</code>或<code>rmmod</code>命令加载或卸载内核模块。</li><li><strong>直接访问设备文件</strong>：通过<code>/dev</code>目录下的设备文件直接与硬件通信，比如进行磁盘I&#x2F;O操作或配置特定的硬件设备。</li></ol><p>网络相关</p><ol><li><strong>修改网络接口配置</strong>：配置或更改网络接口的IP地址、子网掩码、网关等参数，通常通过<code>ifconfig</code>（已经较少使用）或<code>ip</code>命令进行。</li><li><strong>配置路由表</strong>：添加或删除路由规则，管理系统的路由表，这对于定制网络流量的路径非常重要，可以使用<code>route</code>或<code>ip route</code>命令。</li><li><strong>配置和管理防火墙</strong>：设置或更改<code>iptables</code>、<code>nftables</code>或<code>firewalld</code>等防火墙工具的规则，以控制进出网络流量的允许或禁止。</li><li><strong>启动网络服务</strong>：在低于1024的端口启动网络服务，这些端口被认为是特权端口，很多基础网络服务（如HTTP、HTTPS、SSH）默认运行在这些端口上。</li><li><strong>配置端口转发和NAT（网络地址转换）</strong>：通过<code>iptables</code>或其他网络工具配置端口转发和NAT规则，这对于网络地址和端口的映射非常重要，特别是在多个网络之间进行通信时。</li><li><strong>监控和捕获网络流量</strong>：使用<code>tcpdump</code>、<code>wireshark</code>（在非图形界面环境中使用<code>tshark</code>）等工具监控和捕获网络接口上的流量，通常需要更高权限来访问网络接口。</li><li><strong>修改系统的网络设置</strong>：比如通过<code>sysctl</code>命令调整TCP&#x2F;IP栈的行为，例如改变IP转发、TCP窗口缩放等参数。</li><li><strong>管理VPN和其他隧道接口</strong>：设置和配置VPN连接或其他类型的网络隧道，如IPsec、OpenVPN或WireGuard等，这些操作需要访问网络配置和安全密钥。</li><li><strong>绑定到特权端口</strong>：除了启动网络服务外，直接绑定到1024以下的特权端口进行监听也需要更高的权限。</li><li><strong>配置动态主机配置协议（DHCP）</strong>：设置和管理DHCP服务器或客户端，为网络设备动态分配IP地址。</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在如今虚拟化如此普及的今天，要么，应用都在容器中被隔离，要么，大厂商的软件都是独占机器的，机器和软件都是一家的，是否真的有收紧权限的必要性，是不是从找到漏洞的角度去做到安全更 “合理”。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h3 id="最小权限原则"><a href="#最小权限原则" class="headerlink" title="最小权限原则"></a>最小权限原则</h3><ul><li><strong>安全最佳实践</strong>：即使在高度隔离的环境中，应用最小权限原则（Least Privilege Principle）仍然是安全最佳实践的核心。这个原则要求只授予完成特定任务所必需的最少权限，从而限制安全漏洞被利用的潜在影响。</li></ul><h3 id="容器与虚拟化环境的漏洞"><a href="#容器与虚拟化环境的漏洞" class="headerlink" title="容器与虚拟化环境的漏洞"></a>容器与虚拟化环境的漏洞</h3><ul><li><strong>隔离并非万无一失</strong>：虽然容器和虚拟机提供了隔离环境，但它们自身也可能包含漏洞，这些漏洞可能被利用来逃逸隔离或提升权限。例如，历史上曾经发现过多个容器逃逸漏洞。</li></ul><h3 id="内部威胁与配置错误"><a href="#内部威胁与配置错误" class="headerlink" title="内部威胁与配置错误"></a>内部威胁与配置错误</h3><ul><li><strong>内部威胁</strong>：过宽的权限设置不仅增加了外部攻击者的攻击面，也增加了内部威胁的风险。一个内部人员或恶意软件可能利用不必要的高权限来进行数据泄露、破坏或其他恶意行为。</li><li><strong>配置错误</strong>：权限设置过宽还可能导致配置错误，从而无意中暴露敏感数据或系统功能。随着环境变得更加复杂，这种风险也相应增加。</li></ul><h3 id="法规和合规性要求"><a href="#法规和合规性要求" class="headerlink" title="法规和合规性要求"></a>法规和合规性要求</h3><ul><li><strong>合规性要求</strong>：许多行业和国际标准（如GDPR、HIPAA、PCI DSS）对数据保护和访问控制有严格要求。实施严格的权限控制是满足这些要求的关键组成部分。</li></ul><h3 id="安全与漏洞发现的平衡"><a href="#安全与漏洞发现的平衡" class="headerlink" title="安全与漏洞发现的平衡"></a>安全与漏洞发现的平衡</h3><ul><li><strong>漏洞发现重要，但不是唯一解决方案</strong>：虽然发现并修补安全漏洞是提高软件安全性的重要手段，但仅依赖于漏洞发现并不足以全面保障安全。权限管理是构建深度防御策略（Defense in Depth）的一个重要方面，能够在漏洞被发现并利用之前提供额外的保护层。</li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英文书籍翻译方案.md</title>
    <link href="/2024/02/27/mdstorage/resource/%E7%BF%BB%E8%AF%91%E5%B7%A5%E5%85%B7/%E8%8B%B1%E6%96%87%E4%B9%A6%E7%B1%8D%E7%BF%BB%E8%AF%91%E6%96%B9%E6%A1%88/"/>
    <url>/2024/02/27/mdstorage/resource/%E7%BF%BB%E8%AF%91%E5%B7%A5%E5%85%B7/%E8%8B%B1%E6%96%87%E4%B9%A6%E7%B1%8D%E7%BF%BB%E8%AF%91%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="沉浸式翻译"><a href="#沉浸式翻译" class="headerlink" title="沉浸式翻译"></a>沉浸式翻译</h3><p><code>https://immersivetranslate.com/docs/installation/</code></p>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>翻译工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tool</tag>
      
      <tag>book</tag>
      
      <tag>翻译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>easyconnect.md</title>
    <link href="/2024/02/21/mdstorage/resource/vpn/easyconnect/"/>
    <url>/2024/02/21/mdstorage/resource/vpn/easyconnect/</url>
    
    <content type="html"><![CDATA[<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><code>https://github.com/docker-easyconnect/docker-easyconnect</code></p>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>vpn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vpn</tag>
      
      <tag>easyconnect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flutter技巧.md</title>
    <link href="/2024/02/18/mdstorage/domain/dart/flutter%E6%8A%80%E5%B7%A7/"/>
    <url>/2024/02/18/mdstorage/domain/dart/flutter%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="组件封装"><a href="#组件封装" class="headerlink" title="组件封装"></a>组件封装</h2><h3 id="封装-flutter-组件"><a href="#封装-flutter-组件" class="headerlink" title="封装 flutter 组件"></a>封装 flutter 组件</h3><h2 id="当出现两个-变量-同时决定页面展示时，使用同一个函数封装"><a href="#当出现两个-变量-同时决定页面展示时，使用同一个函数封装" class="headerlink" title="当出现两个 变量 同时决定页面展示时，使用同一个函数封装"></a>当出现两个 变量 同时决定页面展示时，使用同一个函数封装</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> taskLs = [fakeTask, fakeSonTask, fakeSonSonTask, fakeSonTask2, fakeTask2];<br>TaskManifest? selectedManifest;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskManager</span> <span class="hljs-title">with</span> <span class="hljs-title">ChangeNotifier</span> </span>&#123;<br>  <span class="hljs-built_in">List</span>&lt;Task&gt; getTaskLs() &#123;<br>    <span class="hljs-keyword">return</span> taskLs;<br>  &#125;<br><br>  <span class="hljs-built_in">bool</span> createTaskOrUpdateManifest(&#123;Task? task, TaskManifest? manifest&#125;) &#123;<br>    <span class="hljs-keyword">if</span> (manifest != <span class="hljs-keyword">null</span>) &#123;<br>      selectedManifest = manifest;<br>      notifyListeners();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (task != <span class="hljs-keyword">null</span>) &#123;<br>      taskLs.add(task);<br>      notifyListeners();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;unknown&quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br><br>  <span class="hljs-built_in">List</span>&lt;Task&gt; getRootTaskLs() &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---: <span class="hljs-subst">$selectedManifest</span> <span class="hljs-subst">$&#123;selectedManifest?.name&#125;</span>&quot;</span>);<br>    <span class="hljs-keyword">var</span> ls = &lt;Task&gt;[];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> task <span class="hljs-keyword">in</span> getTaskLs()) &#123;<br>      <span class="hljs-keyword">if</span> (task.manifestId == selectedManifest?.id) &#123;<br>        <span class="hljs-keyword">if</span> (task.isRoot == <span class="hljs-keyword">true</span>) &#123;<br>          ls.add(task);<br>        &#125;<br>      &#125;<br>    &#125;<br>    getTaskLs().forEach((element) &#123;<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;el: <span class="hljs-subst">$element</span>&quot;</span>);&#125;<br>    );<br>    <span class="hljs-keyword">return</span> ls;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="cast"><a href="#cast" class="headerlink" title="cast"></a>cast</h3><p>在Dart中，<code>cast</code>函数是一个非常有用的工具，它允许你将一个集合的元素类型转换为另一个类型。这在处理<code>dynamic</code>类型或不同类型之间的转换时尤其有用，但需要谨慎使用以避免运行时错误。下面是使用<code>cast</code>函数的一些最佳实践：</p><h4 id="1-明确知道元素类型时使用"><a href="#1-明确知道元素类型时使用" class="headerlink" title="1. 明确知道元素类型时使用"></a>1. 明确知道元素类型时使用</h4><p>只有当你确定集合中的所有元素都可以安全地被转换为目标类型时，才使用<code>cast</code>。这通常适用于你从动态类型（如从数据库、外部数据源或第三方库中获取的数据）转换到具体类型时。</p><h4 id="2-避免不必要的类型转换"><a href="#2-避免不必要的类型转换" class="headerlink" title="2. 避免不必要的类型转换"></a>2. 避免不必要的类型转换</h4><p>如果你能通过设计来确保数据的类型安全，那么尽量避免使用<code>cast</code>。比如，使用泛型集合来存储和传递具体类型的数据，这样可以让Dart的静态类型检查帮助你捕获类型错误。</p><h4 id="3-处理cast可能失败的情况"><a href="#3-处理cast可能失败的情况" class="headerlink" title="3. 处理cast可能失败的情况"></a>3. 处理<code>cast</code>可能失败的情况</h4><p>使用<code>cast</code>时，如果集合中有任何元素不能被转换为目标类型，都会抛出运行时异常。因此，使用<code>cast</code>时应该尽量确保转换的安全性，或者使用try-catch结构来处理可能的异常。</p><h4 id="4-优先使用类型安全的替代方案"><a href="#4-优先使用类型安全的替代方案" class="headerlink" title="4. 优先使用类型安全的替代方案"></a>4. 优先使用类型安全的替代方案</h4><p>在某些情况下，你可以通过映射（<code>.map()</code>）集合并手动转换每个元素来避免使用<code>cast</code>。这样做的好处是可以在转换每个元素时提供一个回退方案，比如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> list = &lt;<span class="hljs-built_in">dynamic</span>&gt;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> intList = list.map((e) =&gt; e <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span>).toList();<br></code></pre></td></tr></table></figure><p>这种方法比<code>cast</code>更加类型安全，因为你可以控制转换的过程，并且在转换失败时捕获异常。</p><h4 id="5-谨慎使用cast改变集合的可变性"><a href="#5-谨慎使用cast改变集合的可变性" class="headerlink" title="5. 谨慎使用cast改变集合的可变性"></a>5. 谨慎使用<code>cast</code>改变集合的可变性</h4><p>当你对集合使用<code>cast</code>时，返回的是原始集合的一个视图，这意味着原始集合和转换后的集合在底层是相同的数据。对任一集合的修改都会影响另一个，但如果集合的类型不兼容，这种修改可能会引起问题。</p><h4 id="6-在混合类型数据流中使用"><a href="#6-在混合类型数据流中使用" class="headerlink" title="6. 在混合类型数据流中使用"></a>6. 在混合类型数据流中使用</h4><p>在处理混合类型的数据流时（比如一个列表包含了不同类型的对象），<code>cast</code>可以用来过滤出特定类型的对象集合，以便进行进一步处理。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">List&lt;<span class="hljs-keyword">Task</span>&gt; getTaskLs() &#123;<br>  <span class="hljs-comment">// 直接返回Hive box中所有的Task对象</span><br>  <span class="hljs-keyword">if</span> (taskBox != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> taskBox!.values.cast&lt;<span class="hljs-keyword">Task</span>&gt;().<span class="hljs-keyword">toList</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> [];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="as-类型转换"><a href="#as-类型转换" class="headerlink" title="as 类型转换"></a>as 类型转换</h2><p>在Dart语言中，<code>as</code>关键字用于类型转换，将一个对象显式地转换为另一个类型。尽管这是一个强大的功能，但如果不当使用，可能会导致运行时错误。以下是使用<code>as</code>进行类型转换的一些最佳实践：</p><h3 id="1-当你确定转换是安全的时使用"><a href="#1-当你确定转换是安全的时使用" class="headerlink" title="1. 当你确定转换是安全的时使用"></a>1. 当你确定转换是安全的时使用</h3><p>只在你确信对象可以被安全地转换为目标类型时使用<code>as</code>。这通常是在你通过某些方式（例如通过类型检查）已经验证了对象的类型后。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">if</span> (object <span class="hljs-keyword">is</span> TargetType) &#123;<br>  <span class="hljs-keyword">final</span> targetTypeObject = object <span class="hljs-keyword">as</span> TargetType;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-优先使用类型测试运算符is"><a href="#2-优先使用类型测试运算符is" class="headerlink" title="2. 优先使用类型测试运算符is"></a>2. 优先使用类型测试运算符<code>is</code></h3><p>在尝试将一个对象转换为特定类型之前，先使用<code>is</code>运算符检查对象是否为目标类型。这可以避免在转换失败时抛出异常。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">if</span> (object <span class="hljs-keyword">is</span> TargetType) &#123;<br>  <span class="hljs-comment">// 安全地使用object作为TargetType</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-避免不必要的as使用"><a href="#3-避免不必要的as使用" class="headerlink" title="3. 避免不必要的as使用"></a>3. 避免不必要的<code>as</code>使用</h3><p>如果Dart的类型推断能够正确识别对象的类型，就没有必要使用<code>as</code>进行显式转换。过度使用<code>as</code>可能会降低代码的可读性和维护性。</p><h3 id="4-在处理泛型时谨慎使用"><a href="#4-在处理泛型时谨慎使用" class="headerlink" title="4. 在处理泛型时谨慎使用"></a>4. 在处理泛型时谨慎使用</h3><p>当你与泛型类型打交道时，特别是当类型参数在运行时可能变化时，使用<code>as</code>进行类型转换需要格外小心。在这种情况下，确保转换是安全的，或者考虑使用更安全的替代方案。</p><h3 id="5-处理as转换可能失败的情况"><a href="#5-处理as转换可能失败的情况" class="headerlink" title="5. 处理as转换可能失败的情况"></a>5. 处理<code>as</code>转换可能失败的情况</h3><p>尽管通过<code>is</code>检查类型可以避免大多数问题，但在某些情况下，转换可能仍然失败。使用<code>as</code>时，考虑包含异常处理逻辑，特别是当处理外部数据或在你对数据源不完全确定时。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">final</span> targetTypeObject = object <span class="hljs-keyword">as</span> TargetType;<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-comment">// 处理转换失败的情况</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-使用类型安全的集合操作"><a href="#6-使用类型安全的集合操作" class="headerlink" title="6. 使用类型安全的集合操作"></a>6. 使用类型安全的集合操作</h3><p>当从集合中获取元素时，如果你确信集合中的所有元素都属于一个特定类型，使用<code>as</code>进行转换可以使代码更简洁。但是，仍然推荐使用<code>is</code>进行检查，或者使用泛型来保证类型安全。</p><h3 id="7-避免将as用作隐藏逻辑错误的手段"><a href="#7-避免将as用作隐藏逻辑错误的手段" class="headerlink" title="7. 避免将as用作隐藏逻辑错误的手段"></a>7. 避免将<code>as</code>用作隐藏逻辑错误的手段</h3><p>错误地使用<code>as</code>可能会隐藏潜在的逻辑错误，导致难以调试的运行时异常。在使用<code>as</code>之前，仔细考虑是否有其他方式（如改进程序逻辑或使用更合适的类型）来解决问题。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><code>as</code>关键字是Dart中强大的类型转换工具，但应谨慎使用。始终确保转换的安全性，优先使用类型检查运算符<code>is</code>，并在适当的地方处理可能的异常，以编写更安全、更健壯的Dart代码。</p><h2 id="TaskContainerState-状态延迟刷新问题"><a href="#TaskContainerState-状态延迟刷新问题" class="headerlink" title="_TaskContainerState 状态延迟刷新问题"></a>_TaskContainerState 状态延迟刷新问题</h2><h3 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h3><p><code>TaskContainer</code> 组件下的  <code>_TaskContainerState build</code> 定义为</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs dart">Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">// 初始状态 只有一个 SingleTaskP</span><br>    <span class="hljs-comment">// 展开状态 有多个 SingleTaskP</span><br>    <span class="hljs-built_in">List</span>&lt;Widget&gt; loadSonTaskContainerLs(<span class="hljs-built_in">Set</span> <span class="hljs-keyword">set</span>) &#123;<br>        <span class="hljs-keyword">if</span> (_isFolded || !_haveSon) &#123;<br>            <span class="hljs-keyword">return</span> [<span class="hljs-keyword">const</span> SizedBox()];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 获取所有下一层级的 task</span><br>            <span class="hljs-built_in">List</span>&lt;TaskContainer&gt; ls = &lt;TaskContainer&gt;[];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> id <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>) &#123;<br>                ls.add(TaskContainer(indentTime: increaseIndentTime(widget.indentTime), task: taskDBRead.getTaskById(id)));<br>            &#125;<br>            <span class="hljs-keyword">return</span> ls;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> Consumer&lt;TaskUpdateModel&gt;(<br>        builder: (context, taskUpdateModel, child) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">set</span> = taskUpdateModel.getSonTaskIdLsFromParentId(widget.task!.id);<br><br>            _haveSon = <span class="hljs-keyword">set</span>.isEmpty ? <span class="hljs-keyword">false</span> : <span class="hljs-keyword">true</span>;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;set: <span class="hljs-subst">$&#123;set.length&#125;</span> , haveson: <span class="hljs-subst">$_haveSon</span>, isFold: <span class="hljs-subst">$_isFolded</span>&quot;</span>);<br>            <span class="hljs-comment">//print(&quot;foldIconButton : $foldIconButton&quot;);</span><br>            <span class="hljs-keyword">return</span> Row(<br>                crossAxisAlignment: CrossAxisAlignment.start, <span class="hljs-comment">// 确保Row的子项从顶部开始对齐</span><br>                children: [<br>                    Container(<br>                        width: <span class="hljs-number">48</span>, <span class="hljs-comment">// 或其他适当的值，确保足够容纳IconButton</span><br>                        child: _haveSon ? Container(<br>                            margin: <span class="hljs-keyword">const</span> EdgeInsets.all(<span class="hljs-number">12</span>),<br>                            child: IconButton(   <span class="hljs-comment">// 这里之前写在 return 之前</span><br>                                onPressed: () &#123;<br>                                    setState(() &#123;<br>                                        _isFolded = !_isFolded;<br>                                    &#125;);<br>                                &#125;,<br>                                icon: Icon(<br>                                    _isFolded<br>                                    ? Icons.arrow_drop_down_rounded<br>                                    : Icons.arrow_right_rounded,<br>                                    size: <span class="hljs-number">24</span>,<br>                                ),<br>                            ))<br>                        : Container(),<br>                    ),<br>                    Expanded( <span class="hljs-comment">// 使用Expanded来填充剩余空间</span><br>                        child: Column(<br>                            children: [<br>                                SingleTaskP(widget.indentTime, widget.task),<br>                                <span class="hljs-keyword">if</span> (!_isFolded &amp;&amp; _haveSon) ...loadSonTaskContainerLs(<span class="hljs-keyword">set</span>),<br>                            ],<br>                        ),<br>                    ),<br>                ],<br>            );<br>        &#125;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>dart</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dart</tag>
      
      <tag>flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flutter环境搭建.md</title>
    <link href="/2024/02/04/mdstorage/domain/dart/flutter%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2024/02/04/mdstorage/domain/dart/flutter%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="flutter-web"><a href="#flutter-web" class="headerlink" title="flutter web"></a>flutter web</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">flutter create --platforms web .<br># edge 代替 chrome 作为 web 默认浏览器<br><span class="hljs-keyword">export</span> CHROME_EXECUTABLE=<span class="hljs-string">&quot;/usr/bin/microsoft-edge&quot;</span><br>flutter run -d Chrome<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>dart</category>
      
    </categories>
    
    
    <tags>
      
      <tag>flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>etcd集群扩展</title>
    <link href="/2024/02/04/mdstorage/domain/k8s/etcd%E9%9B%86%E7%BE%A4%E6%89%A9%E5%B1%95/"/>
    <url>/2024/02/04/mdstorage/domain/k8s/etcd%E9%9B%86%E7%BE%A4%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h2 id="单节点扩展为-3-节点"><a href="#单节点扩展为-3-节点" class="headerlink" title="单节点扩展为 3 节点"></a>单节点扩展为 3 节点</h2><h3 id="1-安装单节点-etcd"><a href="#1-安装单节点-etcd" class="headerlink" title="1. 安装单节点 etcd"></a>1. 安装单节点 etcd</h3><p>假设你的单节点 etcd 将安装在 <code>192.168.122.124</code> 上，节点名称为 <code>a8260edb-651e-49b5-a4e5-5145bb99edd3</code>。</p><h4 id="在-192-168-122-124-上安装并启动-etcd"><a href="#在-192-168-122-124-上安装并启动-etcd" class="headerlink" title="在 192.168.122.124 上安装并启动 etcd"></a>在 <code>192.168.122.124</code> 上安装并启动 etcd</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh">ETCD_OPTS=<span class="hljs-string">&quot;--name a8260edb-651e-49b5-a4e5-5145bb99edd3 \</span><br><span class="hljs-string">           --max-request-bytes 10485760 \</span><br><span class="hljs-string">           --data-dir /opt/etcd/data/data \</span><br><span class="hljs-string">           --wal-dir /opt/etcd/data/wal \</span><br><span class="hljs-string">           --advertise-client-urls http://192.168.122.124:2379,http://127.0.0.1:2379 \</span><br><span class="hljs-string">           --listen-client-urls http://192.168.122.124:2379,http://127.0.0.1:2379 \</span><br><span class="hljs-string">           --listen-peer-urls http://192.168.122.124:2380 \</span><br><span class="hljs-string">           --initial-advertise-peer-urls http://192.168.122.124:2380 \</span><br><span class="hljs-string">           --initial-cluster-token cluster_token1 \</span><br><span class="hljs-string">           --initial-cluster a8260edb-651e-49b5-a4e5-5145bb99edd3=http://192.168.122.124:2380 \</span><br><span class="hljs-string">           --initial-cluster-state new&quot;</span><br><br>etcd <span class="hljs-variable">$ETCD_OPTS</span><br></code></pre></td></tr></table></figure><h3 id="2-将-etcd-conf-写入到第二台节点-192-168-122-23-，并启动-etcd"><a href="#2-将-etcd-conf-写入到第二台节点-192-168-122-23-，并启动-etcd" class="headerlink" title="2. 将 etcd.conf 写入到第二台节点 (192.168.122.23)，并启动 etcd"></a>2. 将 etcd.conf 写入到第二台节点 (192.168.122.23)，并启动 etcd</h3><h4 id="在-192-168-122-23-上创建-etcd-配置并启动"><a href="#在-192-168-122-23-上创建-etcd-配置并启动" class="headerlink" title="在 192.168.122.23 上创建 etcd 配置并启动"></a>在 <code>192.168.122.23</code> 上创建 etcd 配置并启动</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">ETCD_OPTS=<span class="hljs-string">&quot;--name node2 \</span><br><span class="hljs-string">           --max-request-bytes 10485760 \</span><br><span class="hljs-string">           --data-dir /opt/etcd/data/data \</span><br><span class="hljs-string">           --wal-dir /opt/etcd/data/wal \</span><br><span class="hljs-string">           --advertise-client-urls http://192.168.122.23:2379,http://127.0.0.1:2379 \</span><br><span class="hljs-string">           --listen-client-urls http://192.168.122.23:2379,http://127.0.0.1:2379 \</span><br><span class="hljs-string">           --listen-peer-urls http://192.168.122.23:2380 \</span><br><span class="hljs-string">           --initial-advertise-peer-urls http://192.168.122.23:2380 \</span><br><span class="hljs-string">           --initial-cluster a8260edb-651e-49b5-a4e5-5145bb99edd3=http://192.168.122.124:2380,node2=http://192.168.122.23:2380 \</span><br><span class="hljs-string">           --initial-cluster-state existing&quot;</span><br><br>etcd <span class="hljs-variable">$ETCD_OPTS</span><br></code></pre></td></tr></table></figure><h3 id="3-在-node2-中使用-etcdctl-命令，将-node2-添加到集群"><a href="#3-在-node2-中使用-etcdctl-命令，将-node2-添加到集群" class="headerlink" title="3. 在 node2 中使用 etcdctl 命令，将 node2 添加到集群"></a>3. 在 <code>node2</code> 中使用 <code>etcdctl</code> 命令，将 <code>node2</code> 添加到集群</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ETCDCTL_API=3 etcdctl --endpoints=http://192.168.122.124:2379 member add node2 --peer-urls=http://192.168.122.23:2380<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><br>/opt/etcd/bin/etcdctl --endpoints=http://172.17.0.100:2379 member add test-uid-1 --peer-urls=http://172.17.0.101:2380<br>/opt/etcd/bin/etcdctl --write-out=table --endpoints=http://172.17.0.100:2379 member list<br><br><br><span class="hljs-comment"># remove</span><br>/opt/etcd/bin/etcdctl --endpoints=http://172.17.0.100:2379 member remove $(/opt/etcd/bin/etcdctl --endpoints=http://172.17.0.100:2379 member list | grep http://172.17.0.101:2380 | <span class="hljs-built_in">cut</span> -d<span class="hljs-string">&#x27;,&#x27;</span> -f1)<br><br><br></code></pre></td></tr></table></figure><h3 id="4-将-etcd-conf-写入到第三台节点-192-168-122-95-，并启动-etcd"><a href="#4-将-etcd-conf-写入到第三台节点-192-168-122-95-，并启动-etcd" class="headerlink" title="4. 将 etcd.conf 写入到第三台节点 (192.168.122.95)，并启动 etcd"></a>4. 将 etcd.conf 写入到第三台节点 (192.168.122.95)，并启动 etcd</h3><h4 id="在-192-168-122-95-上创建-etcd-配置并启动"><a href="#在-192-168-122-95-上创建-etcd-配置并启动" class="headerlink" title="在 192.168.122.95 上创建 etcd 配置并启动"></a>在 <code>192.168.122.95</code> 上创建 etcd 配置并启动</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">ETCD_OPTS=<span class="hljs-string">&quot;--name node3 \</span><br><span class="hljs-string">           --max-request-bytes 10485760 \</span><br><span class="hljs-string">           --data-dir /opt/etcd/data/data \</span><br><span class="hljs-string">           --wal-dir /opt/etcd/data/wal \</span><br><span class="hljs-string">           --advertise-client-urls http://192.168.122.95:2379,http://127.0.0.1:2379 \</span><br><span class="hljs-string">           --listen-client-urls http://192.168.122.95:2379,http://127.0.0.1:2379 \</span><br><span class="hljs-string">           --listen-peer-urls http://192.168.122.95:2380 \</span><br><span class="hljs-string">           --initial-advertise-peer-urls http://192.168.122.95:2380 \</span><br><span class="hljs-string">           --initial-cluster a8260edb-651e-49b5-a4e5-5145bb99edd3=http://192.168.122.124:2380,node2=http://192.168.122.23:2380,node3=http://192.168.122.95:2380 \</span><br><span class="hljs-string">           --initial-cluster-state existing&quot;</span><br><br>etcd <span class="hljs-variable">$ETCD_OPTS</span><br></code></pre></td></tr></table></figure><h3 id="5-在-node3-中使用-etcdctl-命令，将-node3-添加到集群"><a href="#5-在-node3-中使用-etcdctl-命令，将-node3-添加到集群" class="headerlink" title="5. 在 node3 中使用 etcdctl 命令，将 node3 添加到集群"></a>5. 在 <code>node3</code> 中使用 <code>etcdctl</code> 命令，将 <code>node3</code> 添加到集群</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ETCDCTL_API=3 etcdctl --endpoints=http://192.168.122.124:2379 member add node3 --peer-urls=http://192.168.122.95:2380<br></code></pre></td></tr></table></figure><h3 id="验证集群状态"><a href="#验证集群状态" class="headerlink" title="验证集群状态"></a>验证集群状态</h3><p>在任意一个节点上使用 <code>etcdctl</code> 命令验证集群状态，确保所有节点都已成功加入集群：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">ETCDCTL_API=3 etcdctl --endpoints=http://192.168.122.124:2379 member list<br>ETCDCTL_API=3 etcdctl --endpoints=http://192.168.122.23:2379 member list<br>ETCDCTL_API=3 etcdctl --endpoints=http://192.168.122.95:2379 member list<br></code></pre></td></tr></table></figure><h3 id="验证数据一致性"><a href="#验证数据一致性" class="headerlink" title="验证数据一致性"></a>验证数据一致性</h3><p>在所有节点上验证存入的键值对：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">ETCDCTL_API=3 etcdctl --endpoints=http://192.168.122.124:2379 get foo<br>ETCDCTL_API=3 etcdctl --endpoints=http://192.168.122.23:2379 get foo<br>ETCDCTL_API=3 etcdctl --endpoints=http://192.168.122.95:2379 get foo<br></code></pre></td></tr></table></figure><h2 id="三节点到单节点"><a href="#三节点到单节点" class="headerlink" title="三节点到单节点"></a>三节点到单节点</h2><h3 id="1-从-node3-开始移除"><a href="#1-从-node3-开始移除" class="headerlink" title="1. 从 node3 开始移除"></a>1. 从 <code>node3</code> 开始移除</h3><h4 id="在-node1-192-168-122-124-上使用-etcdctl-命令移除-node3"><a href="#在-node1-192-168-122-124-上使用-etcdctl-命令移除-node3" class="headerlink" title="在 node1 (192.168.122.124) 上使用 etcdctl 命令移除 node3"></a>在 <code>node1</code> (192.168.122.124) 上使用 <code>etcdctl</code> 命令移除 <code>node3</code></h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ETCDCTL_API=3 etcdctl --endpoints=http://192.168.122.124:2379 member remove $(ETCDCTL_API=3 etcdctl --endpoints=http://192.168.122.124:2379 member list | grep http://192.168.122.95:2380 | <span class="hljs-built_in">cut</span> -d<span class="hljs-string">&#x27;,&#x27;</span> -f1)<br></code></pre></td></tr></table></figure><p>验证 <code>node3</code> 是否已移除：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ETCDCTL_API=3 etcdctl --endpoints=http://192.168.122.124:2379 member list<br></code></pre></td></tr></table></figure><p>确认 <code>node3</code> 不在成员列表中。</p><h3 id="2-移除-node2"><a href="#2-移除-node2" class="headerlink" title="2. 移除 node2"></a>2. 移除 <code>node2</code></h3><h4 id="在-node1-192-168-122-124-上使用-etcdctl-命令移除-node2"><a href="#在-node1-192-168-122-124-上使用-etcdctl-命令移除-node2" class="headerlink" title="在 node1 (192.168.122.124) 上使用 etcdctl 命令移除 node2"></a>在 <code>node1</code> (192.168.122.124) 上使用 <code>etcdctl</code> 命令移除 <code>node2</code></h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ETCDCTL_API=3 etcdctl --endpoints=http://192.168.122.124:2379 member remove $(ETCDCTL_API=3 etcdctl --endpoints=http://192.168.122.124:2379 member list | grep http://192.168.122.23:2380 | <span class="hljs-built_in">cut</span> -d<span class="hljs-string">&#x27;,&#x27;</span> -f1)<br></code></pre></td></tr></table></figure><p>验证 <code>node2</code> 是否已移除：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ETCDCTL_API=3 etcdctl --endpoints=http://192.168.122.124:2379 member list<br></code></pre></td></tr></table></figure><p>确认 <code>node2</code> 不在成员列表中。</p><h3 id="3-更新-node1-配置"><a href="#3-更新-node1-配置" class="headerlink" title="3. 更新 node1 配置"></a>3. 更新 <code>node1</code> 配置</h3><p>在 <code>node1</code> 上更新 etcd 配置，移除 <code>node2</code> 和 <code>node3</code> 的信息：</p><h4 id="在-192-168-122-124-上更新-etcd-配置并重启-etcd"><a href="#在-192-168-122-124-上更新-etcd-配置并重启-etcd" class="headerlink" title="在 192.168.122.124 上更新 etcd 配置并重启 etcd"></a>在 <code>192.168.122.124</code> 上更新 etcd 配置并重启 etcd</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh">ETCD_OPTS=<span class="hljs-string">&quot;--name a8260edb-651e-49b5-a4e5-5145bb99edd3 \</span><br><span class="hljs-string">           --max-request-bytes 10485760 \</span><br><span class="hljs-string">           --data-dir /opt/etcd/data/data \</span><br><span class="hljs-string">           --wal-dir /opt/etcd/data/wal \</span><br><span class="hljs-string">           --advertise-client-urls http://192.168.122.124:2379,http://127.0.0.1:2379 \</span><br><span class="hljs-string">           --listen-client-urls http://192.168.122.124:2379,http://127.0.0.1:2379 \</span><br><span class="hljs-string">           --listen-peer-urls http://192.168.122.124:2380 \</span><br><span class="hljs-string">           --initial-advertise-peer-urls http://192.168.122.124:2380 \</span><br><span class="hljs-string">           --initial-cluster-token cluster_token1 \</span><br><span class="hljs-string">           --initial-cluster a8260edb-651e-49b5-a4e5-5145bb99edd3=http://192.168.122.124:2380 \</span><br><span class="hljs-string">           --initial-cluster-state new&quot;</span><br><br>etcd <span class="hljs-variable">$ETCD_OPTS</span><br></code></pre></td></tr></table></figure><h3 id="验证最终的单节点状态"><a href="#验证最终的单节点状态" class="headerlink" title="验证最终的单节点状态"></a>验证最终的单节点状态</h3><h4 id="使用-etcdctl-验证集群状态"><a href="#使用-etcdctl-验证集群状态" class="headerlink" title="使用 etcdctl 验证集群状态"></a>使用 <code>etcdctl</code> 验证集群状态</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ETCDCTL_API=3 etcdctl --endpoints=http://192.168.122.124:2379 member list<br></code></pre></td></tr></table></figure><p>确认只有 <code>node1</code> (a8260edb-651e-49b5-a4e5-5145bb99edd3) 在成员列表中。</p><h3 id="验证数据一致性-1"><a href="#验证数据一致性-1" class="headerlink" title="验证数据一致性"></a>验证数据一致性</h3><h4 id="验证-foo-数据是否存在"><a href="#验证-foo-数据是否存在" class="headerlink" title="验证 foo 数据是否存在"></a>验证 <code>foo</code> 数据是否存在</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ETCDCTL_API=3 etcdctl --endpoints=http://192.168.122.124:2379 get foo<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>k8s</category>
      
    </categories>
    
    
    <tags>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flutter常用组件.md</title>
    <link href="/2024/01/31/mdstorage/domain/dart/flutter%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6/"/>
    <url>/2024/01/31/mdstorage/domain/dart/flutter%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="RepaintBoundary"><a href="#RepaintBoundary" class="headerlink" title="RepaintBoundary"></a>RepaintBoundary</h2><p><code>RepaintBoundary</code> 是一个 Flutter widget，它的主要作用是创建一个新的绘制层，这有助于优化渲染性能。使用 <code>RepaintBoundary</code> 可以减少不必要的绘制操作，特别是在复杂的 UI 布局中。以下是关于 <code>RepaintBoundary</code> 的最佳实践：</p><h3 id="1-理解什么时候使用"><a href="#1-理解什么时候使用" class="headerlink" title="1. 理解什么时候使用"></a>1. <strong>理解什么时候使用</strong></h3><ul><li>当你有一个复杂的 widget 树，并且其中一部分经常重绘时（例如动画、滚动等），但其他部分保持静态。</li><li>在滚动列表中，特别是当列表项有复杂的绘制操作时，使用 <code>RepaintBoundary</code> 可以避免整个列表在滚动时重新绘制。</li><li>当有一个小部分 widget 频繁重绘，而你不希望这影响到整个应用的性能时。</li></ul><h3 id="2-如何使用"><a href="#2-如何使用" class="headerlink" title="2. 如何使用"></a>2. <strong>如何使用</strong></h3><p>将 <code>RepaintBoundary</code> 作为需要隔离重绘的部分的父 widget：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">RepaintBoundary(<br>  child: MyFrequentlyRedrawnWidget(),<br>)<br></code></pre></td></tr></table></figure><h3 id="3-在列表中使用"><a href="#3-在列表中使用" class="headerlink" title="3. 在列表中使用"></a>3. <strong>在列表中使用</strong></h3><p>在 <code>ListView</code> 或 <code>GridView</code> 中的每个项前使用 <code>RepaintBoundary</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">ListView.builder(<br>  itemBuilder: (context, index) &#123;<br>    <span class="hljs-keyword">return</span> RepaintBoundary(<br>      child: MyListItemWidget(index),<br>    );<br>  &#125;,<br>)<br></code></pre></td></tr></table></figure><h3 id="4-避免过度使用"><a href="#4-避免过度使用" class="headerlink" title="4. 避免过度使用"></a>4. <strong>避免过度使用</strong></h3><ul><li>不要在每个 widget 前都添加 <code>RepaintBoundary</code>，因为过度使用会增加内存占用和应用的启动时间。</li><li>只在那些真正能从中受益的地方使用它，比如独立的、重绘频繁的 UI 组件。</li></ul><h3 id="5-分析和测试"><a href="#5-分析和测试" class="headerlink" title="5. 分析和测试"></a>5. <strong>分析和测试</strong></h3><ul><li>使用 Flutter 的性能分析工具，如 DevTools，来观察你的应用的绘制行为，特别是在考虑添加 <code>RepaintBoundary</code> 的地方。</li><li>在添加 <code>RepaintBoundary</code> 后，观察性能指标，确保它带来了正面的影响。</li></ul><h3 id="6-理解工作原理"><a href="#6-理解工作原理" class="headerlink" title="6. 理解工作原理"></a>6. <strong>理解工作原理</strong></h3><ul><li><code>RepaintBoundary</code> 实际上将其子树的绘制操作缓存在了独立的绘制层中。当子树内的 widget 需要重绘时，它不会影响到其他绘制层。</li><li>这意味着即使子树内部有变化，也不会影响到 <code>RepaintBoundary</code> 之外的部分。</li></ul><p>通过遵循这些最佳实践，你可以有效地使用 <code>RepaintBoundary</code> 来优化你的 Flutter 应用的渲染性能，尤其是在面对复杂 UI 和高频重绘的场景时。</p><h2 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h2><p><code>Padding</code> widget 在 Flutter 中用于创建围绕子 widget 的空间，这是一种常见的布局实践。合理地使用 <code>Padding</code> 可以改善应用的视觉效果和用户体验。以下是使用 <code>Padding</code> 的一些最佳实践：</p><h3 id="1-了解何时使用-Padding"><a href="#1-了解何时使用-Padding" class="headerlink" title="1. 了解何时使用 Padding"></a>1. <strong>了解何时使用 Padding</strong></h3><ul><li>当您需要在 widget 的周围增加一些空间时使用 <code>Padding</code>，例如为了增加可点击区域或改善布局的视觉感。</li><li>在布局中适当地使用空白可以使界面看起来更加清晰、有序。</li></ul><h3 id="2-避免不必要的嵌套"><a href="#2-避免不必要的嵌套" class="headerlink" title="2. 避免不必要的嵌套"></a>2. <strong>避免不必要的嵌套</strong></h3><ul><li>只在必要时添加 <code>Padding</code>。避免无意义的嵌套，因为这会增加布局树的复杂性和性能开销。</li><li>如果可能，尝试使用父 widget 的 padding 属性（如 <code>Container</code> 的 <code>padding</code>），而不是添加一个单独的 <code>Padding</code> widget。</li></ul><h3 id="3-与其他布局-widget-结合使用"><a href="#3-与其他布局-widget-结合使用" class="headerlink" title="3. 与其他布局 widget 结合使用"></a>3. <strong>与其他布局 widget 结合使用</strong></h3><ul><li><code>Padding</code> 经常与其他布局 widget 结合使用，如 <code>Column</code>、<code>Row</code>、<code>ListView</code> 等。它可以用来为这些布局元素中的子 widget 提供必要的空间。</li><li>在列表项中使用 <code>Padding</code> 以创建更舒适的观感和更好的触摸目标。</li></ul><h3 id="4-使用-EdgeInsets"><a href="#4-使用-EdgeInsets" class="headerlink" title="4. 使用 EdgeInsets"></a>4. <strong>使用 EdgeInsets</strong></h3><ul><li><p>使用 <code>EdgeInsets</code> 类来设置 padding。<code>EdgeInsets</code> 提供了多种方便的构造函数，如 <code>EdgeInsets.all</code>、<code>EdgeInsets.symmetric</code>、<code>EdgeInsets.only</code> 等。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">Padding(<br>  padding: EdgeInsets.all(<span class="hljs-number">8.0</span>), <span class="hljs-comment">// 在所有方向上添加相同的 padding</span><br>  child: MyWidget(),<br>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="5-考虑设备的大小和方向"><a href="#5-考虑设备的大小和方向" class="headerlink" title="5. 考虑设备的大小和方向"></a>5. <strong>考虑设备的大小和方向</strong></h3><ul><li>在设置 padding 时，考虑到不同设备的屏幕大小和方向。可能需要根据设备大小或方向调整 padding 的大小。</li></ul><h3 id="6-响应式设计"><a href="#6-响应式设计" class="headerlink" title="6. 响应式设计"></a>6. <strong>响应式设计</strong></h3><ul><li>在实现响应式设计时，padding 的值可能需要根据屏幕大小的不同而调整。可以通过 MediaQuery 获取设备的尺寸，并据此调整 padding。</li></ul><h3 id="7-与主题和样式一致"><a href="#7-与主题和样式一致" class="headerlink" title="7. 与主题和样式一致"></a>7. <strong>与主题和样式一致</strong></h3><ul><li>确保应用中的 padding 与整体设计和主题保持一致。这有助于保持界面整洁和统一。</li></ul><p>通过遵循这些最佳实践，您可以有效地使用 <code>Padding</code> 来提升您的 Flutter 应用的界面质量和用户体验。</p><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><p><code>Container</code> 是 Flutter 中一个非常通用且多功能的布局 widget，它可以用于装饰、定位、调整大小等多种用途。为了最有效地使用 <code>Container</code>，以下是一些最佳实践：</p><h3 id="1-明确使用目的"><a href="#1-明确使用目的" class="headerlink" title="1. 明确使用目的"></a>1. <strong>明确使用目的</strong></h3><ul><li>在使用 <code>Container</code> 之前，明确您的使用目的。<code>Container</code> 可以用于设置大小、边距、内边距、装饰（如颜色、边框、阴影）、变换（如旋转）等。</li><li>如果只需要边距或内边距，可以使用 <code>Padding</code> 或 <code>Margin</code>。如果只需要装饰，<code>DecoratedBox</code> 或其他专用 widget 可能更适合。</li></ul><h3 id="2-避免过度使用"><a href="#2-避免过度使用" class="headerlink" title="2. 避免过度使用"></a>2. <strong>避免过度使用</strong></h3><ul><li>避免在不必要的情况下使用 <code>Container</code>。例如，如果您只需要排列子元素，使用 <code>Column</code> 或 <code>Row</code> 更合适。</li><li>过度使用 <code>Container</code> 可能会导致布局树变得更复杂，影响性能。</li></ul><h3 id="3-使用装饰属性"><a href="#3-使用装饰属性" class="headerlink" title="3. 使用装饰属性"></a>3. <strong>使用装饰属性</strong></h3><ul><li>使用 <code>Container</code> 的 <code>decoration</code> 属性来添加边框、圆角、阴影、渐变等效果。这是通过 <code>BoxDecoration</code> 实现的。</li><li>如果同时设置了 <code>Container</code> 的 <code>color</code> 和 <code>decoration</code> 属性，可能会引发冲突。将背景色包含在 <code>BoxDecoration</code> 中。</li></ul><h3 id="4-调整大小"><a href="#4-调整大小" class="headerlink" title="4. 调整大小"></a>4. <strong>调整大小</strong></h3><ul><li><code>Container</code> 可以通过设置 <code>width</code> 和 <code>height</code> 属性来调整大小。</li><li>如果没有设置大小，<code>Container</code> 会根据其父级和子级自动调整大小。</li></ul><h3 id="5-利用边距和内边距"><a href="#5-利用边距和内边距" class="headerlink" title="5. 利用边距和内边距"></a>5. <strong>利用边距和内边距</strong></h3><ul><li>使用 <code>margin</code> 和 <code>padding</code> 属性来创建所需的空间效果。<code>margin</code> 用于创建与外部元素的空间，<code>padding</code> 用于在 <code>Container</code> 内部和子元素之间创建空间。</li></ul><h3 id="6-结合使用布局构建"><a href="#6-结合使用布局构建" class="headerlink" title="6. 结合使用布局构建"></a>6. <strong>结合使用布局构建</strong></h3><ul><li><code>Container</code> 可以与 <code>Column</code>、<code>Row</code>、<code>Flex</code> 等布局 widget 结合使用，以实现复杂的布局需求。</li></ul><h3 id="7-响应式设计"><a href="#7-响应式设计" class="headerlink" title="7. 响应式设计"></a>7. <strong>响应式设计</strong></h3><ul><li>考虑在不同屏幕尺寸和方向下 <code>Container</code> 的表现。可能需要使用 <code>MediaQuery</code> 或其他响应式设计技术来调整 <code>Container</code> 的尺寸和布局。</li></ul><h3 id="8-不要用作无内容的占位符"><a href="#8-不要用作无内容的占位符" class="headerlink" title="8. 不要用作无内容的占位符"></a>8. <strong>不要用作无内容的占位符</strong></h3><ul><li>如果您需要一个占位符或分隔符，使用 <code>SizedBox</code> 可能更合适，尤其是在没有子元素、装饰或内外边距的情况下。</li></ul><p>通过遵循这些最佳实践，您可以更有效地使用 <code>Container</code> 来创建优雅且性能良好的 Flutter 布局。</p><h2 id="DecoratedBox"><a href="#DecoratedBox" class="headerlink" title="DecoratedBox"></a>DecoratedBox</h2><p><code>DecoratedBox</code> 是 Flutter 中一个用于装饰其子 widget 的 widget。它通常用于添加背景、边框、圆角、阴影等效果。以下是使用 <code>DecoratedBox</code> 的一些最佳实践：</p><h3 id="1-明确装饰的目的"><a href="#1-明确装饰的目的" class="headerlink" title="1. 明确装饰的目的"></a>1. <strong>明确装饰的目的</strong></h3><ul><li>使用 <code>DecoratedBox</code> 时，首先明确您的装饰目的。如果您只是想添加简单的背景颜色或图片，那么使用 <code>Container</code> 可能更方便。</li><li><code>DecoratedBox</code> 主要用于更复杂的装饰，如渐变、边框、圆角等。</li></ul><h3 id="2-使用-BoxDecoration"><a href="#2-使用-BoxDecoration" class="headerlink" title="2. 使用 BoxDecoration"></a>2. <strong>使用 BoxDecoration</strong></h3><ul><li>利用 <code>BoxDecoration</code> 来定义装饰。它允许您指定多种装饰属性，如颜色、图片、边框、圆角、阴影、渐变等。</li><li>您可以在 <code>BoxDecoration</code> 中组合多种装饰效果。</li></ul><h3 id="3-考虑性能"><a href="#3-考虑性能" class="headerlink" title="3. 考虑性能"></a>3. <strong>考虑性能</strong></h3><ul><li>对于简单的装饰，考虑使用更轻量级的 widget，如 <code>Container</code>。<code>DecoratedBox</code> 更适用于需要多重装饰效果的情况。</li><li>如果有多个 widget 使用相同的装饰，考虑重用 <code>BoxDecoration</code> 实例以提高性能。</li></ul><h3 id="4-结合其他布局-widget-使用"><a href="#4-结合其他布局-widget-使用" class="headerlink" title="4. 结合其他布局 widget 使用"></a>4. <strong>结合其他布局 widget 使用</strong></h3><ul><li><code>DecoratedBox</code> 可以和 <code>Padding</code>、<code>Align</code>、<code>Center</code> 等布局 widget 结合使用来创建期望的布局和视觉效果。</li><li>通常将 <code>DecoratedBox</code> 作为子 widget 放入其他布局 widget 中。</li></ul><h3 id="5-响应式和适配性"><a href="#5-响应式和适配性" class="headerlink" title="5. 响应式和适配性"></a>5. <strong>响应式和适配性</strong></h3><ul><li>在不同屏幕尺寸和方向上测试您的装饰。确保装饰在不同设备和方向上都保持良好的视觉效果。</li></ul><h3 id="6-不要过度使用"><a href="#6-不要过度使用" class="headerlink" title="6. 不要过度使用"></a>6. <strong>不要过度使用</strong></h3><ul><li>避免在一个界面中过度使用 <code>DecoratedBox</code>，因为每个 <code>DecoratedBox</code> 都会创建一个新的绘制层，这可能会影响性能。</li><li>仅在需要特定装饰效果时使用。</li></ul><h3 id="7-适当使用渐变和阴影"><a href="#7-适当使用渐变和阴影" class="headerlink" title="7. 适当使用渐变和阴影"></a>7. <strong>适当使用渐变和阴影</strong></h3><ul><li>当使用渐变和阴影时，合理调整其属性以达到预期的视觉效果，同时考虑其对性能的影响。</li></ul><h2 id="MouseRegion"><a href="#MouseRegion" class="headerlink" title="MouseRegion"></a>MouseRegion</h2><p><code>MouseRegion</code> 是 Flutter 中用于检测和响应鼠标悬停（hover）事件的 widget。它特别适用于增强桌面和Web平台上的用户交互体验。以下是使用 <code>MouseRegion</code> 的一些最佳实践：</p><h3 id="1-明确使用目的-1"><a href="#1-明确使用目的-1" class="headerlink" title="1. 明确使用目的"></a>1. <strong>明确使用目的</strong></h3><ul><li>使用 <code>MouseRegion</code> 来检测鼠标指针进入、移动和离开一个区域的事件。</li><li>常见的用途包括改变 widget 的视觉表现（如颜色、大小、显示隐藏元素等）来提供视觉反馈，或执行特定的交互逻辑。</li></ul><h3 id="2-避免不必要的重建"><a href="#2-避免不必要的重建" class="headerlink" title="2. 避免不必要的重建"></a>2. <strong>避免不必要的重建</strong></h3><ul><li>在 <code>MouseRegion</code> 的回调函数（如 <code>onEnter</code>、<code>onExit</code>、<code>onHover</code>）中避免执行复杂的操作，因为这些回调可能会频繁触发。</li><li>使用状态管理来最小化不必要的 widget 重建。例如，使用 <code>setState</code>、<code>Provider</code>、<code>Bloc</code> 等来有效管理状态。</li></ul><h3 id="3-结合其他交互"><a href="#3-结合其他交互" class="headerlink" title="3. 结合其他交互"></a>3. <strong>结合其他交互</strong></h3><ul><li><code>MouseRegion</code> 可以与 <code>GestureDetector</code>、<code>InkWell</code> 等手势检测 widget 结合使用，为用户提供多种交互方式。</li><li>注意处理好鼠标交互和触摸交互的兼容性和一致性。</li></ul><h3 id="4-提供适当的视觉反馈"><a href="#4-提供适当的视觉反馈" class="headerlink" title="4. 提供适当的视觉反馈"></a>4. <strong>提供适当的视觉反馈</strong></h3><ul><li>根据鼠标的悬停状态改变 widget 的视觉样式，如改变颜色、显示阴影、改变字体样式等，以提供直观的反馈。</li><li>考虑使用动画和过渡效果以平滑地显示视觉变化。</li></ul><h3 id="5-优化性能"><a href="#5-优化性能" class="headerlink" title="5. 优化性能"></a>5. <strong>优化性能</strong></h3><ul><li><code>MouseRegion</code> 通常性能开销不大，但如果你有大量的 <code>MouseRegion</code> widget，或者它们包含复杂的子树，那么可能需要考虑性能优化。</li><li>在可能的情况下，尝试重用 <code>MouseRegion</code> 而不是为每个小组件都创建一个新的实例。</li></ul><h3 id="6-适当使用游标"><a href="#6-适当使用游标" class="headerlink" title="6. 适当使用游标"></a>6. <strong>适当使用游标</strong></h3><ul><li>可以通过 <code>cursor</code> 属性改变鼠标悬停时的游标样式，提供更多的上下文信息。</li></ul><h3 id="7-测试和可访问性"><a href="#7-测试和可访问性" class="headerlink" title="7. 测试和可访问性"></a>7. <strong>测试和可访问性</strong></h3><ul><li>测试鼠标交互在不同平台（尤其是桌面和Web）上的行为。</li><li>确保鼠标交互不会影响应用的可访问性。</li></ul><h2 id="IconButton"><a href="#IconButton" class="headerlink" title="IconButton"></a>IconButton</h2><p><code>IconButton</code> 是 Flutter 中的一个内置 widget，它创建一个具有图标的按钮，通常用于响应用户的点击操作。这个 widget 结合了图标显示和触摸处理功能，是实现可点击图标的一种简便方法。</p><h3 id="IconButton-的特点"><a href="#IconButton-的特点" class="headerlink" title="IconButton 的特点"></a>IconButton 的特点</h3><ol><li><strong>内置触摸反馈</strong>：<code>IconButton</code> 自动包含了触摸反馈，如 Material Design 风格的水波纹效果。</li><li><strong>图标显示</strong>：可以直接传递一个 <code>Icon</code> 给 <code>IconButton</code> 以显示图标。</li><li><strong>大小调整</strong>：允许设置图标的大小。</li><li><strong>颜色自定义</strong>：可以自定义图标和水波纹的颜色。</li><li><strong>边距和填充</strong>：具有默认的边距和填充，可以通过参数调整。</li></ol><h3 id="IconButton-的最佳实践"><a href="#IconButton-的最佳实践" class="headerlink" title="IconButton 的最佳实践"></a>IconButton 的最佳实践</h3><h4 id="1-明确使用场景"><a href="#1-明确使用场景" class="headerlink" title="1. 明确使用场景"></a>1. <strong>明确使用场景</strong></h4><p><code>IconButton</code> 适用于当您需要一个图标按钮，并且希望有标准的 Material Design 触摸反馈时。例如，用于工具栏、对话框和卡片中的操作按钮。</p><h4 id="2-适当调整大小"><a href="#2-适当调整大小" class="headerlink" title="2. 适当调整大小"></a>2. <strong>适当调整大小</strong></h4><p>考虑到触摸目标的大小，确保 <code>IconButton</code> 的大小适合用户操作。如果需要，可以调整 <code>iconSize</code> 属性以更改图标大小。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">IconButton(<br>  iconSize: <span class="hljs-number">30.0</span>,<br>  icon: Icon(Icons.add),<br>  onPressed: () &#123;<br>    <span class="hljs-comment">// 处理点击事件</span><br>  &#125;,<br>)<br></code></pre></td></tr></table></figure><h4 id="3-使用语义化图标"><a href="#3-使用语义化图标" class="headerlink" title="3. 使用语义化图标"></a>3. <strong>使用语义化图标</strong></h4><p>选择清晰、易于理解的图标，使用户能够直观地识别按钮的功能。</p><h4 id="4-处理点击事件"><a href="#4-处理点击事件" class="headerlink" title="4. 处理点击事件"></a>4. <strong>处理点击事件</strong></h4><p>为 <code>onPressed</code> 回调提供一个函数，以处理用户的点击事件。如果 <code>IconButton</code> 应该是禁用状态，将 <code>onPressed</code> 设置为 <code>null</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">IconButton(<br>  icon: Icon(Icons.add),<br>  onPressed: isActive ? () &#123;<br>    <span class="hljs-comment">// 处理点击事件</span><br>  &#125; : <span class="hljs-keyword">null</span>,<br>)<br></code></pre></td></tr></table></figure><h4 id="5-考虑可访问性"><a href="#5-考虑可访问性" class="headerlink" title="5. 考虑可访问性"></a>5. <strong>考虑可访问性</strong></h4><p>为按钮提供适当的语义标签，以提高无障碍性。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">IconButton(<br>  icon: Icon(Icons.add),<br>  onPressed: () &#123;<br>    <span class="hljs-comment">// 处理点击事件</span><br>  &#125;,<br>  tooltip: <span class="hljs-string">&#x27;Add Item&#x27;</span>, <span class="hljs-comment">// 提供工具提示</span><br>)<br></code></pre></td></tr></table></figure><h4 id="6-测试在不同平台上的表现"><a href="#6-测试在不同平台上的表现" class="headerlink" title="6. 测试在不同平台上的表现"></a>6. <strong>测试在不同平台上的表现</strong></h4><p>确保 <code>IconButton</code> 在您支持的所有平台上均有良好的表现，包括其大小、颜色和反馈效果。</p><h2 id="GestureDetector"><a href="#GestureDetector" class="headerlink" title="GestureDetector"></a>GestureDetector</h2><h2 id="GestureDetector-1"><a href="#GestureDetector-1" class="headerlink" title="GestureDetector"></a>GestureDetector</h2><p><code>GestureDetector</code> 是 Flutter 中的一个非常灵活的 widget，它用于检测和响应用户的各种手势操作，如点击、双击、长按、滑动等。这个 widget 通过包裹其他 widgets 来实现对它们的手势检测，是实现自定义手势响应的基础工具。</p><h3 id="GestureDetector-的特点"><a href="#GestureDetector-的特点" class="headerlink" title="GestureDetector 的特点"></a>GestureDetector 的特点</h3><ol><li><strong>支持多种手势</strong>：<code>GestureDetector</code> 能够监听多种类型的用户手势，并对它们做出响应。</li><li><strong>自定义手势响应</strong>：可以自定义对特定手势的响应，如在长按时显示菜单，或在滑动时切换视图。</li><li><strong>无视觉反馈</strong>：与 <code>IconButton</code> 不同，<code>GestureDetector</code> 本身不提供任何视觉反馈（如水波纹效果），但可以结合其他 widget 使用来实现视觉反馈。</li><li><strong>灵活性和兼容性</strong>：可以包裹几乎所有类型的 widget，使它们具有可交互性。</li></ol><h3 id="GestureDetector-的最佳实践"><a href="#GestureDetector-的最佳实践" class="headerlink" title="GestureDetector 的最佳实践"></a>GestureDetector 的最佳实践</h3><h4 id="1-选择正确的手势检测"><a href="#1-选择正确的手势检测" class="headerlink" title="1. 选择正确的手势检测"></a>1. <strong>选择正确的手势检测</strong></h4><p>根据你的应用场景选择合适的手势进行监听。例如，使用 <code>onTap</code> 来监听简单点击，<code>onLongPress</code> 来监听长按事件。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart">GestureDetector(<br>  onTap: () &#123;<br>    <span class="hljs-comment">// 处理点击事件</span><br>  &#125;,<br>  onLongPress: () &#123;<br>    <span class="hljs-comment">// 处理长按事件</span><br>  &#125;,<br>  child: Container(<br>    <span class="hljs-comment">// 被监听的 widget</span><br>  ),<br>)<br></code></pre></td></tr></table></figure><h4 id="2-结合视觉反馈"><a href="#2-结合视觉反馈" class="headerlink" title="2. 结合视觉反馈"></a>2. <strong>结合视觉反馈</strong></h4><p>虽然 <code>GestureDetector</code> 本身不提供视觉反馈，但你可以通过修改子 widget 的状态或结合使用 <code>InkWell</code> 来提供反馈。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">GestureDetector(<br>  onTap: () &#123;<br>    <span class="hljs-comment">// 触发状态变化或视觉反馈</span><br>  &#125;,<br>  child: Container(<br>    <span class="hljs-comment">// 被监听的 widget，根据状态变化更新其样式</span><br>  ),<br>)<br></code></pre></td></tr></table></figure><h4 id="3-利用条件和状态管理"><a href="#3-利用条件和状态管理" class="headerlink" title="3. 利用条件和状态管理"></a>3. <strong>利用条件和状态管理</strong></h4><p>在某些情况下，根据应用的状态启用或禁用特定的手势监听。例如，只有在特定模式下才允许拖动。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">GestureDetector(<br>  onPanUpdate: isDraggable ? (details) &#123;<br>    <span class="hljs-comment">// 处理拖动事件</span><br>  &#125; : <span class="hljs-keyword">null</span>,<br>  child: Container(<br>    <span class="hljs-comment">// 被监听的 widget</span><br>  ),<br>)<br></code></pre></td></tr></table></figure><h4 id="4-优化性能"><a href="#4-优化性能" class="headerlink" title="4. 优化性能"></a>4. <strong>优化性能</strong></h4><p>避免在手势回调中执行复杂的操作或长时间的同步任务，这可能会影响用户体验。对于需要更多时间处理的操作，考虑使用异步方法或将任务移至后台。</p><h4 id="5-保证可访问性"><a href="#5-保证可访问性" class="headerlink" title="5. 保证可访问性"></a>5. <strong>保证可访问性</strong></h4><p>虽然 <code>GestureDetector</code> 本身不提供语义信息，但你应确保被包裹的 widget 具有适当的语义标签，特别是当它们用于重要的交互操作时。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart">GestureDetector(<br>  onTap: () &#123;<br>    <span class="hljs-comment">// 处理点击事件</span><br>  &#125;,<br>  child: Container(<br>    <span class="hljs-comment">// 为被监听的 widget 提供适当的语义</span><br>    child: Text(<span class="hljs-string">&#x27;Clickable Text&#x27;</span>),<br>  ),<br>)<br></code></pre></td></tr></table></figure><h4 id="6-测试和验证"><a href="#6-测试和验证" class="headerlink" title="6. 测试和验证"></a>6. <strong>测试和验证</strong></h4><p>确保在不同的设备和配置上测试 <code>GestureDetector</code> 的行为，包括触摸屏和非触摸屏设备，以验证手势响应的一致性和准确性。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>dart</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dart</tag>
      
      <tag>flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Snipaste和Flameshot.md</title>
    <link href="/2024/01/31/mdstorage/resource/%E5%9B%BE%E7%89%87/Snipaste%E5%92%8CFlameshot/"/>
    <url>/2024/01/31/mdstorage/resource/%E5%9B%BE%E7%89%87/Snipaste%E5%92%8CFlameshot/</url>
    
    <content type="html"><![CDATA[<h2 id="Snipaste-windows、Linux"><a href="#Snipaste-windows、Linux" class="headerlink" title="Snipaste(windows、Linux)"></a>Snipaste(windows、Linux)</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="https://www.snipaste.com/download.html">链接</a></p>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>图片</category>
      
    </categories>
    
    
    <tags>
      
      <tag>software</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信创适配软件经验.md</title>
    <link href="/2024/01/29/mdstorage/project/sr/%E4%BF%A1%E5%88%9B%E9%80%82%E9%85%8D%E8%BD%AF%E4%BB%B6%E7%BB%8F%E9%AA%8C/"/>
    <url>/2024/01/29/mdstorage/project/sr/%E4%BF%A1%E5%88%9B%E9%80%82%E9%85%8D%E8%BD%AF%E4%BB%B6%E7%BB%8F%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="信创（麒麟）操作系统选型适配及实施经验分享"><a href="#信创（麒麟）操作系统选型适配及实施经验分享" class="headerlink" title="信创（麒麟）操作系统选型适配及实施经验分享"></a>信创（麒麟）操作系统选型适配及实施经验分享</h2><h3 id="常用软件选型适配-MySQL-MongoDB-Redis"><a href="#常用软件选型适配-MySQL-MongoDB-Redis" class="headerlink" title="常用软件选型适配(MySQL MongoDB Redis)"></a><strong>常用软件选型适配</strong>(MySQL MongoDB Redis)</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NTk0MTM1Mw==&mid=2650695048&idx=1&sn=729973e8de838591d995858168ebb6bc&chksm=befa1b0e898d9218a3052f943091b2c7e372b80e92266431136b4062e899e268e3abe503b2b6&mpshare=1&scene=1&srcid=0129gOC4javC42zN5qp2h1wI&sharer_shareinfo=077deb6c5c07b77c051261b054ff3b1b&sharer_shareinfo_first=6280d78e2feba47280cd12fad53b4051&from=industrynews&version=4.1.20.6015&platform=win#rd">链接</a></p><p><strong>概述</strong></p><ul><li>本文主要介绍了信创适配方面的经验。</li></ul><p><strong>算法原理</strong></p><ul><li>本文没有涉及算法原理。</li></ul><p><strong>详细内容</strong></p><ul><li>本文详细介绍了信创适配的五大经验要点，包括项目进度的把控、信创改造系统的选择、技术路线的选型、系统集成实施、基础资源的规划与架构以及软硬件的兼容性。</li><li>本文还提到了信创适配的实践经验，包括明确目标和战略、建立协同化组织结构、培养数字化人才以及持续创新与优化。</li></ul><p><strong>实际示例</strong></p><ul><li>本文没有提供代码示例或案例研究。</li><li>本文提到了银行业一般类业务系统“存贷款服务平台”的信创改造和适配落地实践，介绍了应用系统在信创改造和适配中的需求分析、建设方案及改造实践。</li></ul><p><strong>最佳实践和建议</strong></p><ul><li>本文提供了五大经验要点，包括项目进度的把控、信创改造系统的选择、技术路线的选型、系统集成实施、基础资源的规划与架构以及软硬件的兼容性。</li><li>本文提到了信创适配的实践经验，包括明确目标和战略、建立协同化组织结构、培养数字化人才以及持续创新与优化。</li></ul><p><strong>结论</strong></p><ul><li>本文的主要观点是信创适配需要遵循五大经验要点，包括项目进度的把控、信创改造系统的选择、技术路线的选型、系统集成实施、基础资源的规划与架构以及软硬件的兼容性。</li><li>本文建议企业在信创适配过程中，需要明确目标和战略、建立协同化组织结构、培养数字化人才以及持续创新与优化。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>信创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周会议程-1.26.md</title>
    <link href="/2024/01/26/mdstorage/project/sr/%E5%91%A8%E4%BC%9A%E8%AE%AE%E7%A8%8B-1.26/"/>
    <url>/2024/01/26/mdstorage/project/sr/%E5%91%A8%E4%BC%9A%E8%AE%AE%E7%A8%8B-1.26/</url>
    
    <content type="html"><![CDATA[<h1 id="周会议程"><a href="#周会议程" class="headerlink" title="周会议程"></a>周会议程</h1><h2 id="开场白"><a href="#开场白" class="headerlink" title="开场白"></a>开场白</h2><ul><li><strong>时间</strong>：2024&#x2F;1&#x2F;26</li><li><strong>地点</strong>：培训室</li><li><strong>参与人员</strong>：全体 Golang 组员</li><li><strong>会议主题</strong>：1.5 版本任务各组组员梳理</li><li><strong>会议时长</strong>：0.5 小时内</li></ul><h2 id="1-5-版本任务梳理"><a href="#1-5-版本任务梳理" class="headerlink" title="1.5 版本任务梳理"></a>1.5 版本任务梳理</h2><ul><li><strong>目的</strong>：对整体 Go 组组员关于 1.5 版本任务一个基础的认识</li><li><strong>内容</strong>：<ul><li>根据产品规划表对 1.5 版本任务进行梳理，每个人物分到小组</li><li>下周二之前每人任务拆分完成</li></ul></li></ul><h3 id="任务来源"><a href="#任务来源" class="headerlink" title="任务来源"></a>任务来源</h3><ul><li>参考材料： 2024产品规划表</li><li>消化2024产品规划表内容做出自己的判断</li><li>跟组长、产品、项目经理交流</li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><ul><li><strong>小结</strong>：1.5 版本各组员基本了解自己任务。</li><li><strong>行动项</strong>：各组员消化会议内容，进行 1.5 版本任务拆分。</li><li><strong>感谢</strong>：对团队的努力和贡献表示感谢。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>周会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信链路改造设计文档.md</title>
    <link href="/2024/01/25/mdstorage/project/sr/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2024/01/25/mdstorage/project/sr/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><h3 id="现状分析"><a href="#现状分析" class="headerlink" title="现状分析"></a>现状分析</h3><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><h3 id="困难点"><a href="#困难点" class="headerlink" title="困难点"></a>困难点</h3><h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><h1 id="项目概述-1"><a href="#项目概述-1" class="headerlink" title="项目概述"></a>项目概述</h1><h2 id="现状分析-1"><a href="#现状分析-1" class="headerlink" title="现状分析"></a>现状分析</h2><h3 id="总控、引擎、插件跨节点通信链路"><a href="#总控、引擎、插件跨节点通信链路" class="headerlink" title="总控、引擎、插件跨节点通信链路"></a>总控、引擎、插件跨节点通信链路</h3><pre><code class=" mermaid">graph LRsubgraph Sc[总控]scsv[可视化 sv]installer-manager[引擎安装 manager]endsubgraph Se[流量引擎]        subgraph Sem[流量引擎 管理节点]            installer-agent[引擎安装 agent]            webserver[Webserver]            admin_dam[admin Dam]            apiserver[Apiserver]            admin_ha[admin HA]nexus_m[Nexus]global_plugin_server[global-plugin-server]        end        subgraph Sew[流量引擎 工作节点]            data_dam[data Dam]            nexus_w[Nexus]            envoy[Envoy]        end                subgraph Ses[流量引擎 调度节点]        nexus_s[Nexus]        data_ha[Data HA]        endendinstaller-manager --&gt;|vip/nodeIP:8099|installer-agentinstaller-manager --&gt;|vip:6898|admin_hasv --&gt;|vip:1234|admin_damsv --&gt;|vip:8899|admin_damsv --&gt;|vip:8299|webserversc --&gt;|vip:8229|webserverinstaller-agent --&gt;|nodeIP:8098|installer-managerdata_dam --&gt;|nodeIp:4150|svdata_ha --&gt;|nodeIp:6443| apiserverwebserver --&gt;|nodeIp:9001|data_damwebserver --&gt;|nodeIp:8000| nexus_m &amp; nexus_s &amp; nexus_wenvoy --&gt;|vip:7878 7978| global_plugin_server%%installer-agent --&gt;|vip:6443|apiserver</code></pre><p>结论： 可以看出来现有的通信链路有两个不符合设计要求的点 1. 通信建立连接方向为总控端到引擎端  2. 通信链路不规则，各个组件缺乏管制，随意建立链接。</p><p>缺点很明显，1 会导致与实际客户部署场景不吻合 2 会导致后期运维困难、系统维护困难、系统开发成本提高等。</p><h2 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h2><h3 id="改造后总控引擎通信链路（不算引擎内部）"><a href="#改造后总控引擎通信链路（不算引擎内部）" class="headerlink" title="改造后总控引擎通信链路（不算引擎内部）"></a>改造后总控引擎通信链路（不算引擎内部）</h3><pre><code class=" mermaid">graph LRsubgraph Sc[总控]sc[sc]core[core 0.0.0.0:20111]sv[可视化 sv]installer-manager[引擎安装 manager]endsubgraph Se[流量引擎]        subgraph Sem[流量引擎 管理节点]            installer-agent[引擎安装 agent]            webserver[Webserver]            admin_dam[admin Dam]            apiserver[Apiserver]            admin_ha[admin HA]nexus_m[Nexus]global_plugin_server[global-plugin-server]        end        subgraph Sew[流量引擎 工作节点]            data_dam[data Dam]            nexus_w[Nexus]            envoy[Envoy]        end                subgraph Ses[流量引擎 调度节点]        nexus_s[Nexus]        endend%%installer-manager --&gt;|vip/nodeIP:8099|installer-agent%%installer-manager --&gt;|vip:6898|admin_ha%%sv --&gt;|vip:1234|admin_dam%%sv --&gt;|vip:8899|admin_dam%%sv --&gt;|vip:8299|webserver%%sc --&gt;|vip:8229|webserversc --&gt; corewebserver --&gt; coresv --&gt; coreadmin_dam ---&gt; coreinstaller-manager --&gt; coreadmin_ha ---&gt; coreinstaller-agent ---&gt; coreinstaller-manager --&gt;|nodeIp:22 |Se%%installer-agent --&gt;|nodeIP:8098|installer-manager%%data_dam --&gt;|nodeIp:4150|sv%%data_dam --&gt;|nodeIp:9001|webserver%%webserver --&gt;|nodeIp:8000| nexus_m &amp; nexus_s &amp; nexus_w%%envoy --&gt;|vip:7878 7978| global_plugin_server%%installer-agent --&gt;|vip:6443|apiserver</code></pre><h3 id="改造后总控引擎通信链路（算引擎内部）"><a href="#改造后总控引擎通信链路（算引擎内部）" class="headerlink" title="改造后总控引擎通信链路（算引擎内部）"></a>改造后总控引擎通信链路（算引擎内部）</h3><pre><code class=" mermaid">graph LRsubgraph Sc[总控]sc[sc]core[core 0.0.0.0:20111]sv[可视化 sv]installer-manager[引擎安装 manager]endsubgraph Se[流量引擎]        subgraph Sem[流量引擎 管理节点]            installer-agent[引擎安装 agent]            webserver[Webserver]            admin_dam[admin Dam]            apiserver[Apiserver]            admin_ha[admin HA]nexus_m[Nexus]global_plugin_server[global-plugin-server]        end        subgraph Sew[流量引擎 工作节点]            data_dam[data Dam]            nexus_w[Nexus]            envoy[Envoy]        end                subgraph Ses[流量引擎 调度节点]        nexus_s[Nexus]        data_ha[Data HA]        endend%%installer-manager --&gt;|vip/nodeIP:8099|installer-agent%%installer-manager --&gt;|vip:6898|admin_ha%%sv --&gt;|vip:1234|admin_dam%%sv --&gt;|vip:8899|admin_dam%%sv --&gt;|vip:8299|webserver%%sc --&gt;|vip:8229|webserversc --&gt; corewebserver --&gt; coresv --&gt; coreadmin_dam ---&gt; coreinstaller-manager --&gt; coreadmin_ha ---&gt; coreinstaller-agent ---&gt; coredata_ha --&gt;|nodeIp:6443| apiserver%%installer-agent --&gt;|nodeIP:8098|installer-manager%%data_dam --&gt;|nodeIp:4150|sv%%data_dam --&gt;|nodeIp:9001|webserverwebserver --&gt;|nodeIp:8000| nexus_m &amp; nexus_s &amp; nexus_wenvoy --&gt;|vip:7878 7978| global_plugin_serverinstaller-manager --&gt;|:22 |Se%%installer-agent --&gt;|vip:6443|apiserver</code></pre><h2 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h2><h3 id="建立连接反转"><a href="#建立连接反转" class="headerlink" title="建立连接反转"></a>建立连接反转</h3><p>（本次改动不涉及 可视化数据传输的流，这是考虑到可视化的数据流过大，经过一次转发消耗的资源比较大）</p><p>在 core 参与的框架中，完成组件之间通信有两步：</p><ol><li>与 core 建立通信</li><li>发送&#x2F;接收、处理请求</li></ol><p>图表标识</p><ul><li>红线表示需要完成 1 2 步编码</li><li>紫线表示不需要实现</li><li>橙色表示需要实现 2 步</li></ul><h4 id="sc-到-webserver"><a href="#sc-到-webserver" class="headerlink" title="sc 到 webserver"></a>sc 到 webserver</h4><pre><code class=" mermaid">graph LRsubgraph Sc[总控]        subgraph ScApi[总控API]            client[SCClient]            subgraph Client                conn_ctx[引擎连接管理]                gw_obj[引擎服务搭建]                node_ctx[引擎节点管理]                auth_ctx[引擎授权管理]                ha_ctx[调度策略管理]            end        end        subgraph Core            core_conn_ctx[各组件连接上下文管理]            subgraph Stream                Agent            end        endendsubgraph Serouter[Webserver]subgraph Router            gw[网关、虚拟服务对象等接口]            node_manage[引擎节点状态接口]            auth_manage[引擎授权管理接口]            ha_manage[调度策略管理接口]endend router --&gt; Agentclient --&gt; Agentrouter --&gt; Routerclient --&gt; Client &amp; core_conn_ctx    linkStyle 0,1,2,3,4 stroke:red,stroke-width:8px,color:black;    </code></pre><h4 id="sv-到-webserver"><a href="#sv-到-webserver" class="headerlink" title="sv 到 webserver"></a>sv 到 webserver</h4><pre><code class=" mermaid">graph LRsubgraph Sc[总控]        subgraph ScApi[总控API]            client[SVClient]            subgraph Client                conn_ctx[引擎连接管理]                gw_obj[引擎服务搭建]                node_ctx[引擎节点管理]                auth_ctx[引擎授权管理]                ha_ctx[调度策略管理]            end        end        subgraph Core            core_conn_ctx[各组件连接上下文管理]            subgraph Stream                Agent            end        endendsubgraph Serouter[Webserver]subgraph Router            gw[网关、虚拟服务对象等接口]            node_manage[引擎节点状态接口]            auth_manage[引擎授权管理接口]            ha_manage[调度策略管理接口]endend router --&gt; Agentclient --&gt; Agentrouter --&gt; Routerclient --&gt; Client &amp; core_conn_ctx    linkStyle 1,3,4 stroke:red,stroke-width:8px,color:black;    </code></pre><h4 id="sv-到-admin-dam"><a href="#sv-到-admin-dam" class="headerlink" title="sv 到 admin_dam"></a>sv 到 admin_dam</h4><pre><code class=" mermaid">graph LRsubgraph Sc[总控]        subgraph ScApi[总控API]            client[SVClient]            subgraph Client                conn_ctx[引擎连接管理]                gw_obj[引擎服务搭建]                node_ctx[引擎节点管理]                auth_ctx[引擎授权管理]                ha_ctx[调度策略管理]            end        end        subgraph Core            core_conn_ctx[各组件连接上下文管理]            subgraph Stream                Agent            end        endendsubgraph Serouter[adminDam]subgraph Router            gw[网关、虚拟服务对象等接口]            node_manage[引擎节点状态接口]            auth_manage[引擎授权管理接口]            ha_manage[调度策略管理接口]endend router --&gt; Agentclient --&gt; Agentrouter --&gt; Routerclient --&gt; Client &amp; core_conn_ctx    linkStyle 1,3,4 stroke:red,stroke-width:8px,color:black;    </code></pre><h4 id="installer-manager-到-admin-ha"><a href="#installer-manager-到-admin-ha" class="headerlink" title="installer-manager 到 admin_ha"></a>installer-manager 到 admin_ha</h4><pre><code class=" mermaid">graph LRsubgraph Sc[总控]        subgraph InstallerApi[InstallerAPI]            client[InstallerManagerClient]            subgraph Client                conn_ctx[提供dataWorker的节点状态管理]                gw_obj[提供dataHA节点删除能力]                node_ctx[提供工作节点删除能力]                auth_ctx[提供虚拟服务器的算法信息]                ha_ctx[提供LVS的算法列表]                system_ctx[更新真实服务器的信息]            end        end        subgraph Core            core_conn_ctx[各组件连接上下文管理]            subgraph Stream                Agent            end        endendsubgraph Serouter[admin_ha]subgraph Router            gw[dataWorker的节点状态管理等接口]            node_manage[提供dataHA节点删除能力接口]            auth_manage[工作节点删除能力接口]            ha_manage[调度策略管理接口]            manage1[虚拟服务器的算法信息接口]            manage2[LVS的算法列表接口]            manage3[更新真实服务器的信息接口]endend router --&gt; Agentclient --&gt; Agentrouter --&gt; Routerclient --&gt; Client &amp; core_conn_ctx    linkStyle 0,1,2,3,4 stroke:red,stroke-width:8px,color:black;    </code></pre><h4 id="installer-manager-到-installer-agent"><a href="#installer-manager-到-installer-agent" class="headerlink" title="installer-manager 到 installer-agent"></a>installer-manager 到 installer-agent</h4><pre><code class=" mermaid">graph LRsubgraph Sc[总控]        subgraph InstallerApi[InstallerManagerAPI]            client[InstallerManagerClient]            subgraph Client                conn_ctx[引擎安装指令发送]            end        end        subgraph Core            core_conn_ctx[各组件连接上下文管理]            subgraph Stream                Agent            end        endendsubgraph Serouter[installer-agent]subgraph Router            gw[引擎安装指令发送等接口]endend router --&gt; Agentclient --&gt; Agentrouter --&gt; Routerclient --&gt; Client &amp; core_conn_ctx    linkStyle 1,3,4 stroke:red,stroke-width:8px,color:black;        linkStyle 0,2 stroke:orange,stroke-width:8px,color:black;    </code></pre><h3 id="通信链路规整"><a href="#通信链路规整" class="headerlink" title="通信链路规整"></a>通信链路规整</h3><p>todo</p>]]></content>
    
    
    
    <tags>
      
      <tag>通信链路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>社会公理</title>
    <link href="/2024/01/24/mdstorage/%E7%A4%BE%E4%BC%9A%E5%85%AC%E7%90%86/"/>
    <url>/2024/01/24/mdstorage/%E7%A4%BE%E4%BC%9A%E5%85%AC%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="社会公理"><a href="#社会公理" class="headerlink" title="社会公理"></a>社会公理</h2><h3 id="生物本能趋利避害"><a href="#生物本能趋利避害" class="headerlink" title="生物本能趋利避害"></a>生物本能趋利避害</h3><ul><li><strong>推论</strong></li></ul><p>如果想提倡什么，就要根据对方想要什么设置奖励，以提高对方积极性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>社会</tag>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zerotier_truenas.md</title>
    <link href="/2024/01/24/mdstorage/resource/vpn/zerotier_truenas/"/>
    <url>/2024/01/24/mdstorage/resource/vpn/zerotier_truenas/</url>
    
    <content type="html"><![CDATA[<h2 id="truenas-zerotier-app使用"><a href="#truenas-zerotier-app使用" class="headerlink" title="truenas zerotier app使用"></a>truenas zerotier app使用</h2><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>truenas 23.10</p><p>zerotier app 1.0.9 </p><h3 id="NAS系统配置"><a href="#NAS系统配置" class="headerlink" title="NAS系统配置"></a>NAS系统配置</h3><ul><li>系统设置 -&gt; 高级 -&gt; 系统控制 -&gt; <a href="https://truecharts.org/charts/stable/zerotier/How-To-Guide">添加两个变量和值</a></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">net<span class="hljs-selector-class">.ipv4</span><span class="hljs-selector-class">.ip_forward</span>    <span class="hljs-number">1</span> <br>net<span class="hljs-selector-class">.ipv4</span><span class="hljs-selector-class">.conf</span><span class="hljs-selector-class">.all</span><span class="hljs-selector-class">.src_valid_mark</span>    <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><strong>网络</strong>： 粘贴 zerotier 网站中的 Network ID</p><p><strong>Network Configuration</strong> <strong>-&gt; Host Network</strong>： 勾选</p><h3 id="zerotier-配置"><a href="#zerotier-配置" class="headerlink" title="zerotier 配置"></a>zerotier 配置</h3><ul><li>登入 zerotier </li><li>勾选刚刚接入的设备，复制分配给此设备的 $IP</li><li>Add Routes: 填入接入的网段，via： $IP</li></ul><p>即可完成通过此 app，访问接入网段的目的</p>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>vpn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zerotier</tag>
      
      <tag>truenas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周会议程-1.22.md</title>
    <link href="/2024/01/22/mdstorage/project/sr/%E5%91%A8%E4%BC%9A%E8%AE%AE%E7%A8%8B-1.22/"/>
    <url>/2024/01/22/mdstorage/project/sr/%E5%91%A8%E4%BC%9A%E8%AE%AE%E7%A8%8B-1.22/</url>
    
    <content type="html"><![CDATA[<h1 id="周会议程"><a href="#周会议程" class="headerlink" title="周会议程"></a>周会议程</h1><h2 id="开场白"><a href="#开场白" class="headerlink" title="开场白"></a>开场白</h2><ul><li><strong>时间</strong>：2024&#x2F;1&#x2F;22</li><li><strong>地点</strong>：培训室</li><li><strong>参与人员</strong>：全体 Golang 组员</li><li><strong>会议主题</strong>：1.4 1.5 版本任务拆分相关注意事项</li><li><strong>会议时长</strong>：1 小时内</li></ul><h2 id="一、-1-4-1-5-版本任务拆分要求"><a href="#一、-1-4-1-5-版本任务拆分要求" class="headerlink" title="一、 1.4 1.5 版本任务拆分要求"></a>一、 1.4 1.5 版本任务拆分要求</h2><ul><li><strong>目的</strong>：对整体 Go 组组员关于 1.4 1.5 版本任务拆分有一个基础的认识</li><li><strong>内容</strong>：<ul><li>拆分后的内容填入到企微文档 《截止0119Go组人员工作梳理情况》</li><li>给两到三天时间做拆分工作</li></ul></li></ul><h2 id="二、-1-4-1-5-版本任务拆分注意事项"><a href="#二、-1-4-1-5-版本任务拆分注意事项" class="headerlink" title="二、 1.4 1.5 版本任务拆分注意事项"></a>二、 1.4 1.5 版本任务拆分注意事项</h2><h3 id="任务拆分粒度要求"><a href="#任务拆分粒度要求" class="headerlink" title="任务拆分粒度要求"></a>任务拆分粒度要求</h3><ul><li>原则上尽量拆细</li><li>1.4 的粒度尽量拆细到 3 天内</li><li>1.5 的粒度尽量拆细到 1 周内</li></ul><h3 id="任务来源"><a href="#任务来源" class="headerlink" title="任务来源"></a>任务来源</h3><ul><li>参考材料： 2024产品规划表</li><li>消化2024产品规划表内容做出自己的判断</li><li>跟组长、产品、项目经理交流</li></ul><h3 id="拆分注意事项"><a href="#拆分注意事项" class="headerlink" title="拆分注意事项"></a>拆分注意事项</h3><ul><li>拆分不是最终结果，这点不需要过于担心</li></ul><h2 id="拆分现场演示"><a href="#拆分现场演示" class="headerlink" title="拆分现场演示"></a>拆分现场演示</h2><ul><li>邓天翔现场演示拆分</li></ul><h2 id="周报格式要求"><a href="#周报格式要求" class="headerlink" title="周报格式要求"></a>周报格式要求</h2><ul><li><p>主题</p></li><li><p>内容细则</p></li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><ul><li><strong>小结</strong>：目前 1.4 1.5 任务比较赶，有些人 1.4 没有任务，应该将 1.5 拆分得更细，更便于执行。1.4 有任务的，拆分粒度可以粗一点。</li><li><strong>行动项</strong>：各组员消化会议内容，拆分任务和注意周报。</li><li><strong>感谢</strong>：对团队的努力和贡献表示感谢。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>周会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ppt写作.md</title>
    <link href="/2024/01/19/mdstorage/domain/%E6%96%87%E6%A1%A3/ppt%E5%86%99%E4%BD%9C/"/>
    <url>/2024/01/19/mdstorage/domain/%E6%96%87%E6%A1%A3/ppt%E5%86%99%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="PPT-模板"><a href="#PPT-模板" class="headerlink" title="PPT 模板"></a>PPT 模板</h2><p><a href="smb://truenas.local/public/resource/公司通用工作汇报模板PPT.pptx">公司通用工作汇报模板PPT</a> </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li><strong>独特性</strong><ul><li>模板独特</li><li>思路独特</li><li>观点独特</li></ul></li><li><h2 id="完整性-结构完整-全局整体描述-局部细节把控-内容完整"><a href="#完整性-结构完整-全局整体描述-局部细节把控-内容完整" class="headerlink" title="完整性- 结构完整  - 全局整体描述  - 局部细节把控- 内容完整"></a><strong>完整性</strong><br>- 结构完整<br>  - 全局整体描述<br>  - 局部细节把控<br>- 内容完整</h2><ul><li>方案完整<ul><li>生命周期各个环节</li><li>各个执行流程</li><li>各个阶段</li><li>所需资源</li></ul></li></ul></li><li><strong>一致性</strong><ul><li>设计与真实一致</li><li>方案与执行一致</li><li>结构与设计一致</li><li>自己在时间周期前后一致</li></ul></li><li>TODO</li></ul><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ppt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信创认证.md</title>
    <link href="/2024/01/19/mdstorage/project/sr/%E4%BF%A1%E5%88%9B%E8%AE%A4%E8%AF%81/"/>
    <url>/2024/01/19/mdstorage/project/sr/%E4%BF%A1%E5%88%9B%E8%AE%A4%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h2 id="信创认证"><a href="#信创认证" class="headerlink" title="信创认证"></a>信创认证</h2><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">machine</span>:<br><span class="hljs-attribute">10</span>.<span class="hljs-number">8</span>.<span class="hljs-number">10</span>.<span class="hljs-number">206</span><br><span class="hljs-attribute">7</span>!-r&#123;<span class="hljs-number">5</span>HU[b<br><br><span class="hljs-attribute">vm</span>:<br><span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">122</span>.<span class="hljs-number">24</span><br><span class="hljs-attribute">root</span>/<span class="hljs-number">123</span>.com/<span class="hljs-number">456</span><br></code></pre></td></tr></table></figure><h3 id="devkit-软件安装部署"><a href="#devkit-软件安装部署" class="headerlink" title="devkit 软件安装部署"></a>devkit 软件安装部署</h3><h4 id="安装依赖系统工具"><a href="#安装依赖系统工具" class="headerlink" title="安装依赖系统工具"></a>安装依赖系统工具</h4><h4 id="安装-devkit"><a href="#安装-devkit" class="headerlink" title="安装 devkit"></a>安装 devkit</h4><p><a href="https://www.hikunpeng.com/zh/developer/devkit/download">浏览器工作模式安装包下载地址</a></p><p><a href="https://www.hikunpeng.com/document/detail/zh/kunpengdevps/userguide/usermanual/KunpengDevKit_0017.html">安装指导文档</a></p><h4 id="修改-ip-port"><a href="#修改-ip-port" class="headerlink" title="修改 ip port"></a>修改 ip port</h4><h5 id="nginx-修改"><a href="#nginx-修改" class="headerlink" title="nginx 修改"></a>nginx 修改</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># /opt/ 作为安装目录</span><br><span class="hljs-comment"># 找到 nginx 目录 的 devkit_xxx.conf 修改 server 8086 监听地址</span><br><span class="hljs-comment"># /usr/bin/systemctl restart devkit_nginx</span><br></code></pre></td></tr></table></figure><h5 id="ssh-隧道转发流量"><a href="#ssh-隧道转发流量" class="headerlink" title="ssh 隧道转发流量"></a>ssh 隧道转发流量</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -L 0.0.0.0:8086:192.168.122.24:8086 root@10.8.10.206<br><br><span class="hljs-comment"># 服务监听 `https://10.8.10.206:8086/`</span><br><span class="hljs-comment"># 帐号密码 : devadmin 123.com/456</span><br></code></pre></td></tr></table></figure><h3 id="迁移工具使用"><a href="#迁移工具使用" class="headerlink" title="迁移工具使用"></a>迁移工具使用</h3><ul><li>源码扫描（源码 tar gz 上传）</li><li>软件扫描（安装包 tar gz 上传）</li></ul><h3 id="确定扫描源码组件"><a href="#确定扫描源码组件" class="headerlink" title="确定扫描源码组件"></a>确定扫描源码组件</h3><ul><li>sc</li><li>sv</li><li>installer</li><li>api-gov</li><li></li><li>webserver</li><li>nexus</li><li>dam</li><li>nuclei</li><li></li><li>envoy</li><li>polycube</li><li>sx-ha</li><li></li><li>mysql</li><li>mongodb</li><li>redis</li><li>nsq</li><li>etcd</li><li>hyperscan</li><li>kube-apiserver</li><li>kubectl</li></ul><h3 id="扫描工具原理分析"><a href="#扫描工具原理分析" class="headerlink" title="扫描工具原理分析"></a>扫描工具原理分析</h3><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/image-20240119175222574.png" alt="image-20240119175222574"></p><p>通过构建文件内容扫描关键字匹配，如 <strong>-l</strong>  参数，<strong>arm dpkg x86</strong> ，软件扫描，大概是扫描 <strong>so</strong> 文件是否兼容</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>libdflags.so 依赖</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">从红框有半部分的内容可以确认用户提供分析的待认证应用中所包含的依赖文件待替换信息。此部分内容不需要做前后严格对比，只需要保证前后两次分析中每次“依赖文件总数”、“可兼容替换”、“待验证替换”这三项不全为0即可。如果是第一次分析有报告，第二次分析时提示“您指定的分析路径/分析包中没有需要迁移的内容”，则结果也可以判定为通过。<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">从红框有半部分的内容可以确认用户提供分析的待认证应用中所包含的依赖文件待替换信息。此部分内容不需要做前后严格对比，只需要保证前后两次分析中每次“依赖文件总数”、“源码迁移人力”这两项不全为0即可。如果是第一次分析有报告，第二次分析时提示“源码迁移成功：您指定的分析路径/分析包中没有需要迁移的内容”，则结果也可以判定为通过。<br></code></pre></td></tr></table></figure><h3 id="是否扫描工具中有代码泄露风险"><a href="#是否扫描工具中有代码泄露风险" class="headerlink" title="是否扫描工具中有代码泄露风险"></a>是否扫描工具中有代码泄露风险</h3><h4 id="验证扫描是否依赖公网环境（结论：确实需要公网）"><a href="#验证扫描是否依赖公网环境（结论：确实需要公网）" class="headerlink" title="验证扫描是否依赖公网环境（结论：确实需要公网）"></a>验证扫描是否依赖公网环境（结论：确实需要公网）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# <span class="hljs-built_in">sudo</span> iptables -P INPUT ACCEPT<br>[root@localhost ~]# <span class="hljs-built_in">sudo</span> iptables -P FORWARD ACCEPT<br>[root@localhost ~]# <span class="hljs-built_in">sudo</span> iptables -P OUTPUT ACCEPT<br>[root@localhost ~]# <span class="hljs-built_in">sudo</span> iptables -A INPUT -s 192.168.122.0/24 -j ACCEPT<br>[root@localhost ~]# <span class="hljs-built_in">sudo</span> iptables -A OUTPUT -d 192.168.122.0/24 -j ACCEPT<br>[root@localhost ~]# <span class="hljs-built_in">sudo</span> iptables -A OUTPUT ! -d 192.168.122.0/24 -j DROP<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# curl -v https://www.baidu.com<br>*   Trying 183.2.172.42:443...<br>*   Trying 240e:ff:e020:9ae:0:ff:b014:8e8b:443...<br>* Immediate connect fail <span class="hljs-keyword">for</span> 240e:ff:e020:9ae:0:ff:b014:8e8b: 网络不可达<br>*   Trying 240e:ff:e020:966:0:ff:b042:f296:443...<br>* Immediate connect fail <span class="hljs-keyword">for</span> 240e:ff:e020:966:0:ff:b042:f296: 网络不可达<br>^C<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">10:53:46.738577 IP localhost.localdomain.34448 &gt; ecs-124-70-125-167.compute.hwclouds-dns.com.https: Flags [S], <span class="hljs-built_in">seq</span> 851829615, win 64240, options [mss 1460,sackOK,TS val 953561537 ecr 0,nop,wscale 7], length 0<br>10:53:46.784314 IP localhost.localdomain.34448 &gt; ecs-124-70-125-167.compute.hwclouds-dns.com.https: Flags [.], ack 2880648456, win 502, options [nop,nop,TS val 953561583 ecr 3062878975], length 0<br>10:53:46.785374 IP localhost.localdomain.34448 &gt; ecs-124-70-125-167.compute.hwclouds-dns.com.https: Flags [P.], <span class="hljs-built_in">seq</span> 0:517, ack 1, win 502, options [nop,nop,TS val 953561584 ecr 3062878975], length 517<br>10:53:46.832766 IP localhost.localdomain.34448 &gt; ecs-124-70-125-167.compute.hwclouds-dns.com.https: Flags [.], ack 3399, win 491, options [nop,nop,TS val 953561632 ecr 3062879024], length 0<br>10:53:46.833224 IP localhost.localdomain.34448 &gt; ecs-124-70-125-167.compute.hwclouds-dns.com.https: Flags [P.], <span class="hljs-built_in">seq</span> 517:523, ack 3399, win 491, options [nop,nop,TS val 953561632 ecr 3062879024], length 6<br>10:53:46.918337 IP localhost.localdomain.34448 &gt; ecs-124-70-125-167.compute.hwclouds-dns.com.https: Flags [P.], <span class="hljs-built_in">seq</span> 523:597, ack 3399, win 501, options [nop,nop,TS val 953561717 ecr 3062879110], length 74<br>10:53:46.963808 IP localhost.localdomain.34448 &gt; ecs-124-70-125-167.compute.hwclouds-dns.com.https: Flags [P.], <span class="hljs-built_in">seq</span> 597:833, ack 3399, win 501, options [nop,nop,TS val 953561763 ecr 3062879155], length 236<br>10:53:46.963999 IP localhost.localdomain.34448 &gt; ecs-124-70-125-167.compute.hwclouds-dns.com.https: Flags [.], ack 3941, win 501, options [nop,nop,TS val 953561763 ecr 3062879155], length 0<br>10:53:47.014211 IP localhost.localdomain.34448 &gt; ecs-124-70-125-167.compute.hwclouds-dns.com.https: Flags [F.], <span class="hljs-built_in">seq</span> 833, ack 4459, win 501, options [nop,nop,TS val 953561813 ecr 3062879205], length 0<br>10:53:47.059715 IP localhost.localdomain.34448 &gt; ecs-124-70-125-167.compute.hwclouds-dns.com.https: Flags [.], ack 4460, win 501, options [nop,nop,TS val 953561858 ecr 3062879251], length 0<br></code></pre></td></tr></table></figure><h2 id="信创兼容性测试用例"><a href="#信创兼容性测试用例" class="headerlink" title="信创兼容性测试用例"></a>信创兼容性测试用例</h2><ul><li>data_ha</li><li>admin_ha</li><li>agent</li><li>data_worker</li><li>webserver</li><li>nexus</li><li>dam</li><li>nuclei</li><li>envoy</li><li>polycubed</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># stop 指令</span><br>systemctl stop admin_ha.service adminDam.service dataDam.service data_ha.service nuclei.service envoy.service polycubed.service agent.service data_worker.service nexus webserver<br><br><span class="hljs-comment"># start 指令</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> enp1s0 up, systemctl start admin_ha.service adminDam.service dataDam.service data_ha.service nuclei.service envoy.service polycubed.service agent.service data_worker.service nexus webserver<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>信创</tag>
      
      <tag>devkit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zerotier.md</title>
    <link href="/2024/01/19/mdstorage/resource/vpn/zerotier/"/>
    <url>/2024/01/19/mdstorage/resource/vpn/zerotier/</url>
    
    <content type="html"><![CDATA[<h2 id="zerotier-安装使用（此方案有问题，废弃）"><a href="#zerotier-安装使用（此方案有问题，废弃）" class="headerlink" title="zerotier 安装使用（此方案有问题，废弃）"></a>zerotier 安装使用（此方案有问题，废弃）</h2><h3 id="zerotier-网络建立"><a href="#zerotier-网络建立" class="headerlink" title="zerotier 网络建立"></a>zerotier 网络建立</h3><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="Truenas-SCALE平台"><a href="#Truenas-SCALE平台" class="headerlink" title="Truenas SCALE平台"></a>Truenas SCALE平台</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -s https://install.zerotier.com | <span class="hljs-built_in">sudo</span> bash<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chmod</span> +x /bin/apt* /bin/dpkg<br></code></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>vpn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zerotier</tag>
      
      <tag>软路由</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux防火墙.md</title>
    <link href="/2024/01/18/mdstorage/domain/linux/Linux%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <url>/2024/01/18/mdstorage/domain/linux/Linux%E9%98%B2%E7%81%AB%E5%A2%99/</url>
    
    <content type="html"><![CDATA[<h2 id="场景用例"><a href="#场景用例" class="headerlink" title="场景用例"></a>场景用例</h2><h3 id="禁止公网访问、不限制局域网访问和进流量"><a href="#禁止公网访问、不限制局域网访问和进流量" class="headerlink" title="禁止公网访问、不限制局域网访问和进流量"></a>禁止公网访问、不限制局域网访问和进流量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 用例局域网为 192.168.122.0/24</span><br><span class="hljs-comment"># 直接用 sudo iptables -P OUTPUT DROP 会把被访问连接也断开</span><br><br>[root@localhost ~]# <span class="hljs-built_in">sudo</span> iptables -P INPUT ACCEPT<br>[root@localhost ~]# <span class="hljs-built_in">sudo</span> iptables -P FORWARD ACCEPT<br>[root@localhost ~]# <span class="hljs-built_in">sudo</span> iptables -P OUTPUT ACCEPT<br>[root@localhost ~]# <span class="hljs-built_in">sudo</span> iptables -A INPUT -s 192.168.122.0/24 -j ACCEPT<br>[root@localhost ~]# <span class="hljs-built_in">sudo</span> iptables -A OUTPUT -d 192.168.122.0/24 -j ACCEPT<br>[root@localhost ~]# <span class="hljs-built_in">sudo</span> iptables -A OUTPUT ! -d 192.168.122.0/24 -j DROP<br><br><span class="hljs-comment"># iptables -D 是删除策略</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>firewall</tag>
      
      <tag>Linux</tag>
      
      <tag>iptables</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QemuKVM共享剪贴板.md</title>
    <link href="/2024/01/18/mdstorage/domain/linux/QemuKVM%E5%85%B1%E4%BA%AB%E5%89%AA%E8%B4%B4%E6%9D%BF/"/>
    <url>/2024/01/18/mdstorage/domain/linux/QemuKVM%E5%85%B1%E4%BA%AB%E5%89%AA%E8%B4%B4%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h3 id="QEMU-KVM-安装Windows虚拟机"><a href="#QEMU-KVM-安装Windows虚拟机" class="headerlink" title="QEMU&#x2F;KVM 安装Windows虚拟机"></a>QEMU&#x2F;KVM 安装Windows虚拟机</h3><ol><li>打开virt-manager</li><li>File -&gt; Add connection…</li><li>New Virtual Machine<br> - Local install media<br> - Choose ISO,  type: <code>Generic or unknown OS. Usage is not recommended.</code><br> - 4C&#x2F;8G&#x2F;128G<br> - ……<br> - [x] Customize configuration before install</li><li>Overview -&gt; Hypervisor Details<br> - Firmware: BIOS</li><li>启动开始安装</li><li>Windows系统安装后下载安装<br> - 剪贴板📋共享: <a href="https://www.spice-space.org/download/windows/spice-guest-tools/spice-guest-tools-latest.exe">spice-guest-tools</a><br>     - 文件夹共享: <a href="https://www.spice-space.org/download/windows/spice-webdavd/spice-webdavd-x86-latest.msi">spice-webdavd</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VM</tag>
      
      <tag>QEMU</tag>
      
      <tag>KVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Remmina</title>
    <link href="/2024/01/18/mdstorage/domain/linux/Remmina/"/>
    <url>/2024/01/18/mdstorage/domain/linux/Remmina/</url>
    
    <content type="html"><![CDATA[<h2 id="Remmina"><a href="#Remmina" class="headerlink" title="Remmina"></a>Remmina</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><a href="https://zhuanlan.zhihu.com/p/26879292">介绍链接</a></p><p>特点： Linux 中功能较丰富的 rdp 客户端</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get install -y remmina remmina-plugin-*<br></code></pre></td></tr></table></figure><h3 id="实用功能"><a href="#实用功能" class="headerlink" title="实用功能"></a>实用功能</h3><h4 id="动态分辨率更新"><a href="#动态分辨率更新" class="headerlink" title="动态分辨率更新"></a>动态分辨率更新</h4>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rdp_client</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QemuKVM共享剪贴板.md</title>
    <link href="/2024/01/18/mdstorage/domain/%E8%99%9A%E6%8B%9F%E5%8C%96/QemuKVM%E5%85%B1%E4%BA%AB%E5%89%AA%E8%B4%B4%E6%9D%BF/"/>
    <url>/2024/01/18/mdstorage/domain/%E8%99%9A%E6%8B%9F%E5%8C%96/QemuKVM%E5%85%B1%E4%BA%AB%E5%89%AA%E8%B4%B4%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h3 id="QEMU-KVM-安装Windows虚拟机"><a href="#QEMU-KVM-安装Windows虚拟机" class="headerlink" title="QEMU&#x2F;KVM 安装Windows虚拟机"></a>QEMU&#x2F;KVM 安装Windows虚拟机</h3><ol><li>打开virt-manager</li><li>File -&gt; Add connection…</li><li>New Virtual Machine<br> - Local install media<br> - Choose ISO,  type: <code>Generic or unknown OS. Usage is not recommended.</code><br> - 4C&#x2F;8G&#x2F;128G<br> - ……<br> - [x] Customize configuration before install</li><li>Overview -&gt; Hypervisor Details<br> - Firmware: BIOS</li><li>启动开始安装</li><li>Windows系统安装后下载安装<br> - 剪贴板📋共享: <a href="https://www.spice-space.org/download/windows/spice-guest-tools/spice-guest-tools-latest.exe">spice-guest-tools</a><br>     - 文件夹共享: <a href="https://www.spice-space.org/download/windows/spice-webdavd/spice-webdavd-x86-latest.msi">spice-webdavd</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VM</tag>
      
      <tag>QEMU</tag>
      
      <tag>KVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dart语法.md</title>
    <link href="/2024/01/15/mdstorage/domain/dart/dart%E8%AF%AD%E6%B3%95/"/>
    <url>/2024/01/15/mdstorage/domain/dart/dart%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="成员变量赋值"><a href="#成员变量赋值" class="headerlink" title="成员变量赋值"></a>成员变量赋值</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> Color color;<br><br>  MyClass(<span class="hljs-keyword">this</span>.color);   <span class="hljs-comment">// 在 Dart 中，MyClass(this.color); 这种语法直接将构造函数的参数 color 赋值给类的成员变量 color。这是 Dart 语言的特性，用于简化代码，避免显式地写出 this.color = color; 这样的赋值语句。</span><br><br>  <span class="hljs-keyword">void</span> describeColor() &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The color is: <span class="hljs-subst">$color</span>&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>&#123;<br>  <span class="hljs-built_in">int</span> a;<br>  Parent(<span class="hljs-keyword">this</span>.a);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>&#123;<br>  <span class="hljs-built_in">int</span> b;<br>  Child(<span class="hljs-built_in">int</span> a, <span class="hljs-keyword">this</span>.b) : <span class="hljs-keyword">super</span>(a) &#123;<br>    <span class="hljs-comment">// 初始化逻辑</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字典传参"><a href="#字典传参" class="headerlink" title="字典传参"></a>字典传参</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-built_in">int</span> id;<br>  <span class="hljs-built_in">String?</span> name;<br>  <span class="hljs-built_in">String</span> password;<br>  <span class="hljs-built_in">String?</span> email;<br>  <span class="hljs-built_in">String?</span> phone;<br>  <span class="hljs-built_in">String</span> address;<br>  <span class="hljs-built_in">String</span> avatar;<br>  <span class="hljs-built_in">String</span> introduction;<br>  Gender? gender;<br>  <span class="hljs-built_in">DateTime?</span> birthday;<br><br>  UserStatus status;<br>  UserType type;<br>  <span class="hljs-built_in">DateTime</span> createdAt;<br>  <span class="hljs-built_in">DateTime?</span> updatedAt;<br><br>  User(&#123;<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.id,<br>    <span class="hljs-keyword">this</span>.name,<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.password,<br>    <span class="hljs-keyword">this</span>.email,<br>    <span class="hljs-keyword">this</span>.phone,<br>    <span class="hljs-keyword">this</span>.address = <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-keyword">this</span>.avatar = <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-keyword">this</span>.introduction = <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-keyword">this</span>.gender,<br>    <span class="hljs-keyword">this</span>.birthday,<br>    <span class="hljs-keyword">this</span>.status = UserStatus.using,<br>    <span class="hljs-keyword">this</span>.type = UserType.unknown,<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.createdAt,<br>    <span class="hljs-keyword">this</span>.updatedAt,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="非空类型赋值"><a href="#非空类型赋值" class="headerlink" title="非空类型赋值"></a>非空类型赋值</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-built_in">String?</span> taskTitle, taskRelativePerson;<br>  <span class="hljs-built_in">DateTime?</span> taskDate;<br>  SingleTask(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">this</span>.taskTitle,<br>    <span class="hljs-keyword">this</span>.taskDate,<br>    <span class="hljs-keyword">this</span>.taskRelativePerson,<br>  &#125;) : <span class="hljs-keyword">super</span>(key: key) &#123;<br>    taskTitle ??= <span class="hljs-string">&quot;&quot;</span>;<br>    taskRelativePerson ??= <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">$taskTitle</span>, <span class="hljs-subst">$taskRelativePerson</span>, <span class="hljs-subst">$taskDate</span>&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;SingleTask&gt; createState() =&gt; _SingleTaskState();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">$taskTitle</span>, <span class="hljs-subst">$taskRelativePerson</span>, <span class="hljs-subst">$taskDate</span>&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="map-方法"><a href="#map-方法" class="headerlink" title="map 方法"></a>map 方法</h2><p>在 Dart 中，<code>map</code> 方法是一个非常强大的工具，用于对集合（如列表或可迭代对象）中的每个元素执行一个函数，并将结果收集为一个新的可迭代对象。这种用法广泛应用于数据转换、过滤、和操作场景中。</p><h3 id="map-方法的使用"><a href="#map-方法的使用" class="headerlink" title="map 方法的使用"></a><code>map</code> 方法的使用</h3><p>当你看到如下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">subTask.map((task) =&gt; taskPlane(task)).toList(),<br></code></pre></td></tr></table></figure><p>这里发生的事情是：</p><ol><li><code>subTask</code> 是一个可迭代的集合，比如 List。</li><li><code>.map((task) =&gt; taskPlane(task))</code> 对 <code>subTask</code> 集合中的每一个元素执行 <code>taskPlane(task)</code> 函数。<code>task</code> 是当前迭代到的元素。</li><li><code>.toList()</code> 是将 <code>map</code> 操作的结果（仍然是一个可迭代对象）转换成一个列表。</li></ol><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol><li><p><strong>使用箭头函数简化代码（当适用时）</strong>：如果你的转换逻辑非常简单，可以直接使用箭头函数，使代码更加简洁。</p></li><li><p><strong>明确类型注解</strong>：尽管 Dart 能够推断出类型，明确地声明输入和输出的类型可以提高代码的可读性和维护性。</p></li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">List</span>&lt;NewType&gt; newList = subTask.map&lt;NewType&gt;((Task task) =&gt; taskPlane(task)).toList();<br></code></pre></td></tr></table></figure><ol start="3"><li><p><strong>避免不必要的性能损耗</strong>：<code>.toList()</code> 会创建一个新的集合，如果你只需要迭代结果，不一定需要转换成 List，直接使用 <code>.map()</code> 的结果进行迭代可以节省资源。</p></li><li><p><strong>结合使用其他迭代方法</strong>：<code>map</code> 经常与 <code>where</code>（过滤）、<code>any</code>（检查是否至少有一个元素满足条件）、<code>fold</code>（累加器）等方法结合使用，以实现更复杂的数据处理逻辑。</p></li><li><p><strong>理解 <code>map</code> 和 <code>forEach</code> 的区别</strong>：<code>map</code> 用于转换集合中的每个元素并收集结果，而 <code>forEach</code> 仅用于遍历集合中的元素执行操作，不返回任何结果。</p></li></ol><p>使用 <code>map</code> 的目的是生成一个新的集合，其中包含对原始集合中每个元素应用给定函数后的结果。它是函数式编程的一个体现，可以让你写出更清晰、更简洁、更易于维护的代码。</p><h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><h3 id=""><a href="#" class="headerlink" title="??&#x3D;"></a>??&#x3D;</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskTitle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-type">String</span>? title;<br>  <span class="hljs-type">TaskTitle</span>(&#123;<span class="hljs-type">Key</span>? key, <span class="hljs-keyword">this</span>.title&#125;) : <span class="hljs-keyword">super</span>(key: key) &#123;<br>    title ??= <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-comment">// 如果为空则赋值为 &quot;&quot;</span><br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-type">Widget</span> build(<span class="hljs-type">BuildContext</span> context) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">Expanded</span>(<br>      child: <span class="hljs-type">Text</span>(<br>        title!,<br>        style: const <span class="hljs-type">TextStyle</span>(fontWeight: <span class="hljs-type">FontWeight</span>.bold),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>在Dart中，断言（assertions）是一种在开发过程中用于检查代码逻辑的工具，它可以确保变量或表达式符合特定条件。如果断言失败（即条件评估为<code>false</code>），程序会抛出一个<code>AssertionError</code>异常。这在开发和测试阶段非常有用，因为它可以帮助开发者及早发现和修复潜在的错误。然而，需要注意的是，断言只在开发模式下工作，在生产模式下会被忽略。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> text = <span class="hljs-string">&#x27;Dart&#x27;</span>;<br>  <br>  <span class="hljs-comment">// 断言文本不为空</span><br>  <span class="hljs-keyword">assert</span>(text.isNotEmpty, <span class="hljs-string">&#x27;The text should not be empty.&#x27;</span>);<br><br>  <span class="hljs-comment">// 断言文本长度大于3</span><br>  <span class="hljs-keyword">assert</span>(text.length &gt; <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;The text should be more than 3 characters.&#x27;</span>);<br>  <br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Passed all assertions.&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>dart</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dart</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang安装.md</title>
    <link href="/2024/01/12/mdstorage/domain/golang/golang%E5%AE%89%E8%A3%85/"/>
    <url>/2024/01/12/mdstorage/domain/golang/golang%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="golang-安装"><a href="#golang-安装" class="headerlink" title="golang 安装"></a>golang 安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">set</span> -eux<br><br><span class="hljs-built_in">cd</span> $(<span class="hljs-built_in">dirname</span> <span class="hljs-variable">$0</span>) || <span class="hljs-built_in">exit</span> 1<br><br>GO_VERSION=1.22.3<br>GO_INSTALL_DIR=/opt/go<br>GO_ROOT=<span class="hljs-variable">$&#123;GO_INSTALL_DIR&#125;</span>/<span class="hljs-variable">$&#123;GO_VERSION&#125;</span><br>GO_PATH=~/go<br>ENV_FILE=/etc/profile<br><span class="hljs-comment">#GO_INSECURE_LIB=</span><br><br><span class="hljs-comment"># Install Golang</span><br>wget -c https://go.dev/dl/go<span class="hljs-variable">$&#123;GO_VERSION&#125;</span>.linux-amd64.tar.gz<br><br><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$&#123;GO_INSTALL_DIR&#125;</span><br><span class="hljs-built_in">rm</span> -rf <span class="hljs-variable">$&#123;GO_INSTALL_DIR&#125;</span>/*<br>tar -zxf go<span class="hljs-variable">$&#123;GO_VERSION&#125;</span>.linux-amd64.tar.gz -C <span class="hljs-variable">$&#123;GO_INSTALL_DIR&#125;</span>/<br><span class="hljs-built_in">mv</span> <span class="hljs-variable">$&#123;GO_INSTALL_DIR&#125;</span>/go <span class="hljs-variable">$&#123;GO_ROOT&#125;</span><br><br><span class="hljs-comment"># Config env for all user</span><br><span class="hljs-comment">#sed -i &#x27;s/^export GOROOT=.*$//g&#x27; $&#123;ENV_FILE&#125;</span><br><span class="hljs-comment">#sed -i &#x27;$a export GOROOT=&#x27;&quot;$&#123;GO_ROOT&#125;&quot;&#x27;&#x27; $&#123;ENV_FILE&#125;</span><br><span class="hljs-comment">#sed -i &#x27;s/^export GOPATH=.*$//g&#x27; $&#123;ENV_FILE&#125;</span><br><span class="hljs-comment">#sed -i &#x27;$a export GOPATH=&#x27;&quot;$&#123;GO_PATH&#125;&quot;&#x27;&#x27; $&#123;ENV_FILE&#125;</span><br>sed -i <span class="hljs-string">&#x27;s/^export PATH=.*\/go\/bin.*$//g&#x27;</span> <span class="hljs-variable">$&#123;ENV_FILE&#125;</span><br>sed -i <span class="hljs-string">&#x27;$a export PATH=&#x27;</span><span class="hljs-string">&quot;<span class="hljs-variable">$&#123;GO_ROOT&#125;</span>&quot;</span><span class="hljs-string">&#x27;/bin:&#x27;</span><span class="hljs-string">&quot;<span class="hljs-variable">$&#123;GO_PATH&#125;</span>&quot;</span><span class="hljs-string">&#x27;/bin:$PATH&#x27;</span> <span class="hljs-variable">$&#123;ENV_FILE&#125;</span><br><br><span class="hljs-comment">## Remove consecutive blank lines</span><br>sed -i <span class="hljs-string">&#x27;/^$/&#123;N;/\n$/D&#125;;&#x27;</span> <span class="hljs-variable">$&#123;ENV_FILE&#125;</span><br><br><span class="hljs-comment"># Config Golang env for current user</span><br><span class="hljs-variable">$&#123;GO_ROOT&#125;</span>/bin/go <span class="hljs-built_in">env</span> -w GO111MODULE=on<br><span class="hljs-variable">$&#123;GO_ROOT&#125;</span>/bin/go <span class="hljs-built_in">env</span> -w GOPROXY=https://goproxy.cn,direct<br><span class="hljs-variable">$&#123;GO_ROOT&#125;</span>/bin/go <span class="hljs-built_in">env</span> -w GOROOT=<span class="hljs-variable">$&#123;GO_ROOT&#125;</span><br><span class="hljs-variable">$&#123;GO_ROOT&#125;</span>/bin/go <span class="hljs-built_in">env</span> -w GOPATH=<span class="hljs-variable">$&#123;GO_PATH&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>安装</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人才培养</title>
    <link href="/2024/01/12/mdstorage/project/sr/%E4%BA%BA%E6%89%8D%E5%9F%B9%E5%85%BB/"/>
    <url>/2024/01/12/mdstorage/project/sr/%E4%BA%BA%E6%89%8D%E5%9F%B9%E5%85%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="人才培养"><a href="#人才培养" class="headerlink" title="人才培养"></a>人才培养</h2><h3 id="1-确定技能需求和职业路径"><a href="#1-确定技能需求和职业路径" class="headerlink" title="1. 确定技能需求和职业路径"></a>1. 确定技能需求和职业路径</h3><h3 id="2-制定个性化培训计划"><a href="#2-制定个性化培训计划" class="headerlink" title="2. 制定个性化培训计划"></a>2. 制定个性化培训计划</h3><h3 id="3-实践和应用"><a href="#3-实践和应用" class="headerlink" title="3. 实践和应用"></a>3. 实践和应用</h3><h3 id="4-提供反馈和指导"><a href="#4-提供反馈和指导" class="headerlink" title="4. 提供反馈和指导"></a>4. 提供反馈和指导</h3><h3 id="5-建立知识共享文化"><a href="#5-建立知识共享文化" class="headerlink" title="5. 建立知识共享文化"></a>5. 建立知识共享文化</h3><h3 id="6-鼓励创新和自我提升"><a href="#6-鼓励创新和自我提升" class="headerlink" title="6. 鼓励创新和自我提升"></a>6. 鼓励创新和自我提升</h3><h3 id="7-注重团队合作和沟通"><a href="#7-注重团队合作和沟通" class="headerlink" title="7. 注重团队合作和沟通"></a>7. 注重团队合作和沟通</h3><h3 id="1-增强自我意识和领导力"><a href="#1-增强自我意识和领导力" class="headerlink" title="1. 增强自我意识和领导力"></a>1. 增强自我意识和领导力</h3><h3 id="2-学习有效的沟通技巧"><a href="#2-学习有效的沟通技巧" class="headerlink" title="2. 学习有效的沟通技巧"></a>2. 学习有效的沟通技巧</h3><h3 id="3-建立有效的培训和发展程序"><a href="#3-建立有效的培训和发展程序" class="headerlink" title="3. 建立有效的培训和发展程序"></a>3. 建立有效的培训和发展程序</h3><h3 id="4-促进学习和成长的文化"><a href="#4-促进学习和成长的文化" class="headerlink" title="4. 促进学习和成长的文化"></a>4. 促进学习和成长的文化</h3><h3 id="5-实践授权和信任"><a href="#5-实践授权和信任" class="headerlink" title="5. 实践授权和信任"></a>5. 实践授权和信任</h3><h3 id="6-拓展视野和网络"><a href="#6-拓展视野和网络" class="headerlink" title="6. 拓展视野和网络"></a>6. 拓展视野和网络</h3><h3 id="7-关注个人发展"><a href="#7-关注个人发展" class="headerlink" title="7. 关注个人发展"></a>7. 关注个人发展</h3>]]></content>
    
    
    
    <tags>
      
      <tag>人才培养</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目销售支持.md</title>
    <link href="/2024/01/12/mdstorage/project/sr/%E9%A1%B9%E7%9B%AE%E9%94%80%E5%94%AE%E6%94%AF%E6%8C%81/"/>
    <url>/2024/01/12/mdstorage/project/sr/%E9%A1%B9%E7%9B%AE%E9%94%80%E5%94%AE%E6%94%AF%E6%8C%81/</url>
    
    <content type="html"><![CDATA[<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>市场、研发信息对齐</p><h2 id="销售不明产品定义"><a href="#销售不明产品定义" class="headerlink" title="销售不明产品定义"></a>销售不明产品定义</h2><p>见客户时、销售不清楚产品定义： 加强市场与研发沟通交流，每月有固定会议，规划市场策略</p><h2 id="销售突破（研发如何协助）"><a href="#销售突破（研发如何协助）" class="headerlink" title="销售突破（研发如何协助）"></a>销售突破（研发如何协助）</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>WAF 这个销售场景，研发支持跟长亭研发有劣势，如何补足</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>研发的输出本质上是产品的：时间、质量、成本 三个维度</p><p>寻求必要的各需求方最小集，资源足够的情况下，带着最小集沿着最佳方案实施</p><p>资源不足的情况下，评估竞争对手做到什么程度、级别，我们追上的可能性，有可能性后，沿着最佳方案实施，无可能，换个方向努力</p><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>研究我方各部人马优势项，研发带着最小的包袱输出产品冲击市场，以获取一定规模业务。</p><p>具体，市场带研发，研发助市场，形成良性循环，研发需要输入： 1. 行业信息 2. 客户真实需要 3. 竞争对手材料。研发需要输出： 1. 场景 2. 亮点</p><p>四两拨千斤，实现销售突破。</p><h3 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h3><p>以何种粒度实施</p><h2 id="如何有亮点（以脱敏功能为例）"><a href="#如何有亮点（以脱敏功能为例）" class="headerlink" title="如何有亮点（以脱敏功能为例）"></a>如何有亮点（以脱敏功能为例）</h2><h3 id="第一种（适合项目初期找不到销售突破）"><a href="#第一种（适合项目初期找不到销售突破）" class="headerlink" title="第一种（适合项目初期找不到销售突破）"></a>第一种（适合项目初期找不到销售突破）</h3><ul><li>寻找目标客户（是否愿意将数据脱敏从95做到100分）</li><li>研发调研需要哪些材料（如接口API协议格式）</li><li>市场积极寻找对方材料（对方技术等）</li><li>针对性局部性突破到 100 分</li></ul><h3 id="第二种（适合初期实力不够强，有愿意合作的供应商）"><a href="#第二种（适合初期实力不够强，有愿意合作的供应商）" class="headerlink" title="第二种（适合初期实力不够强，有愿意合作的供应商）"></a>第二种（适合初期实力不够强，有愿意合作的供应商）</h3><ul><li>石犀各组件化整为零，单项突破，以小博大</li><li>与合作供应商结合，汲取供应商资源</li><li>渐渐整合资源、自立山头</li></ul><h2 id="销售策略"><a href="#销售策略" class="headerlink" title="销售策略"></a>销售策略</h2><h3 id="阶段一：-集中测试"><a href="#阶段一：-集中测试" class="headerlink" title="阶段一： 集中测试"></a>阶段一： 集中测试</h3><ul><li><p>5-10 医院 POC 测试项目</p></li><li><p>API治理，业务安全发布</p></li><li><p>正在测试：2家</p></li><li><p>本月部署：3家</p></li><li><p>测试方面的的支持</p></li><li><p>形成有效的案例</p></li></ul><h3 id="阶段二：行业爆破"><a href="#阶段二：行业爆破" class="headerlink" title="阶段二：行业爆破"></a>阶段二：行业爆破</h3><ul><li>医疗行业：行业研讨会</li><li>扩大行业品牌影响力</li><li>促进项目成交落地</li></ul><h3 id="阶段三：-建立优势"><a href="#阶段三：-建立优势" class="headerlink" title="阶段三： 建立优势"></a>阶段三： 建立优势</h3><ul><li>输出行业解决方案机案例</li><li>产品形成行业优势</li></ul><h3 id="阶段四：-复制"><a href="#阶段四：-复制" class="headerlink" title="阶段四： 复制"></a>阶段四： 复制</h3><ul><li>提高行业覆盖率</li><li>寻求签单率</li></ul><h2 id="销售团队文化"><a href="#销售团队文化" class="headerlink" title="销售团队文化"></a>销售团队文化</h2><p>狼性</p><p>学习型</p><p>流程、标准</p><p>结果</p><h2 id="销售组织协同需求"><a href="#销售组织协同需求" class="headerlink" title="销售组织协同需求"></a>销售组织协同需求</h2><ul><li>刘总：参与到实习团队的销售工作中来，月度总结会</li><li>研发、技术：建立沟通机制；每周通过售前反馈市场信息；每月一次交流会</li><li>售前：绩效引导</li><li>众云：客户需求、进展信息胡同；合作BD客户</li></ul><h2 id="问题和场景"><a href="#问题和场景" class="headerlink" title="问题和场景"></a>问题和场景</h2><h3 id="医院已有供应商、直接进不太现实"><a href="#医院已有供应商、直接进不太现实" class="headerlink" title="医院已有供应商、直接进不太现实"></a>医院已有供应商、直接进不太现实</h3><ul><li>要找到门当户对的供应商，大供应商不会和小团队合作，看不上</li><li>从医院客户提场景，倒逼供应商与我们结合</li></ul><h2 id="重点客户项目"><a href="#重点客户项目" class="headerlink" title="重点客户项目"></a>重点客户项目</h2><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><ul><li>政务云</li><li>数字政府</li><li>智慧城市</li><li>城市安全大脑</li><li>数据安全中台</li><li>云资源池安全平台</li><li>数据要素安全管理平台</li></ul><h3 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h3><p>公检发、政法委、GA</p><p>数字政府： 网信办&#x2F;司法、应急、消防</p><p>补充党政口：人设、组织、档案、纪委</p><p>三大运营商、设计院</p><p>大国企：南方电网、传媒、大交通、铁投、城投</p><p>烟草、税务、电力、运营商、税务、边检、海关</p><p>股份制、城商行、农商行</p><p>消费金融，融资机构等反金融行业</p><p>渠道合作伙伴</p>]]></content>
    
    
    
    <tags>
      
      <tag>销售</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu机器微信安装.md</title>
    <link href="/2024/01/12/mdstorage/resource/%E5%BE%AE%E4%BF%A1/Ubuntu%E5%AE%89%E8%A3%85%E5%BE%AE%E4%BF%A1/"/>
    <url>/2024/01/12/mdstorage/resource/%E5%BE%AE%E4%BF%A1/Ubuntu%E5%AE%89%E8%A3%85%E5%BE%AE%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="Ubuntu-机器微信安装"><a href="#Ubuntu-机器微信安装" class="headerlink" title="Ubuntu 机器微信安装"></a>Ubuntu 机器微信安装</h2><h3 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h3><p><a href="https://archive.ubuntukylin.com/ubuntukylin/pool/partner/weixin_2.1.4_amd64.deb">Kylinos weixin amd64</a></p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>v2.1.4 amd64 deb  kylinos 2022-05-23 105M</p><h3 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://archive.ubuntukylin.com/ubuntukylin/pool/partner/weixin_2.1.4_amd64.deb<br><span class="hljs-built_in">sudo</span> apt install -f  weixin_2.1.4_amd64.deb## Ubuntu 机器微信安装<br><br><span class="hljs-comment">### 下载链接</span><br><br>[Kylinos weixin amd64](https://archive.ubuntukylin.com/ubuntukylin/pool/partner/weixin_2.1.4_amd64.deb)<br><br><span class="hljs-comment">### 版本</span><br><br>v2.1.4 amd64 deb  kylinos 2022-05-23 105M<br><br><span class="hljs-comment">### 安装方式</span><br><br>```bash<br>wget https://archive.ubuntukylin.com/ubuntukylin/pool/partner/weixin_2.1.4_amd64.deb<br><span class="hljs-built_in">sudo</span> apt install -f  weixin_2.1.4_amd64.deb<br>```<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>微信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>debian</tag>
      
      <tag>wechat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信创环境搭建.md</title>
    <link href="/2024/01/11/mdstorage/project/sr/%E4%BF%A1%E5%88%9B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2024/01/11/mdstorage/project/sr/%E4%BF%A1%E5%88%9B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="机器配置"><a href="#机器配置" class="headerlink" title="机器配置"></a>机器配置</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">TaiShan</span> <span class="hljs-number">200</span>( Model <span class="hljs-number">2280</span>)<br><span class="hljs-attribute">2</span>* Kunpeng <span class="hljs-number">920</span>-<span class="hljs-number">32</span>Core@<span class="hljs-number">2</span>.<span class="hljs-number">6</span>GHz CPU <br><span class="hljs-attribute">4</span>*<span class="hljs-number">32</span>G内存<br><span class="hljs-attribute">SR450C</span>-M RAID0/<span class="hljs-number">1</span>/<span class="hljs-number">5</span>/<span class="hljs-number">6</span>/<span class="hljs-number">2</span>G Cache<br><span class="hljs-attribute">12</span>* <span class="hljs-number">4</span>T SATA <br><span class="hljs-attribute">4</span>* <span class="hljs-number">1</span>GE <br><span class="hljs-attribute">2</span>*<span class="hljs-number">900</span>w AC 电源<br><span class="hljs-attribute">12</span>盘位,<span class="hljs-number">3</span>.<span class="hljs-number">5</span>寸硬盘服务器<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>信创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go单元测试.md</title>
    <link href="/2024/01/10/mdstorage/domain/golang/Go%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/01/10/mdstorage/domain/golang/Go%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="场景用例"><a href="#场景用例" class="headerlink" title="场景用例"></a>场景用例</h2><h3 id="依赖外部文件-config-ini-等"><a href="#依赖外部文件-config-ini-等" class="headerlink" title="依赖外部文件 config.ini 等"></a>依赖外部文件 config.ini 等</h3><p>在使用 Go 的 <code>go test</code> 框架编写单元测试时，如果测试依赖于 <code>config.ini</code> 文件来初始化配置，最佳实践通常包括以下几点：</p><ol><li><p><strong>隔离和模拟配置</strong>：避免在单元测试中直接依赖外部文件。可以通过模拟（mocking）配置的方式来提供必要的设置，或者使用临时的配置文件。</p></li><li><p><strong>测试环境设置</strong>：为测试创建专用的配置环境，确保测试不受生产或开发环境配置的影响。</p></li><li><p><strong>清晰的依赖注入</strong>：在代码中明确配置依赖，使其容易在测试中被替换或模拟。这有助于创建更可靠和可维护的测试。</p></li><li><p><strong>使用环境变量</strong>：考虑使用环境变量来传递配置信息，这样可以在测试时轻松地覆盖它们。</p></li></ol><h4 id="隔离和模拟配置"><a href="#隔离和模拟配置" class="headerlink" title="隔离和模拟配置"></a>隔离和模拟配置</h4><p>在 Go 中实现配置的模拟（mocking）通常涉及以下步骤：</p><ol><li><p><strong>定义配置接口</strong>：首先定义一个配置接口，该接口包含用于获取配置的方法。</p></li><li><p><strong>实现接口的模拟版本</strong>：创建一个模拟的配置结构体，它实现了配置接口。这个模拟版本不是从 <code>config.ini</code> 读取数据，而是直接返回硬编码的值或测试时动态设置的值。</p></li><li><p><strong>在测试中使用模拟对象</strong>：在单元测试中，使用这个模拟的配置对象而不是实际的配置读取逻辑。这样，测试不再依赖于外部的 <code>config.ini</code> 文件。</p></li></ol><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">interface</span> &#123;<br>    GetValue(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> MockConfig <span class="hljs-keyword">struct</span> &#123;<br>    values <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m MockConfig)</span></span> GetValue(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> m.values[key]<br>&#125;<br><br><span class="hljs-comment">// 在测试中使用 MockConfig</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSomeFunction</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    mockConfig := MockConfig&#123;<br>        values: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>            <span class="hljs-string">&quot;key1&quot;</span>: <span class="hljs-string">&quot;testValue1&quot;</span>,<br>            <span class="hljs-string">&quot;key2&quot;</span>: <span class="hljs-string">&quot;testValue2&quot;</span>,<br>        &#125;,<br>    &#125;<br><br>    result := SomeFunction(mockConfig)<br>    <span class="hljs-comment">// 断言和验证 result</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法有助于使单元测试独立于外部环境，使其更加稳定和可靠。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>单元测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go类型和接口技巧</title>
    <link href="/2024/01/10/mdstorage/domain/golang/Go%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%8A%80%E5%B7%A7/"/>
    <url>/2024/01/10/mdstorage/domain/golang/Go%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="编译时检查类型实现接口-类型断言"><a href="#编译时检查类型实现接口-类型断言" class="headerlink" title="编译时检查类型实现接口&#x2F;类型断言"></a>编译时检查类型实现接口&#x2F;类型断言</h2><p>在 Go 语言中，这行代码 <code>var _ interfaces.CoreServer = (*serverService)(nil)</code> 是一种常用的编译时类型断言惯用法。这行代码并不会在运行时创建变量，而是起到两个主要作用：</p><ol><li><p><strong>确保类型实现了接口</strong>：它断言 <code>serverService</code> 实现了 <code>interfaces.CoreServer</code> 接口。如果 <code>serverService</code> 没有实现 <code>interfaces.CoreServer</code> 接口的所有方法，程序将无法编译。这是一种在编译阶段而非运行时检查接口实现的方式。</p></li><li><p><strong>文档作用</strong>：这行代码还作为明确的文档说明。它向阅读代码的开发人员清楚地显示 <code>serverService</code> 旨在实现 <code>interfaces.CoreServer</code> 接口。在大型代码库中，这种表示方法特别有用，因为接口及其实现之间的关系可能不会立即清楚。</p></li></ol><p>本质上，这是一个静态检查，确保 <code>serverService</code> 正确实现了 <code>interfaces.CoreServer</code> 接口。如果实现缺少任何方法，你将在编译时而不是运行时发现错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> serverService <span class="hljs-keyword">struct</span> &#123;<br>corev1.UnimplementedCoreServiceServer<br>ctx     context.Context<br>options options.SrviceOption<br>streams <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]corev1.CoreService_AgentServer<br>mu      sync.RWMutex<br>&#125;<br><br><span class="hljs-keyword">var</span> _ interfaces.CoreServer = (*serverService)(<span class="hljs-literal">nil</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServerService</span><span class="hljs-params">(ctx context.Context, options options.SrviceOption)</span></span> interfaces.CoreServer &#123;<br><span class="hljs-keyword">return</span> &amp;serverService&#123;<br>ctx:     ctx,<br>options: options,<br>streams: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]corev1.CoreService_AgentServer),<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口组合"><a href="#接口组合" class="headerlink" title="接口组合"></a>接口组合</h2><ol><li><p><strong>接口组合</strong>：Go 允许通过组合小的接口来创建更大的接口。这是接口重用和模块化设计的有效方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123;<br>    Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> &#123;<br>    Write(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> &#123;<br>    Reader<br>    Writer<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="空接口应用"><a href="#空接口应用" class="headerlink" title="空接口应用"></a>空接口应用</h2><p><strong>空接口应用</strong>：空接口 <code>interface&#123;&#125;</code> 可以用来处理未知类型的值。这在处理动态内容时非常有用，类似于其他语言中的泛型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PrintAnything</span><span class="hljs-params">(v <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>    fmt.Println(v)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h2><p><strong>类型选择（Type Switch）</strong>：可以使用类型选择来查询接口值的类型，这在需要根据类型执行不同操作时非常有用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> v := myVar.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:<br>    fmt.Println(<span class="hljs-string">&quot;Integer:&quot;</span>, v)<br><span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>    fmt.Println(<span class="hljs-string">&quot;String:&quot;</span>, v)<br><span class="hljs-keyword">default</span>:<br>    fmt.Println(<span class="hljs-string">&quot;Unknown type&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QARs概述.md</title>
    <link href="/2024/01/10/mdstorage/domain/%E6%9E%B6%E6%9E%84/QARs%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/01/10/mdstorage/domain/%E6%9E%B6%E6%9E%84/QARs%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>“QARs”（Quality Attribute Requirements）指的是软件工程中的质量属性需求。这些需求通常与软件的非功能特性有关，例如性能、安全性、可靠性、可用性、维护性和可扩展性。它们是软件设计和评估的重要组成部分，用于确保软件产品不仅满足其功能需求，还能以满足用户期望的方式运行。</p><p>举几个例子：</p><ol><li><strong>性能</strong>：软件响应时间、处理速度、资源使用效率等。</li><li><strong>安全性</strong>：保护软件免受未授权访问和攻击。</li><li><strong>可靠性</strong>：软件的稳定性和故障恢复能力。</li><li><strong>可用性</strong>：软件的易用性和用户界面设计。</li><li><strong>维护性</strong>：软件的可维护性，包括代码的可读性和模块化程度。</li><li><strong>可扩展性</strong>：软件的扩展能力，支持未来的增长或变化。</li></ol><p>质量属性需求通常由利益相关者提出，并在软件开发的整个生命周期中进行管理和评估。这些需求帮助团队确定设计选择、技术栈和测试策略。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ol><li><p><strong>需求识别与收集</strong>：</p><ul><li>在这个阶段，与项目相关的所有利益相关者（如用户、客户、项目经理、开发者）会一起确定和讨论软件应该达到的质量标准。</li><li>这包括定义性能、安全性、可靠性、可用性等方面的具体需求。</li><li>这些需求通常是基于用户的期望、市场标准或行业规范。</li></ul></li><li><p><strong>分析与规划</strong>：</p><ul><li>在此阶段，对收集到的需求进行分析，确定它们的可行性、优先级和对开发过程的影响。</li><li>然后，将这些需求转化为具体的设计和实施计划。</li><li>这可能涉及技术选择、架构决策、资源分配和时间表的设定。</li></ul></li><li><p><strong>设计</strong>：</p><ul><li>设计阶段涉及将 QARs 融入软件架构和设计决策中。</li><li>设计团队需要确保软件架构支持这些需求，例如通过采用模块化设计来提高可维护性，或者通过合适的数据加密技术来确保安全性。</li></ul></li><li><p><strong>实现</strong>：</p><ul><li>在实现阶段，开发团队编写代码并构建系统，同时确保所有的 QARs 得到满足。</li><li>这可能包括编写特定的代码来处理性能优化、安全性措施等。</li></ul></li><li><p><strong>测试与验证</strong>：</p><ul><li>在这个阶段，软件通过各种测试来验证是否满足 QARs。</li><li>这包括性能测试、安全测试、可用性测试等。</li><li>测试结果用于确认软件是否符合既定的质量标准。</li></ul></li><li><p><strong>部署与维护</strong>：</p><ul><li>软件部署后，将持续监控其性能和其他质量指标，确保它们符合 QARs。</li><li>在维护阶段，可能需要对软件进行更新或改进，以维持或提高质量标准。</li></ul></li><li><p><strong>评估与反馈</strong>：</p><ul><li>最后，定期评估软件的整体质量，收集用户和利益相关者的反馈。</li><li>这些信息可用于未来项目的 QARs 制定和改进。</li></ul></li></ol><h3 id="角色维度"><a href="#角色维度" class="headerlink" title="角色维度"></a>角色维度</h3><ol><li><p><strong>利益相关者（Stakeholders）</strong>：</p><ul><li>需求识别与收集阶段：提供对软件质量的期望和需求，如业务目标、用户体验需求等。</li><li>评估与反馈阶段：对软件的实际性能和质量提供反馈。</li></ul></li><li><p><strong>产品经理（Product Managers）</strong>：</p><ul><li>需求识别与收集阶段：理解和记录业务需求，确保需求与业务目标一致。</li><li>分析与规划阶段：确定需求的优先级，规划产品路线图。</li><li>评估与反馈阶段：确保软件满足市场需求和用户期望，评估用户反馈。</li></ul></li><li><p><strong>系统架构师（System Architects）</strong>：</p><ul><li>分析与规划阶段：基于QARs设计软件架构，确保架构支持所有的质量属性。</li><li>设计阶段：决定技术方案，规划整体系统设计。</li></ul></li><li><p><strong>开发团队（Developers）</strong>：</p><ul><li>设计阶段：根据架构和设计决策进行编码。</li><li>实现阶段：编写代码，实现功能的同时确保符合QARs。</li></ul></li><li><p><strong>质量保证团队（Quality Assurance）</strong>：</p><ul><li>测试与验证阶段：执行各种测试，包括性能测试、安全性测试等，以确保软件符合QARs。</li><li>部署与维护阶段：监控软件性能，识别和报告问题。</li></ul></li><li><p><strong>运维团队（Operations Team）</strong>：</p><ul><li>部署与维护阶段：部署软件，监控运行环境，确保软件的稳定性和性能。</li><li>评估与反馈阶段：提供实际运行中的性能和稳定性反馈。</li></ul></li></ol><h2 id="场景用例"><a href="#场景用例" class="headerlink" title="场景用例"></a>场景用例</h2><p>维护性是软件的一个关键质量属性，它涉及到软件在未来的可支持性、可改进性和可适应性。一个具有高维护性的软件可以更容易、更经济地被修改和更新，这对开发团队来说是一个重要的考虑因素。以下是如何将这个目标融入QARs的几个要点：</p><ol><li><strong>代码质量</strong>：确保代码易于理解和修改。这包括良好的代码结构、清晰的命名约定和充分的注释。</li><li><strong>文档</strong>：提供详细的文档，包括设计决策、代码库的结构和功能描述，以及开发和维护指南。</li><li><strong>模块化设计</strong>：采用模块化设计原则，使得各个部分的代码相对独立，易于管理和维护。</li><li><strong>自动化测试</strong>：实施自动化测试以确保代码更改不会意外破坏现有功能，减少维护时的风险和工作量。</li><li><strong>代码复用和标准化</strong>：鼓励代码复用和遵循编程标准，以减少重复工作和提高代码的一致性。</li><li><strong>技术债务管理</strong>：定期评估和解决技术债务，防止过时的代码和设计决策增加未来的维护负担。</li></ol><p>当产品需求与模块化设计发生冲突时，这通常是一个挑战，因为它涉及到平衡具体功能的实现与保持系统整体架构清晰和可维护性之间的矛盾。在这种情况下，可以采取以下步骤来解决这个问题：</p><ol><li><p><strong>详细评估冲突</strong>：</p><ul><li>准确地识别冲突点。是需求太复杂，无法适应现有的模块结构？还是模块化设计过于严格，限制了功能的实现？</li><li>分析冲突对项目目标和长期维护的影响。</li></ul></li><li><p><strong>利益相关者沟通</strong>：</p><ul><li>将冲突情况和可能的影响清晰地传达给项目利益相关者，包括产品经理、开发团队和客户。</li><li>讨论各种选择的利弊，包括对时间表、成本、产品质量和维护的影响。</li></ul></li><li><p><strong>探索替代方案</strong>：</p><ul><li>寻找能够满足需求同时尽量保持模块化完整性的替代解决方案。</li><li>这可能包括重新设计某些模块、调整需求或找到创新的技术解决方案。</li></ul></li><li><p><strong>权衡与决策</strong>：</p><ul><li>基于详细分析和讨论，进行权衡决策。在某些情况下，可能需要对原有的模块化设计进行调整以适应新的需求。</li><li>在其他情况下，可能需要修改或简化需求以保持系统的模块化和可维护性。</li></ul></li><li><p><strong>实施与监控</strong>：</p><ul><li>实施决定的解决方案，并密切监控其对整个系统的影响。</li><li>确保在实施过程中保持代码质量和系统的整体完整性。</li></ul></li><li><p><strong>持续评估</strong>：</p><ul><li>在后续的开发周期中，持续评估所做决策的效果。</li><li>如果必要，进行调整以确保项目目标的实现和系统的长期可维护性。</li></ul></li></ol><p>关键是在保持系统的整体架构和设计原则的同时，灵活地应对特定需求的挑战。这要求开发团队、产品经理和其他利益相关者之间有良好的沟通和协作。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件关键质量属性.md</title>
    <link href="/2024/01/10/mdstorage/domain/%E6%9E%B6%E6%9E%84/%E8%BD%AF%E4%BB%B6%E5%85%B3%E9%94%AE%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7/"/>
    <url>/2024/01/10/mdstorage/domain/%E6%9E%B6%E6%9E%84/%E8%BD%AF%E4%BB%B6%E5%85%B3%E9%94%AE%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>软件的关键质量属性通常涵盖了软件系统不同方面的非功能特性。这些质量属性对于确保软件系统满足用户的需求和预期至关重要。主要的软件关键质量属性包括：</p><ol><li><p><strong>性能</strong>：涉及软件的响应时间、处理速度、资源消耗等。性能好的软件能够高效地执行并满足用户对速度和效率的期望。</p></li><li><p><strong>可靠性</strong>：指软件的稳定性和准确性。高可靠性的软件能够在预期的时间和条件下无故障地运行。</p></li><li><p><strong>可用性</strong>：涉及软件的易用性和用户界面的友好性。易于使用的软件可以提高用户满意度和生产效率。</p></li><li><p><strong>安全性</strong>：包括数据保护、访问控制和抵御恶意攻击的能力。安全性是特别重要的，尤其是对于处理敏感信息的软件。</p></li><li><p><strong>可维护性</strong>：指的是软件的修改和更新的容易程度。高可维护性的软件可以更快速、成本更低地进行更新和修复。</p></li><li><p><strong>可扩展性</strong>：软件适应增加的负载或功能变化的能力。可扩展的系统能够容纳业务增长和技术变革。</p></li><li><p><strong>兼容性</strong>：软件与其他系统、设备或软件版本之间的兼容性。这对于确保软件在不同环境中的正常运行非常重要。</p></li><li><p><strong>可移植性</strong>：软件从一个环境迁移到另一个环境的能力。这包括不同操作系统、硬件或网络环境的适应性。</p></li><li><p><strong>可测试性</strong>：软件的测试容易程度，包括识别缺陷和验证功能的能力。</p></li><li><p><strong>国际化和本地化</strong>：软件适应不同地区语言和文化的能力，这对于全球市场中的软件尤为重要。</p></li></ol><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ol><li><p><strong>规划阶段</strong>：</p><ul><li>在软件项目的初始阶段，首先要确定关键质量属性的需求和优先级。这包括性能、可靠性、可用性、安全性等。</li><li>在这一阶段，需求分析师和项目经理会与利益相关者协商，确定哪些质量属性对项目最为关键，并据此制定相应的目标和指标。</li></ul></li><li><p><strong>设计阶段</strong>：</p><ul><li>设计团队需要确保软件架构和设计能够支持这些质量属性的要求。例如，为了提高性能，可能需要选择更高效的数据结构和算法。</li><li>安全性、可维护性和可扩展性也是在设计阶段需要考虑的重要因素，通过适当的架构设计来确保这些属性。</li></ul></li><li><p><strong>开发阶段</strong>：</p><ul><li>开发团队在编写代码时，需要遵循既定的编码标准和实践，以确保软件质量。例如，代码的可读性和测试性对于保证可维护性至关重要。</li><li>在这一阶段，对性能和安全性的关注也非常重要，特别是在处理大量数据或敏感信息时。</li></ul></li><li><p><strong>测试阶段</strong>：</p><ul><li>软件测试是验证和确保软件满足其质量属性要求的关键环节。性能测试、安全测试、可用性测试等都是必不可少的。</li><li>测试结果帮助确定是否需要进一步的优化或改进以满足质量标准。</li></ul></li><li><p><strong>部署阶段</strong>：</p><ul><li>在软件部署时，运维团队需确保软件的性能和稳定性符合预期，特别是在不同的部署环境中。</li><li>此阶段还需要考虑到软件的可维护性和可扩展性，以应对未来可能的变更和升级。</li></ul></li><li><p><strong>维护阶段</strong>：</p><ul><li>在软件的维护阶段，持续监控软件性能和稳定性，同时响应用户反馈和需求变更。</li><li>定期的维护和更新有助于保持软件的安全性和兼容性，同时也是可持续性的一个关键方面。</li></ul></li><li><p><strong>退役阶段</strong>：</p><ul><li>当软件到达生命周期的末端时，需要有计划地进行退役，确保数据的安全迁移和资源的有效释放。</li><li>在这个阶段，还要考虑如何处理遗留数据和与其他系统的集成问题。</li></ul></li></ol><h3 id="软件关键质量属性持续进化"><a href="#软件关键质量属性持续进化" class="headerlink" title="软件关键质量属性持续进化"></a>软件关键质量属性持续进化</h3><ol><li><p><strong>持续的需求分析和调整</strong>：</p><ul><li>在项目的每个阶段都重新评估和精细化质量属性的需求。</li><li>适应变化的业务需求、技术环境和用户期望。</li></ul></li><li><p><strong>迭代的设计和开发</strong>：</p><ul><li>采用敏捷或迭代的开发方法，允许在项目周期中不断调整设计和开发工作。</li><li>在每个迭代阶段考虑质量属性，并根据反馈和测试结果进行优化。</li></ul></li><li><p><strong>持续集成和持续部署（CI&#x2F;CD）</strong>：</p><ul><li>实施持续集成和持续部署流程，允许频繁地集成新代码和功能。</li><li>这样可以及时发现和修正影响质量属性的问题。</li></ul></li><li><p><strong>定期的性能和质量测试</strong>：</p><ul><li>定期进行性能测试、安全测试、可用性测试等，确保在整个项目周期中持续满足质量标准。</li><li>利用自动化测试工具来提高测试的效率和频率。</li></ul></li><li><p><strong>反馈循环</strong>：</p><ul><li>从用户和利益相关者那里收集反馈，并将这些反馈整合到项目的下一个迭代或阶段中。</li><li>使用用户故事、反馈会议和评审会议来了解用户的需求和体验。</li></ul></li><li><p><strong>质量度量和监控</strong>：</p><ul><li>利用质量度量工具来持续监控软件的关键质量属性。</li><li>这些度量可以包括性能指标、故障率、用户满意度等。</li></ul></li><li><p><strong>敏捷和灵活的项目管理</strong>：</p><ul><li>采用敏捷的项目管理方法，以灵活地应对变化和挑战。</li><li>保持团队成员之间的密切沟通和协作，以快速响应变化。</li></ul></li><li><p><strong>技术债务管理</strong>：</p><ul><li>定期评估和管理技术债务，确保长期的维护性和可扩展性。</li><li>避免短期的解决方案损害长期的质量目标。</li></ul></li></ol><h3 id="角色和关注维度"><a href="#角色和关注维度" class="headerlink" title="角色和关注维度"></a>角色和关注维度</h3><p>软件关键质量属性的关注点和责任在项目的不同阶段由不同角色承担。以下是各个角色及其在不同项目阶段对软件关键质量属性的关注重点：</p><ol><li><p><strong>需求分析师&#x2F;业务分析师</strong>：</p><ul><li><strong>需求收集阶段</strong>：识别和记录软件的质量属性需求，如性能、安全性、可用性等，确保它们符合业务目标和用户需求。</li></ul></li><li><p><strong>产品经理</strong>：</p><ul><li><strong>规划和定义阶段</strong>：确定产品的目标和愿景，包括质量属性的优先级设定。</li><li><strong>整个项目周期</strong>：确保产品满足市场需求，并且在整个项目生命周期中保持对质量属性的关注。</li></ul></li><li><p><strong>系统架构师&#x2F;软件架构师</strong>：</p><ul><li><strong>设计阶段</strong>：设计软件架构时考虑如何支持和实现这些质量属性，如选择适当的架构模式和技术栈。</li><li><strong>开发阶段</strong>：确保架构决策能够满足预定的质量要求。</li></ul></li><li><p><strong>开发团队（软件开发人员）</strong>：</p><ul><li><strong>实现阶段</strong>：编写代码时考虑如何实现这些质量属性，例如编写高效、可维护的代码。</li><li><strong>测试阶段</strong>：参与单元测试和集成测试，以确保代码质量。</li></ul></li><li><p><strong>质量保证团队（QA工程师）</strong>：</p><ul><li><strong>测试阶段</strong>：通过功能测试、性能测试、安全测试等，确保软件满足既定的质量标准。</li><li><strong>维护阶段</strong>：监控软件性能和稳定性，确保长期满足质量要求。</li></ul></li><li><p><strong>项目经理&#x2F;Scrum主管</strong>：</p><ul><li><strong>整个项目周期</strong>：监控项目进度和资源分配，确保有足够的时间和资源来满足质量目标。</li><li><strong>风险管理阶段</strong>：识别可能影响质量属性的风险并制定应对策略。</li></ul></li><li><p><strong>运维团队（DevOps工程师）</strong>：</p><ul><li><strong>部署和运维阶段</strong>：部署软件并监控其在生产环境中的表现，特别是性能和稳定性方面。</li><li><strong>维护阶段</strong>：及时响应性能下降或安全问题，并实施必要的维护工作。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flutter使用.md</title>
    <link href="/2024/01/04/mdstorage/domain/dart/flutter%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/01/04/mdstorage/domain/dart/flutter%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="1-Widgets"><a href="#1-Widgets" class="headerlink" title="1. Widgets"></a>1. <strong>Widgets</strong></h3><ul><li><strong>基础</strong>: 在 Flutter 中，几乎所有东西都是一个 Widget —— 它是构建界面的基本单位。Widgets 描述了它们在当前配置和状态下应该呈现的 UI。</li><li><strong>类型</strong>: 有两种主要类型的 Widgets —— StatelessWidget 和 StatefulWidget。StatelessWidget 不变，而 StatefulWidget 持有状态，并且可以在其生命周期内改变。</li></ul><h3 id="2-Widget-树和渲染流程"><a href="#2-Widget-树和渲染流程" class="headerlink" title="2. Widget 树和渲染流程"></a>2. <strong>Widget 树和渲染流程</strong></h3><ul><li><strong>Widget 树</strong>: 应用的界面是由 Widgets 组成的树状结构。每个 Widget 嵌套在其父 Widget 中，并且可能有多个子 Widget。</li><li><strong>渲染流程</strong>: 当 Widget 的状态改变时（在 StatefulWidget 中），Flutter 框架会重建 Widget 树的一部分，这导致界面更新。</li></ul><h3 id="3-状态管理"><a href="#3-状态管理" class="headerlink" title="3. 状态管理"></a>3. <strong>状态管理</strong></h3><ul><li><strong>状态</strong>: 在 Flutter 中，状态是指应用数据或 UI 状态的当前配置。状态管理是指如何创建、显示和维护这些状态。</li><li><strong>方法</strong>: 有多种方式可以管理状态，包括局部状态管理（如 StatefulWidget）和全局状态管理（如 Provider、Bloc、Redux）。</li></ul><h3 id="4-布局和约束"><a href="#4-布局和约束" class="headerlink" title="4. 布局和约束"></a>4. <strong>布局和约束</strong></h3><ul><li><strong>布局</strong>: Flutter 使用一种强大且灵活的布局系统。Widgets 通过它们的父 Widget 提供的约束来确定自己的大小和位置。</li><li><strong>常用布局 Widgets</strong>: 如 <code>Row</code>、<code>Column</code>、<code>Stack</code>、<code>Container</code> 等，它们各自有不同的布局行为。</li></ul><h3 id="5-导航和路由"><a href="#5-导航和路由" class="headerlink" title="5. 导航和路由"></a>5. <strong>导航和路由</strong></h3><ul><li><strong>导航</strong>: 在 Flutter 应用中从一个屏幕（页面）导航到另一个屏幕。</li><li><strong>路由</strong>: 路由是应用的屏幕或页面。Flutter 提供了 <code>Navigator</code> 类来管理路由栈。</li></ul><h3 id="6-异步编程"><a href="#6-异步编程" class="headerlink" title="6. 异步编程"></a>6. <strong>异步编程</strong></h3><ul><li><strong>异步操作</strong>: 如 API 调用或数据库操作，这些操作不会立即完成并返回结果。</li><li><strong>Future 和 Stream</strong>: Dart 的 Future 和 Stream 用于处理异步数据。</li></ul><h3 id="7-动画和动态交互"><a href="#7-动画和动态交互" class="headerlink" title="7. 动画和动态交互"></a>7. <strong>动画和动态交互</strong></h3><ul><li>Flutter 提供了强大的动画库来创建平滑和复杂的动画。</li><li>了解如何使用 <code>AnimationController</code>、<code>Tween</code> 等来创建动画效果。</li></ul><h3 id="8-包和插件"><a href="#8-包和插件" class="headerlink" title="8. 包和插件"></a>8. <strong>包和插件</strong></h3><ul><li>使用外部包和插件来增强应用的功能。</li><li>如何在 <code>pubspec.yaml</code> 中添加依赖，并使用 Dart Packages 中的资源。</li></ul><h3 id="9-测试"><a href="#9-测试" class="headerlink" title="9. 测试"></a>9. <strong>测试</strong></h3><ul><li>测试是确保应用质量和性能的关键部分。Flutter 支持单元测试、组件测试和集成测试。</li></ul><h3 id="10-性能优化"><a href="#10-性能优化" class="headerlink" title="10. 性能优化"></a>10. <strong>性能优化</strong></h3><ul><li>了解如何诊断性能问题并优化 Flutter 应用以提高效率和响应速度。</li></ul><h3 id="11-国际化和本地化"><a href="#11-国际化和本地化" class="headerlink" title="11. 国际化和本地化"></a>11. <strong>国际化和本地化</strong></h3><ul><li>支持多语言和本地文化，确保应用可以在全球范围内使用。</li></ul><h3 id="12-Flutter-2-0-之后的新特性"><a href="#12-Flutter-2-0-之后的新特性" class="headerlink" title="12. Flutter 2.0 之后的新特性"></a>12. <strong>Flutter 2.0 之后的新特性</strong></h3><ul><li>如果你已经是 Flutter 的经验开发者，那么了解自 Flutter 2.0 以来引入的新特性（如空安全、新的渲染引擎等）也很重要。</li></ul><h2 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h2><p>在 Flutter 中，<code>StatefulWidget</code> 是一种当其状态可能在其生命周期内发生变化时使用的 Widget。以下是一个<code>StatefulWidget</code>的示例，它演示了一个简单的计数器应用，以及对其各部分的解释：</p><h3 id="示例：简单计数器"><a href="#示例：简单计数器" class="headerlink" title="示例：简单计数器"></a>示例：简单计数器</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MyApp());<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      title: <span class="hljs-string">&#x27;Stateful Widget Demo&#x27;</span>,<br>      home: CounterScreen(),<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  _CounterScreenState createState() =&gt; _CounterScreenState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_CounterScreenState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">CounterScreen</span>&gt; </span>&#123;<br>  <span class="hljs-built_in">int</span> _counter = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">void</span> _incrementCounter() &#123;<br>    setState(() &#123;<br>      _counter++;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&#x27;Stateful Widget Example&#x27;</span>),<br>      ),<br>      body: Center(<br>        child: Column(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: &lt;Widget&gt;[<br>            Text(<span class="hljs-string">&#x27;You have pushed the button this many times:&#x27;</span>),<br>            Text(<br>              <span class="hljs-string">&#x27;<span class="hljs-subst">$_counter</span>&#x27;</span>,<br>              style: Theme.of(context).textTheme.headline4,<br>            ),<br>          ],<br>        ),<br>      ),<br>      floatingActionButton: FloatingActionButton(<br>        onPressed: _incrementCounter,<br>        tooltip: <span class="hljs-string">&#x27;Increment&#x27;</span>,<br>        child: Icon(Icons.add),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><ul><li><p><strong>MyApp 类</strong>:</p><ul><li><code>MyApp</code> 继承自 <code>StatelessWidget</code>，因为它本身不需要维护任何状态。</li><li><code>build</code> 方法返回一个 <code>MaterialApp</code>，其 <code>home</code> 属性设置为 <code>CounterScreen</code>。</li></ul></li><li><p><strong>CounterScreen 类</strong>:</p><ul><li><code>CounterScreen</code> 是一个 <code>StatefulWidget</code>。当你需要根据用户交互或其他因素来改变 Widget 的显示时，你应该使用 <code>StatefulWidget</code>。</li><li>它重写了 <code>createState</code> 方法来创建 <code>_CounterScreenState</code> 的实例。</li></ul></li><li><p><strong>_CounterScreenState 类</strong>:</p><ul><li><code>_CounterScreenState</code> 类包含了 <code>CounterScreen</code> 的状态。</li><li>它定义了一个 <code>_counter</code> 变量来存储计数器的值，并且有一个 <code>_incrementCounter</code> 方法来增加计数器的值。</li><li>每次调用 <code>_incrementCounter</code> 方法时，都会通过调用 <code>setState</code> 来更新界面。<code>setState</code> 会触发框架调用 <code>_CounterScreenState</code> 的 <code>build</code> 方法，从而更新 UI。</li></ul></li><li><p><strong>build 方法</strong>:</p><ul><li><code>build</code> 方法构建并返回一个 <code>Scaffold</code>，包含一个 <code>AppBar</code>、一个显示计数器值的 <code>Text</code>，以及一个用于增加计数器值的 <code>FloatingActionButton</code>。</li><li>每当用户点击 <code>FloatingActionButton</code> 时，都会调用 <code>_incrementCounter</code> 方法。</li></ul></li></ul><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>将状态逻辑保持在 <code>State</code> 类中，而不是在 <code>StatefulWidget</code> 中。</li><li>使用 <code>setState</code> 来更新状态，这会导致 Flutter 重建 UI。</li><li>尽量保持 <code>State</code> 对象的简洁，避免过度膨胀。</li></ul><p>通过使用 <code>StatefulWidget</code>，你可以创建可以动态改变的交互式界面。在上面的例子中，每次点击按钮，计数器的值都会增加，并且界面会相应地更新显示新的值。</p><h2 id="StatelessWidget"><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h2><p>在 Flutter 中，<code>StatelessWidget</code> 是一种不可变的 widget，它不会改变其状态。它非常适合用于不需要响应任何内部状态改变的 UI 部分。以下是一个简单的 <code>StatelessWidget</code> 最佳实践示例，以及对其各部分的解释：</p><h3 id="显示静态文本的-StatelessWidget"><a href="#显示静态文本的-StatelessWidget" class="headerlink" title="显示静态文本的 StatelessWidget"></a>显示静态文本的 StatelessWidget</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MyApp());<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      title: <span class="hljs-string">&#x27;Stateless Widget Demo&#x27;</span>,<br>      home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&#x27;Stateless Widget Example&#x27;</span>),<br>        ),<br>        body: Center(<br>          child: GreetingText(),<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingText</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Text(<br>      <span class="hljs-string">&#x27;Hello, Flutter!&#x27;</span>,<br>      style: TextStyle(fontSize: <span class="hljs-number">24</span>, fontWeight: FontWeight.bold),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解释：-1"><a href="#解释：-1" class="headerlink" title="解释："></a>解释：</h3><ul><li><p><strong>导入必要的包</strong>:</p><ul><li><code>import &#39;package:flutter/material.dart&#39;;</code> 导入了 Flutter Material 库，这是构建 Material Design 应用的核心库。</li></ul></li><li><p><strong>主函数 (<code>main</code>)</strong>:</p><ul><li><code>void main() &#123; runApp(MyApp()); &#125;</code>: 这是每个 Flutter 应用的入口点。<code>runApp</code> 函数接收一个 <code>Widget</code> 并使其成为 widget 树的根。</li></ul></li><li><p><strong>MyApp 类</strong>:</p><ul><li><code>MyApp</code> 类扩展了 <code>StatelessWidget</code>，这意味着 <code>MyApp</code> 是不可变的，并且其属性不会随时间改变。</li><li><code>build</code> 方法返回一个 <code>MaterialApp</code> 实例，它是 Material Design 应用的根 Widget。</li></ul></li><li><p><strong>MaterialApp</strong>:</p><ul><li><code>MaterialApp</code> 是一个便利的 widget，它封装了多个用于 Material Design 应用程序的 widgets。</li><li><code>title</code> 属性定义了应用的标题。</li><li><code>home</code> 属性是应用的主屏幕，这里是一个 <code>Scaffold</code>。</li></ul></li><li><p><strong>Scaffold</strong>:</p><ul><li><code>Scaffold</code> 是一个提供默认的导航栏、标题和包含主屏幕 widget 树的 body 属性的 widget。</li><li><code>appBar</code> 定义了应用的顶部栏。</li><li><code>body</code> 是一个 <code>Center</code> widget，它包含了自定义的 <code>GreetingText</code> widget。</li></ul></li><li><p><strong>GreetingText 类</strong>:</p><ul><li><code>GreetingText</code> 也是一个 <code>StatelessWidget</code>，它的 <code>build</code> 方法返回一个 <code>Text</code> widget，显示 “Hello, Flutter!”。</li><li><code>TextStyle</code> 用于设置文本的样式，如字体大小和权重。</li></ul></li></ul><h3 id="最佳实践："><a href="#最佳实践：" class="headerlink" title="最佳实践："></a>最佳实践：</h3><ul><li><strong>简洁性</strong>: <code>StatelessWidget</code> 应保持简洁，只包含必要的 UI 元素。</li><li><strong>无状态</strong>: 由于 <code>StatelessWidget</code> 不保存任何状态，它们应用于不需要响应任何状态更改的 UI 部分。</li><li><strong>重用性</strong>: 将常用的 UI 部分封装在 <code>StatelessWidget</code> 中，以提高代码的重用性。</li></ul><p>这个示例展示了如何使用 <code>StatelessWidget</code> 创建基础的静态 UI。理解和熟练使用 <code>StatelessWidget</code> 是学习 Flutter 的重要一步。</p><h2 id="State-类"><a href="#State-类" class="headerlink" title="State 类"></a>State 类</h2><p>在 Flutter 中，<code>State</code> 类是与 <code>StatefulWidget</code> 紧密相关的，用于管理 <code>StatefulWidget</code> 的状态。<code>State</code> 对象存储了状态信息并提供了构建与其关联的 <code>StatefulWidget</code> 的界面的逻辑。以下是一个使用 <code>State</code> 类的示例，包括一个简单的计数器应用及其解释。</p><h3 id="示例：简单计数器-1"><a href="#示例：简单计数器-1" class="headerlink" title="示例：简单计数器"></a>示例：简单计数器</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(MyApp());<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      title: <span class="hljs-string">&#x27;State Class Demo&#x27;</span>,<br>      home: CounterScreen(),<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  _CounterScreenState createState() =&gt; _CounterScreenState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_CounterScreenState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">CounterScreen</span>&gt; </span>&#123;<br>  <span class="hljs-built_in">int</span> _counter = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">void</span> _incrementCounter() &#123;<br>    setState(() &#123;<br>      _counter++;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&#x27;State Class Example&#x27;</span>),<br>      ),<br>      body: Center(<br>        child: Column(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: &lt;Widget&gt;[<br>            Text(<span class="hljs-string">&#x27;You have pushed the button this many times:&#x27;</span>),<br>            Text(<br>              <span class="hljs-string">&#x27;<span class="hljs-subst">$_counter</span>&#x27;</span>,<br>              style: Theme.of(context).textTheme.headline4,<br>            ),<br>          ],<br>        ),<br>      ),<br>      floatingActionButton: FloatingActionButton(<br>        onPressed: _incrementCounter,<br>        tooltip: <span class="hljs-string">&#x27;Increment&#x27;</span>,<br>        child: Icon(Icons.add),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解释：-2"><a href="#解释：-2" class="headerlink" title="解释："></a>解释：</h3><ol><li><p><strong><code>CounterScreen</code> 类</strong>:</p><ul><li>这是一个 <code>StatefulWidget</code>。它重写了 <code>createState()</code> 方法来创建 <code>_CounterScreenState</code> 的实例。</li></ul></li><li><p><strong><code>_CounterScreenState</code> 类</strong>:</p><ul><li><code>_CounterScreenState</code> 类扩展了 <code>State&lt;CounterScreen&gt;</code>，表明这是 <code>CounterScreen</code> 的状态。</li><li>它包含一个 <code>_counter</code> 变量，这是它的状态（在这个例子中是计数器的值）。</li><li><code>_incrementCounter()</code> 方法用于递增 <code>_counter</code> 变量。在这个方法中，调用 <code>setState()</code> 会通知 Flutter 框架这个状态对象的状态已改变，导致它重新运行 <code>build()</code> 方法，从而更新 UI。</li><li><code>build()</code> 方法构建并返回一个 <code>Scaffold</code> widget，显示计数器的值并包含一个增加计数器的按钮。</li></ul></li></ol><h3 id="最佳实践：-1"><a href="#最佳实践：-1" class="headerlink" title="最佳实践："></a>最佳实践：</h3><ul><li><strong>封装状态</strong>：将状态封装在 <code>State</code> 类中，而不是直接在 <code>StatefulWidget</code> 中。这有助于代码的组织和可读性。</li><li>**使用 <code>setState()</code>**：当状态改变时，使用 <code>setState()</code> 更新状态。这会通知框架需要重建 UI。</li><li><strong>最小化 <code>build()</code> 方法的工作</strong>：<code>build()</code> 方法可能会频繁调用，因此应避免在其中放置过多的逻辑。将计算和复杂的操作移到 <code>build()</code> 方法之外。</li><li><strong>管理资源</strong>：对于需要监听器或订阅的资源，应在 <code>State</code> 对象的 <code>initState()</code> 中进行初始化，在 <code>dispose()</code> 中进行清理，以避免内存泄漏。</li></ul><p>通过使用 <code>StatefulWidget</code> 和 <code>State</code> 类，您可以创建动态且响应式的用户界面，其内容可以根据用户交互或内部状态的变化而改变。</p><p>要使另一个 <code>StatefulWidget</code> 监听 <code>_counter</code> 变量的变化，我们需要使用一种状态管理解决。在 Flutter 中，有多种方式来实现跨 widget 的状态共享和监听，例如使用 <code>Provider</code>、<code>InheritedWidget</code>、<code>Bloc</code> 或简单的回调。以下是使用回调和 <code>Provider</code> 包的两种方法：</p><h3 id="方法-1-使用回调"><a href="#方法-1-使用回调" class="headerlink" title="方法 1: 使用回调"></a>方法 1: 使用回调</h3><p>如果你只需要简单地在几个 widget 之间共享状态，可以使用回调函数。</p><p>首先，修改 <code>CounterScreen</code>，使它接受一个回调函数，并在 <code>_incrementCounter</code> 方法中调用这个回调：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">int</span>) onCounterChanged;<br><br>  CounterScreen(&#123;<span class="hljs-keyword">this</span>.onCounterChanged&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  _CounterScreenState createState() =&gt; _CounterScreenState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_CounterScreenState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">CounterScreen</span>&gt; </span>&#123;<br>  <span class="hljs-built_in">int</span> _counter = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">void</span> _incrementCounter() &#123;<br>    setState(() &#123;<br>      _counter++;<br>    &#125;);<br>    widget.onCounterChanged?.call(_counter);<br>  &#125;<br><br>  <span class="hljs-comment">// ... 其他代码保持不变</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在创建 <code>CounterScreen</code> 的地方，传递一个处理 <code>_counter</code> 变化的回调函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart">CounterScreen(<br>  onCounterChanged: (newCounterValue) &#123;<br>    <span class="hljs-comment">// 处理 _counter 变化的逻辑</span><br>  &#125;,<br>)<br></code></pre></td></tr></table></figure><h3 id="方法-2-使用-Provider"><a href="#方法-2-使用-Provider" class="headerlink" title="方法 2: 使用 Provider"></a>方法 2: 使用 Provider</h3><p>对于更复杂的应用，你可能想要使用 <code>Provider</code> 包来更优雅地管理状态。</p><ol><li><p><strong>添加 Provider 依赖</strong>：<br>在 <code>pubspec.yaml</code> 文件中添加 <code>provider</code> 包的依赖。</p></li><li><p><strong>创建一个 Model 类</strong>：<br>创建一个用于存储 <code>_counter</code> 变量和更改通知的模型类。</p></li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChangeNotifier</span> </span>&#123;<br>  <span class="hljs-built_in">int</span> _counter = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-built_in">int</span> <span class="hljs-keyword">get</span> counter =&gt; _counter;<br><br>  <span class="hljs-keyword">void</span> incrementCounter() &#123;<br>    _counter++;<br>    notifyListeners();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>在应用顶层使用 ChangeNotifierProvider</strong>：<br>在 <code>main.dart</code> 或最顶层 widget 中，使用 <code>ChangeNotifierProvider</code> 包裹你的应用或特定屏幕。</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(<br>    ChangeNotifierProvider(<br>      create: (context) =&gt; CounterModel(),<br>      child: MyApp(),<br>    ),<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>修改 CounterScreen 以使用 CounterModel</strong>：<br>然后，修改 <code>CounterScreen</code> 以使用 <code>CounterModel</code>。</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_CounterScreenState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">CounterScreen</span>&gt; </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">final</span> counterModel = Provider.of&lt;CounterModel&gt;(context, listen: <span class="hljs-keyword">false</span>);<br><br>    <span class="hljs-keyword">return</span> Scaffold(<br>      <span class="hljs-comment">// ... UI代码</span><br>      floatingActionButton: FloatingActionButton(<br>        onPressed: () =&gt; counterModel.incrementCounter(),<br>        tooltip: <span class="hljs-string">&#x27;Increment&#x27;</span>,<br>        child: Icon(Icons.add),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li><strong>在其他 widget 中监听变化</strong>：<br>在另一个 <code>StatefulWidget</code> 中，你可以使用 <code>Provider.of</code> 来监听 <code>_counter</code> 的变化。</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br>Widget build(BuildContext context) &#123;<br>  <span class="hljs-built_in">int</span> counter = Provider.of&lt;CounterModel&gt;(context).counter; <span class="hljs-comment">// 自动监听变化</span><br><br>  <span class="hljs-comment">// 使用 counter 构建 UI</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>Provider</code>，你可以在应用的不同部分中共享和监听 <code>CounterModel</code> 的状态，从而实现跨 widget 的状态同步。这种方法适合于更复杂或更大型的应用，它有助于保持代码的清晰和组织。</p><h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><p><code>Provider</code> 是 Flutter 中一种流行的状态管理解决方案，它允许数据和状态跨 widget 树高效地共享和更新。以下是使用 <code>Provider</code> 的一个最佳实践示例，以及对其各部分的解释：</p><h3 id="示例：计数器应用"><a href="#示例：计数器应用" class="headerlink" title="示例：计数器应用"></a>示例：计数器应用</h3><p>首先，在你的 Flutter 项目的 <code>pubspec.yaml</code> 文件中添加 <code>provider</code> 作为依赖项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dependencies:</span><br>  <span class="hljs-attr">flutter:</span><br>    <span class="hljs-attr">sdk:</span> <span class="hljs-string">flutter</span><br>  <span class="hljs-attr">provider:</span> <span class="hljs-string">^5.0.0</span> <span class="hljs-comment"># 请使用最新版本</span><br></code></pre></td></tr></table></figure><p>然后，创建一个简单的计数器模型：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/foundation.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterModel</span> <span class="hljs-title">with</span> <span class="hljs-title">ChangeNotifier</span> </span>&#123;<br>  <span class="hljs-built_in">int</span> _count = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-built_in">int</span> <span class="hljs-keyword">get</span> count =&gt; _count;<br><br>  <span class="hljs-keyword">void</span> increment() &#123;<br>    _count++;<br>    notifyListeners(); <span class="hljs-comment">// 通知监听器有更新</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CounterModel</code> 类使用 <code>ChangeNotifier</code> 来通知听众（在这种情况下是 widget），当内部状态（这里是 <code>_count</code>）改变时。</p><p>接下来，在应用的顶层使用 <code>ChangeNotifierProvider</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:provider/provider.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(<br>    ChangeNotifierProvider(<br>      create: (context) =&gt; CounterModel(),<br>      child: MyApp(),<br>    ),<br>  );<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      title: <span class="hljs-string">&#x27;Provider Demo&#x27;</span>,<br>      home: CounterScreen(),<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&#x27;Provider Example&#x27;</span>),<br>      ),<br>      body: Center(<br>        child: Consumer&lt;CounterModel&gt;(<br>          builder: (context, counter, child) &#123;<br>            <span class="hljs-keyword">return</span> Text(<span class="hljs-string">&#x27;Count: <span class="hljs-subst">$&#123;counter.count&#125;</span>&#x27;</span>);<br>          &#125;,<br>        ),<br>      ),<br>      floatingActionButton: FloatingActionButton(<br>        onPressed: () =&gt; context.read&lt;CounterModel&gt;().increment(),<br>        child: Icon(Icons.add),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解释：-3"><a href="#解释：-3" class="headerlink" title="解释："></a>解释：</h3><ol><li><p><strong>CounterModel</strong>:</p><ul><li><code>CounterModel</code> 继承自 <code>ChangeNotifier</code>，它允许在模型更改时通知其监听者。</li><li>当调用 <code>increment</code> 方法时，它增加 <code>_count</code> 的值并调用 <code>notifyListeners</code>。</li></ul></li><li><p><strong>ChangeNotifierProvider</strong>:</p><ul><li><code>ChangeNotifierProvider</code> 创建并提供 <code>CounterModel</code> 的一个实例。</li><li>它位于 <code>MyApp</code> 的顶层，确保在整个应用范围内都可以访问到 <code>CounterModel</code>。</li></ul></li><li><p><strong>Consumer<CounterModel></strong>:</p><ul><li><code>Consumer&lt;CounterModel&gt;</code> 用于构建依赖于 <code>CounterModel</code> 的 widget。</li><li>它的 builder 方法会在 <code>CounterModel</code> 发送通知时被重新调用。</li></ul></li><li><p><strong>FloatingActionButton</strong>:</p><ul><li>当按钮被按下时，通过 <code>context.read&lt;CounterModel&gt;().increment()</code> 调用 <code>CounterModel</code> 的 <code>increment</code> 方法。</li></ul></li></ol><h3 id="最佳实践：-2"><a href="#最佳实践：-2" class="headerlink" title="最佳实践："></a>最佳实践：</h3><ul><li><strong>封装状态逻辑</strong>：在模型类（如 <code>CounterModel</code>）中封装状态和状态管理逻辑。</li><li><strong>使用 <code>ChangeNotifier</code> 通知变化</strong>：当模型的状态改变时，通过调用 <code>notifyListeners</code> 通知监听者。</li><li><strong>在 widget 树的合适位置提供模型</strong>：使用 <code>ChangeNotifierProvider</code> 在 widget 树中的适当位置提供模型实例。</li><li><strong>使用 <code>Consumer</code> 或 <code>Provider.of</code> 来访问模型</strong>：在需要接收模型数据的 widget 中，使用 <code>Consumer</code> 或 <code>context.watch/read</code> 来获取并使用模型数据。</li><li><strong>分离 UI 和业务逻辑</strong>：通过将状态管理从 UI 代码中分离出来，让代码更易于维护和测试。</li></ul><p>通过这种方式使用 <code>Provider</code>，你可以在应用中有效地管理和共享状态，同时保持代码的清晰和组织。</p><h2 id="MaterialApp"><a href="#MaterialApp" class="headerlink" title="MaterialApp"></a>MaterialApp</h2><p><code>MaterialApp</code> 是 Flutter 中一个非常重要的 widget，它将多个用于构建 Material Design 应用的 widgets 封装在一起。理解 <code>MaterialApp</code> 的最佳实践和使用场景对于高效地开发 Flutter 应用至关重要。</p><h3 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol><li><p><strong>应用的入口</strong>: 将 <code>MaterialApp</code> 作为应用的根 Widget。通常在 <code>main.dart</code> 文件的 <code>main</code> 函数中通过 <code>runApp</code> 方法启动。</p></li><li><p><strong>配置主题</strong>: 使用 <code>MaterialApp</code> 的 <code>theme</code> 属性来全局定义应用的基本风格，如颜色、字体样式、按钮样式等。</p></li><li><p><strong>导航和路由</strong>: 使用 <code>MaterialApp</code> 的 <code>routes</code> 属性来定义应用的顶级路由表，利用 <code>navigatorKey</code> 和 <code>onGenerateRoute</code> 管理更复杂的路由场景。</p></li><li><p><strong>本地化和国际化</strong>: 通过 <code>MaterialApp</code> 的 <code>localizationsDelegates</code> 和 <code>supportedLocales</code> 属性支持多语言。</p></li><li><p><strong>性能监控</strong>: 利用 <code>MaterialApp</code> 的 <code>debugShowCheckedModeBanner</code>、<code>debugShowMaterialGrid</code> 等属性来显示调试信息，帮助优化布局和性能。</p></li><li><p><strong>错误处理</strong>: 使用 <code>MaterialApp</code> 的 <code>onUnknownRoute</code> 和 <code>builder</code> 属性来处理未知路由或生成应用级别的 widget。</p></li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p><strong>标准 Material Design 应用</strong>: 当你需要构建符合 Material Design 指南的应用时，<code>MaterialApp</code> 提供了一套现成的解决方案。</p></li><li><p><strong>多页面路由管理</strong>: 对于拥有多个页面和复杂路由需求的应用，<code>MaterialApp</code> 提供了路由管理的功能，简化了页面间的导航。</p></li><li><p><strong>主题统一管理</strong>: 在需要统一管理应用级别样式和主题时，<code>MaterialApp</code> 允许你在一个地方定义整个应用的外观。</p></li><li><p><strong>国际化应用</strong>: 当应用需要支持多种语言时，<code>MaterialApp</code> 通过本地化代理简化了这个过程。</p></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dart">MaterialApp(<br>  title: <span class="hljs-string">&#x27;My Flutter App&#x27;</span>,<br>  theme: ThemeData(<br>    primarySwatch: Colors.blue,<br>    visualDensity: VisualDensity.adaptivePlatformDensity,<br>  ),<br>  initialRoute: <span class="hljs-string">&#x27;/&#x27;</span>,<br>  routes: &#123;<br>    <span class="hljs-string">&#x27;/&#x27;</span>: (context) =&gt; HomePage(),<br>    <span class="hljs-string">&#x27;/details&#x27;</span>: (context) =&gt; DetailsPage(),<br>  &#125;,<br>  onUnknownRoute: (settings) =&gt; MaterialPageRoute(<br>    builder: (context) =&gt; UnknownPage(),<br>  ),<br>);<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>MaterialApp</code> 定义了应用的标题、主题、初始路由、路由表以及未知路由的处理方式。这样的配置确保了应用具有统一的风格和行为，并且易于维护和扩展。</p><p>总之，<code>MaterialApp</code> 是构建任何基于 Material Design 的 Flutter 应用的基础，理解并熟练使用它对于开发高质量的 Flutter 应用是非常重要的。</p><p><code>MaterialApp</code> 是 Flutter 中的一个非常重要的 widget，提供了许多参数来配置应用程序的各个方面。以下是 <code>MaterialApp</code> 的一些主要参数及其含义的详细说明：</p><h2 id="MaterialApp-参数"><a href="#MaterialApp-参数" class="headerlink" title="MaterialApp 参数"></a>MaterialApp 参数</h2><h3 id="1-title"><a href="#1-title" class="headerlink" title="1. title"></a>1. <code>title</code></h3><ul><li><strong>类型</strong>: <code>String</code></li><li><strong>含义</strong>: 应用程序的标题。通常用于设备任务管理器和浏览器标签页。</li></ul><h3 id="2-theme"><a href="#2-theme" class="headerlink" title="2. theme"></a>2. <code>theme</code></h3><ul><li><strong>类型</strong>: <code>ThemeData</code></li><li><strong>含义</strong>: 应用的默认主题。你可以通过此参数定义应用的基本风格，如颜色、字体样式、按钮样式等。</li></ul><h3 id="3-color"><a href="#3-color" class="headerlink" title="3. color"></a>3. <code>color</code></h3><ul><li><strong>类型</strong>: <code>Color</code></li><li><strong>含义</strong>: 在 Android 中，此颜色用作应用任务管理器中的背景颜色。</li></ul><h3 id="4-home"><a href="#4-home" class="headerlink" title="4. home"></a>4. <code>home</code></h3><ul><li><strong>类型</strong>: <code>Widget</code></li><li><strong>含义</strong>: 应用的首页 widget。它是显示在应用程序启动时的首个屏幕。</li></ul><h3 id="5-routes"><a href="#5-routes" class="headerlink" title="5. routes"></a>5. <code>routes</code></h3><ul><li><strong>类型</strong>: <code>Map&lt;String, WidgetBuilder&gt;</code></li><li><strong>含义</strong>: 应用的路由表。键是路由的名称，值是构建它们的构造器。</li></ul><h3 id="6-initialRoute"><a href="#6-initialRoute" class="headerlink" title="6. initialRoute"></a>6. <code>initialRoute</code></h3><ul><li><strong>类型</strong>: <code>String</code></li><li><strong>含义</strong>: 应用启动时的初始路由名。如果提供了 <code>home</code> 参数，则此参数将被忽略。</li></ul><h3 id="7-onGenerateRoute"><a href="#7-onGenerateRoute" class="headerlink" title="7. onGenerateRoute"></a>7. <code>onGenerateRoute</code></h3><ul><li><strong>类型</strong>: <code>RouteFactory</code></li><li><strong>含义</strong>: 当通过 <code>Navigator.pushNamed</code> 导航到命名路由时，会使用这个函数来生成路由。</li></ul><h3 id="8-onUnknownRoute"><a href="#8-onUnknownRoute" class="headerlink" title="8. onUnknownRoute"></a>8. <code>onUnknownRoute</code></h3><ul><li><strong>类型</strong>: <code>RouteFactory</code></li><li><strong>含义</strong>: 当 <code>onGenerateRoute</code> 无法生成路由时调用，通常用于显示错误视图。</li></ul><h3 id="9-navigatorKey"><a href="#9-navigatorKey" class="headerlink" title="9. navigatorKey"></a>9. <code>navigatorKey</code></h3><ul><li><strong>类型</strong>: <code>GlobalKey&lt;NavigatorState&gt;</code></li><li><strong>含义</strong>: 用于访问应用的 Navigator 的全局键。</li></ul><h3 id="10-builder"><a href="#10-builder" class="headerlink" title="10. builder"></a>10. <code>builder</code></h3><ul><li><strong>类型</strong>: <code>TransitionBuilder</code></li><li><strong>含义</strong>: 一个用于在应用上方插入 widget 的构造器，例如用于插入一个全局的 Overlay 或者 Theme。</li></ul><h3 id="11-debugShowCheckedModeBanner"><a href="#11-debugShowCheckedModeBanner" class="headerlink" title="11. debugShowCheckedModeBanner"></a>11. <code>debugShowCheckedModeBanner</code></h3><ul><li><strong>类型</strong>: <code>bool</code></li><li><strong>含义</strong>: 在调试模式下，在屏幕右上角显示一个横幅。默认为 <code>true</code>。</li></ul><h3 id="12-locale"><a href="#12-locale" class="headerlink" title="12. locale"></a>12. <code>locale</code></h3><ul><li><strong>类型</strong>: <code>Locale</code></li><li><strong>含义</strong>: 应用的区域设置。如果未设置，则根据设备设置决定。</li></ul><h3 id="13-supportedLocales"><a href="#13-supportedLocales" class="headerlink" title="13. supportedLocales"></a>13. <code>supportedLocales</code></h3><ul><li><strong>类型</strong>: <code>Iterable&lt;Locale&gt;</code></li><li><strong>含义</strong>: 应用支持的区域列表。用于国际化。</li></ul><h3 id="14-localizationsDelegates"><a href="#14-localizationsDelegates" class="headerlink" title="14. localizationsDelegates"></a>14. <code>localizationsDelegates</code></h3><ul><li><strong>类型</strong>: <code>Iterable&lt;LocalizationsDelegate&lt;dynamic&gt;&gt;</code></li><li><strong>含义</strong>: 用于生成本地化资源的委托。</li></ul><h3 id="15-localeResolutionCallback"><a href="#15-localeResolutionCallback" class="headerlink" title="15. localeResolutionCallback"></a>15. <code>localeResolutionCallback</code></h3><ul><li><strong>类型</strong>: <code>LocaleResolutionCallback</code></li><li><strong>含义</strong>: 当应用的区域设置与 <code>supportedLocales</code> 不匹配时，可以用此回调来自定义选择匹配的逻辑。</li></ul><h3 id="16-highContrastTheme-和-darkTheme"><a href="#16-highContrastTheme-和-darkTheme" class="headerlink" title="16. highContrastTheme 和 darkTheme"></a>16. <code>highContrastTheme</code> 和 <code>darkTheme</code></h3><ul><li><strong>类型</strong>: <code>ThemeData</code></li><li><strong>含义</strong>: 分别为高对比度和暗色模式指定主题。</li></ul><p>这些参数提供了对 Flutter 应用外观、行为和路由的全面控制。通过合理配置这些参数，可以开发出符合需求且用户体验良好的应用程序。</p><h2 id="pubspec-yaml"><a href="#pubspec-yaml" class="headerlink" title="pubspec.yaml"></a>pubspec.yaml</h2><p><code>pubspec.yaml</code> 是一个在每个 Dart 和 Flutter 项目中都非常关键的文件。它用于定义项目的名称、版本、依赖项以及其他一些重要的元数据。以下是 <code>pubspec.yaml</code> 文件的主要部分及其作用的介绍：</p><h3 id="1-项目名称和描述"><a href="#1-项目名称和描述" class="headerlink" title="1. 项目名称和描述"></a>1. <strong>项目名称和描述</strong></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">my_flutter_app</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">A</span> <span class="hljs-string">new</span> <span class="hljs-string">Flutter</span> <span class="hljs-string">project.</span><br></code></pre></td></tr></table></figure><ul><li><code>name</code>: 项目的名称，通常与包名一致。</li><li><code>description</code>: 项目的简短描述。</li></ul><h3 id="2-版本"><a href="#2-版本" class="headerlink" title="2. 版本"></a>2. <strong>版本</strong></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-number">1.0</span><span class="hljs-number">.0</span><span class="hljs-string">+1</span><br></code></pre></td></tr></table></figure><ul><li><code>version</code>: 项目的当前版本号。这通常遵循 <a href="https://semver.org/">语义化版本控制</a>。<code>+1</code> 是构建号，它通常用于更新程序时不改变版本号的情况。</li></ul><h3 id="3-环境要求"><a href="#3-环境要求" class="headerlink" title="3. 环境要求"></a>3. <strong>环境要求</strong></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">environment:</span><br>  <span class="hljs-attr">sdk:</span> <span class="hljs-string">&quot;&gt;=2.7.0 &lt;3.0.0&quot;</span><br></code></pre></td></tr></table></figure><ul><li><code>environment</code>: 指定项目所需的 Dart SDK 版本。</li></ul><h3 id="4-依赖"><a href="#4-依赖" class="headerlink" title="4. 依赖"></a>4. <strong>依赖</strong></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dependencies:</span><br>  <span class="hljs-attr">flutter:</span><br>    <span class="hljs-attr">sdk:</span> <span class="hljs-string">flutter</span><br>  <span class="hljs-attr">cupertino_icons:</span> <span class="hljs-string">^1.0.2</span><br></code></pre></td></tr></table></figure><ul><li><code>dependencies</code>: 列出项目需要的所有包依赖。这里包括了 Flutter SDK 本身和其他的包，如 <code>cupertino_icons</code>。</li></ul><h3 id="5-开发依赖"><a href="#5-开发依赖" class="headerlink" title="5. 开发依赖"></a>5. <strong>开发依赖</strong></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dev_dependencies:</span><br>  <span class="hljs-attr">flutter_test:</span><br>    <span class="hljs-attr">sdk:</span> <span class="hljs-string">flutter</span><br></code></pre></td></tr></table></figure><ul><li><code>dev_dependencies</code>: 列出项目开发过程中需要的依赖，但在生产环境中不需要的。例如，测试框架。</li></ul><h3 id="6-Flutter-特定配置"><a href="#6-Flutter-特定配置" class="headerlink" title="6. Flutter 特定配置"></a>6. <strong>Flutter 特定配置</strong></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">flutter:</span><br>  <span class="hljs-attr">uses-material-design:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">assets:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">images/a_dot_burr.jpeg</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">images/a_dot_ham.jpeg</span><br></code></pre></td></tr></table></figure><ul><li><code>flutter</code>: 特定于 Flutter 的配置。<ul><li><code>uses-material-design</code>: 是否在项目中使用 Material Design。</li><li><code>assets</code>: 项目资源的列表，例如图片、字体等。</li></ul></li></ul><h3 id="7-其他配置"><a href="#7-其他配置" class="headerlink" title="7. 其他配置"></a>7. <strong>其他配置</strong></h3><p>还可以包括其他配置，如 <code>publish_to</code>（定义是否应将包发布到 pub.dev）、自定义脚本等。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><code>pubspec.yaml</code> 文件是项目的核心，用于管理项目的依赖项、版本和其他重要设置。当你运行 <code>flutter pub get</code> 命令时，Flutter 会查看 <code>pubspec.yaml</code> 文件并下载所需的依赖包。这个文件对于项目的构建和打包也至关重要。</p><p>简而言之，<code>pubspec.yaml</code> 是 Dart 和 Flutter 项目的蓝图，它告诉 Flutter 如何正确构建和运行你的应用。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>dart</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dart</tag>
      
      <tag>flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git使用问题.md</title>
    <link href="/2024/01/04/mdstorage/domain/vsc/git%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2024/01/04/mdstorage/domain/vsc/git%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><h3 id="kex-exchange-identification"><a href="#kex-exchange-identification" class="headerlink" title="kex_exchange_identification"></a>kex_exchange_identification</h3><p><strong>文档标题：</strong> 解决通过 SSH 连接 GitHub 时的连接问题</p><p><strong>目的：</strong> 本文档旨在提供一个清晰的指南，用于解决在通过 SSH 连接到 GitHub 时遇到的连接问题，特别是当出现 “kex_exchange_identification: Connection closed by remote host” 错误时。</p><hr><p><strong>问题描述：</strong></p><ul><li>很可能是由于 github gitee 混用导致的</li><li>执行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 察看详细日志</span><br>ssh -vT git@github.com<br><br><span class="hljs-comment"># 查看 本地仓库设置</span><br>git config -l<br><br><span class="hljs-comment"># 查看 git 全局配置</span><br>git config --global -l<br></code></pre></td></tr></table></figure><p>在这里基本可以看出来了，可能是 credential 导致的</p><p>可以通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换成 https 拉取</span><br>git remote set-url origin https://github.com/abrance/dairy.git<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>vsc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>git</tag>
      
      <tag>gitlab 问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>grpc服务调用资料.md</title>
    <link href="/2024/01/04/mdstorage/domain/network/%E5%8D%8F%E8%AE%AE/grpc%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E8%B5%84%E6%96%99/"/>
    <url>/2024/01/04/mdstorage/domain/network/%E5%8D%8F%E8%AE%AE/grpc%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E8%B5%84%E6%96%99/</url>
    
    <content type="html"><![CDATA[<h3 id="Service-中-rpc-服务"><a href="#Service-中-rpc-服务" class="headerlink" title="Service 中 rpc 服务"></a>Service 中 rpc 服务</h3><p>在<code>grpc-go</code>中，当客户端调用<code>ChatService</code>的<code>Chat1</code>或<code>Chat2</code>服务时，以下是连接建立的过程：</p><ol><li><p><strong>客户端初始化</strong>：客户端创建一个gRPC连接到服务器。这通常是在客户端应用的启动阶段完成的，例如通过<code>grpc.Dial</code>。</p></li><li><p><strong>服务调用时机</strong>：客户端在需要时调用<code>Chat1</code>或<code>Chat2</code>服务。这是根据客户端应用的业务逻辑决定的，可能是用户发起的动作或其他触发条件。</p></li><li><p><strong>建立连接</strong>：在客户端首次调用<code>Chat1</code>或<code>Chat2</code>时，gRPC框架通过之前建立的连接与服务器进行通信。若连接已存在，gRPC会重用该连接。</p></li><li><p><strong>流式通信</strong>：一旦调用开始，客户端和服务器之间就建立了流式通信，可以互发消息。</p></li></ol><p>在这个过程中，<code>Chat1</code>和<code>Chat2</code>服务共享同一个gRPC连接，这是由gRPC的HTTP&#x2F;2基础设施自动处理的。</p><ol><li><strong>定义多个操作的单个RPC服务</strong>：<ul><li><strong>优点</strong>：简化服务发现和管理；更少的网络开销；方便版本控制和API管理。</li><li><strong>劣势</strong>：服务可能变得臃肿，难以维护；服务间耦合度高。</li><li><strong>使用场景</strong>：功能相关性较高，且数量不多的操作。</li></ul></li><li><strong>定义多个RPC服务</strong>：<ul><li><strong>优点</strong>：服务清晰、职责单一；降低耦合，易于维护和扩展。</li><li><strong>劣势</strong>：增加了服务发现和网络交互的复杂性。</li><li><strong>使用场景</strong>：功能模块之间区分明显，服务需要独立扩展和部署。</li></ul></li></ol><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>不要使用多个 rpc 服务封装前面的 sc -&gt; webserver 业务</p><h5 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h5><ul><li><strong>代码行数</strong>：服务代码量巨大，难以管理和理解。</li><li><strong>复杂性</strong>：服务包含多个不相关的功能，导致逻辑复杂。</li><li><strong>维护困难</strong>：频繁的变更导致维护成本高。</li><li><strong>部署和扩展问题</strong>：服务部署和扩展变得笨重和缓慢。</li><li><strong>性能瓶颈</strong>：单一服务成为整个系统的性能瓶颈。</li><li><strong>团队协作障碍</strong>：服务过大导致团队协作困难。</li></ul><h5 id="量级"><a href="#量级" class="headerlink" title="量级"></a>量级</h5><ul><li><strong>代码行数</strong>：上万行代码时可能需要考虑拆分。</li><li><strong>复杂性</strong>：如果功能模块之间的耦合导致理解和修改一个功能需要深入其他多个功能，可能需要拆分。</li><li><strong>维护</strong>：频繁的变更导致回归测试和部署风险增加。</li><li><strong>部署和扩展</strong>：服务启动时间过长或单个服务的资源需求影响到整体系统性能。</li><li><strong>性能</strong>：单个服务成为性能瓶颈，影响用户体验。</li><li><strong>团队协作</strong>：多个团队在同一服务上工作导致协调困难。</li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>network</category>
      
      <category>协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>grpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MDNS.md</title>
    <link href="/2023/12/28/mdstorage/domain/network/%E5%8D%8F%E8%AE%AE/MDNS/"/>
    <url>/2023/12/28/mdstorage/domain/network/%E5%8D%8F%E8%AE%AE/MDNS/</url>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="简短介绍"><a href="#简短介绍" class="headerlink" title="简短介绍"></a>简短介绍</h4><p>本文将深入探讨MDNS（Multicast DNS）技术，它是一种在小型网络上实现设备名称解析到IP地址的机制。本文的目的是为读者提供一个全面的MDNS知识框架，包括其工作原理、实际应用和最佳实践。</p><h4 id="主题和目的概述"><a href="#主题和目的概述" class="headerlink" title="主题和目的概述"></a>主题和目的概述</h4><p>我们将首先概述MDNS的基本概念，然后详细讲解其背后的技术原理，以及如何在实际环境中应用MDNS。最后，本文将提供一些最佳实践和性能优化的建议。</p><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><h4 id="相关技术的涉及的算法历史演进概述"><a href="#相关技术的涉及的算法历史演进概述" class="headerlink" title="相关技术的涉及的算法历史演进概述"></a>相关技术的涉及的算法历史演进概述</h4><p>MDNS起源于传统的DNS（Domain Name System），用于解决小型网络（如家庭或小型办公室）中设备发现和名称解析的需求。与传统DNS不同，MDNS不依赖于中央DNS服务器，而是使用多播查询在本地网络上进行通信。</p><h4 id="适用场景概述"><a href="#适用场景概述" class="headerlink" title="适用场景概述"></a>适用场景概述</h4><p>MDNS适用于设备数量相对较少、缺乏专用DNS服务器的网络环境。它在IoT设备、家庭自动化、小型办公网络中尤为常见。</p><h3 id="详细内容"><a href="#详细内容" class="headerlink" title="详细内容"></a>详细内容</h3><h4 id="核心技术概念的详细解释"><a href="#核心技术概念的详细解释" class="headerlink" title="核心技术概念的详细解释"></a>核心技术概念的详细解释</h4><p>MDNS利用UDP协议在224.0.0.251地址和5353端口上进行多播。当一个设备需要解析另一个设备的名称时，它会在局域网上发送一个多播查询。所有网络上的设备都会监听这个查询，如果某个设备识别出查询中的名称与其相匹配，它会响应其IP地址。</p><h4 id="逐步指南或操作步骤"><a href="#逐步指南或操作步骤" class="headerlink" title="逐步指南或操作步骤"></a>逐步指南或操作步骤</h4><ul><li><strong>步骤1</strong>：在网络上的设备启动时，它会通过MDNS协议广播自己的名字。</li><li><strong>步骤2</strong>：当需要找到特定设备的IP地址时，发送一个多播请求。</li><li><strong>步骤3</strong>：接收到请求的设备检查名称是否匹配，如果匹配则响应其IP地址。</li></ul><h3 id="实际示例"><a href="#实际示例" class="headerlink" title="实际示例"></a>实际示例</h3><h4 id="代码示例或案例研究"><a href="#代码示例或案例研究" class="headerlink" title="代码示例或案例研究"></a>代码示例或案例研究</h4><p>以Python编写的简单MDNS查询示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 伪代码，用于演示MDNS查询</span><br><span class="hljs-keyword">import</span> mdns<br><br><span class="hljs-comment"># 查询网络上的设备名称</span><br>response = mdns.query(<span class="hljs-string">&#x27;device-name.local&#x27;</span>)<br><span class="hljs-built_in">print</span>(response)<br></code></pre></td></tr></table></figure><h4 id="实际应用场景描述"><a href="#实际应用场景描述" class="headerlink" title="实际应用场景描述"></a>实际应用场景描述</h4><p>在家庭自动化系统中，MDNS可用于自动发现和连接智能家居设备，如智能灯泡或温控器。</p><h3 id="最佳实践和建议"><a href="#最佳实践和建议" class="headerlink" title="最佳实践和建议"></a>最佳实践和建议</h3><h4 id="实用技巧和技术最佳实践"><a href="#实用技巧和技术最佳实践" class="headerlink" title="实用技巧和技术最佳实践"></a>实用技巧和技术最佳实践</h4><ul><li>保持设备名称的唯一性和一致性。</li><li>在网络负载较重时，优化MDNS的查询频率。</li></ul><h4 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h4><ul><li>使用缓存机制减少网络上的查询次数。</li><li>在适当的情况下，考虑使用静态IP地址以减少对MDNS的依赖。</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><h4 id="文章的主要观点总结"><a href="#文章的主要观点总结" class="headerlink" title="文章的主要观点总结"></a>文章的主要观点总结</h4><p>MDNS是一种适用于小型网络的有效设备发现和名称解析技术。通过广播和监听多播查询，它允许设备在没有中央DNS服务器的情况下彼此发现和交互。</p><h4 id="对读者的最后建议"><a href="#对读者的最后建议" class="headerlink" title="对读者的最后建议"></a>对读者的最后建议</h4><p>掌握MDNS的工作原理和最佳实践对于管理小型网络环境非常有用。它不仅简化了设备配置，还为资源有限</p><p>的环境提供了有效的解决方案。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>[1] “MDNS Explained,” [Online]. Available: <a href="https://www.example-mdns.com/">https://www.example-mdns.com</a></li><li>[2] “Networking Basics: MDNS,” [Online]. Available: <a href="https://www.networkingbasics.com/mdns">https://www.networkingbasics.com/mdns</a></li><li>[3] Python MDNS Library Documentation, [Online]. Available: <a href="https://www.python-mdns.org/">https://www.python-mdns.org</a></li><li>[4] “Home Automation using MDNS,” [Online]. Available: <a href="https://www.homeautomation-mdns.com/">https://www.homeautomation-mdns.com</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>network</category>
      
      <category>协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DNS 多播</tag>
      
      <tag>设备发现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile指定cpu架构选项.md</title>
    <link href="/2023/12/27/mdstorage/domain/makefile/Makefile%E6%8C%87%E5%AE%9Acpu%E6%9E%B6%E6%9E%84%E9%80%89%E9%A1%B9/"/>
    <url>/2023/12/27/mdstorage/domain/makefile/Makefile%E6%8C%87%E5%AE%9Acpu%E6%9E%B6%E6%9E%84%E9%80%89%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="Makefile-构建，使用环境变量来控制编译选项"><a href="#Makefile-构建，使用环境变量来控制编译选项" class="headerlink" title="Makefile 构建，使用环境变量来控制编译选项"></a>Makefile 构建，使用环境变量来控制编译选项</h3><ol><li><strong>设置环境变量</strong>：在命令行上或在用户的环境配置文件中设置环境变量，如 <code>ARCH=arm</code> 或 <code>ARCH=x86</code>。</li><li><strong>在 Makefile 中使用条件语句</strong>：Makefile 使用 <code>ifeq</code>、<code>ifdef</code> 等条件语句根据环境变量的值选择不同的编译器选项、链接器选项和其他设置。</li></ol><h5 id="ARCH-可选值"><a href="#ARCH-可选值" class="headerlink" title="ARCH 可选值"></a>ARCH 可选值</h5><ol><li><strong>aarch64</strong>：代表 ARM 架构的 64 位版本（ARMv8-A 和更高版本）。</li><li><strong>x86-64</strong>（或 <strong>amd64</strong>）：代表 Intel 和 AMD 的 64 位 x86 架构。</li><li><strong>risc-v</strong>：指的是开源的 RISC-V 架构。</li><li><strong>mips</strong>：代表 MIPS 架构，一种较老的 RISC 架构，常用于嵌入式系统。</li><li><strong>arm</strong> 或 <strong>armv7</strong>：用于 ARM 架构的 32 位版本（如 ARMv7）。</li><li><strong>powerpc</strong> 或 <strong>ppc</strong>：代表 PowerPC 架构，一种由 IBM、摩托罗拉和苹果开发的 RISC 架构。</li><li><strong>sparc</strong>：代表由 Sun Microsystems 开发的 SPARC 架构。</li><li><strong>i386</strong> 或 <strong>x86</strong>：指的是 Intel 和 AMD 的 32 位 x86 架构。</li><li><strong>s390x</strong>：用于 IBM 的 System z 大型机架构。</li><li><strong>ia64</strong>：代表 Intel 的 Itanium 架构，这是一种不同于 x86 的 64 位架构。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 默认的编译器</span><br>CC=gcc<br><span class="hljs-comment"># 默认的编译器标志</span><br>CFLAGS=-Wall<br><br><span class="hljs-comment"># 根据 ARCH 环境变量设置编译器和特定的编译器标志</span><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(ARCH)</span>,aarch64)<br>    CC=arm-linux-gnueabihf-gcc<br>    CFLAGS+= -march=arm<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(ARCH)</span>,x86-64)<br>    CC=gcc<br>    CFLAGS+= -march=x86-64<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-comment"># 目标可执行文件名</span><br>TARGET=myapp<br><br><span class="hljs-comment"># 构建目标</span><br><span class="hljs-section">all: <span class="hljs-variable">$(TARGET)</span></span><br><br><span class="hljs-variable">$(TARGET)</span>: myapp.c<br>    <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -o <span class="hljs-variable">$(TARGET)</span> myapp.c<br><br><span class="hljs-comment"># 清理构建文件</span><br><span class="hljs-section">clean:</span><br>    rm -f <span class="hljs-variable">$(TARGET)</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: all clean</span><br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 默认的目标平台</span><br>ARCH ?= x86-64<br><br><span class="hljs-comment"># Go 编译器</span><br>GO=go<br><br><span class="hljs-comment"># 根据 ARCH 环境变量设置 GOARCH</span><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(ARCH)</span>,aarch64)<br>    GOARCH=arm64<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(ARCH)</span>,x86-64)<br>    GOARCH=amd64<br><span class="hljs-keyword">else</span><br>    <span class="hljs-variable">$(<span class="hljs-built_in">error</span> Unknown <span class="hljs-built_in">or</span> unsupported architecture)</span><br><span class="hljs-keyword">endif</span><br><br><span class="hljs-comment"># 目标可执行文件名</span><br>TARGET=myapp<br><br><span class="hljs-comment"># 源代码文件</span><br>SRC=<span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.go)</span><br><br><span class="hljs-comment"># 构建目标</span><br><span class="hljs-section">all: <span class="hljs-variable">$(TARGET)</span></span><br><br><span class="hljs-variable">$(TARGET)</span>: <span class="hljs-variable">$(SRC)</span><br>    GOARCH=<span class="hljs-variable">$(GOARCH)</span> <span class="hljs-variable">$(GO)</span> build -o <span class="hljs-variable">$(TARGET)</span> <span class="hljs-variable">$(SRC)</span><br><br><span class="hljs-comment"># 清理构建文件</span><br><span class="hljs-section">clean:</span><br>    rm -f <span class="hljs-variable">$(TARGET)</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: all clean</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>makefile</category>
      
    </categories>
    
    
    <tags>
      
      <tag>make</tag>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile的函数使用.md</title>
    <link href="/2023/12/27/mdstorage/domain/makefile/Makefile%E7%9A%84%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/12/27/mdstorage/domain/makefile/Makefile%E7%9A%84%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h2><p>使通配符生效场景</p><p>在Makefile规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。</p><p>$(wildcard &lt;PATTERN…&gt;)</p><h2 id="patsubst"><a href="#patsubst" class="headerlink" title="patsubst"></a>patsubst</h2><p>patsubst函数返回被替换过后的字符串。</p><p>$(patsubst  <pattern>,<replacement>,<text>)</p><h2 id="define"><a href="#define" class="headerlink" title="define"></a>define</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">define</span> fun1<br>@echo <span class="hljs-string">&quot;My name is $(0)&quot;</span><br><span class="hljs-keyword">endef</span><br><span class="hljs-keyword">define</span> fun2<br>@echo <span class="hljs-string">&quot;My name is $(0), param is $(1)&quot;</span><br>@echo <span class="hljs-string">&quot;My name is $(0)&quot;</span><br><span class="hljs-keyword">endef</span><br><br><span class="hljs-keyword">define</span> fun2<br>@echo <span class="hljs-string">&quot;My name is $(0), param is $(1)&quot;</span><br>enddef<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>makefile</category>
      
    </categories>
    
    
    <tags>
      
      <tag>make</tag>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4+1架构视角模型.md</title>
    <link href="/2023/12/26/mdstorage/domain/%E6%9E%B6%E6%9E%84/4+1%E6%9E%B6%E6%9E%84%E8%A7%86%E8%A7%92%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/12/26/mdstorage/domain/%E6%9E%B6%E6%9E%84/4+1%E6%9E%B6%E6%9E%84%E8%A7%86%E8%A7%92%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>“4+1”架构视角模型是一种框架，用于描述复杂软件系统的架构。由Philippe Kruchten在1995年提出，这个模型旨在满足不同利益相关者的需求，并提供全面的系统视图。下面详细介绍这个模型的五个部分：</p><h3 id="1-逻辑视图（Logical-View）"><a href="#1-逻辑视图（Logical-View）" class="headerlink" title="1. 逻辑视图（Logical View）"></a>1. 逻辑视图（Logical View）</h3><ul><li><strong>目的</strong>：描述系统的功能性需求，即系统“做什么”。</li><li><strong>内容</strong>：包括系统的关键功能模块、类或对象，以及它们之间的关系。</li><li><strong>重点</strong>：系统的业务功能和对象模型。</li><li><strong>面向的利益相关者</strong>：软件开发者、系统分析师。</li><li><strong>示例</strong>：类图、对象图。</li></ul><h3 id="2-开发视图（Development-View）"><a href="#2-开发视图（Development-View）" class="headerlink" title="2. 开发视图（Development View）"></a>2. 开发视图（Development View）</h3><ul><li><strong>目的</strong>：描述软件模块的组织和静态结构。</li><li><strong>内容</strong>：系统的软件模块、包、子系统的组织方式，以及它们在开发环境中的布局。</li><li><strong>重点</strong>：软件管理、源代码组织、重用、维护性。</li><li><strong>面向的利益相关者</strong>：程序员、开发管理者。</li><li><strong>示例</strong>：源代码目录结构、开发环境配置。</li></ul><h3 id="3-物理视图（Physical-View）"><a href="#3-物理视图（Physical-View）" class="headerlink" title="3. 物理视图（Physical View）"></a>3. 物理视图（Physical View）</h3><ul><li><strong>目的</strong>：描述系统的物理部署和分布。</li><li><strong>内容</strong>：物理节点（如服务器、计算机、网络设备）的布局，以及软件组件如何映射到这些节点上。</li><li><strong>重点</strong>：系统的扩展性、性能、安全性、系统集成。</li><li><strong>面向的利益相关者</strong>：系统工程师、网络管理员。</li><li><strong>示例</strong>：部署图、网络拓扑图。</li></ul><h3 id="4-过程视图（Process-View）"><a href="#4-过程视图（Process-View）" class="headerlink" title="4. 过程视图（Process View）"></a>4. 过程视图（Process View）</h3><ul><li><strong>目的</strong>：展示系统的运行时行为。</li><li><strong>内容</strong>：进程、线程的组织和交互，以及系统运行时的动态。</li><li><strong>重点</strong>：并发、分布式处理、系统的运行时性能和容错性。</li><li><strong>面向的利益相关者</strong>：系统集成者、性能测试工程师。</li><li><strong>示例</strong>：进程图、运行时交互图。</li></ul><h3 id="5-场景（Scenarios）-用例视图（Use-Case-View）"><a href="#5-场景（Scenarios）-用例视图（Use-Case-View）" class="headerlink" title="5. 场景（Scenarios）&#x2F;用例视图（Use Case View）"></a>5. 场景（Scenarios）&#x2F;用例视图（Use Case View）</h3><ul><li><strong>目的</strong>：通过具体的用例或场景来验证其他四个视图。</li><li><strong>内容</strong>：代表用户交互或系统事件的一系列用例或故事。</li><li><strong>重点</strong>：系统的整体功能性和非功能性需求。</li><li><strong>面向的利益相关者</strong>：最终用户、市场分析师、所有利益相关者。</li><li><strong>示例</strong>：用例图、用户故事。</li></ul><h3 id="使用场景和范围"><a href="#使用场景和范围" class="headerlink" title="使用场景和范围"></a>使用场景和范围</h3><ol><li><strong>大型和复杂的软件项目</strong>：在这些项目中，需求复杂多变，涉及多个团队和不同的技术栈。”4+1” 模型能够帮助组织和沟通大量的信息。</li><li><strong>多团队协作的项目</strong>：不同团队可能关注项目的不同方面（比如开发、测试、部署）。此模型通过提供不同的视图，帮助不同团队更好地理解他们的责任和需求。</li><li><strong>需要高度文档化的项目</strong>：在一些项目中，如企业级应用或符合特定行业标准的项目，详细的文档化是必须的。这个模型提供了一个架构文档化的框架。</li><li><strong>系统重构或升级</strong>：在现有系统的重构或升级过程中，”4+1” 模型可以帮助理解系统的当前架构，并规划新的架构设计。</li></ol><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol><li><strong>全面性</strong>：通过不同的视图，它能全面捕获系统的不同方面，从逻辑、开发、物理、过程到用例。</li><li><strong>沟通效率</strong>：它提供了一个共同的语言和框架，有助于不同背景的利益相关者之间的沟通。</li><li><strong>灵活性</strong>：模型本身足够灵活，可以根据项目的具体需求调整重点。</li><li><strong>验证和完整性</strong>：用例视图可以用来验证其他视图的完整性和正确性。</li></ol><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ol><li><strong>复杂性</strong>：对于小型或较少复杂的项目来说，这个模型可能过于复杂，导致不必要的工作量。</li><li><strong>资源消耗</strong>：维护这五个视图需要时间和资源，特别是在快速迭代的开发环境中。</li><li><strong>更新和同步</strong>：随着项目的进展，保持这五个视图的同步更新是一个挑战。</li><li><strong>需要专业知识</strong>：正确地实施和利用这个模型需要团队成员具备一定程度的架构知识和经验。</li></ol>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总控、引擎、插件软件架构梳理.md</title>
    <link href="/2023/12/26/mdstorage/project/sr/%E6%80%BB%E6%8E%A7%E3%80%81%E5%BC%95%E6%93%8E%E3%80%81%E6%8F%92%E4%BB%B6%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A2%B3%E7%90%86/"/>
    <url>/2023/12/26/mdstorage/project/sr/%E6%80%BB%E6%8E%A7%E3%80%81%E5%BC%95%E6%93%8E%E3%80%81%E6%8F%92%E4%BB%B6%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="现有架构梳理"><a href="#现有架构梳理" class="headerlink" title="现有架构梳理"></a>现有架构梳理</h2><h2 id="核心系统组件、应用、插件构想"><a href="#核心系统组件、应用、插件构想" class="headerlink" title="核心系统组件、应用、插件构想"></a>核心系统组件、应用、插件构想</h2><h3 id="核心系统"><a href="#核心系统" class="headerlink" title="核心系统"></a>核心系统</h3><p>总控、流量引擎</p><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><p>核心系统中的核心应用</p><p>属性： 核心组件的启动、运行依赖关系、通信链路形成有向无环图结构，核心组件之间逻辑自洽，向上提供的接口已在内部达成逻辑自洽</p><p>依赖：操作系统底层资源、其他核心组件</p><h4 id="系统核心组件依赖关系和通信链路示意图"><a href="#系统核心组件依赖关系和通信链路示意图" class="headerlink" title="系统核心组件依赖关系和通信链路示意图"></a>系统核心组件依赖关系和通信链路示意图</h4><pre><code class=" mermaid">graph TBsubgraph kernel[系统核心组件]comp2[Comp2]comp1[Comp1]comp3[Comp3]comp4[Comp4]comp5[Comp5]comp3 --&gt; comp1comp5 --&gt; comp1 &amp; comp2 &amp; comp3 &amp; comp4end</code></pre><h3 id="核心系统功能"><a href="#核心系统功能" class="headerlink" title="核心系统功能"></a>核心系统功能</h3><h4 id="核心系统功能-1"><a href="#核心系统功能-1" class="headerlink" title="核心系统功能"></a>核心系统功能</h4><p>最核心系统为流量引擎，功能为反向代理。其中的系统组件重要且紧急，如果其中出现故障属于一级紧急事故</p><p>核心系统旁路：目前延伸出可视化旁路，它同样重要，但是属于次紧急的链路。</p><p>提供插件应用接口，完成插件注册、绑定、插件之间通信问题</p><p>为普通应用提供接口，提供核心系统功能的延伸</p><h4 id="核心系统组件职责"><a href="#核心系统组件职责" class="headerlink" title="核心系统组件职责"></a>核心系统组件职责</h4><p>流量引擎侧: 完成反向代理功能，提供流量引擎侧必须提供的信息</p><p>总控侧：完成引擎配置下发、建立事件总线，提供总控侧必须提供的信息。</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>核心系统组件异常推荐设置管理员通知机制，意味着紧急事件发生</p><p>核心系统旁路可设置较松的通知</p><p>其他不重要错误信息可只显示于日志文件中，日志文件可支持导出</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>应用是在软件系统上运行的程序，它们使用系统提供的服务和接口完成特定的功能或任务。应用通常是用户与系统交互的主要方式。</p><h4 id="普通应用功能"><a href="#普通应用功能" class="headerlink" title="普通应用功能"></a>普通应用功能</h4><p>属性： 应用依赖关系形成有向无环图结构，应用之间逻辑自洽，向上提供的接口已在内部达成逻辑自洽</p><p>依赖：操作系统资源、通常独立于其他应用（可能依赖其他应用和核心组件）</p><h4 id="依赖关系和通信链路示意图"><a href="#依赖关系和通信链路示意图" class="headerlink" title="依赖关系和通信链路示意图"></a>依赖关系和通信链路示意图</h4><pre><code class=" mermaid">graph TBsubgraph kernel[系统核心组件层]comp2[Comp2]comp1[Comp1]comp3[Interface==Comp3]comp4[Comp4]comp5[Interface==Comp5]comp3 --&gt; comp1comp5 --&gt; comp1 &amp; comp2 &amp; comp3 &amp; comp4endsubgraph app[应用层]app1[APP1]app2[APP2]app3[APP3]app3 ----&gt; app1 &amp; app2 app1 --&gt; app2endapp3 --&gt; comp5app1 --&gt; comp3linkStyle 8,9 stroke:red,stroke-width:5px;</code></pre><h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><p>应用有自己的鉴权机制，因为应用可能被其他应用调用，可以简单实现，借鉴 Linux 用户权限机制。</p><h3 id="应用关于核心系统组件接口使用方式"><a href="#应用关于核心系统组件接口使用方式" class="headerlink" title="应用关于核心系统组件接口使用方式"></a>应用关于核心系统组件接口使用方式</h3><p>应遵循就进原则，每个应用应明确与之最近的核心组件接口，并严格执行，不可连接越过最近的组件，连接更远的组件。</p><p>这个限制通过设置核心系统组件接口必须通过本地回环网络访问</p><p>如果本机不存在核心系统组件但是想要获取此数据，须安装一个核心系统组件的 agent,并在 agent 做了准入处理。</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>插件是软件的组件（也可以为组件），可以在不改变核心系统代码的情况下，为系统增加新的功能或扩展现有功能。它们通常是可选的，按需加载，并与核心系统通过定义好的接口交互。</p><h4 id="权限-1"><a href="#权限-1" class="headerlink" title="权限"></a>权限</h4><p>插件本身没有权限概念，因为它依附于核心系统，而核心系统脱离了权限概念。</p><p>插件可以在通过某些普通应用提供权限管理，如 dashboard 等管理界面，这些应用已获准接入了核心系统应用接口，应该在这些应用中做好鉴权体系。</p><h3 id="应用与插件区别"><a href="#应用与插件区别" class="headerlink" title="应用与插件区别"></a>应用与插件区别</h3><h4 id="1-功能范围和目的"><a href="#1-功能范围和目的" class="headerlink" title="1. 功能范围和目的"></a>1. 功能范围和目的</h4><ul><li><strong>插件</strong>：通常设计为扩展或增强主程序的特定功能。它们是为了增加额外的核心系统的特性或工具而设计的，不是独立运行的程序。</li><li><strong>应用</strong>：是独立的程序，用于执行完整的任务或工作流程。应用通常具有更广泛和独立的功能范围。</li></ul><h4 id="2-依赖性"><a href="#2-依赖性" class="headerlink" title="2. 依赖性"></a>2. 依赖性</h4><ul><li><strong>插件</strong>：依赖于核心系统，不能独立于核心存在。它们是核心系统功能的补充。</li><li><strong>应用</strong>：通常独立于任何其他应用。应用提供一组完整的接口或功能集，可能提供独立界面。</li></ul><h4 id="3-交互性和集成"><a href="#3-交互性和集成" class="headerlink" title="3. 交互性和集成"></a>3. 交互性和集成</h4><ul><li><strong>插件</strong>：紧密集成于核心系统，通过预定义的接口与核心系统组件交互。</li><li><strong>应用</strong>：可能与系统的其他部分交互，但不一定需要集成到另一个特定的程序中。</li></ul><h4 id="4-用户控制和定制"><a href="#4-用户控制和定制" class="headerlink" title="4. 用户控制和定制"></a>4. 用户控制和定制</h4><ul><li><strong>插件</strong>：提供给用户更多的定制选项来修改或增强核心系统的行为。</li><li><strong>应用</strong>：通常作为完整的解决方案提供，用户定制性相对较少。</li></ul><h4 id="5-安装和维护"><a href="#5-安装和维护" class="headerlink" title="5. 安装和维护"></a>5. 安装和维护</h4><ul><li><strong>插件</strong>：作为核心系统的一部分进行安装和更新，其生命周期通常与核心系统相关联。</li><li><strong>应用</strong>：独立安装和更新，拥有自己的生命周期管理。</li></ul><h4 id="6-资源使用和性能影响"><a href="#6-资源使用和性能影响" class="headerlink" title="6. 资源使用和性能影响"></a>6. 资源使用和性能影响</h4><ul><li><strong>插件</strong>：由于与核心系统紧密集成，其对系统资源的使用和性能影响需要更加小心处理，以免影响核心系统。</li><li><strong>应用</strong>：作为独立实体，负责自己的资源管理和性能优化。</li></ul><h4 id="7-安全性和权限"><a href="#7-安全性和权限" class="headerlink" title="7. 安全性和权限"></a>7. 安全性和权限</h4><ul><li><strong>插件</strong>：其安全性和权限直接关联于核心系统，通常受到更严格的限制和控制。</li><li><strong>应用</strong>：需要独立管理自己的安全性和用户权限。</li></ul><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>核心组件安全性由操作系统保证，操作系统是经过改造过的，用户不知道操作系统账户密码，不能简单进入到系统终端</p><p>插件目前是由可信任的插件开发者完成，通过统一的发布平台发布，并在发布和导入插件包阶段做了相应校验，不存在安全问题</p><p>应用同插件一样</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>暂无分析</p>]]></content>
    
    
    
    <tags>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总控引擎插件跨节点通信链路和改造计划.md</title>
    <link href="/2023/12/25/mdstorage/project/sr/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0/%E6%80%BB%E6%8E%A7%E5%BC%95%E6%93%8E%E6%8F%92%E4%BB%B6%E8%B7%A8%E8%8A%82%E7%82%B9%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E5%92%8C%E6%94%B9%E9%80%A0%E8%AE%A1%E5%88%92/"/>
    <url>/2023/12/25/mdstorage/project/sr/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0/%E6%80%BB%E6%8E%A7%E5%BC%95%E6%93%8E%E6%8F%92%E4%BB%B6%E8%B7%A8%E8%8A%82%E7%82%B9%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E5%92%8C%E6%94%B9%E9%80%A0%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h3 id="总控、引擎、插件跨节点通信链路"><a href="#总控、引擎、插件跨节点通信链路" class="headerlink" title="总控、引擎、插件跨节点通信链路"></a>总控、引擎、插件跨节点通信链路</h3><pre><code class=" mermaid">graph LRsubgraph Sc[总控]scsv[可视化 sv]installer-manager[引擎安装 manager]endsubgraph Se[流量引擎]        subgraph Sem[流量引擎 管理节点]            installer-agent[引擎安装 agent]            webserver[Webserver]            admin_dam[admin Dam]            apiserver[Apiserver]            admin_ha[admin HA]nexus_m[Nexus]global_plugin_server[global-plugin-server]        end        subgraph Sew[流量引擎 工作节点]            data_dam[data Dam]            nexus_w[Nexus]            envoy[Envoy]        end                subgraph Ses[流量引擎 调度节点]        nexus_s[Nexus]        endendinstaller-manager --&gt;|vip/nodeIP:8099|installer-agentinstaller-manager --&gt;|vip:6898|admin_hasv --&gt;|vip:1234|admin_damsv --&gt;|vip:8899|admin_damsv --&gt;|vip:8299|webserversc --&gt;|vip:8229|webserverinstaller-agent --&gt;|nodeIP:8098|installer-managerdata_dam --&gt;|nodeIp:4150|svdata_dam --&gt;|nodeIp:9001|webserverwebserver --&gt;|nodeIp:8000| nexus_m &amp; nexus_s &amp; nexus_wenvoy --&gt;|vip:7878 7978| global_plugin_server%%installer-agent --&gt;|vip:6443|apiserver</code></pre><h3 id="第一步改造（通信方向反转）"><a href="#第一步改造（通信方向反转）" class="headerlink" title="第一步改造（通信方向反转）"></a>第一步改造（通信方向反转）</h3><h4 id="改造前"><a href="#改造前" class="headerlink" title="改造前"></a>改造前</h4><pre><code class=" mermaid">graph LRsubgraph Sc[总控]scsv[可视化 sv]installer-manager[引擎安装 manager]endsubgraph Se[流量引擎]        subgraph Sem[流量引擎 管理节点]            installer-agent[引擎安装 agent]            webserver[Webserver]            admin_dam[admin Dam]            apiserver[Apiserver]            admin_ha[admin HA]nexus_m[Nexus]global_plugin_server[global-plugin-server]        end        subgraph Sew[流量引擎 工作节点]            data_dam[data Dam]            nexus_w[Nexus]            envoy[Envoy]        end                subgraph Ses[流量引擎 调度节点]        nexus_s[Nexus]        endendinstaller-manager --&gt;|vip/nodeIP:8099|installer-agentinstaller-manager --&gt;|vip:6898|admin_hasv --&gt;|vip:1234|admin_damsv --&gt;|vip:8899|admin_damsv --&gt;|vip:8299|webserversc --&gt;|vip:8229|webserver</code></pre><h4 id="改造后"><a href="#改造后" class="headerlink" title="改造后"></a>改造后</h4><pre><code class=" mermaid">graph RLsubgraph Sc[总控]scsv[可视化 sv]installer-manager[引擎安装 manager]endsubgraph Se[流量引擎]        subgraph Sem[流量引擎 管理节点]            installer-agent[引擎安装 agent]            webserver[Webserver]            admin_dam[admin Dam]            apiserver[Apiserver]            admin_ha[admin HA]nexus_m[Nexus]global_plugin_server[global-plugin-server]        end        subgraph Sew[流量引擎 工作节点]            data_dam[data Dam]            nexus_w[Nexus]            envoy[Envoy]        end                subgraph Ses[流量引擎 调度节点]        nexus_s[Nexus]        endendinstaller-agent --&gt;|nodeIp:29030|installer-manageradmin_ha --&gt;|nodeIp:29030| installer-manageradmin_dam --&gt;|nodeIp:29120|svadmin_dam --&gt;|nodeIp:29120|svwebserver --&gt;|nodeIp:29120|svwebserver --&gt;|nodeIp:29020|sc</code></pre><h4 id="改造后开放端口策略"><a href="#改造后开放端口策略" class="headerlink" title="改造后开放端口策略"></a>改造后开放端口策略</h4><h5 id="涉及组件"><a href="#涉及组件" class="headerlink" title="涉及组件"></a>涉及组件</h5><ul><li>sc </li><li>sv </li><li>webserver </li><li>admin-ha </li><li>installer-manager </li><li>installer-agent </li><li>admin-dam</li></ul><h5 id="改造后-1"><a href="#改造后-1" class="headerlink" title="改造后"></a>改造后</h5><h6 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h6><p>sc sv installer-manager</p><h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h6><p>webserver admin-ha admin-dam installer-agent</p><h6 id="组件开放端口"><a href="#组件开放端口" class="headerlink" title="组件开放端口"></a>组件开放端口</h6><p><strong>sc</strong> ：29020<br><strong>sv</strong> ：29120<br><strong>installer-manager</strong>： 29030</p><h6 id="总结开放端口策略："><a href="#总结开放端口策略：" class="headerlink" title="总结开放端口策略："></a>总结开放端口策略：</h6><p>总控侧开放 nodeIp:29029 29120 29030 端口、客户端通过 nodeIp 这些端口来建立通信</p><h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><ul><li><p>grpc 双向流</p><ul><li><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li><strong>基于 HTTP&#x2F;2</strong>: 支持流控制、头部压缩等高效功能。</li><li><strong>强类型接口定义</strong>: 使用 Protocol Buffers，可以定义清晰的服务接口。</li><li><strong>多语言支持</strong>: 客户端和服务端可以使用不同的编程语言实现。</li></ul><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul><li><strong>浏览器支持有限</strong>: 直接在浏览器中使用 gRPC 可能有兼容性问题。</li><li><strong>复杂度较高</strong>: 相比于 RESTful API 或 WebSocket，gRPC 的学习曲线更陡峭。</li></ul></li></ul></li><li><p><del>websocket 双向通信</del></p><ul><li><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a><del>优势</del></h4><ul><li><del><strong>全双工通信</strong>: 允许服务器和客户端之间进行实时、双向通信。</del></li><li><del><strong>低延迟</strong>: 一旦建立连接，数据交换延迟非常低。</del></li><li><del><strong>广泛支持</strong>: 大多数现代浏览器和网络库都支持 WebSocket。</del></li></ul><h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a><del>劣势</del></h4><ul><li><del><strong>缺乏内置消息格式</strong>: 需要自定义协议来处理消息。</del></li><li><del><strong>缺少先进的消息处理功能</strong>: 如消息队列、消息确认等。</del></li><li><del><strong>扩展性</strong>: 在大规模应用中，保持大量的 WebSocket 连接可能会导致资源问题。</del></li></ul></li></ul></li><li><p><del>http2.0 双向通信</del></p><ul><li><h4 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a><del>优势</del></h4><ul><li><del><strong>多路复用</strong>: 单个连接上可以并行多个请求&#x2F;响应，提高效率。</del></li><li><del><strong>头部压缩</strong>: 减少了额外的网络开销。</del></li><li><del><strong>服务器推送</strong>: 服务器可以主动向客户端发送资源。</del></li></ul><h4 id="劣势-2"><a href="#劣势-2" class="headerlink" title="劣势"></a><del>劣势</del></h4><ul><li><del><strong>兼容性和支持</strong>: 虽然现代浏览器普遍支持 HTTP&#x2F;2，但在某些环境中可能仍需考虑兼容性问题。</del></li><li><del><strong>复杂性</strong>: 相比 HTTP&#x2F;1.1，HTTP&#x2F;2 实现更复杂。</del></li></ul></li></ul></li><li><p><del>长轮询</del></p></li><li><p><del>消息队列&#x2F;订阅发布模型</del></p><ul><li><h4 id="优势-3"><a href="#优势-3" class="headerlink" title="优势"></a><del>优势</del></h4><ul><li><del><strong>解耦生产者和消费者</strong>: 生产者和消费者不必知道对方的存在。</del></li><li><del><strong>可扩展性</strong>: 更容易在分布式系统中扩展。</del></li><li><del><strong>可靠性</strong>: 很多消息队列系统提供消息持久化、确认机制等功能，确保消息不会丢失。</del></li></ul><h4 id="劣势-3"><a href="#劣势-3" class="headerlink" title="劣势"></a><del>劣势</del></h4><ul><li><del><strong>延迟</strong>: 相比直接的双向通信，可能会引入更多的延迟。</del></li><li><del><strong>复杂性</strong>: 引入消息队列系统会增加系统架构的复杂性。</del></li><li><del><strong>维护成本</strong>: 需要管理和维护额外的消息队列服务。</del></li></ul></li></ul></li></ul><h3 id="第二步改造（规整）"><a href="#第二步改造（规整）" class="headerlink" title="第二步改造（规整）"></a>第二步改造（规整）</h3>]]></content>
    
    
    
    <tags>
      
      <tag>通信链路</tag>
      
      <tag>通信方向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>架构决定日志模板.md</title>
    <link href="/2023/12/21/mdstorage/domain/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E5%86%B3%E5%AE%9A%E6%97%A5%E5%BF%97%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/12/21/mdstorage/domain/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E5%86%B3%E5%AE%9A%E6%97%A5%E5%BF%97%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h2><ul><li><strong>版本信息</strong>：version 时间 作者</li><li><strong>项目描述</strong>：xxx</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><table><thead><tr><th>编号</th><th>标题</th><th>简要描述</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="详细记录"><a href="#详细记录" class="headerlink" title="详细记录"></a>详细记录</h2><ul><li><strong>决定编号</strong>：唯一标识每个架构决定。</li><li><strong>标题</strong>：简洁描述决定的内容。</li><li><strong>日期</strong>：决定做出的日期。</li><li><strong>状态</strong>：例如，“已实施”、“正在审议”或“已废弃”。</li><li><strong>问题描述</strong>：描述决定解决的问题或需求。</li><li><strong>决定内容</strong>：具体说明做出的架构决定。</li><li><strong>替代方案</strong>：列出考虑过的其他方案，并解释为什么没有选择它们。</li><li><strong>原因和理由</strong>：解释为什么选择这个方案，包括技术、业务和其他考虑因素。</li><li><strong>影响</strong>：评估这个决定对项目的影响，包括正面和负面影响。</li><li><strong>相关决定</strong>：如果适用，指出与其他架构决定的关联。</li><li><strong>附件和参考资料</strong>：</li><li><strong>审核批准人员名单</strong>：</li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构决定</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总控架构决定日志.md</title>
    <link href="/2023/12/21/mdstorage/project/sr/sc/%E6%80%BB%E6%8E%A7%E6%9E%B6%E6%9E%84%E5%86%B3%E5%AE%9A%E6%97%A5%E5%BF%97/"/>
    <url>/2023/12/21/mdstorage/project/sr/sc/%E6%80%BB%E6%8E%A7%E6%9E%B6%E6%9E%84%E5%86%B3%E5%AE%9A%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h2 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h2><ul><li><strong>版本信息</strong>：v1.3.0 2023&#x2F;12&#x2F;21 小歪</li><li><strong>项目描述</strong>：总控该系统是本项目开发的核心软件组件，它负责统筹管理各种引擎和插件的操作，确保系统整体运行的效率和安全性。</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><table><thead><tr><th>编号</th><th>标题</th><th>简要描述</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>- </p><h2 id="详细记录"><a href="#详细记录" class="headerlink" title="详细记录"></a>详细记录</h2><h3 id="总控引擎插件组件通信方向反转"><a href="#总控引擎插件组件通信方向反转" class="headerlink" title="总控引擎插件组件通信方向反转"></a>总控引擎插件组件通信方向反转</h3><ul><li><strong>决定编号</strong>：1</li><li><strong>标题</strong>：总控引擎插件组件通信方向反转</li><li><strong>日期</strong>：2023&#x2F;12&#x2F;25</li><li><strong>状态</strong>：正在审议</li><li><strong>问题描述</strong>：总控、引擎管理配置通信链路中现状是 建立连接方向、数据流向 SC –&gt; SE，而，客户场景中，引擎的连接方式不支持长期被动连接，所以需要将建立连接方向改变为 SE –&gt; SC。</li><li><strong>决定内容</strong>：使用 grpc 双向流式通信建立连接并消息推送。其中 SE 的组件为客户端，SC 组件为服务端建立通信。具体查看附件</li><li><strong>替代方案</strong>：1. 长轮询（延迟高、占用资源高、性能差） 2. websocket（限制少出错几率更大、数据压缩流控特性支持更少） 3. 消息队列&#x2F;发布订阅模型（复杂度高、团队目前没用过这种模型风险大） 4. http2.0 双向通信（限制少出错几率更大、数据压缩流控特性支持更少）</li><li><strong>原因和理由</strong>：grpc 更成熟，适用的场景更多，需要自己实现的功能更少，开发人员出错的概率更小。</li><li><strong>影响</strong>：1. 产品层面上重新定义引擎连接状态 2. 总控、引擎开发端口策略需改变 3. 引擎安装时需要更改相应逻辑 具体目标查看附件</li><li><strong>相关决定</strong>：可能有目前总控、引擎、插件组件通信链路过于繁杂的问题</li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="详细记录模板"><a href="#详细记录模板" class="headerlink" title="详细记录模板"></a>详细记录模板</h3><ul><li><strong>决定编号</strong>：唯一标识每个架构决定。</li><li><strong>标题</strong>：简洁描述决定的内容。</li><li><strong>日期</strong>：决定做出的日期。</li><li><strong>状态</strong>：例如，“已实施”、“正在审议”或“已废弃”。</li><li><strong>问题描述</strong>：描述决定解决的问题或需求。</li><li><strong>决定内容</strong>：具体说明做出的架构决定。</li><li><strong>替代方案</strong>：列出考虑过的其他方案，并解释为什么没有选择它们。</li><li><strong>原因和理由</strong>：解释为什么选择这个方案，包括技术、业务和其他考虑因素。</li><li><strong>影响</strong>：评估这个决定对项目的影响，包括正面和负面影响。</li><li><strong>相关决定</strong>：如果适用，指出与其他架构决定的关联。</li><li><strong>附件和参考资料</strong>：</li><li><strong>审核批准人员名单</strong>：</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一周看板-12.18.md</title>
    <link href="/2023/12/18/mdstorage/project/sr/%E4%B8%80%E5%91%A8%E7%9C%8B%E6%9D%BF/%E4%B8%80%E5%91%A8%E7%9C%8B%E6%9D%BF-12.18/"/>
    <url>/2023/12/18/mdstorage/project/sr/%E4%B8%80%E5%91%A8%E7%9C%8B%E6%9D%BF/%E4%B8%80%E5%91%A8%E7%9C%8B%E6%9D%BF-12.18/</url>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs kanban"># 2023/12/11 Task List<br><br>## Todo<br>- https://github.com/mli/autocut 是什么<br>- on-premise 综述<br>- InfoQ 一周消息速递<br>- 搜书方法、主流格式文档转换方法、以图搜图、学习资料搜索<br><br>- 周会 （1. 转测流程 2. 任务进度 3. 说说问题）<br>- 新人培训计划文档<br><br>- chatgpt 插件调研文档<br>- SR 问题跟踪文档<br>- 虚拟机克隆调研文档<br><br>- SR 研发工作流程统计时长<br><br>- 安装升级框架实施方案<br><br>- 文章类型概述文档<br>- 部门会议总结<br>- 基础设施组概述<br>- 测试用例设计文档内容要求<br><br>- 公共库维护指南文档<br>- 慢速拒绝需求<br><br>- PostgreSQL数据库内核分析 拆解<br><br>- 针对产品的石犀培训文档<br><br>- AES 算法<br><br>- mermaid 流程图文档（重要）<br><br>- 插件架构设计文档（重要）<br><br>## In-Progress<br>- 总控软件设计说明书(重要不紧急)<br>- 总控修改IP构想文档、问题解决、文档组织(重要)<br><br>- 分支管理文档<br><br>- SC后端启动原理，启动协程，常驻协程，与文件系统的交互通道，网络通道，进程通信通道，系统权限使用情况，系统资源占用情况，可能的依赖关系。 中长期规划<br>- markdown 文档模板--操作手册<br>- 网络配置蓝图<br><br>- 引擎备份/恢复 机制<br><br>- 升级兼容性要求文档<br><br>- api-gov 安装目录改造<br><br>- 11/24 跟老板关于 SV 重构的讨论总结<br>- 近半年内总控引擎插件软件系统架构调整规划、人力资源以及招聘计划<br><br>- 软件架构概述 文档<br><br>- 代码能力恢复计划 文档<br><br>- 总控引擎修改IP 需求评审<br><br>- 总控 引擎 通信链路整理文档<br><br>- 石犀适配kylin分析文档<br>-- kylin 环境搭建文档<br>-- kylin 问题整理文档<br><br><br>- gitlab commit 信息对不上问题文档<br><br>- Golang 组长项目管理文档<br>-- 组长职责<br>-- 组员管理事项<br><br>- 架构 12 项修炼<br><br>- 我想要什么<br>-- 编码时间<br>-- 自由时间<br>-- 娱乐时间<br><br><br>- docker hub<br><br>## Completed<br><br>- 绩效模板审查（紧急）<br>-- 团队贡献加分事项<br><br>- 12/11任务跟进<br>-- 动态口令<br>-- 慢速拒绝<br><br>- 软件兼容性文档<br>- SOA架构和ESB<br><br>- 12.15总结会议准备发言稿<br><br>- 石犀适配 kylin 任务分发<br>- 石犀客户环境遭病毒攻击排查解决记录<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>看板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>石犀客户环境遭病毒攻击排查解决记录.md</title>
    <link href="/2023/12/15/mdstorage/project/sr/%E7%9F%B3%E7%8A%80%E5%AE%A2%E6%88%B7%E7%8E%AF%E5%A2%83%E9%81%AD%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB%E6%8E%92%E6%9F%A5%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/12/15/mdstorage/project/sr/%E7%9F%B3%E7%8A%80%E5%AE%A2%E6%88%B7%E7%8E%AF%E5%A2%83%E9%81%AD%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB%E6%8E%92%E6%9F%A5%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="石犀客户环境遭病毒攻击排查解决记录"><a href="#石犀客户环境遭病毒攻击排查解决记录" class="headerlink" title="石犀客户环境遭病毒攻击排查解决记录"></a>石犀客户环境遭病毒攻击排查解决记录</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>检测到机器频繁访问外网 10w 次</p><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/image-20231215152706997.png" alt="image-20231215152706997"></p><h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><h4 id="top-ps-排查"><a href="#top-ps-排查" class="headerlink" title="top ps 排查"></a>top ps 排查</h4><p>一般进程会排到比较前，如果没排查到，也有可能是 top 程序被黑客替换，新装一个系统资源检测工具试试。</p><p>这一步可以查到异常进程 pid 和进程启动用户</p><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/image-20231215153729017.png" alt="image-20231215153729017"></p><p>ps -efl | grep $pid  显示是 kworker </p><h4 id="查看用户登录历史和进程环境变量"><a href="#查看用户登录历史和进程环境变量" class="headerlink" title="查看用户登录历史和进程环境变量"></a>查看用户登录历史和进程环境变量</h4><h5 id="last-查看用户登录历史"><a href="#last-查看用户登录历史" class="headerlink" title="last 查看用户登录历史"></a>last 查看用户登录历史</h5><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/image-20231215160118595.png" alt="image-20231215160118595"></p><h5 id="cat-proc-pid-environ"><a href="#cat-proc-pid-environ" class="headerlink" title="cat &#x2F;proc&#x2F;$pid&#x2F;environ"></a>cat &#x2F;proc&#x2F;$pid&#x2F;environ</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@sr:/home/sr# <span class="hljs-built_in">cat</span> /proc/479850/environ<br>SHELL=/bin/bashHISTSIZE=0PWD=/mnt/.xLOGNAME=rootXDG_SESSION_TYPE=ttyMOTD_SHOWN=pamHOME=/rootLANG=en_US.UTF-8HISTFILE=/dev/nullLS_COLORS=rs=0:di=01;34:<span class="hljs-built_in">ln</span>=01;36:mh=00:pi=40;33:so=01;35:<span class="hljs-keyword">do</span>=01;35:bd=40;33;01:<span class="hljs-built_in">cd</span>=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.<span class="hljs-built_in">rm</span>=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:SSH_CONNECTION=10.110.13.44 46598 192.168.241.150 22LESSCLOSE=/usr/bin/lesspipe %s %sXDG_SESSION_CLASS=userTERM=xtermLESSOPEN=| /usr/bin/lesspipe %sUSER=rootSHLVL=1XDG_SESSION_ID=114015LC_CTYPE=en_US.UTF-8XDG_RUNTIME_DIR=/run/user/0SSH_CLIENT=10.110.13.44 46598 22XDG_DATA_DIRS=/usr/local/share:/usr/share:/var/lib/snapd/desktopPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/binHISTFILESIZE=0DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/0/busSSH_TTY=/dev/pts/0OLDPWD=/mnt/.x_=./<br></code></pre></td></tr></table></figure><h3 id="清理病毒程序"><a href="#清理病毒程序" class="headerlink" title="清理病毒程序"></a>清理病毒程序</h3><h4 id="杀死进程和可执行文件"><a href="#杀死进程和可执行文件" class="headerlink" title="杀死进程和可执行文件"></a>杀死进程和可执行文件</h4><p>kill $pid </p><p>rm &#x2F;mnt&#x2F;.x</p><h4 id="查杀系统定时任务"><a href="#查杀系统定时任务" class="headerlink" title="查杀系统定时任务"></a>查杀系统定时任务</h4><p>vim &#x2F;etc&#x2F;crontab</p><h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>持续监控被攻击机器，避免未杀干净</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>经客户确认 last 返回结果中 10.110.13.44 为内网一台被黑客攻陷的机器。推测是通过此机器暴力破解两台 sc se 机器 root 帐号密码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="漏洞和防护"><a href="#漏洞和防护" class="headerlink" title="漏洞和防护"></a>漏洞和防护</h3><ol><li>机器网络访问安全策略没做，应该对机器做源IP访问白名单和目的IP访问白名单</li><li>（客户那边应该做网络隔离）</li><li>root 权限不应该允许直接登录</li><li>不管是什么环境，应该将密码设置为高安全级别，防暴力破解</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>问题排查</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总控引擎数据链路.md</title>
    <link href="/2023/12/14/mdstorage/project/sr/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0/%E6%80%BB%E6%8E%A7%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF/"/>
    <url>/2023/12/14/mdstorage/project/sr/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0/%E6%80%BB%E6%8E%A7%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-params">###</span> 总控引擎节点通信链路、引擎节点之间通信链路<br><br><span class="hljs-params">####</span> 总控-&gt;引擎  服务搭建链路<br><br><span class="hljs-params">####</span> 总控-&gt;引擎 引擎安装链路1<br><br><span class="hljs-params">#####</span> 链路 1<br><br>manager -&gt; agent<br>协议： http<br>ip: vip/nodeIp<br>端口: 8099<br><br><span class="hljs-params">#####</span> 链路 2<br><br>manager -&gt; admin<span class="hljs-built_in">_</span>ha<br>协议: grpc<br>ip: vip<br>端口：6898<br><br><span class="hljs-params">#####</span> 链路 3<br><br>manager -&gt; sc<br>协议： https<br>ip: 127.0.0.1<br>端口： 443<br><br><span class="hljs-params">#####</span> 链路 4<br><br>manager -&gt; sv<br>协议：http<br>端口：20522<br><br><span class="hljs-params">#####</span> 链路 5<br><br>agent -&gt; manager<br>协议：http<br>ip：nodeIp<br>端口：8098<br><br><span class="hljs-params">#####</span> 链路 6<br><br>agent -&gt; apiserver<br>协议: https<br>ip：vip<br>端口：6443<br><br><span class="hljs-params">####</span> 引擎-&gt;总控 引擎安装链路2<br><br><span class="hljs-params">####</span> 引擎-&gt;总控 可视化数据链路<br><br>sv -&gt; sc<br>协议: https<br>IP: 127.0.0.1<br>端口: 29105<br><br>sv -&gt; dam<br>协议: grpc<br>IP: vip<br>端口: 1234<br><br>sv -&gt; dam<br>协议: http<br>IP: vip<br>端口: 8899<br><br>sv -&gt; webserver<br>协议: https<br>IP: vip<br>端口: 8299<br><br>dam -&gt; sv<br>协议: tcp<br>IP:  0.0.0.0<br>端口: 4150<br><br><span class="hljs-params">####</span> 引擎-&gt;引擎 引擎管理链路<br><br>**adminDam**<br><br><span class="hljs-params">#####</span> dam 链路1<br><br>协议: http<br>ip: vip<br>端口：8443<br>kube-apiserver -&gt; adminDam<br>备注：webhook<br><br><span class="hljs-params">#####</span> dam 链路2<br><br>协议: http<br>ip: vip<br>端口：8899<br>webserver -&gt; adminDam<br>sv -&gt; adminDam<br><br><span class="hljs-params">#####</span> dam 链路3<br><br>协议: grpc<br>ip: vip<br>端口：1234<br>sv -&gt; adminDam<br><br><span class="hljs-params">#####</span> dam 链路4<br><br>**dataDam**<br><br><span class="hljs-params">#####</span> dam 链路5<br><br>协议: grpc<br>ip: vip<br>端口：7000<br>dataDam -&gt; adminDam<br><br><span class="hljs-params">#####</span> dam 链路6<br><br>协议: grpc<br>ip: 127.0.0.1<br>端口：9977<br>envoy -&gt; dataDam<br><br><span class="hljs-params">#####</span> dam 链路7<br><br>协议: http<br>ip: 节点IP<br>端口：9001<br>webserver -&gt; dataDam<br><br><span class="hljs-params">#####</span> dam 链路8<br><br>协议: grpc<br>ip: 127.0.0.1<br>端口：9002<br>polycube -&gt; dataDam<br><br><br><br><br><br><span class="hljs-params">###</span> 总控-&gt;引擎<br><br><span class="hljs-params">####</span> manager -&gt; agent<br><br>协议： http<br>ip: vip/nodeIp<br>端口: 8099<br><br><span class="hljs-params">####</span> manager -&gt; admin<span class="hljs-built_in">_</span>ha<br><br>协议: grpc<br>ip: vip<br>端口：6898<br><br><span class="hljs-params">####</span> sv -&gt; dam<br><br>协议: grpc<br>IP: vip<br>端口: 1234<br><br><span class="hljs-params">####</span> sv -&gt; dam<br><br>协议: http<br>IP: vip<br>端口: 8899<br><br><span class="hljs-params">####</span> sv -&gt; webserver<br><br>协议: https<br>IP: vip<br>端口: 8299<br><br><span class="hljs-params">###</span> 引擎-&gt;总控<br><br><span class="hljs-params">####</span> agent -&gt; manager<br><br>协议：http<br>ip：nodeIp<br>端口：8098<br><br><span class="hljs-params">####</span> dam -&gt; sv<br><br>协议: tcp<br>IP:  0.0.0.0<br>端口: 4150<br></code></pre></td></tr></table></figure><p>写上</p><ol><li>协议 tcp 或 http 等协议</li><li>服务所使用的 IP 是 VIP，还是 127.0.0.1 、0.0.0.0、*，没用就填 无</li><li>绑定端口，没用填无</li></ol><h1 id="总控-–-xx-引擎"><a href="#总控-–-xx-引擎" class="headerlink" title="总控 –&gt; xx 引擎"></a>总控 –&gt; xx 引擎</h1><p>引擎 –&gt; 总控</p><p>引擎节点 –&gt; 引擎节点</p><h3 id="总控、引擎、插件跨节点通信链路"><a href="#总控、引擎、插件跨节点通信链路" class="headerlink" title="总控、引擎、插件跨节点通信链路"></a>总控、引擎、插件跨节点通信链路</h3><pre><code class=" mermaid">graph LRsubgraph Sc[总控]scsv[可视化 sv]installer-manager[引擎安装 manager]endsubgraph Se[流量引擎]        subgraph Sem[流量引擎 管理节点]            installer-agent[引擎安装 agent]            webserver[Webserver]            admin_dam[admin Dam]            apiserver[Apiserver]            admin_ha[admin HA]nexus_m[Nexus]global_plugin_server[global-plugin-server]        end        subgraph Sew[流量引擎 工作节点]            data_dam[data Dam]            nexus_w[Nexus]            envoy[Envoy]        end                subgraph Ses[流量引擎 调度节点]        nexus_s[Nexus]        endendinstaller-manager --&gt;|vip/nodeIP:8099|installer-agentinstaller-manager --&gt;|vip:6898|admin_hasv --&gt;|vip:1234|admin_damsv --&gt;|vip:8899|admin_damsv --&gt;|vip:8299|webserversc --&gt;|vip:8229|webserverinstaller-agent --&gt;|nodeIP:8098|installer-managerdata_dam --&gt;|nodeIp:4150|svdata_dam --&gt;|nodeIp:9001|webserverwebserver --&gt;|nodeIp:8000| nexus_m &amp; nexus_s &amp; nexus_wenvoy --&gt;|vip:7878 7978| global_plugin_server%%installer-agent --&gt;|vip:6443|apiserver</code></pre><h3 id="第一步改造（通信方向反转）"><a href="#第一步改造（通信方向反转）" class="headerlink" title="第一步改造（通信方向反转）"></a>第一步改造（通信方向反转）</h3><pre><code class=" mermaid">graph LRsubgraph Sc[总控]scsv[可视化 sv]installer-manager[引擎安装 manager]endsubgraph Se[流量引擎]        subgraph Sem[流量引擎 管理节点]            installer-agent[引擎安装 agent]            webserver[Webserver]            admin_dam[admin Dam]            apiserver[Apiserver]            admin_ha[admin HA]nexus_m[Nexus]global_plugin_server[global-plugin-server]        end        subgraph Sew[流量引擎 工作节点]            data_dam[data Dam]            nexus_w[Nexus]            envoy[Envoy]        end                subgraph Ses[流量引擎 调度节点]        nexus_s[Nexus]        endendinstaller-manager --&gt;|vip/nodeIP:8099|installer-agentinstaller-manager --&gt;|vip:6898|admin_hasv --&gt;|vip:1234|admin_damsv --&gt;|vip:8899|admin_damsv --&gt;|vip:8299|webserversc --&gt;|vip:8229|webserver</code></pre><h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><ul><li><p>grpc 双向流</p><ul><li><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li><strong>基于 HTTP&#x2F;2</strong>: 支持流控制、头部压缩等高效功能。</li><li><strong>强类型接口定义</strong>: 使用 Protocol Buffers，可以定义清晰的服务接口。</li><li><strong>多语言支持</strong>: 客户端和服务端可以使用不同的编程语言实现。</li></ul><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul><li><strong>浏览器支持有限</strong>: 直接在浏览器中使用 gRPC 可能有兼容性问题。</li><li><strong>复杂度较高</strong>: 相比于 RESTful API 或 WebSocket，gRPC 的学习曲线更陡峭。</li></ul></li></ul></li><li><p>websocket 双向通信</p><ul><li><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ul><li><strong>全双工通信</strong>: 允许服务器和客户端之间进行实时、双向通信。</li><li><strong>低延迟</strong>: 一旦建立连接，数据交换延迟非常低。</li><li><strong>广泛支持</strong>: 大多数现代浏览器和网络库都支持 WebSocket。</li></ul><h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><ul><li><strong>缺乏内置消息格式</strong>: 需要自定义协议来处理消息。</li><li><strong>缺少先进的消息处理功能</strong>: 如消息队列、消息确认等。</li><li><strong>扩展性</strong>: 在大规模应用中，保持大量的 WebSocket 连接可能会导致资源问题。</li></ul></li></ul></li><li><p>http2.0 双向通信</p><ul><li><h4 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h4><ul><li><strong>多路复用</strong>: 单个连接上可以并行多个请求&#x2F;响应，提高效率。</li><li><strong>头部压缩</strong>: 减少了额外的网络开销。</li><li><strong>服务器推送</strong>: 服务器可以主动向客户端发送资源。</li></ul><h4 id="劣势-2"><a href="#劣势-2" class="headerlink" title="劣势"></a>劣势</h4><ul><li><strong>兼容性和支持</strong>: 虽然现代浏览器普遍支持 HTTP&#x2F;2，但在某些环境中可能仍需考虑兼容性问题。</li><li><strong>复杂性</strong>: 相比 HTTP&#x2F;1.1，HTTP&#x2F;2 实现更复杂。</li></ul></li></ul></li><li><p>长轮询</p></li><li><p>消息队列&#x2F;订阅发布模型</p><ul><li><h4 id="优势-3"><a href="#优势-3" class="headerlink" title="优势"></a>优势</h4><ul><li><strong>解耦生产者和消费者</strong>: 生产者和消费者不必知道对方的存在。</li><li><strong>可扩展性</strong>: 更容易在分布式系统中扩展。</li><li><strong>可靠性</strong>: 很多消息队列系统提供消息持久化、确认机制等功能，确保消息不会丢失。</li></ul><h4 id="劣势-3"><a href="#劣势-3" class="headerlink" title="劣势"></a>劣势</h4><ul><li><strong>延迟</strong>: 相比直接的双向通信，可能会引入更多的延迟。</li><li><strong>复杂性</strong>: 引入消息队列系统会增加系统架构的复杂性。</li><li><strong>维护成本</strong>: 需要管理和维护额外的消息队列服务。</li></ul></li></ul></li></ul><h3 id="第二步改造（规整）"><a href="#第二步改造（规整）" class="headerlink" title="第二步改造（规整）"></a>第二步改造（规整）</h3><pre><code class=" mermaid">```以下是去重后的通信链路，每条链路信息单独展示在一行中：1. **总控 -&gt; 总控**   - manager -&gt; sc: 协议 https, IP 127.0.0.1, 端口 443   - manager -&gt; sv: 协议 http, 端口 205222. **总控 -&gt; 引擎**- manager -&gt; agent: 协议 http, IP vip/nodeIp, 端口 8099- manager -&gt; admin_ha: 协议 grpc, IP vip, 端口 68983. **引擎 -&gt; 总控**- agent -&gt; manager: 协议 http, IP nodeIp, 端口 8098- agent -&gt; apiserver: 协议 https, IP vip, 端口 6443- sv -&gt; sc: 协议 https, IP 127.0.0.1, 端口 29105- sv -&gt; dam: 协议 grpc, IP vip, 端口 1234- sv -&gt; dam: 协议 http, IP vip, 端口 8899- sv -&gt; webserver: 协议 https, IP vip, 端口 8299- dam -&gt; sv: 协议 tcp, IP 0.0.0.0, 端口 41504. **引擎 -&gt; 引擎**- kube-apiserver -&gt; adminDam: 协议 http, IP vip, 端口 8443, 备注 webhook- webserver -&gt; adminDam: 协议 http, IP vip, 端口 8899- sv -&gt; adminDam: 协议 grpc, IP vip, 端口 1234- dataDam -&gt; adminDam: 协议 grpc, IP vip, 端口 7000- envoy -&gt; dataDam: 协议 grpc, IP 127.0.0.1, 端口 9977- webserver -&gt; dataDam: 协议 http, IP 节点IP, 端口 9001- polycube -&gt; dataDam: 协议 grpc, IP 127.0.0.1, 端口 9002这样的展示形式使得每个通信链路都清晰地在一行内显示，方便对照和查阅。```mermaid---title: 总控逻辑架构图---graph LR    subgraph 总控    direction TBsubgraph 用户接口层direction TBDataSV[数据可视]APIAsset[API可视]SysInfo[系统信息]SEInfo[引擎信息]ObjectInfo[对象信息]UserInfo[用户信息]endsubgraph 业务层direction LRAPI[API]subgraph SCDashboard[SC]Auth[授权管理]User[用户管理]Object[对象管理]System[系统管理]SVClient[可视化]subgraph 引擎管理SEInstallerClient[引擎安装]服务搭建endendsubgraph SVServer[SV]数据可视API可视业务可视插件可视endsubgraph Install-ManageSEInstall[流量引擎安装]SidecarSE[边车引擎在线、离线安装]路由引擎安装引擎节点管理endendsubgraph 数据层Redis[(Redis)]SCEtcd[(Etcd)]NSQ([NSQ])MySQL[(MySQL)]MongoDB[(MongoDB)]FS(((FS)))endendsubgraph 引擎                subgraph SEAppLayer[业务层]        direction TB        subgraph SE-M_cluster        subgraph SE-M        Webserver        adminDam        adminHA        adminKA        semGRL[global-rate-limit]        kube-ApiServer        semInstallAgent[Install-Agent]        semNexus[Nexus]        end        end                subgraph SE-S_cluster        subgraph SE-S        dataHA:::Yellow        dataKA        sesInstallAgent[Install-Agent]        sesNexus[Nexus]                end        end                subgraph SE-W_cluster        subgraph SE-W        sewWorkDam[workDam]        dataWorker        Polycube        Envoy        sewGRL[global-rate-limit]        sewInstallAgent[Install-Agent]        sewNexus[Nexus]                end        end                end                subgraph SEDataLayer[数据层]        SEEtcd[(ETCD)]        SEFS(((FS)))        end            end         服务搭建 --&gt; Webserver    API &lt;====&gt; SCDashboard    API &lt;====&gt; 用户接口层    SVClient -.-&gt; SVServer    SEInstallerClient -.-&gt; Install-Manage    Install-Manage &lt;--&gt; semInstallAgent &amp; sesInstallAgent &amp; sewInstallAgent    Envoy --&gt; sewWorkDam --&gt; 数据可视    业务可视 --&gt; Envoy    linkStyle 1,2 stroke:blue,stroke-width:8px,color:black;    linkStyle 5,6,7 stroke:red,stroke-width:8px,color:black;    style SEDataLayer fill:#FFEBB5classDef Yellow fill:#f96    </code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SOA架构和ESB.md</title>
    <link href="/2023/12/12/mdstorage/domain/%E6%9E%B6%E6%9E%84/SOA%E6%9E%B6%E6%9E%84%E5%92%8CESB/"/>
    <url>/2023/12/12/mdstorage/domain/%E6%9E%B6%E6%9E%84/SOA%E6%9E%B6%E6%9E%84%E5%92%8CESB/</url>
    
    <content type="html"><![CDATA[<p>SOA（Service-Oriented Architecture，面向服务的架构）是一种高层次的架构设计理念，旨在通过将业务功能划分为一系列服务来提升企业 IT 系统的效率和灵活性。在 SOA 架构中，每个业务功能被视为一项服务，这些服务既可以是大规模的，如人力资源管理，也可以是小规模的，如人员基本信息管理。服务的粒度（粗粒度或细粒度）取决于企业的实际需求和情况。</p><p>关键概念和组件包括：</p><ol><li><p><strong>服务（Service）</strong>：在 SOA 中，所有业务功能都被视为服务。服务的核心特点是对外提供开放的能力，这意味着其他系统可以在无需定制化开发的情况下使用这些服务。服务的设计可以根据需要进行调整，以适应不同的业务需求。</p></li><li><p><strong>企业服务总线（ESB）</strong>：ESB 的概念源自计算机总线，其作用是将企业中的各种服务连接起来。由于各服务可能是异构的，ESB 的作用是屏蔽这些异构系统所提供的不同接口方式，以实现服务间的高效互联互通。ESB 是 SOA 中解决服务集成问题的关键组件。</p></li><li><p><strong>松耦合（Loose Coupling）</strong>：松耦合是 SOA 的一个重要目标，旨在减少服务之间的依赖关系和相互影响。在 SOA 架构中，各服务独立运行，相互之间的依赖关系最小化。这种设计有助于降低服务升级或变更时对其他服务的影响。</p></li></ol><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h4><ul><li>SOA 提出的背景是企业内部的 IT 系统重复建设且效率低下。 </li><li>SOA 更 多是在传统企业（例如 ，制造业、 金融业等〉落地和推广 ，在互联网行业并没 有大规模的实践和推广。 </li><li>SOA 三个关键概念 ：服务、 ESB 和松耦合。</li><li>SOA 架构中，每项业务功能都是一项服务，服务就意味着要对外提供开放的能力。 </li><li>SOA 使用 ESB 来屏蔽异构系统对外提供各种不同的 接 口方式，以此来达到服务间 高效 的互联互通。 •</li><li>SOA 解决了传统 IT 系统重复建设和扩展效 率低的问题，但其本身也引入了更多的 复杂 性， SOA 最广为人诣病的就是 ESB 。</li><li>SOA 的 ESB 设计也是无奈之举，企业在应用 SOA 时，各种异构的 IT 系统都己经存在 很多年了，完全重写或按照统一标准进行改造的成本是非常大的，只能通过 ESB 方式 去适配已经存在的各种异构系统。</li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件兼容性.md</title>
    <link href="/2023/12/12/mdstorage/domain/%E6%9E%B6%E6%9E%84/%E8%BD%AF%E4%BB%B6%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    <url>/2023/12/12/mdstorage/domain/%E6%9E%B6%E6%9E%84/%E8%BD%AF%E4%BB%B6%E5%85%BC%E5%AE%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="向前兼容（Forward-Compatibility）："><a href="#向前兼容（Forward-Compatibility）：" class="headerlink" title="向前兼容（Forward Compatibility）："></a>向前兼容（Forward Compatibility）：</h3><p>向前兼容是指新版本的软件或系统能够与旧版本的数据或接口兼容，也就是说，新版本能够处理旧版本的数据或与旧版本的接口进行通信。这就好比想象一个软件更新后，它仍然能够读取和处理旧版本的文件格式，使得用户可以平稳地升级到新版本而不会失去旧数据。</p><p><strong>实例</strong>：考虑一个文本编辑器，新版本的编辑器能够打开和编辑旧版本创建的文档，而不需要进行额外的转换或修改。这就是向前兼容的一个实例。</p><p><strong>可视化</strong>：你可以想象一个箭头从旧版本指向新版本，表示新版本可以处理旧版本的内容。</p><h3 id="向后兼容（Backward-Compatibility）："><a href="#向后兼容（Backward-Compatibility）：" class="headerlink" title="向后兼容（Backward Compatibility）："></a>向后兼容（Backward Compatibility）：</h3><p>向后兼容是指旧版本的软件或系统能够与新版本的数据或接口兼容，也就是说，旧版本能够处理新版本的数据或与新版本的接口进行通信。这就好比想象一个新版本的操作系统可以运行旧版本的应用程序，而不需要对这些应用程序进行修改。</p><p><strong>实例</strong>：考虑一个游戏控制器，旧版本的控制器可以与新版本的游戏主机一起使用，而不需要更新控制器的固件或驱动程序。这就是向后兼容的一个实例。</p><p><strong>可视化</strong>：你可以想象一个箭头从新版本指向旧版本，表示新版本允许与旧版本兼容。</p><h3 id="类比："><a href="#类比：" class="headerlink" title="类比："></a>类比：</h3><p>类比可以帮助我们更好地理解向前和向后兼容。我们可以将软件版本类比为书籍版本。假设一本书的新版本出版了，如果你可以在新版本的书中找到旧版本中的内容，并且可以理解它，那么这就是向前兼容。反之，如果你可以继续使用旧版本的书来理解新版本中的内容，那么这就是向后兼容。</p><h3 id="可视化："><a href="#可视化：" class="headerlink" title="可视化："></a>可视化：</h3><p>可视化可以通过图表、图形或流程图来帮助解释向前和向后兼容。你可以绘制两个版本之间的数据流程图，显示数据如何在它们之间传递，以及它们是否兼容。这种可视化方式可以使概念更加清晰。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>software</tag>
      
      <tag>兼容</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>团队贡献事项.md</title>
    <link href="/2023/12/11/mdstorage/project/sr/%E5%9B%A2%E9%98%9F%E8%B4%A1%E7%8C%AE%E4%BA%8B%E9%A1%B9/"/>
    <url>/2023/12/11/mdstorage/project/sr/%E5%9B%A2%E9%98%9F%E8%B4%A1%E7%8C%AE%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="团队贡献事项"><a href="#团队贡献事项" class="headerlink" title="团队贡献事项"></a>团队贡献事项</h2><h3 id="基础设施搭建、优化"><a href="#基础设施搭建、优化" class="headerlink" title="基础设施搭建、优化"></a>基础设施搭建、优化</h3><ol><li><strong>代码仓库管理</strong></li><li><strong>持续集成&#x2F;持续部署（CI&#x2F;CD）系统</strong></li><li><strong>代码质量和安全工具</strong></li><li><strong>文档管理</strong></li><li><strong>监控和日志系统</strong></li><li><strong>开发和测试环境</strong></li><li><strong>项目管理工具</strong></li></ol><h3 id="研发流程、制度制定、优化"><a href="#研发流程、制度制定、优化" class="headerlink" title="研发流程、制度制定、优化"></a>研发流程、制度制定、优化</h3><h3 id="团队关键问题攻坚"><a href="#团队关键问题攻坚" class="headerlink" title="团队关键问题攻坚"></a>团队关键问题攻坚</h3><ol><li><strong>技术债务管理</strong></li><li><strong>性能瓶颈分析和方案支持</strong></li><li><strong>难点问题攻克（带团队攻克也算）</strong></li></ol><h3 id="培训、技术分享"><a href="#培训、技术分享" class="headerlink" title="培训、技术分享"></a>培训、技术分享</h3><ol><li><strong>主持定期技术研讨会</strong></li><li><strong>创新或新领域研究和培训</strong></li><li><strong>白皮书编写和分享</strong></li><li><strong>跨团队知识共享</strong></li></ol><h3 id="创新和研究"><a href="#创新和研究" class="headerlink" title="创新和研究"></a>创新和研究</h3><ol><li><strong>创新或新领域研究和分享</strong></li></ol><h3 id="客户支持和反馈"><a href="#客户支持和反馈" class="headerlink" title="客户支持和反馈"></a>客户支持和反馈</h3><ol><li><strong>兄弟部门问题攻克、支持</strong></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>绩效</tag>
      
      <tag>评价</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一周看板-12.11.md</title>
    <link href="/2023/12/11/mdstorage/project/sr/%E4%B8%80%E5%91%A8%E7%9C%8B%E6%9D%BF/%E4%B8%80%E5%91%A8%E7%9C%8B%E6%9D%BF-12.11/"/>
    <url>/2023/12/11/mdstorage/project/sr/%E4%B8%80%E5%91%A8%E7%9C%8B%E6%9D%BF/%E4%B8%80%E5%91%A8%E7%9C%8B%E6%9D%BF-12.11/</url>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs kanban"># 2023/12/11 Task List<br><br>## Todo<br>- https://github.com/mli/autocut 是什么<br>- on-premise 综述<br>- InfoQ 一周消息速递<br>- 搜书方法、主流格式文档转换方法、以图搜图、学习资料搜索<br><br>- 周会 （1. 转测流程 2. 任务进度 3. 说说问题）<br>- 新人培训计划文档<br><br>- chatgpt 插件调研文档<br>- SR 问题跟踪文档<br>- 虚拟机克隆调研文档<br><br>- SR 研发工作流程统计时长<br><br>- 安装升级框架实施方案<br><br>- 文章类型概述文档<br>- 部门会议总结<br>- 基础设施组概述<br>- 测试用例设计文档内容要求<br>- 组长职责<br>- 公共库维护指南文档<br>- 慢速拒绝需求<br><br>- PostgreSQL数据库内核分析 拆解<br><br>- 针对产品的石犀培训文档<br><br>- AES 算法<br><br>- mermaid 流程图文档<br><br>## In-Progress<br>- 总控软件设计说明书(重要不紧急)<br>- 总控修改IP构想文档、问题解决、文档组织(重要)<br><br>- 分支管理文档<br><br>- SC后端启动原理，启动协程，常驻协程，与文件系统的交互通道，网络通道，进程通信通道，系统权限使用情况，系统资源占用情况，可能的依赖关系。 中长期规划<br>- markdown 文档模板--操作手册<br>- 网络配置蓝图<br><br>- 引擎备份/恢复 机制<br><br>- 升级兼容性要求文档<br><br>- api-gov 安装目录改造<br><br>- 11/24 跟老板关于 SV 重构的讨论总结<br>- 近半年内总控引擎插件软件系统架构调整规划、人力资源以及招聘计划<br><br>- 软件架构概述 文档<br><br>- 代码能力恢复计划 文档<br><br>- 总控引擎修改IP 需求评审<br><br>- 总控 引擎 通信链路整理文档<br><br>## Completed<br>- 基础设施组维护<br>- 引擎组项目管理<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>看板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>麦克阿瑟.md</title>
    <link href="/2023/12/07/mdstorage/project/%E5%86%99%E4%BD%9C/%E9%BA%A6%E5%85%8B%E9%98%BF%E7%91%9F/"/>
    <url>/2023/12/07/mdstorage/project/%E5%86%99%E4%BD%9C/%E9%BA%A6%E5%85%8B%E9%98%BF%E7%91%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="文案碎片"><a href="#文案碎片" class="headerlink" title="文案碎片"></a>文案碎片</h2><h3 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h3><h3 id="中间"><a href="#中间" class="headerlink" title="中间"></a>中间</h3><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>此言一出，便迅速引起世界各地广泛关注。那么，到底究竟如何呢，敬请收看大型纪录片xxx</p>]]></content>
    
    
    
    <tags>
      
      <tag>media</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CICD团队运维.md</title>
    <link href="/2023/12/07/mdstorage/project/sr/CICD%E5%9B%A2%E9%98%9F%E8%BF%90%E7%BB%B4/"/>
    <url>/2023/12/07/mdstorage/project/sr/CICD%E5%9B%A2%E9%98%9F%E8%BF%90%E7%BB%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="标准的构建和部署流程"><a href="#标准的构建和部署流程" class="headerlink" title="标准的构建和部署流程"></a>标准的构建和部署流程</h2><h3 id="1-源代码管理"><a href="#1-源代码管理" class="headerlink" title="1. 源代码管理"></a>1. 源代码管理</h3><ul><li><strong>版本控制系统设置</strong>：如 Git，用于追踪代码变更历史。</li><li><strong>分支策略</strong>：确定如何使用分支来管理功能开发、修复和发布。</li></ul><h3 id="2-构建环境搭建"><a href="#2-构建环境搭建" class="headerlink" title="2. 构建环境搭建"></a>2. 构建环境搭建</h3><ul><li><strong>选择和配置构建服务器</strong>：如 Jenkins, TeamCity 或 GitLab CI。</li><li><strong>环境依赖</strong>：确保所有必要的编译器、库和工具都已安装和配置。</li></ul><h3 id="3-代码变更触发"><a href="#3-代码变更触发" class="headerlink" title="3. 代码变更触发"></a>3. 代码变更触发</h3><ul><li><strong>代码提交</strong>：开发者提交代码到版本控制系统。</li><li><strong>触发构建</strong>：代码提交自动触发构建过程。</li></ul><h3 id="4-自动化编译"><a href="#4-自动化编译" class="headerlink" title="4. 自动化编译"></a>4. 自动化编译</h3><ul><li><strong>获取最新代码</strong>：从版本控制系统获取最新的代码分支。</li><li><strong>依赖管理</strong>：通过工具如 Maven, Gradle 或 npm 处理任何依赖。</li><li><strong>编译源代码</strong>：将源代码编译成二进制文件或字节码。</li></ul><h3 id="5-自动化测试"><a href="#5-自动化测试" class="headerlink" title="5. 自动化测试"></a>5. 自动化测试</h3><ul><li><strong>单元测试</strong>：运行单元测试来验证代码片段的功能。</li><li><strong>集成测试</strong>：在集成环境中测试不同组件的协同工作。</li><li><strong>性能测试</strong>：检查应用的性能指标。</li><li><strong>安全测试</strong>：检测潜在的安全漏洞。</li></ul><h3 id="6-构建结果"><a href="#6-构建结果" class="headerlink" title="6. 构建结果"></a>6. 构建结果</h3><ul><li><strong>构建状态</strong>：成功或失败的反馈。</li><li><strong>构建产物存储</strong>：如成功，将构建的产物（如 JAR, WAR 文件）存储在制品库中，例如 Nexus 或 Artifactory。</li></ul><h3 id="7-部署到测试环境"><a href="#7-部署到测试环境" class="headerlink" title="7. 部署到测试环境"></a>7. 部署到测试环境</h3><ul><li><strong>自动部署</strong>：将构建的产物部署到测试环境。</li><li><strong>自动化测试</strong>：进行更多的自动化测试（UI 测试、端到端测试）。</li></ul><h3 id="8-质量保证"><a href="#8-质量保证" class="headerlink" title="8. 质量保证"></a>8. 质量保证</h3><ul><li><strong>手动测试</strong>：QA 团队进行探索性测试或验收测试。</li><li><strong>问题修复</strong>：开发者根据测试反馈修复问题。</li></ul><h3 id="9-部署到生产环境"><a href="#9-部署到生产环境" class="headerlink" title="9. 部署到生产环境"></a>9. 部署到生产环境</h3><ul><li><strong>准备生产发布</strong>：执行部署前的最终检查。</li><li><strong>蓝绿部署&#x2F;滚动更新</strong>：减少部署时的停机时间。</li><li><strong>监控和验证</strong>：确保生产环境稳定运行。</li></ul><h3 id="10-维护和监控"><a href="#10-维护和监控" class="headerlink" title="10. 维护和监控"></a>10. 维护和监控</h3><ul><li><strong>日志记录</strong>：收集和分析日志文件。</li><li><strong>性能监控</strong>：监控系统性能指标。</li><li><strong>故障恢复</strong>：在发生故障时进行快速恢复。</li></ul><h3 id="11-反馈和迭代"><a href="#11-反馈和迭代" class="headerlink" title="11. 反馈和迭代"></a>11. 反馈和迭代</h3><ul><li><strong>用户反馈</strong>：收集用户对新版本的反馈。</li><li><strong>持续改进</strong>：基于反馈和监控数据进行改进。</li></ul><h2 id="职位要求"><a href="#职位要求" class="headerlink" title="职位要求"></a>职位要求</h2><p>一个 Devops 应该将上述流程负责完成，并跟重要代码负责人紧密沟通</p>]]></content>
    
    
    
    <tags>
      
      <tag>CI/CD</tag>
      
      <tag>运维</tag>
      
      <tag>交付</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为鲲鹏信创平台分析.md</title>
    <link href="/2023/12/07/mdstorage/project/sr/%E5%8D%8E%E4%B8%BA%E9%B2%B2%E9%B9%8F%E4%BF%A1%E5%88%9B%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90/"/>
    <url>/2023/12/07/mdstorage/project/sr/%E5%8D%8E%E4%B8%BA%E9%B2%B2%E9%B9%8F%E4%BF%A1%E5%88%9B%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p><a href="http://www.leagsoft.com/doc/article/103107.html">华为VPN客户端</a></p><h2 id="平台分析"><a href="#平台分析" class="headerlink" title="平台分析"></a>平台分析</h2><h3 id="proc-cpuinfo"><a href="#proc-cpuinfo" class="headerlink" title="/proc/cpuinfo"></a><code>/proc/cpuinfo</code></h3><ol><li><p><strong>Processor</strong>: 63</p><ul><li>这表示您正在查看的是第 64 个逻辑处理器的信息（处理器编号从 0 开始计数）。</li></ul></li><li><p><strong>Model Name</strong>: HUAWEI, Kunpeng 920</p><ul><li>这是处理器的型号和品牌。Kunpeng 920 是华为开发的处理器，主要用于服务器和高性能计算。</li></ul></li><li><p><strong>BogoMIPS</strong>: 200.00</p><ul><li>BogoMIPS 是一种计算机性能的测量方式，代表“每秒可以执行的无用操作次数”。它并不是一个精确的性能指标，但可以提供一些基本的速度概念。</li></ul></li><li><p><strong>Features</strong></p><ul><li>这列出了处理器支持的特性和指令集。例如，<code>fp</code> 表示浮点处理能力，<code>asimd</code> 表示高级 SIMD (单指令多数据) 执行能力，<code>aes</code> 表示高级加密标准支持，等等。这些特性通常对于理解处理器在特定任务（如加密、数据处理等）上的性能很重要。</li></ul></li><li><p><strong>CPU Implementer</strong>: 0x48</p><ul><li>这是一个表示处理器实现者的十六进制代码。在 ARM 架构中，不同的数字代表不同的实现者。</li></ul></li><li><p><strong>CPU Architecture</strong>: 8</p><ul><li>表示处理器的架构版本。ARMv8 架构支持 64 位处理，是 ARM 架构的一个主要升级版本。</li></ul></li><li><p><strong>CPU Variant</strong>: 0x1, <strong>CPU Part</strong>: 0xd01, <strong>CPU Revision</strong>: 0</p><ul><li>这些信息进一步描述了处理器的具体版本和修订情况。CPU Variant 和 CPU Part 对于区分同一架构下不同处理器型号非常有用，而 CPU Revision 则提供了修订级别的信息。</li></ul></li></ol><h3 id="uname-a"><a href="#uname-a" class="headerlink" title="uname -a"></a><code>uname -a</code></h3><ol><li><p><strong>Linux</strong></p><ul><li>这表明您正在使用的是 Linux 操作系统。</li></ul></li><li><p><strong>IC22-04-007</strong></p><ul><li>这是您的机器（或主机）的名称。它是在网络中唯一标识该机器的名称。</li></ul></li><li><p><strong>4.19.90-52.15.v2207.ky10.aarch64</strong></p><ul><li>这是正在运行的 Linux 内核的版本号。其中：<ul><li><code>4.19.90</code> 是主版本号。</li><li><code>52.15.v2207.ky10</code> 可能是特定于发行版或厂商的额外版本标识。</li><li><code>aarch64</code> 表示该内核是为 ARM 架构的 64 位处理器编译的。</li></ul></li></ul></li><li><p><strong>#1 SMP Thu Nov 24 15:59:41 CST 2022</strong></p><ul><li>这部分提供了编译内核的时间戳和一些编译选项。<ul><li><code>#1</code> 表示这可能是一系列编译中的第一个。</li><li><code>SMP</code> 表示对称多处理，意味着内核支持多核处理器。</li><li><code>Thu Nov 24 15:59:41 CST 2022</code> 是内核编译的日期和时间。</li></ul></li></ul></li><li><p><strong>aarch64 GNU&#x2F;Linux</strong></p><ul><li>这再次确认了操作系统的架构（<code>aarch64</code>，即 64 位 ARM 架构）和操作系统类型（GNU&#x2F;Linux）。</li></ul></li></ol><h3 id="etc-os-release"><a href="#etc-os-release" class="headerlink" title="/etc/os-release"></a><code>/etc/os-release</code></h3><ol><li><p><strong>NAME&#x3D;”Kylin Linux Advanced Server”</strong></p><ul><li>这表示您的操作系统是“Kylin Linux Advanced Server”。麒麟操作系统是一种基于 Linux 的操作系统，主要在中国使用，通常用于企业和政府环境。</li></ul></li><li><p><strong>VERSION&#x3D;”V10 (Lance)”</strong></p><ul><li>这是操作系统的版本信息。V10 指的是版本号，而“(Lance)”可能是这个版本的代号或别名。</li></ul></li><li><p><strong>ID&#x3D;”kylin”</strong></p><ul><li>这是操作系统的唯一标识符，用于在脚本和自动化工具中区分不同的 Linux 发行版。</li></ul></li><li><p><strong>VERSION_ID&#x3D;”V10”</strong></p><ul><li>这是操作系统版本的另一种表示方式，重申您正在使用的是 V10 版本。</li></ul></li><li><p><strong>PRETTY_NAME&#x3D;”Kylin Linux Advanced Server V10 (Lance)”</strong></p><ul><li>这是操作系统的全名，通常用于显示给用户。它结合了操作系统名称、版本号和版本代号。</li></ul></li><li><p><strong>ANSI_COLOR&#x3D;”0;31”</strong></p><ul><li>这定义了在终端或控制台中用于显示操作系统信息的 ANSI 颜色代码。”0;31” 通常代表红色。</li></ul></li></ol><h2 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h2><p><a href="https://devpress.csdn.net/database/64844b1aade290484cb2ee7a.html">kylin安装docker</a></p><h3 id="yum-源添加"><a href="#yum-源添加" class="headerlink" title="yum 源添加"></a>yum 源添加</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-params">#</span> 要识别到下面有 repodata/repomd.xml 文件的那一层，并且先确认确实是 kylin10 sp3 系统，不然会拒绝<br>[openlab-kylin10sp3]<br>name=openlab-kylin10sp3<br>baseurl=https://update.cs2c.com.cn/NS/V10/V10SP3/os/adv/lic/base/aarch64/<br>gpgcheck=0<br>enabled=1<br><br></code></pre></td></tr></table></figure><h3 id="修改-sshd-config"><a href="#修改-sshd-config" class="headerlink" title="修改 sshd_config"></a>修改 sshd_config</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ClientAliveInterval 60<br>ClientAliveCountMax 1000<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>信创</tag>
      
      <tag>华为</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一周看板-12.4.md</title>
    <link href="/2023/12/04/mdstorage/project/sr/%E4%B8%80%E5%91%A8%E7%9C%8B%E6%9D%BF/%E4%B8%80%E5%91%A8%E7%9C%8B%E6%9D%BF-12.4/"/>
    <url>/2023/12/04/mdstorage/project/sr/%E4%B8%80%E5%91%A8%E7%9C%8B%E6%9D%BF/%E4%B8%80%E5%91%A8%E7%9C%8B%E6%9D%BF-12.4/</url>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs kanban"># 2023/11/13 Task List<br><br>## Todo<br>- https://github.com/mli/autocut 是什么<br>- on-premise 综述<br>- InfoQ 一周消息速递<br>- 搜书方法、主流格式文档转换方法、以图搜图、学习资料搜索<br><br>- meituan 对接、价格<br><br>- 周会 （1. 转测流程 2. 任务进度 3. 说说问题）<br>- 新人培训计划文档<br><br>- chatgpt 插件调研文档<br>- SR 问题跟踪文档<br>- 虚拟机克隆调研文档<br><br>- SR 研发工作流程统计时长<br><br>- 安装升级框架实施方案<br><br>- 文章类型概述文档<br>- 部门会议总结<br>- 基础设施组概述<br>- 测试用例设计文档内容要求<br>- 组长职责<br>- 公共库维护指南文档<br>- 慢速拒绝需求<br><br>- PostgreSQL数据库内核分析 拆解<br><br>## In-Progress<br>- 总控软件设计说明书(重要不紧急)<br>- 总控修改IP构想文档、问题解决、文档组织(重要)<br><br>- 分支管理文档<br><br>- SC后端启动原理，启动协程，常驻协程，与文件系统的交互通道，网络通道，进程通信通道，系统权限使用情况，系统资源占用情况，可能的依赖关系。 中长期规划<br>- markdown 文档模板--操作手册<br>- 网络配置蓝图<br><br>- TLS 双向认证文档<br><br>- 引擎备份/恢复 机制<br><br>- 升级兼容性要求文档<br><br>- api-gov 安装目录改造<br><br>- 11/24 跟老板关于 SV 重构的讨论总结<br>- 近半年内总控引擎插件软件系统架构调整规划、人力资源以及招聘计划<br><br>- 软件架构概述 文档<br><br>- 代码能力恢复计划 文档<br><br>## Completed<br>- 近期工作安排<br><br>- 商城提供给总控要实现的功能的API设计<br>- 现有总控、引擎、插件中存在的问题和相应解决方案路径以及解决问题所需的人才模型<br><br>- 业务可视化 因工作节点网络异常等原因推送数据阻塞导致 可视化部分页面无数据返回问题 解决<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>慢速拒绝和解决方案.md</title>
    <link href="/2023/11/30/mdstorage/domain/network/%E6%85%A2%E9%80%9F%E6%8B%92%E7%BB%9D%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2023/11/30/mdstorage/domain/network/%E6%85%A2%E9%80%9F%E6%8B%92%E7%BB%9D%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p><strong>HTTP慢速拒绝服务防御方案</strong></p><p><strong>一、背景与问题描述</strong><br>慢速拒绝服务攻击（LDOS）区别于传统的DDOS或CC攻击。它通过以极低的速度发送数据，旨在耗尽服务器资源。现有的安全插件（如WAF、Anti-CC、流量限速等）主要针对高频次攻击，但对于低频次的慢速拒绝服务攻击防御能力不足。这些插件工作在应用层（L7），处理由envoy解析后的HTTP消息，因此缺少一些关键的“元数据”，如连接时间、请求发起时间等，这使得它们难以有效防御慢速拒绝服务攻击。</p><p><strong>二、HTTP慢速拒绝服务攻击方式</strong><br>攻击者在与HTTP服务器建立连接后，尽可能长时间保持该连接，以占用服务器的socket资源和内存资源。例如，对于一个696字节的HTTP请求，攻击者可能每秒只发送一个字符，导致服务器需要696秒才能接收完整个请求，从而耗尽服务器资源。</p><p><strong>三、防御手段</strong><br>针对HTTP慢速拒绝服务攻击，防御措施包括：</p><ul><li>限制HTTP请求头超时</li><li>HTTP请求超时</li><li>流空闲超时</li><li>连接超时</li></ul><p><strong>四、envoy字段介绍</strong></p><ol><li><code>stream_idle_timeout</code>: 流空闲超时，收到HTTP起始行后开始计时，无数据时发送408回复并关闭连接。默认30秒，范围1-3600秒。</li><li><code>request_timeout</code>: 请求超时，收到HTTP起始行后开始计时，整个请求（请求头、请求体）未在设定时间内接收完毕时发送408回复并关闭连接。默认60秒，范围1-300秒。</li><li><code>request_headers_timeout</code>: 请求头超时，收到HTTP起始行后开始计时，请求头未在设定时间内接收完毕时发送408回复并关闭连接。默认5秒，范围1-60秒。</li><li><code>common_http_protocol_options.idle_timeout</code>: 连接空闲超时，建立TCP连接后无数据时断开连接。默认30秒，范围1-3600秒。</li><li><code>common_http_protocol_options.max_connection_duration</code>: 连接超时，建立TCP连接后的最大持续时间，超时则断开连接。默认值不受限，范围1秒-365天。</li></ol><p><strong>总结</strong><br>本文档提供了对HTTP慢速拒绝服务攻击的基本理解以及使用envoy配置来防御这类攻击的方法。然而，需要注意的是，实施这些防御措施时应考虑到攻击检测、误报处理、多层防御策略、性能考量、环境适应性以及定期更新和维护策略，以确保既有效地防御攻击，又不影响正常用户的体验。</p><h2 id="HTTP慢速拒绝攻击抵御-石犀方案"><a href="#HTTP慢速拒绝攻击抵御-石犀方案" class="headerlink" title="HTTP慢速拒绝攻击抵御 石犀方案"></a>HTTP慢速拒绝攻击抵御 石犀方案</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><br><span class="hljs-section">缺乏具体实施细节:</span><br>    文档提供了防御手段的概述，但缺少具体的实施步骤或配置示例。在实际应用中，详细的配置指导和最佳实践是非常重要的。<br><br><span class="hljs-section">缺少攻击检测和响应策略:</span><br>    文档主要集中在防御措施上，但没有提到如何检测慢速攻击的发生。在网络安全中，及时检测攻击同样重要，这有助于快速响应和调整防御策略。<br><br><span class="hljs-section">未考虑误报和合法流量的影响:</span><br>    在设置超时参数时，需要考虑到正常用户的行为。过于严格的超时设置可能会导致误报，影响正常用户的体验。<br><br><span class="hljs-section">缺少多层防御策略:</span><br>    仅依赖于应用层（L7）的防御可能不足以应对所有类型的慢速攻击。结合网络层（L3/L4）的防御措施可能会更有效。<br><br><span class="hljs-section">性能考量未提及:</span><br>    实施这些防御措施可能会对服务器性能产生影响。文档中没有提及如何平衡安全性和性能，特别是在高流量环境下。<br><br><span class="hljs-section">缺乏上下文和环境适应性讨论:</span><br>    不同的服务器环境和应用场景可能需要不同的配置。文档没有讨论如何根据具体环境调整这些设置。<br><br><span class="hljs-section">更新和维护策略未提及:</span><br>    网络安全是一个不断发展的领域，攻击手段也在不断进化。文档中没有提及如何定期更新和维护防御措施以应对新的威胁。<br></code></pre></td></tr></table></figure><h2 id="多层防御策略"><a href="#多层防御策略" class="headerlink" title="多层防御策略"></a>多层防御策略</h2><p>针对“缺少多层防御策略”的缺陷，可以通过以下几个方面来补充和完善设计：</p><h3 id="1-网络层（L3-L4）防御"><a href="#1-网络层（L3-L4）防御" class="headerlink" title="1. 网络层（L3&#x2F;L4）防御"></a>1. 网络层（L3&#x2F;L4）防御</h3><ul><li><p><strong>流量监控与异常检测</strong>:</p><ul><li>实施持续的流量监控，使用机器学习或基于规则的系统来识别异常流量模式。</li><li>部署入侵检测系统（IDS）和入侵防御系统（IPS）来识别和阻止可疑流量。</li></ul></li><li><p><strong>速率限制和流量整形</strong>:</p><ul><li>在网络边界实施速率限制，以减少到达应用层的恶意流量。</li><li>使用流量整形技术来控制流量的速率和量，确保关键服务的可用性。</li></ul></li><li><p><strong>黑名单&#x2F;白名单</strong>:</p><ul><li>基于IP地址或地理位置实施黑名单或白名单策略，阻止已知的恶意来源。</li></ul></li><li><p><strong>分布式防御</strong>:</p><ul><li>使用内容分发网络（CDN）或其他分布式解决方案来分散流量，减轻单点压力。</li></ul></li></ul><h3 id="2-应用层（L7）防御"><a href="#2-应用层（L7）防御" class="headerlink" title="2. 应用层（L7）防御"></a>2. 应用层（L7）防御</h3><ul><li><p><strong>会话管理</strong>:</p><ul><li>实施严格的会话管理，例如会话超时和限制并发连接数，以防止资源被过度占用。</li></ul></li><li><p><strong>自定义规则</strong>:</p><ul><li>根据应用的特定需求和行为模式，定制WAF（Web应用防火墙）规则。</li></ul></li><li><p><strong>行为分析</strong>:</p><ul><li>对用户行为进行分析，识别出与正常用户行为显著不同的模式。</li></ul></li></ul><h3 id="3-系统级防御"><a href="#3-系统级防御" class="headerlink" title="3. 系统级防御"></a>3. 系统级防御</h3><ul><li><p><strong>资源分配和限制</strong>:</p><ul><li>在操作系统层面限制进程资源使用，例如CPU和内存使用限制，防止单个进程耗尽系统资源。</li></ul></li><li><p><strong>高可用性和冗余</strong>:</p><ul><li>设计高可用性架构，包括负载均衡和故障转移机制，以确保服务的连续性。</li></ul></li></ul><h3 id="4-响应和恢复计划"><a href="#4-响应和恢复计划" class="headerlink" title="4. 响应和恢复计划"></a>4. 响应和恢复计划</h3><ul><li><p><strong>紧急响应计划</strong>:</p><ul><li>制定并测试紧急响应计划，以便在攻击发生时迅速采取行动。</li></ul></li><li><p><strong>备份和恢复</strong>:</p><ul><li>定期备份关键数据和配置，确保在攻击后能够快速恢复服务。</li></ul></li></ul><h3 id="5-持续监控和评估"><a href="#5-持续监控和评估" class="headerlink" title="5. 持续监控和评估"></a>5. 持续监控和评估</h3><ul><li><p><strong>安全审计和日志分析</strong>:</p><ul><li>定期进行安全审计，分析日志以识别潜在的安全漏洞或攻击迹象。</li></ul></li><li><p><strong>性能和安全测试</strong>:</p><ul><li>定期进行性能和安全测试，以评估防御措施的有效性。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信、存储、处理、展示.md</title>
    <link href="/2023/11/30/mdstorage/domain/%E6%9E%B6%E6%9E%84/%E9%80%9A%E4%BF%A1%E3%80%81%E5%AD%98%E5%82%A8%E3%80%81%E5%A4%84%E7%90%86%E3%80%81%E5%B1%95%E7%A4%BA%E8%BD%AF%E4%BB%B6%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/30/mdstorage/domain/%E6%9E%B6%E6%9E%84/%E9%80%9A%E4%BF%A1%E3%80%81%E5%AD%98%E5%82%A8%E3%80%81%E5%A4%84%E7%90%86%E3%80%81%E5%B1%95%E7%A4%BA%E8%BD%AF%E4%BB%B6%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p><strong>文章概述</strong></p><ul><li>文章标题: “软件系统的四大支柱：通信、存储、处理与展示”</li><li>文章主题简介: 本文探讨了软件系统设计中的四个核心概念：通信、存储、处理和展示，分析了它们的相互关系和在构建复杂系统中的重要性。</li></ul><p><strong>主要观点</strong></p><ul><li>观点一：软件系统的有效运作依赖于通信、存储、处理和展示这四个核心概念的协同工作。</li><li>观点二：这四个概念虽然在功能上不同，但在系统设计中是平等、互补的。</li></ul><p><strong>支持论据</strong></p><ul><li>观点一的支持论据：每个概念在系统中扮演独特角色，如通信负责数据传输，存储处理数据保存，处理涉及数据操作，而展示则关注于用户界面和信息呈现。</li><li>观点二的支持论据：这些概念相互依赖，例如，有效的数据处理需要可靠的存储和高效的通信，而良好的展示增强了用户交互和体验。</li></ul><p><strong>逻辑连贯性分析</strong></p><ul><li>论点间的逻辑关系：文章从四个独立的概念出发，逐步揭示它们之间的相互依赖性和协同作用，构建了一个全面的系统设计视角。</li><li>文章整体结构分析：文章结构清晰，从各个概念的独立分析过渡到它们之间的相互作用，最后总结其在系统设计中的综合重要性。</li></ul><p><strong>不同视角考量</strong></p><ul><li>其他可能的观点或反驳：一些专家可能会强调安全性、可靠性等其他方面的重要性，认为它们与通信、存储、处理和展示同等重要。</li><li>行业或领域内不同专家的意见：不同领域的专家可能会根据其专业背景和经验，对这四个概念的重要性和应用方式有不同的看法。</li></ul><p><strong>结论与实践意义</strong></p><ul><li>作者的主要结论：在设计和评估复杂软件系统时，通信、存储、处理和展示这四个概念是不可或缺的，它们共同构成了系统的基础。</li><li>对行业&#x2F;读者的实际意义：理解这些概念及其相互关系对于软件工程师、系统分析师和项目经理等专业人士在实际工作中至关重要。</li></ul><p><strong>个人观点与反思</strong></p><ul><li>个人对文章的看法：</li><li>文章对个人或工作的启发：</li></ul><p>这个框架提供了一个全面的视角来分析和讨论软件系统设计的关键概念，同时也为读者提供了深入理解这些概念的机会。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>总控引擎插件问题列举、分析、解决方案.md</title>
    <link href="/2023/11/30/mdstorage/project/sr/%E6%80%BB%E6%8E%A7%E5%BC%95%E6%93%8E%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98%E5%88%97%E4%B8%BE%E3%80%81%E5%88%86%E6%9E%90%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2023/11/30/mdstorage/project/sr/%E6%80%BB%E6%8E%A7%E5%BC%95%E6%93%8E%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98%E5%88%97%E4%B8%BE%E3%80%81%E5%88%86%E6%9E%90%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>总控、引擎、插件是 总控-引擎软件系统中的逻辑组件，引擎是一个流量代理功能的集群，主要完成 API网关职能，总控是用户操作入口， 部署于单独一台机器，总控集成多个、多种引擎的管理和控制逻辑，插件是完成一组独立功能的逻辑组件，工作于总控、引擎的节点。</li></ul><h3 id="文档组织思路"><a href="#文档组织思路" class="headerlink" title="文档组织思路"></a>文档组织思路</h3><ul><li>每个大目标下包括一些小事项，每个小事项可以有些已经做过，但有演进的方向，所以也列出</li><li>先列出目前想要完成的目标，其中确立每个目标需要怎样的人完成，人进入后就可以快速、持续跟进那个部分的工作，如果没人进入，会造成进度缓慢或者完成质量差</li><li>目标有先后顺序、优先级顺序</li></ul><h3 id="引擎、插件概念定义梳理"><a href="#引擎、插件概念定义梳理" class="headerlink" title="引擎、插件概念定义梳理"></a>引擎、插件概念定义梳理</h3><h4 id="人才模型"><a href="#人才模型" class="headerlink" title="人才模型"></a>人才模型</h4><ul><li><strong>系统架构师</strong></li></ul><h3 id="总控、引擎、插件等系统逻辑组件关系、结构定义"><a href="#总控、引擎、插件等系统逻辑组件关系、结构定义" class="headerlink" title="总控、引擎、插件等系统逻辑组件关系、结构定义"></a>总控、引擎、插件等系统逻辑组件关系、结构定义</h3><h3 id="总控、引擎、插件等系统逻辑组件关系、结构定义改动影响范围"><a href="#总控、引擎、插件等系统逻辑组件关系、结构定义改动影响范围" class="headerlink" title="总控、引擎、插件等系统逻辑组件关系、结构定义改动影响范围"></a>总控、引擎、插件等系统逻辑组件关系、结构定义改动影响范围</h3><h3 id="总控、引擎、插件等系统逻辑组件关系、结构定义改动架构调整方案"><a href="#总控、引擎、插件等系统逻辑组件关系、结构定义改动架构调整方案" class="headerlink" title="总控、引擎、插件等系统逻辑组件关系、结构定义改动架构调整方案"></a>总控、引擎、插件等系统逻辑组件关系、结构定义改动架构调整方案</h3><h4 id="人才模型-1"><a href="#人才模型-1" class="headerlink" title="人才模型"></a>人才模型</h4><ul><li><strong>技术团队领导</strong></li></ul><h3 id="总控、引擎、插件等系统逻辑组件关系、结构定义改动架构调整实施方案"><a href="#总控、引擎、插件等系统逻辑组件关系、结构定义改动架构调整实施方案" class="headerlink" title="总控、引擎、插件等系统逻辑组件关系、结构定义改动架构调整实施方案"></a>总控、引擎、插件等系统逻辑组件关系、结构定义改动架构调整实施方案</h3><h3 id="总控、引擎、插件等系统逻辑组件基础设施维护方案计划"><a href="#总控、引擎、插件等系统逻辑组件基础设施维护方案计划" class="headerlink" title="总控、引擎、插件等系统逻辑组件基础设施维护方案计划"></a>总控、引擎、插件等系统逻辑组件基础设施维护方案计划</h3><ol><li><strong>代码仓库</strong>：用于代码版本控制和协作。</li><li><strong>开发工具</strong>：包括集成开发环境（IDE）、编译器、调试器建议。</li><li><strong>构建工具</strong>：自动化构建系统。</li><li><strong>测试环境</strong>：用于单元测试、集成测试、性能测试等。</li><li><strong>部署工具</strong>：支持代码的自动化部署，如Docker、Kubernetes等。为了支持快速迭代和稳定部署，需要有有效的版本控制和自动化部署流程。</li><li><strong>监控和日志系统</strong>：用于监控软件应用性能,API网关的性能直接影响用户体验，因此需要强大的监控工具来跟踪API的性能，并及时进行优化。</li><li><strong>文档管理系统</strong>：用于存储技术文档、设计文档等。</li><li><strong>项目管理工具</strong>：禅道任务分配和进度跟踪。</li><li><strong>通信工具</strong>：用于团队沟通。</li><li><strong>安全工具</strong>：用于代码安全扫描和漏洞检测。</li><li><strong>数据库和存储</strong>：包括各种数据和静态文件存储解决方案。</li><li><strong>云服务和虚拟化</strong>：云计算资源和虚拟化平台。</li><li><strong>高级网络配置支持</strong>：具有维持项目的网络配置和网络安全能力，由于涉及网络安全，需要对网络架构有深入的理解和配置能力，包括但不限于防火墙、VPN、负载均衡等。</li><li><strong>安全性和合规性</strong>：需要专门的安全措施来保护API和网络，包括数据加密、入侵检测系统、安全审计和合规性管理。</li><li><strong>高可用性和灾难恢复</strong>：提供支持项目运作的高可用性。并为软件应用系统关键组件提供高可用性和灾难恢复能力建议。</li><li><strong>数据备份和存储管理</strong>：可靠的数据备份和存储管理策略。</li></ol><h3 id="总控、引擎、插件组件等系统逻辑组件公共库建设"><a href="#总控、引擎、插件组件等系统逻辑组件公共库建设" class="headerlink" title="总控、引擎、插件组件等系统逻辑组件公共库建设"></a>总控、引擎、插件组件等系统逻辑组件公共库建设</h3><h4 id="人才模型-2"><a href="#人才模型-2" class="headerlink" title="人才模型"></a>人才模型</h4><ul><li><strong>资深开发工程师</strong></li></ul><h3 id="总控、引擎、插件组件等系统逻辑组件开发规范、代码规范、流程规范、应急响应"><a href="#总控、引擎、插件组件等系统逻辑组件开发规范、代码规范、流程规范、应急响应" class="headerlink" title="总控、引擎、插件组件等系统逻辑组件开发规范、代码规范、流程规范、应急响应"></a>总控、引擎、插件组件等系统逻辑组件开发规范、代码规范、流程规范、应急响应</h3><h4 id="人才模型-3"><a href="#人才模型-3" class="headerlink" title="人才模型"></a>人才模型</h4><ul><li><strong>资深开发工程师</strong></li></ul><h3 id="石犀的产品有什么样的属性、石犀将要前进的方向？"><a href="#石犀的产品有什么样的属性、石犀将要前进的方向？" class="headerlink" title="石犀的产品有什么样的属性、石犀将要前进的方向？"></a>石犀的产品有什么样的属性、石犀将要前进的方向？</h3><h1 id="人才模型、职责范围和任职要求"><a href="#人才模型、职责范围和任职要求" class="headerlink" title="人才模型、职责范围和任职要求"></a>人才模型、职责范围和任职要求</h1><h2 id="1-系统逻辑组件关系、结构定义改动"><a href="#1-系统逻辑组件关系、结构定义改动" class="headerlink" title="1. 系统逻辑组件关系、结构定义改动"></a>1. 系统逻辑组件关系、结构定义改动</h2><h3 id="人才模型-4"><a href="#人才模型-4" class="headerlink" title="人才模型"></a>人才模型</h3><ul><li><strong>系统架构师</strong></li><li><strong>软件开发工程师</strong></li></ul><h3 id="职责范围"><a href="#职责范围" class="headerlink" title="职责范围"></a>职责范围</h3><ul><li><strong>系统架构师</strong>：负责设计和优化系统架构，确保系统的可扩展性和性能。</li><li><strong>软件开发工程师</strong>：负责实现架构师设计的架构，编写和维护代码。</li></ul><h3 id="任职要求"><a href="#任职要求" class="headerlink" title="任职要求"></a>任职要求</h3><ul><li><strong>系统架构师</strong>：至少5年的系统架构设计经验，熟悉微服务架构和容器化技术。</li><li><strong>软件开发工程师</strong>：至少3年的软件开发经验，熟悉所用编程语言和开发工具。</li></ul><h2 id="2-架构调整方案"><a href="#2-架构调整方案" class="headerlink" title="2. 架构调整方案"></a>2. 架构调整方案</h2><h3 id="人才模型-5"><a href="#人才模型-5" class="headerlink" title="人才模型"></a>人才模型</h3><ul><li><strong>项目经理</strong></li><li><strong>技术团队领导</strong></li></ul><h3 id="职责范围-1"><a href="#职责范围-1" class="headerlink" title="职责范围"></a>职责范围</h3><ul><li><strong>项目经理</strong>：负责整体项目规划、进度控制和资源分配。</li><li><strong>技术团队领导</strong>：负责指导技术团队，确保技术实施符合项目要求。</li></ul><h3 id="任职要求-1"><a href="#任职要求-1" class="headerlink" title="任职要求"></a>任职要求</h3><ul><li><strong>项目经理</strong>：至少5年的项目管理经验，具备良好的组织和沟通能力。</li><li><strong>技术团队领导</strong>：至少5年的技术领导经验，具备出色的技术背景和团队管理能力。</li></ul><h2 id="3-基础设施维护方案计划"><a href="#3-基础设施维护方案计划" class="headerlink" title="3. 基础设施维护方案计划"></a>3. 基础设施维护方案计划</h2><h3 id="人才模型-6"><a href="#人才模型-6" class="headerlink" title="人才模型"></a>人才模型</h3><ul><li><strong>基础设施工程师</strong></li><li><strong>网络安全专家</strong></li></ul><h3 id="职责范围-2"><a href="#职责范围-2" class="headerlink" title="职责范围"></a>职责范围</h3><ul><li><strong>基础设施工程师</strong>：负责维护和优化基础设施，包括服务器、数据库和网络。</li><li><strong>网络安全专家</strong>：负责确保系统的网络安全，进行安全监控和风险评估。</li></ul><h3 id="任职要求-2"><a href="#任职要求-2" class="headerlink" title="任职要求"></a>任职要求</h3><ul><li><strong>基础设施工程师</strong>：至少3年的基础设施维护经验，熟悉云计算和虚拟化技术。</li><li><strong>网络安全专家</strong>：至少5年的网络安全经验，具备相关的安全认证。</li></ul><h2 id="4-公共库建设"><a href="#4-公共库建设" class="headerlink" title="4. 公共库建设"></a>4. 公共库建设</h2><h3 id="人才模型-7"><a href="#人才模型-7" class="headerlink" title="人才模型"></a>人才模型</h3><ul><li><strong>资深开发工程师</strong></li><li><strong>代码库管理员</strong></li></ul><h3 id="职责范围-3"><a href="#职责范围-3" class="headerlink" title="职责范围"></a>职责范围</h3><ul><li><strong>资深开发工程师</strong>：负责开发和维护公共代码库，确保代码质量。</li><li><strong>代码库管理员</strong>：负责代码库的管理和版本控制，处理合并请求。</li></ul><h3 id="任职要求-3"><a href="#任职要求-3" class="headerlink" title="任职要求"></a>任职要求</h3><ul><li><strong>资深开发工程师</strong>：至少5年的软件开发经验，精通多种编程语言。</li><li><strong>代码库管理员</strong>：至少3年的代码库管理经验，熟悉Git或其他版本控制工具。</li></ul><h2 id="5-开发规范、代码规范、流程规范、应急响应"><a href="#5-开发规范、代码规范、流程规范、应急响应" class="headerlink" title="5. 开发规范、代码规范、流程规范、应急响应"></a>5. 开发规范、代码规范、流程规范、应急响应</h2><h3 id="人才模型-8"><a href="#人才模型-8" class="headerlink" title="人才模型"></a>人才模型</h3><ul><li><strong>质量保证工程师</strong></li><li><strong>运维工程师</strong></li></ul><h3 id="职责范围-4"><a href="#职责范围-4" class="headerlink" title="职责范围"></a>职责范围</h3><ul><li><strong>质量保证工程师</strong>：负责制定和维护开发规范，进行代码审查。</li><li><strong>运维工程师</strong>：负责系统的日常运维和应急响应。</li></ul><h3 id="任职要求-4"><a href="#任职要求-4" class="headerlink" title="任职要求"></a>任职要求</h3><ul><li><strong>质量保证工程师</strong>：至少3年的软件质量保证经验，熟悉代码审查流程。</li><li><strong>运维工程师</strong>：至少3年的运维经验，具备良好的问题解决能力。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>清点BUG技巧.md</title>
    <link href="/2023/11/27/mdstorage/%E6%B8%85%E7%82%B9BUG%E6%8A%80%E5%B7%A7/"/>
    <url>/2023/11/27/mdstorage/%E6%B8%85%E7%82%B9BUG%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<p>每个人清点 BUG，汇报能解决的BUG多长时间解决掉</p><h3 id="BUG分类"><a href="#BUG分类" class="headerlink" title="BUG分类"></a>BUG分类</h3><ul><li>能解决<ul><li>3 天以内能解决</li><li>3 天以外能解决</li></ul></li><li>暂时解决不了<ul><li>修改方案</li><li>机制存在问题</li><li>无法复现</li><li>技术难度大</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>pm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础设施组概述.md</title>
    <link href="/2023/11/27/mdstorage/domain/%E6%9E%B6%E6%9E%84/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%BB%84%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/11/27/mdstorage/domain/%E6%9E%B6%E6%9E%84/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%BB%84%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="基础设施组"><a href="#基础设施组" class="headerlink" title="基础设施组"></a>基础设施组</h2><h3 id="职能"><a href="#职能" class="headerlink" title="职能"></a>职能</h3><p>开发维护总控平台的基础设施，兼顾公共库开发维护，为上层应用提供可靠可扩展的接口，脱离具体业务开发。</p><h3 id="技能要求、技术栈、工具选型"><a href="#技能要求、技术栈、工具选型" class="headerlink" title="技能要求、技术栈、工具选型"></a>技能要求、技术栈、工具选型</h3><p>shell、python、golang、(Linux C)</p><p>Linux：网络、文件系统、 敏捷开发工具链、系统监控</p><p>应急响应各种故障排查手段：临时扩容、上云、容量规划、安全、<del>（虚拟网络）</del>等临时需求</p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>公共库开发维护、项目搭建规范保持动作一致性、敏捷开发工具链开发维护</p><h3 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h3><h4 id="人员职责安排"><a href="#人员职责安排" class="headerlink" title="人员职责安排"></a>人员职责安排</h4><h4 id="人力规划"><a href="#人力规划" class="headerlink" title="人力规划"></a>人力规划</h4><h3 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h3><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><h4 id="需求-任务来源"><a href="#需求-任务来源" class="headerlink" title="需求&#x2F;任务来源"></a>需求&#x2F;任务来源</h4><h4 id="处理需求-任务流程"><a href="#处理需求-任务流程" class="headerlink" title="处理需求&#x2F;任务流程"></a>处理需求&#x2F;任务流程</h4><h4 id="输出产物-交付"><a href="#输出产物-交付" class="headerlink" title="输出产物&#x2F;交付"></a>输出产物&#x2F;交付</h4>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概述</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11/24与刘总的谈话内容.md</title>
    <link href="/2023/11/27/mdstorage/project/sr/1124%E4%B8%8E%E5%88%98%E6%80%BB%E7%9A%84%E8%B0%88%E8%AF%9D%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/27/mdstorage/project/sr/1124%E4%B8%8E%E5%88%98%E6%80%BB%E7%9A%84%E8%B0%88%E8%AF%9D%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="11-24与老板谈话"><a href="#11-24与老板谈话" class="headerlink" title="11&#x2F;24与老板谈话"></a>11&#x2F;24与老板谈话</h3><h4 id="考虑思路"><a href="#考虑思路" class="headerlink" title="考虑思路"></a>考虑思路</h4><ul><li>考虑对方角度关心的内容</li><li>未来的展望规划一并考虑</li><li>列出目录、重点内容</li><li>先将本质的问题考虑</li></ul><h4 id="工程思路"><a href="#工程思路" class="headerlink" title="工程思路"></a>工程思路</h4><p>不牺牲用户场景下，降低实时性需求</p><h3 id="SV-职责本质"><a href="#SV-职责本质" class="headerlink" title="SV 职责本质"></a>SV 职责本质</h3><ul><li>能存入</li><li>如何展示、展示什么、怎么展示</li></ul><h4 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h4><h4 id="行业经验"><a href="#行业经验" class="headerlink" title="行业经验"></a>行业经验</h4><ul><li>能阻断性的、实时的问题 要以聚焦型的思路做，而不是全量的</li><li>已知的问题后续能控制、异常的问题尽量实时阻断、常规的问题做到能追溯就行非实时</li><li>CPU 占机器成本 40% 左右</li><li>看 http body 要授权</li><li>性能上不用太纠结，目前一个服务的最大业务请求量不会更高，业务复杂程度不会更高</li><li>做功能要做加法，慢慢往上堆，不要做减法</li></ul><h4 id="硬性条件限制"><a href="#硬性条件限制" class="headerlink" title="硬性条件限制"></a>硬性条件限制</h4><ul><li>影响客户业务的引擎非常轻量并具有<ul><li>高性能</li><li>高稳定</li><li>高扩展（插件）</li></ul></li><li>高可用必须要、这是场景决定的</li></ul><h4 id="系统的演进"><a href="#系统的演进" class="headerlink" title="系统的演进"></a>系统的演进</h4><h5 id="存在形式"><a href="#存在形式" class="headerlink" title="存在形式"></a>存在形式</h5><p>软件形式、硬件形式、虚拟机形式</p><h5 id="演进思路"><a href="#演进思路" class="headerlink" title="演进思路"></a>演进思路</h5><p>先开发软件，容器平台并未在大多数企业普及，迫切程度不如拥抱信创产业</p>]]></content>
    
    
    
    <tags>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试用例设计文档内容要求.md</title>
    <link href="/2023/11/27/mdstorage/project/sr/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E5%86%85%E5%AE%B9%E8%A6%81%E6%B1%82/"/>
    <url>/2023/11/27/mdstorage/project/sr/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E5%86%85%E5%AE%B9%E8%A6%81%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="测试用例设计文档内容要求"><a href="#测试用例设计文档内容要求" class="headerlink" title="测试用例设计文档内容要求"></a>测试用例设计文档内容要求</h2><ol><li><strong>测试用例概览</strong>：文档的概述，包括测试目的、范围、目标和测试环境。</li><li><strong>测试策略和方法</strong>：测试将如何进行，采用哪些类型的测试（如功能测试、性能测试、安全测试等）。</li><li><strong>测试用例</strong>：<ul><li><strong>测试条件</strong>：测试用例的前提条件。</li><li><strong>测试步骤</strong>：执行测试所需的具体操作步骤。</li><li><strong>期望结果</strong>：每个测试步骤应达到的预期结果。</li><li><strong>实际结果</strong>：执行测试后的实际结果（在测试执行阶段填写）。</li><li><strong>通过&#x2F;失败标记</strong>：测试是否通过的标记（在测试执行阶段填写）。</li></ul></li><li><strong>测试数据</strong>：用于测试的输入数据，可能包括有效和无效的输入。</li><li><strong>测试环境</strong>：详细描述执行测试所需的环境设置，包括硬件、软件、网络配置等。</li><li><strong>风险和依赖关系</strong>：可能影响测试执行的任何风险或依赖项。</li><li><strong>日志和记录</strong>：测试过程中记录的任何特殊情况或发现的问题。</li><li><strong>测试总结和评估</strong>：测试执行后的总结报告，包括找到的缺陷、覆盖范围、测试周期和对软件质量的评估。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组长职责.md</title>
    <link href="/2023/11/27/mdstorage/project/sr/%E7%BB%84%E9%95%BF%E8%81%8C%E8%B4%A3/"/>
    <url>/2023/11/27/mdstorage/project/sr/%E7%BB%84%E9%95%BF%E8%81%8C%E8%B4%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li>组长参与的项目的生命周期梳理</li><li>对每项（生命周期的一个节点）进行注意点梳理、情景梳理</li><li>归档</li></ul><h2 id="关于组长管理"><a href="#关于组长管理" class="headerlink" title="关于组长管理"></a>关于组长管理</h2><ul><li>BUG 中组员能自行解决的不要上升到组长级别，组长的事情很多</li><li>定期组织清点 BUG</li><li>定期组织文档维护</li></ul><h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><p>禅道维护</p><p>任务拆解</p><p>任务分配</p><p>组员信息同步</p><p>进度监控</p><h3 id="技术攻坚"><a href="#技术攻坚" class="headerlink" title="技术攻坚"></a>技术攻坚</h3><p>技术难题攻坚</p><p>阻塞性问题、紧急问题处理</p><h3 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h3><p>软件架构设计</p><p>系统问题分析</p><h3 id="代码管理"><a href="#代码管理" class="headerlink" title="代码管理"></a>代码管理</h3><p>merge request 查看</p><p>开发设计文档审查</p><p>开发设计文档评审</p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>需求文档审查</p><p>需求文档评审</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试用例审查</p><p>测试用例评审</p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="项目管理-1"><a href="#项目管理-1" class="headerlink" title="项目管理"></a>项目管理</h3><h4 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h4><p>跟本人有关的所有任务必上禅道</p><h4 id="进度管理"><a href="#进度管理" class="headerlink" title="进度管理"></a>进度管理</h4><p>各组员进度在禅道查看即可，不然要禅道干嘛的</p><h4 id="任务拆解"><a href="#任务拆解" class="headerlink" title="任务拆解"></a>任务拆解</h4><p>任务的第一个子任务必为见到即可行可做的任务，不然就定为任务拆解的任务</p><h3 id="测试问题管理"><a href="#测试问题管理" class="headerlink" title="测试问题管理"></a>测试问题管理</h3><h4 id="BUG-管理"><a href="#BUG-管理" class="headerlink" title="BUG 管理"></a>BUG 管理</h4><p>BUG 能在组员解决的不要上升到组长，不紧急的 BUG 、延期不长的组长不要管，不然组员什么时候能成长</p><h3 id="语言管理"><a href="#语言管理" class="headerlink" title="语言管理"></a>语言管理</h3><h4 id="喜好"><a href="#喜好" class="headerlink" title="喜好"></a>喜好</h4><p>“用你是否考虑过”，表达你不喜欢的</p><p>“干得好，我很喜欢这样”，表达你喜欢的</p><h4 id="自卫"><a href="#自卫" class="headerlink" title="自卫"></a>自卫</h4><p>“你的意思是我做了xxx吗”， </p><ul><li>是的 。   回答： 这并不准确</li><li>不是。    回答： 感谢澄清</li></ul><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h3><h5 id="尽量中立态度解读别人的话，要理解别人而非同意"><a href="#尽量中立态度解读别人的话，要理解别人而非同意" class="headerlink" title="尽量中立态度解读别人的话，要理解别人而非同意"></a>尽量中立态度解读别人的话，要理解别人而非同意</h5><h4 id="沟通策略"><a href="#沟通策略" class="headerlink" title="沟通策略"></a>沟通策略</h4><p>不要说： 我早告诉你过这样</p><p>有时说： 我持保留意见，并给出原因，必要时说，“我觉得这需要再仔细斟酌，我随后答复你吧”。然后在你将完成调研后，再约个日期。</p>]]></content>
    
    
    
    <tags>
      
      <tag>pm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一周看板-11.27.md</title>
    <link href="/2023/11/27/mdstorage/project/sr/%E4%B8%80%E5%91%A8%E7%9C%8B%E6%9D%BF/%E4%B8%80%E5%91%A8%E7%9C%8B%E6%9D%BF-11.27/"/>
    <url>/2023/11/27/mdstorage/project/sr/%E4%B8%80%E5%91%A8%E7%9C%8B%E6%9D%BF/%E4%B8%80%E5%91%A8%E7%9C%8B%E6%9D%BF-11.27/</url>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs kanban"># 2023/11/13 Task List<br><br>## Todo<br>- https://github.com/mli/autocut 是什么<br>- on-premise 综述<br>- InfoQ 一周消息速递<br>- 搜书方法、主流格式文档转换方法、以图搜图、学习资料搜索<br><br>- meituan 对接、价格<br>- 关于授权时间一致性问题，与松达讨论，给出方案(授权涉及的时间后端接口返回应该做到：商城给到什么就返回什么时间格式)<br><br>- 周会 （1. 转测流程 2. 任务进度 3. 说说问题）<br>- 新人培训计划文档<br><br>- chatgpt 插件调研文档<br>- SR 问题跟踪文档<br>- 虚拟机克隆调研文档<br><br>- SR 研发工作流程统计时长<br><br>- 可视化重构问题总结 1. 预计重构需要多长时间 2. 能否数据库做统一 3. 重构能解决现有的哪些问题，有哪些收益 4. 重构后的维护如何进行，预计能支持未来多长时间的不重构 5. 重构给项目组和客户可能带来的影响<br><br>## In-Progress<br>- 总控软件设计说明书(重要不紧急)<br>- 总控修改IP构想文档、问题解决、文档组织(重要)<br><br>- 分支管理文档<br><br>- SC后端启动原理，启动协程，常驻协程，与文件系统的交互通道，网络通道，进程通信通道，系统权限使用情况，系统资源占用情况，可能的依赖关系。 中长期规划<br>- markdown 文档模板--操作手册<br>- 网络配置蓝图<br><br>- TLS 双向认证文档<br><br><br><br>- 引擎备份/恢复 机制<br><br>- 升级兼容性要求文档<br><br>- api-gov 安装目录改造<br><br>- 11/24 跟老板关于 SV 重构的讨论<br><br><br>## Completed<br>- 11.20 与技术部王林对话 商城-总控通信TLS双向认证问题，并输出文档<br>- 第二批新人入职资料-数据库考题<br>- 记录 华为云/鲲鹏 服务器信息出示文档 | CPU指令集，arm架构记录，操作系统信息，虚拟设备信息<br>- 安装升级框架实施方案<br>- 插件升级问题（慧军在跟进复现）<br>- 授权虚拟机克隆失效问题<br>- 总控机器初始网络配置文档<br>- 引擎安装环境检测和安装机制问题<br><br>- 邮箱验证码未正常失效已跟进<br>- 工作节点状态异常已跟进<br>- 组员清点 BUG<br>- 文章类型概述文档<br>- 部门会议总结<br>- cfw TUN 模式文档<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>dairy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据处理和可视化.md</title>
    <link href="/2023/11/24/mdstorage/domain/%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%92%8C%E5%8F%AF%E8%A7%86%E5%8C%96%E9%A2%86%E5%9F%9F%E5%88%86%E6%9E%90/"/>
    <url>/2023/11/24/mdstorage/domain/%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%92%8C%E5%8F%AF%E8%A7%86%E5%8C%96%E9%A2%86%E5%9F%9F%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>《可视化技术架构分析设计》这篇技术架构文档&#x2F;系统分析报告，显然是在<strong>数据处理和可视化</strong>领域的。在这个领域，重点关注的是如何有效地处理和展示大量数据，以便用户可以更容易地理解和分析这些数据。这通常涉及大数据技术、数据存储、计算优化、以及用户界面设计。</p><p>在分析这类文档时，您应该重点关注以下几个部分：</p><ol><li><p><strong>数据流程和架构</strong>：理解数据是如何被收集、处理、存储和展示的。例如，类似于一个水处理厂，数据从源头（原始数据）开始，经过多个处理阶段（清洗、转换、汇总等），最终以干净、易于理解的形式提供给用户（可视化展示）。</p></li><li><p><strong>性能和效率问题</strong>：文档可能会详述系统的性能瓶颈，例如处理速度慢、存储成本高等。这就像是在诊断一辆车的性能问题，找出哪些部件需要升级或修理。</p></li><li><p><strong>技术堆栈和工具选择</strong>：了解构建系统所使用的技术和工具。这相当于了解一座建筑的材料和设计原则，以评估其稳固性和实用性。</p></li><li><p><strong>安全和可扩展性</strong>：考虑系统如何保护数据安全，并能应对未来数据量的增长。可以将其类比为建造一座房子时考虑的安全措施和可扩建性。</p></li><li><p><strong>用户体验和界面设计</strong>：特别注意数据如何被呈现给最终用户，包括界面的易用性和可视化效果。可以想象为一个博物馆的展览设计，目的是为了让参观者更容易理解和欣赏展出的物品。</p></li></ol><p>综上，这篇文档的核心在于如何有效地构建和改进一个复杂的数据处理和可视化系统。通过关注数据流程、性能问题、技术选择、安全&#x2F;可扩展性以及用户体验，可以深入理解文档的重点内容和目的。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据处理</tag>
      
      <tag>可视化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cfwTUN模式.md</title>
    <link href="/2023/11/24/mdstorage/resource/vpn/cfwTUN%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/11/24/mdstorage/resource/vpn/cfwTUN%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>文章概述</strong></p><ul><li>标题：Clash for Windows 设置TUN模式实现真全局模式</li><li>链接地址：<a href="https://doc.miyun.app/app/clash-for-windows-tun/">文章链接</a></li><li>摘要：这篇文章详细介绍了如何在Windows系统中设置Clash for Windows（CFW）的TUN模式，以实现真正的全局网络代理。文章解释了TUN模式的基本概念、特点，并提供了安装和配置CFW的步骤，以及如何开启TUN模式。</li></ul><p><strong>技术背景与原理</strong></p><ul><li>技术背景：文章围绕TUN模式展开，这是一种在Windows系统中常用的虚拟网络接口模式，用于创建VPN连接。</li><li>关键技术：TUN模式通过创建一个虚拟的点对点网络连接，模拟成一个真实的物理网络接口。它主要用于路由IP数据包，如OpenVPN、IPsec等VPN连接。TUN接口可以与其他物理网络接口协同工作，但两个TUN接口之间无法直接通信。</li></ul><p><strong>详细步骤</strong></p><ul><li>逐步指南：<ol><li>安装Service Mode服务，有绿色小地球标识为成功，以便在CFW中启用TUN模式。</li><li>在CFW的界面中，开启TUN Mode开关。</li><li>开启System Proxy，使用TUN代理上网。</li></ol></li><li>截图和示例：文章未提供具体的截图或代码示例，但描述了配置过程。</li></ul><p><strong>问题解决与常见问题</strong></p><ul><li>可能遇到的问题：文章没有特别提及可能遇到的问题。</li><li>解决方案：建议用户仔细遵循安装和配置指南，确保正确设置。</li></ul><p><strong>附加资源</strong></p><ul><li><a href="https://github.com/Fndroid/clash_for_windows_pkg">Clash for Windows 官网</a></li><li><a href="https://github.com/Fndroid/clash_for_windows_pkg/releases">Clash for Windows 官网 GitHub Releases 页面</a></li></ul><p><strong>总结</strong></p><ul><li>文章提供了在Windows系统中设置Clash for Windows的TUN模式的详细指南，帮助用户实现真正的全局网络代理。这对于需要绕过网络限制或进行特殊网络配置的用户特别有用。建议用户仔细遵循指南中的步骤，并根据个人需求进行适当的配置调整。</li></ul>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>vpn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>clash</tag>
      
      <tag>VPN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI阅读文章模板</title>
    <link href="/2023/11/23/mdstorage/domain/ai/AI%E9%98%85%E8%AF%BB%E6%96%87%E7%AB%A0%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/11/23/mdstorage/domain/ai/AI%E9%98%85%E8%AF%BB%E6%96%87%E7%AB%A0%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>在技术和管理领域，文章类型可以多样化，以下是一些常见的类型：</p><ol><li><strong>观点文章</strong>：分享个人观点、经验和见解。</li><li><strong>教程</strong>：提供技能或操作的具体指导。</li><li><strong>案例研究</strong>：深入分析特定项目或情况。</li><li><strong>技术博客</strong>：分享技术知识、经验或趋势。</li><li><strong>行业报告</strong>：提供行业分析、数据和预测。</li><li><strong>研究论文</strong>：呈现科学研究和实验结果。</li><li><strong>访谈</strong>：专家或业内人士的问答形式的内容。</li><li><strong>新闻报道</strong>：报导最新的行业动态和事件。</li><li><strong>白皮书</strong>：提供深入的技术或政策分析。</li><li><strong>产品评测</strong>：评估和比较技术产品或服务。</li><li><strong>最佳实践分享</strong>：介绍行业内的成功案例和策略。</li><li><strong>用户手册或指南</strong>：为特定产品或服务提供详细操作指导。</li><li><strong>行业评论</strong>：分析和评价行业趋势或事件。</li><li><strong>技术架构文档</strong>：这种文档通常详细描述一个系统的技术架构，包括使用的技术、数据流程、组件交互方式等。它的目的是为了让技术团队理解和维护系统架构。</li><li><strong>系统分析报告</strong>：这类文档深入分析现有系统的性能和设计，识别潜在问题，并提出改进方案。它通常包含详细的技术分析和重构建议。</li><li><strong>技术教程</strong></li><li><strong>项目规划与管理</strong></li></ol><h3 id="观点文章"><a href="#观点文章" class="headerlink" title="观点文章"></a>观点文章</h3><h4 id="归纳总结模板"><a href="#归纳总结模板" class="headerlink" title="归纳总结模板"></a>归纳总结模板</h4><p>创建一个归纳总结文章内容的文档模板时，可以遵循以下结构：</p><p><strong>文章概述</strong></p><ul><li>文章标题</li><li>作者</li><li>发布日期</li><li>来源&#x2F;出版物</li><li>文章主题简介</li></ul><p><strong>主要观点</strong></p><ul><li>观点一：[详述]</li><li>观点二：[详述]</li><li>…</li></ul><p><strong>支持论据</strong></p><ul><li>观点一的支持论据：[详述]</li><li>观点二的支持论据：[详述]</li><li>…</li></ul><p><strong>逻辑连贯性分析</strong></p><ul><li>论点间的逻辑关系</li><li>文章整体结构分析</li></ul><p><strong>不同视角考量</strong></p><ul><li>其他可能的观点或反驳</li><li>行业或领域内不同专家的意见</li></ul><p><strong>结论与实践意义</strong></p><ul><li>作者的主要结论</li><li>对行业&#x2F;读者的实际意义</li></ul><p><strong>个人观点与反思</strong></p><ul><li>个人对文章的看法</li><li>文章对个人或工作的启发</li></ul><p>这个模板旨在帮助深入分析和归纳文章的主要内容，同时也鼓励批判性思考和个人反思。</p><p>提示词</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs tex">你是一个软件开发领域的专家并十分擅长文章写作和阅读归纳总结，读取给出的文章链接，分析后以下面的观点文章范文格式输出内容，必要时引入类比，可视化，实例。<br><br>**文章概述**<br>- 文章标题<br>- 作者<br>- 发布日期<br>- 链接地址<br>- 文章主题简介<br><br>**主要观点**<br>- 观点一：[详述]<br>- 观点二：[详述]<br>- ...<br><br>**支持论据**<br>- 观点一的支持论据：[详述]<br>- 观点二的支持论据：[详述]<br>- ...<br><br>**逻辑连贯性分析**<br>- 论点间的逻辑关系<br>- 文章整体结构分析<br><br>**不同视角考量**<br>- 其他可能的观点或反驳<br>- 行业或领域内不同专家的意见<br><br>**结论与实践意义**<br>- 作者的主要结论<br>- 对行业/读者的实际意义<br><br>**个人观点与反思**<br>- 个人对文章的看法<br>- 文章对个人或工作的启发<br></code></pre></td></tr></table></figure><h3 id="技术架构文档"><a href="#技术架构文档" class="headerlink" title="技术架构文档"></a>技术架构文档</h3><p>基于上述对《可视化技术架构分析设计》文章内容的分析，一个合适的文档模板可以包含以下几个部分：</p><h3 id="1-文档标题"><a href="#1-文档标题" class="headerlink" title="1. 文档标题"></a>1. 文档标题</h3><ul><li>文档名称</li><li>编写日期</li><li>作者&#x2F;团队名称</li></ul><h3 id="2-摘要"><a href="#2-摘要" class="headerlink" title="2. 摘要"></a>2. 摘要</h3><ul><li>简要概述文档目的和主要内容</li></ul><h3 id="3-系统概述"><a href="#3-系统概述" class="headerlink" title="3. 系统概述"></a>3. 系统概述</h3><ul><li>系统目标和背景</li><li>主要功能和用户</li></ul><h3 id="4-数据流程和架构"><a href="#4-数据流程和架构" class="headerlink" title="4. 数据流程和架构"></a>4. 数据流程和架构</h3><ul><li>数据收集和输入</li><li>数据处理流程（清洗、转换、汇总）</li><li>数据存储解决方案</li><li>数据展示和可视化方法</li></ul><h3 id="5-性能和效率分析"><a href="#5-性能和效率分析" class="headerlink" title="5. 性能和效率分析"></a>5. 性能和效率分析</h3><ul><li>系统当前性能评估（瓶颈识别）</li><li>效率问题和挑战</li><li>可能的改进方案</li></ul><h3 id="6-技术堆栈和工具"><a href="#6-技术堆栈和工具" class="headerlink" title="6. 技术堆栈和工具"></a>6. 技术堆栈和工具</h3><ul><li>使用的技术和工具</li><li>技术选型的原因和优势</li><li>技术限制和潜在风险</li></ul><h3 id="7-安全性和可扩展性"><a href="#7-安全性和可扩展性" class="headerlink" title="7. 安全性和可扩展性"></a>7. 安全性和可扩展性</h3><ul><li>当前的安全措施</li><li>数据保护策略</li><li>系统的可扩展性和未来发展规划</li></ul><h3 id="8-用户体验和界面设计"><a href="#8-用户体验和界面设计" class="headerlink" title="8. 用户体验和界面设计"></a>8. 用户体验和界面设计</h3><ul><li>界面设计概述</li><li>可视化效果和用户交互</li><li>用户反馈和使用情况分析</li></ul><h3 id="9-问题和挑战"><a href="#9-问题和挑战" class="headerlink" title="9. 问题和挑战"></a>9. 问题和挑战</h3><ul><li>当前面临的主要问题</li><li>潜在的技术或业务挑战</li></ul><h3 id="10-改进方案和发展规划"><a href="#10-改进方案和发展规划" class="headerlink" title="10. 改进方案和发展规划"></a>10. 改进方案和发展规划</h3><ul><li>针对识别问题的改进措施</li><li>短期和长期的发展规划</li><li>预期的成果和影响</li></ul><h3 id="11-结论"><a href="#11-结论" class="headerlink" title="11. 结论"></a>11. 结论</h3><ul><li>对整个项目的总结和展望</li></ul><h3 id="12-附录"><a href="#12-附录" class="headerlink" title="12. 附录"></a>12. 附录</h3><ul><li>参考文献</li><li>图表和额外数据</li></ul><h3 id="13-审核和批准"><a href="#13-审核和批准" class="headerlink" title="13. 审核和批准"></a>13. 审核和批准</h3><ul><li>文档的审阅人员</li><li>批准日期和签名</li></ul><p>提示词</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs tex">你是一个软件开发领域的专家并十分擅长文章写作和阅读归纳总结，读取给出的文章/链接，分析后以下面的技术架构文档范文格式输出内容，必要时引入类比，可视化，实例。<br><br><span class="hljs-params">###</span> 1. 文档标题<br>- 文档名称<br>- 编写日期<br>- 作者/团队名称<br>- 链接地址<br><br><span class="hljs-params">###</span> 2. 摘要<br>- 简要概述文档目的和主要内容<br><br><span class="hljs-params">###</span> 3. 系统概述<br>- 系统目标和背景<br>- 主要功能和用户<br><br><span class="hljs-params">###</span> 4. 数据流程和架构<br>- 数据收集和输入<br>- 数据处理流程（清洗、转换、汇总）<br>- 数据存储解决方案<br>- 数据展示和可视化方法<br><br><span class="hljs-params">###</span> 5. 性能和效率分析<br>- 系统当前性能评估（瓶颈识别）<br>- 效率问题和挑战<br>- 可能的改进方案<br><br><span class="hljs-params">###</span> 6. 技术堆栈和工具<br>- 使用的技术和工具<br>- 技术选型的原因和优势<br>- 技术限制和潜在风险<br><br><span class="hljs-params">###</span> 7. 安全性和可扩展性<br>- 当前的安全措施<br>- 数据保护策略<br>- 系统的可扩展性和未来发展规划<br><br><span class="hljs-params">###</span> 8. 用户体验和界面设计<br>- 界面设计概述<br>- 可视化效果和用户交互<br>- 用户反馈和使用情况分析<br><br><span class="hljs-params">###</span> 9. 问题和挑战<br>- 当前面临的主要问题<br>- 潜在的技术或业务挑战<br><br><span class="hljs-params">###</span> 10. 改进方案和发展规划<br>- 针对识别问题的改进措施<br>- 短期和长期的发展规划<br>- 预期的成果和影响<br><br><span class="hljs-params">###</span> 11. 结论<br>- 对整个项目的总结和展望<br><br><span class="hljs-params">###</span> 12. 附录<br>- 参考文献<br>- 图表和额外数据<br><br><span class="hljs-params">###</span> 13. 审核和批准<br>- 文档的审阅人员<br>- 批准日期和签名<br></code></pre></td></tr></table></figure><h3 id="技术教程"><a href="#技术教程" class="headerlink" title="技术教程"></a>技术教程</h3><p>为了归纳和总结技术教程类文章的内容，你可以使用以下模板：</p><p><strong>文章概述</strong></p><ul><li>标题：文章的标题</li><li>作者：编写教程的作者</li><li>发布日期：文章的发布时间</li><li>摘要：简短描述文章的主要内容和目的</li></ul><p><strong>技术背景与原理</strong></p><ul><li>介绍所涉及的技术背景</li><li>解释文章中使用的关键技术或概念</li></ul><p><strong>详细步骤</strong></p><ul><li>逐步指南：清晰列出完成任务所需的步骤</li><li>截图和示例：提供截图或代码示例以辅助解释</li></ul><p><strong>问题解决与常见问题</strong></p><ul><li>讨论可能遇到的问题及其解决方案</li><li>列出常见问题和解答</li></ul><p><strong>附加资源</strong></p><ul><li>提供进一步阅读的链接或推荐资源</li><li>相关工具或软件的链接</li></ul><p><strong>总结</strong></p><ul><li>总结文章的主要教训或结论</li><li>提供实践建议或后续步骤</li></ul><p>这种模板有助于确保你的总结既全面又有组织，易于理解。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs tex">你是一个软件开发领域的专家并十分擅长文章写作和阅读归纳总结，读取给出的文章/链接，分析后以下面范文输出内容，必要时引入类比，可视化，实例。<br><br>**文章概述**<br>- 标题：文章的标题<br>- 作者：编写教程的作者<br>- 发布日期：文章的发布时间<br>- 链接地址：文章链接或其获取方式<br>- 摘要：简短描述文章的主要内容和目的<br><br>**技术背景与原理**<br>- 介绍所涉及的技术背景<br>- 解释文章中使用的关键技术或概念<br><br>**详细步骤**<br>- 逐步指南：清晰列出完成任务所需的步骤<br>- 截图和示例：提供截图或代码示例以辅助解释<br><br>**问题解决与常见问题**<br>- 讨论可能遇到的问题及其解决方案<br>- 列出常见问题和解答<br><br>**附加资源**<br>- 提供进一步阅读的链接或推荐资源<br>- 相关工具或软件的链接<br><br>**总结**<br>- 总结文章的主要教训或结论<br>- 提供实践建议或后续步骤<br></code></pre></td></tr></table></figure><h3 id="行业报告"><a href="#行业报告" class="headerlink" title="行业报告"></a>行业报告</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs tex">你是一个软件开发领域的专家并十分擅长文章写作和阅读归纳总结，读取给出的文章/链接，分析后以下面范文输出内容，必要时引入类比，可视化，实例。<br>---<br><br>**文档标题**: [企业级产品研发管理全流程分析报告]<br><br>**作者**: [作者姓名]<br><br>**日期**: [撰写日期]<br><br>---<br><br><span class="hljs-params">###</span> 一、引言<br>- **背景简介**: 简要介绍企业产品研发管理的重要性和背景。<br>- **文章目的**: 阐述本文档的目的和预期读者。<br><br>---<br><br><span class="hljs-params">###</span> 二、流程和体系结构<br>- **流程概述**: 描述产品研发管理的整体流程。<br>- **体系结构**: 详细介绍产品研发管理的体系结构，包括关键组成部分和它们之间的关系。<br><br>---<br><br><span class="hljs-params">###</span> 三、战略和市场管理<br>- **产品战略**: 分析文章中提到的产品战略制定方法和案例。<br>- **市场管理**: 探讨市场管理的实践和策略，以及其对产品成功的影响。<br><br>---<br><br><span class="hljs-params">###</span> 四、技术和产品开发<br>- **技术创新**: 讨论技术开发的趋势、挑战和机遇。<br>- **产品开发流程**: 分析产品开发的关键阶段和最佳实践。<br><br>---<br><br><span class="hljs-params">###</span> 五、案例研究<br>- **成功案例**: 描述一至两个相关行业的成功案例，分析其成功的关键因素。<br>- **教训和启示**: 提取案例中的关键教训和对未来的启示。<br><br>---<br><br><span class="hljs-params">###</span> 六、挑战与机遇<br>- **当前挑战**: 讨论当前面临的主要挑战和难题。<br>- **未来机遇**: 探索未来可能的发展机遇和趋势。<br><br>---<br><br><span class="hljs-params">###</span> 七、结论<br>- **主要发现**: 总结文章的主要发现和观点。<br>- **建议和策略**: 提出基于分析的建议和策略。<br><br>---<br><br><span class="hljs-params">###</span> 八、参考文献<br>- **引用来源**: 列出所有参考的文献和资源。<br><br>---<br><br><span class="hljs-params">###</span> 九、附录<br>- **额外信息**: 如有必要，提供额外的图表、数据或详细信息。<br></code></pre></td></tr></table></figure><h3 id="项目规划和管理"><a href="#项目规划和管理" class="headerlink" title="项目规划和管理"></a>项目规划和管理</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs tex">你是一个软件开发领域的专家并十分擅长文章写作和阅读归纳总结，读取给出的文章/链接，分析后以下面范文输出内容，必要时引入类比，可视化，实例。<br><br>**项目概述**<br>- 项目名称<br>- 背景和目标<br>- 预期成果<br><br>**资源规划**<br>- 人力资源需求<br>- 物资和财务预算<br>- 关键资源分配<br><br>**时间线与里程碑**<br>- 总体时间表<br>- 关键里程碑和截止日期<br><br>**风险评估**<br>- 潜在风险列表<br>- 风险应对策略<br><br>**团队组织与角色**<br>- 团队结构图<br>- 成员职责和角色<br><br>**实施策略**<br>- 执行步骤<br>- 方法和工具<br><br>**监控与评估机制**<br>- 进度监控计划<br>- 评估标准和方法<br><br>**案例研究/实例**<br>- 相关案例分析<br>- 学习点和启示<br><br>**附录**<br>- 参考文献<br>- 相关文档链接<br><br>**总结**<br>- 项目的关键要点<br>- 后续步骤和建议<br></code></pre></td></tr></table></figure><h3 id="技术博客"><a href="#技术博客" class="headerlink" title="技术博客"></a>技术博客</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs tex">你是一个软件开发领域的专家并十分擅长文章写作和阅读归纳总结，读取给出的文章/链接，分析后以下面范文输出内容，必要时引入类比，可视化，实例。<br><br>**概述**<br>- 文章的简短介绍<br>- 主题和目的概述<br><br>**算法原理**<br>- 相关技术的涉及的算法历史演进概述<br>- 适用场景概述<br><br>**详细内容**<br>- 核心技术概念的详细解释<br>- 逐步指南或操作步骤<br><br>**实际示例**<br>- 代码示例或案例研究<br>- 实际应用场景描述<br><br>**最佳实践和建议**<br>- 实用技巧和技术最佳实践<br>- 性能优化建议<br><br>**结论**<br>- 文章的主要观点总结<br>- 对读者的最后建议<br><br>**参考资料**<br>- 相关文献或资源链接<br><br></code></pre></td></tr></table></figure><h2 id="提示词"><a href="#提示词" class="headerlink" title="提示词"></a>提示词</h2><p>提示词 1：</p><p>你是一个软件开发领域的专家并十分擅长文章写作和阅读归纳总结，读取给出的文章&#x2F;链接，告诉我这篇文章属于什么主题类型的文章，是什么领域的，分析这类文章重点要关注哪些部分。必要时引入类比，可视化，实例。</p><p>提示词 2：</p><p>你是一个软件开发领域的专家并十分擅长文章写作和阅读归纳总结，读取给出的文章&#x2F;链接，分析后以下面范文输出内容，必要时引入类比，可视化，实例。</p><p>提示词 3：</p><p>参考上述的重点，帮我输出归纳总结文章内容需要输出的文档模板。</p><p>提示词 4：</p><p>告诉我xxx这种主题类型的文章，分析在编写或阅读这类文章重点要关注哪些部分。必要时引入类比，可视化，实例</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>ai</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识管理</tag>
      
      <tag>阅读</tag>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>技术与管理的矛盾.md</title>
    <link href="/2023/11/23/mdstorage/domain/%E6%9E%B6%E6%9E%84/%E6%8A%80%E6%9C%AF%E4%B8%8E%E7%AE%A1%E7%90%86%E7%9A%84%E7%9F%9B%E7%9B%BE/"/>
    <url>/2023/11/23/mdstorage/domain/%E6%9E%B6%E6%9E%84/%E6%8A%80%E6%9C%AF%E4%B8%8E%E7%AE%A1%E7%90%86%E7%9A%84%E7%9F%9B%E7%9B%BE/</url>
    
    <content type="html"><![CDATA[<p><strong>文章概述</strong></p><ul><li><strong>文章标题</strong>: 技术和管理之间不可调和的矛盾</li><li><strong>作者</strong>: 掘金泥石流</li><li><strong>发布日期</strong>: 2021-07-02</li><li><strong>来源&#x2F;出版物</strong>: 掘金网站</li><li><strong>链接</strong>：<a href="https://juejin.cn/post/6980210389531230222">https://juejin.cn/post/6980210389531230222</a></li><li><strong>文章主题简介</strong>: 文章探讨了技术和管理在职业发展中的矛盾，尤其是在软件开发领域。作者分析了技术和管理目标的根本差异，以及这种差异如何影响技术人员的职业生涯发展。</li></ul><p><strong>主要观点</strong></p><ul><li><strong>观点一</strong>: 技术和管理目标的根本差异。作者指出，尽管技术和管理都旨在解决人的问题，但它们的目标完全不同。管理旨在通过培养更强的个体来增强团队，而技术则通过简化和自动化过程来减少对高技能人员的依赖。</li><li><strong>观点二</strong>: 技术发展对中高级工程师的影响。随着技术的发展，如LowCode平台的兴起，中高级工程师面临着被边缘化的风险。这些平台降低了开发门槛，但同时也限制了工程师的成长空间。</li></ul><p><strong>支持论据</strong></p><ul><li><strong>观点一的支持论据</strong>: 文章通过实际例子，如大厂工作环境中对技术追求和业务支持的要求，展示了管理和技术目标的冲突。</li><li><strong>观点二的支持论据</strong>: 作者提到LowCode平台的使用导致研发人员的角色从创造者转变为操作者，这减少了他们的技术成长机会，从而支持了观点二。</li></ul><p><strong>逻辑连贯性分析</strong></p><ul><li><strong>论点间的逻辑关系</strong>: 文章首先阐述了技术和管理目标的差异，然后基于这种差异探讨了它们对职业发展的影响，特别是对中高级工程师的影响。这种逻辑流程清晰，论点相互支持。</li><li><strong>文章整体结构分析</strong>: 文章结构合理，首先介绍了技术和管理的基本矛盾，然后深入探讨了这种矛盾如何影响技术人员的职业生涯，最后总结了对行业的影响。</li></ul><p><strong>不同视角考量</strong></p><ul><li><strong>其他可能的观点或反驳</strong>: 一些人可能认为技术和管理可以协调发展，认为技术人员可以同时具备强大的技术和管理能力。</li><li><strong>行业或领域内不同专家的意见</strong>: 行业内的其他专家可能会强调技术和管理之间的平衡，或者提出不同的职业发展路径。</li></ul><p><strong>结论与实践意义</strong></p><ul><li><strong>作者的主要结论</strong>: 技术和管理在职业发展中存在根本的矛盾，这对技术人员的职业生涯产生重大影响。</li><li><strong>对行业&#x2F;读者的实际意义</strong>: 对于技术人员而言，理解这种矛盾有助于更好地规划自己的职业生涯，对于行业来说，这提供了对未来技术人才需求和培养方式的洞见。</li></ul><p><strong>个人观点与反思</strong></p><ul><li><strong>个人对文章的看法</strong>: 文章提供了对技术和管理矛盾的深刻洞察，尤其是在软件开发领域。这种分析对于理解行业趋势和个人职业规划非常有价值。</li><li><strong>文章对个人或工作的启发</strong>: 这篇文章强调了在职业规划时考虑技术和管理之间的平衡的重要性，这对于正在考虑未来职业道路的技术人员尤其重要。</li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术管理领域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部门会议总结</title>
    <link href="/2023/11/23/mdstorage/project/sr/%E9%83%A8%E9%97%A8%E4%BC%9A%E8%AE%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2023/11/23/mdstorage/project/sr/%E9%83%A8%E9%97%A8%E4%BC%9A%E8%AE%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="道歉与感谢"><a href="#道歉与感谢" class="headerlink" title="道歉与感谢"></a>道歉与感谢</h2><p>在这次版本发布之际，我想先向一些项目中的同志道歉。回顾这个版本的开发过程，我认识到自己在领导Go二组时出现了一些失误。特别是在风险管理方面，我没有及时收集并上报关键信息，导致问题的严重性没有被上级及时认识到，给团队带来了不必要的压力和挑战。</p><p>我要特别向可视化组的向阳、院红、琼婷、育孟，以及引擎安装的贺泽道歉。我的管理和技术上的不足影响了他们的绩效，尤其是在他们向我报告风险并提出解决方案时，我未能采取有效措施。他们在问题发生后积极参与解决，为团队做出了巨大贡献，是我学习的榜样。</p><p>同时，我也要向向阳致以深深的歉意。他加入团队后，不仅帮助我领导团队，还在可视化组独立后承担了重担，我相信他会成功完成项目。</p><p>对于C++组、测试组和项目经理们，我也表达我的歉意。在规范开发流程的过程中，我们之间发生了一些不必要的言语冲突，我对此感到十分后悔。我认识到这不是任何个人的过错，而是整个流程中的挑战。</p><p>我还需要向技术部的李福林、王总道歉。由于我的不足，技术部在客户那里面临了挑战，给团队增加了困难。</p><p>最后，我要向老板们道歉。我没能完全达到你们的期望，但请相信，团队中每个人都有出色的潜力和能力。作为组长，我将承担主要的责任。</p><p>在此，我也要感谢那些在困难时刻仍然坚守岗位的团队成员，如志凯、立成、慧军、松达，他们的努力保持了项目的稳定。同时感谢思华、宋燚、周宇、福林、王总、桂华、刘总，给予我许多信息、资源、时间上支持和帮助。</p><h3 id="好和不好的点"><a href="#好和不好的点" class="headerlink" title="好和不好的点"></a>好和不好的点</h3><p>在这个版本期间，为流程规范建立和执行，团队成员都非常配合，让我真正看到团队在齐心协力地改进项目形态，让项目从幼稚走向成熟。</p><p>团队中各成员的配合还不够默契，还有改进的空间。</p><p>任务评估这个环节上还不够全面、准确。</p><p>总结一下，这个版本让我看到每个团队成员都在成长、在突破。</p><h3 id="提一下团队成员的诉求"><a href="#提一下团队成员的诉求" class="headerlink" title="提一下团队成员的诉求"></a>提一下团队成员的诉求</h3><ul><li>打包时间过长<ul><li>之前需要 二、三十分钟，后面我们已经安排做了缓存优化，能优化到 1 分钟。只是生产环境应用的时机问题。</li></ul></li><li>超融合机器有时性能不行<ul><li>这个后面测试团队接手了这部分工作，我相信他们能帮我们提供这方面支持，改善我们用机器的性能问题。</li></ul></li><li>需求改动频繁，临近上线还有需求变更，版本需求临界点不清晰问题<ul><li>已跟产品团队做了信息同步，将在下版本尽量优化改进，大家也要多给团队一些时间、包容，要记住我们是一个团队，荣辱与共的团体。</li></ul></li><li>测试介入有时不及时，已提测比较久后才发现提了BUG<ul><li>跟测试团队联系更紧密</li><li>项目经理优化测试资源调度</li><li>CI&#x2F;CD 流程建立</li></ul></li></ul><p>总的来说，项目确实是越來越庞大，但也越来越好了。</p><p>“海阔凭鱼跃，天高任鸟飞。” 我期待我们所有人在石犀这片蓝天中自由翱翔、不断进取、一往无前。</p><h4 id="自身的问题"><a href="#自身的问题" class="headerlink" title="自身的问题"></a>自身的问题</h4><p>是一个失败的管理者</p><ul><li>整个组织对管理和技术缺乏认知, 让管理者天然被矛盾包围, 又要人成长又要拿结果, 无休止的加班也换不来认可</li><li>单纯的压力传导, 对管理和技术毫无想法, 仅仅是倾斜上层压力给团队</li><li>以架构师, 技术专家的思维方式去对待团队, 把人看成工具和资源, 只考虑结果不考虑过程, 造成团队内耗严重, 长期无法形成战斗力</li></ul><p>是一个失败的架构师</p><ul><li><p>技术规划的两个极端</p><ul><li>在技术规划和设计中忽视人的因素, 没有将其纳入分析范围, 导致落地变形失败</li><li>对效率的认识不足, 过于考虑使用者的所谓成长空间等本不该考虑的问题,导致方案不伦不类</li></ul></li><li><p>想要目标感, 目的不明确, 缺乏理性, 情绪化, 朝令夕改</p></li></ul><p><strong>一、主要成就</strong></p><p>首先，我想与大家分享我们团队在过去一段时间里取得的显著成就。我们的成就不仅仅体现在完成任务上，更在于我们如何高效、创新地完成这些任务。</p><ol><li><p><strong>成功研发1.3.0版本</strong>：我们的团队按照既定的需求任务，成功完成了总控、引擎、插件1.3.0版本的研发工作。这个版本的研发不仅涉及复杂的技术挑战，还需要我们在紧迫的时间线内保持高效率和高质量的输出。我们的团队展现了出色的技术实力和项目管理能力。</p></li><li><p><strong>规范研发流程</strong>：我们不仅关注产品的开发，同样重视研发流程的规范化。我们对部分研发流程进行了规范，并以微盘文档的形式进行记录和分享，这不仅提高了工作效率，还促进了团队内部的知识共享和学习。这些文档为新成员的快速融入和老成员的持续学习提供了极大的便利。</p></li><li><p><strong>流程培训和共享</strong>：我们认识到仅仅规范流程是不够的，团队成员对这些流程的理解和应用同样重要。因此，我们不仅制定了流程，还开展了相关的培训活动。通过这些培训，我们确保每位团队成员都能充分理解并正确应用这些流程，从而提高整个团队的协作效率和产品质量。</p></li><li><p><strong>技术创新和问题解决</strong>：在这个过程中，我们的团队面临了许多技术挑战和问题。我们不仅成功地解决了这些问题，还在此过程中创新了一些新的技术和方法。这些创新不仅提高了我们当前项目的效率和质量，还为我们未来的项目打下了坚实的基础。</p></li></ol><p>这些成就是我们团队共同努力的结果。每一位团队成员的辛勤工作和奉献精神都是我们能够取得这些成就的关键。</p><p><strong>二、挑战与困难</strong></p><p>在我们的旅程中，我们面临了不少挑战和困难，这些问题对我们的工作流程和项目交付产生了影响。</p><h3 id="A-需求管理"><a href="#A-需求管理" class="headerlink" title="A. 需求管理"></a>A. 需求管理</h3><ol><li><p><strong>需求文档质量问题</strong>：我们遇到了需求文档描述不清晰的问题，这导致了流程的不合理性和功能目标的自相矛盾。为了解决这一问题，我们将加强需求文档的评审流程，确保在开发前与需求方达成一致，并且减少不必要的功能和模块的设计，避免界面风格的不统一。</p></li><li><p><strong>需求变动频繁</strong>：频繁的需求变更，特别是在项目接近上线的阶段，对我们的工作计划和资源分配造成了冲击。未来，我们将设立更明确的版本需求临界点，并加强与各方的沟通，以减少临时变更的影响。</p></li></ol><h3 id="B-开发过程"><a href="#B-开发过程" class="headerlink" title="B. 开发过程"></a>B. 开发过程</h3><ol><li><p><strong>设计文档不全</strong>：部分功能模块缺少完整的设计文档，这影响了开发的连贯性和质量。我们计划在未来强化设计文档的完整性，确保每一个功能模块都有详细的设计记录。</p></li><li><p><strong>设计不充分</strong>：我们也面临了设计考虑不周全的问题，尤其是在安全性、性能和影响范围方面。我们将加强设计阶段的评审流程，确保设计的全面性和适应性。</p></li></ol><h3 id="C-安装升级和联调"><a href="#C-安装升级和联调" class="headerlink" title="C. 安装升级和联调"></a>C. 安装升级和联调</h3><ol><li><p><strong>安装升级问题</strong>：我们遇到了依赖性和升级兼容性问题，这导致了安装和升级的困难。解决这个问题的关键是优化依赖管理和测试升级路径。</p></li><li><p><strong>联调协作不足</strong>：我们的项目在多层面的协作中遇到了障碍。我们计划加强团队间的沟通和协作流程，以改善联调效率。</p></li></ol><h3 id="D-测试与部署"><a href="#D-测试与部署" class="headerlink" title="D. 测试与部署"></a>D. 测试与部署</h3><ol><li><p><strong>测试介入时间</strong>：测试可能的延迟介入影响了问题的早期发现。我们将调整测试流程，确保测试团队可以及时介入和提供反馈。</p></li><li><p><strong>打包部署效率低</strong>：打包和部署的周期过长，影响了整体的工作效率。我们将提升打包部署环境的硬件资源，优化资源配置，以加快这一过程。</p></li></ol><h3 id="E-技术支持与资源配置"><a href="#E-技术支持与资源配置" class="headerlink" title="E. 技术支持与资源配置"></a>E. 技术支持与资源配置</h3><ol><li><p><strong>加强技术支持</strong>：为了改善工作环境，我们计划提供更好的硬件资源，包括磁盘、CPU和内存，并确保网络环境能够满足低延迟和高吞吐量的需求。</p></li><li><p><strong>CI&#x2F;CD实践指导</strong>：我们还面临着CI&#x2F;CD实践的挑战。项目经理和开发团队将更紧密地协调人力和资源，确保CI&#x2F;CD流程的有效实施。</p></li></ol><p><strong>三、未来规划</strong></p><ol><li><p><strong>改进需求管理流程</strong>：我们将专注于改进需求管理流程，确保需求文档的质量，并减少临时需求变更的影响。</p></li><li><p><strong>优化开发和设计流程</strong>：我们计划优化开发流程，强化设计文档的完整性，确保设计的全面性和适应性。</p></li><li><p><strong>强化安装升级和联调流程</strong>：我们将专注于解决安装升级的问题，优化依赖管理，并加强团队间的协作，以提高联调效率。</p></li><li><p><strong>提升测试和部署效率</strong>：我们将调整测试流程，以及提升打包部署环境的硬件资源，以加快测试和部署的周期。</p></li><li><p><strong>增强技术支持和资源配置</strong>：为了支持这些改进，我们将加强技术支持，提供更好的硬件资源，并优化CI&#x2F;CD实践。</p></li></ol><p><strong>四、个别成员表现</strong></p><p>在这一阶段的工作中，我们有几位团队成员的表现值得特别提及。他们的贡献不仅体现在完成任务上，还包括在团队中的积极态度和个人品质。</p><ol><li><p><strong>吴松达和贺泽</strong>：他们在工作中展示了复杂情况下的应对能力。尽管在任务反馈的及时性、请假规定的遵守、考勤和日常报告方面存在一些挑战，但他们在承担的任务量和范围方面表现出色。他们积极活泼的态度，以及对问题的提出和解决方案的思考，体现了他们的爱思考、坚韧、社会性和好奇心这四种珍贵品质。在未来，我们将与他们一起努力改进这些方面的不足。</p></li><li><p><strong>韩志凯和范众星</strong>：这两位同事的表现也非常值得肯定。他们在沟通方面表现充分、稳重，确保了负责模块的无纰漏运作。他们的工作可能不总是显眼，但正如“善战者无赫赫之功”一般，他们在日常工作中的卓越表现是团队稳定运行的关键。他们的贡献在维护模块稳定性和高效性方面尤为突出。</p></li></ol><p><strong>五、感谢</strong></p><ol><li><strong>对全体团队成员的感谢</strong>：首先，我要感谢每一位团队成员。无论是面对复杂的技术挑战，还是在紧迫的项目时间线上工作，大家都表现出了非凡的专业能力和坚定的承诺。您们的热情和奉献是我们团队成功的基石。</li><li><strong>对面临挑战同事的感谢</strong>：或多或少我们都经历了挑战，再次感谢特别是面对挑战时坚持不懈的同事，您们展现的韧性和解决问题的能力对于团队的成功至关重要。</li><li><strong>对管理团队的感谢</strong>：我还要特别感谢我们的管理团队，他们在规划和指导中展现了卓越的领导力。在面对各种挑战和变化时，他们的决策和支持为团队提供了坚实的后盾。</li><li><strong>对家庭和亲人的感谢</strong>：最后，我要感谢我们每位团队成员的家庭和亲人。他们的理解和支持使我们能够全身心投入工作。没有他们的支持，我们的成功也不会完整。</li></ol><p><strong>待关注的点</strong></p><h4 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h4><ul><li>有时项目紧急，人员抽调不合理</li><li>不是所有禅道任务项目管理都有被跟踪、更新</li><li>项目里程碑、版本设计不合理</li><li>开发节奏太紧、流程、规范要求占用很长时间，但是项目管理上没有时间消耗的意识</li><li>禅道任务拆分粒度过大，原因是大家对其认知不够，导致时间评估上不准</li><li>基础设施 禅道、CI&#x2F;CD、wiki 、团队知识库依然简陋</li></ul><h4 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h4><ul><li>有些开发不知道这套系统整体长什么样，不知道怎么部署环境</li><li>代码不规范、review 缺失，也要注意，做这些前提是给时间</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>人为什么会追求权力、金钱、颜值？因为拥有这些东西的人走到哪里都是众星捧月，本质上，最终追求的还是别人的认同。<br>但是，做事情的人都是孤独的，没有人能照顾到各方利益，得到所有人的认同，总会有各种不和谐的声音存在，也没有人能走出绝对正确的路线，总会有试错、反复试错，并在这个过程中变得越来越好。</p><p>举个例子：</p><p>做事情的过程中，感受各方面的条件限制，各方面的压力，各种睡不着、焦虑。<br>而结果是没法即时验证的，所以这种压力会持续很久，直到时间让人淡忘。<br>有些结果可以短时间内验证，如果证明走错了路，当你埋头思考、总结经验时，你会感受到“墙倒众人推”的滋味。<br>当然，如果走对了路，那大家就会认为你有能力、优秀，不过也别飘，下次失败时，还是会“墙倒众人推”。</p><p>面临这样的压力时，大家会想起什么？我只想送一句话，看透世界的残酷而依然埋头赶路的才是英雄。</p><p>我说完了，看起来我说了很多，其实我什么也没有说，要相信，我说的是错的，有收获是你自己的。</p><h2 id="附录：1-3-0-版本问题整理"><a href="#附录：1-3-0-版本问题整理" class="headerlink" title="附录：1.3.0 版本问题整理"></a>附录：1.3.0 版本问题整理</h2><h3 id="A-需求管理-1"><a href="#A-需求管理-1" class="headerlink" title="A. 需求管理"></a>A. 需求管理</h3><ol><li><p><strong>需求文档质量问题</strong>：</p><ul><li>功能和目标描述不清，导致流程不合理和自相矛盾。</li><li>需求文档应在开发介入前完成评审，确保与需求来源方达成一致。</li><li>避免多个模块界面设计风格不一致，减少无意义功能和模块。</li></ul></li><li><p><strong>需求变动频繁</strong>：</p><ul><li>需求变更频繁，尤其是在接近上线阶段。</li><li>需要设立明确的版本需求临界点，及时沟通变更。</li></ul></li></ol><h3 id="B-开发过程-1"><a href="#B-开发过程-1" class="headerlink" title="B. 开发过程"></a>B. 开发过程</h3><ol><li><p><strong>设计文档不全</strong>：</p><ul><li>缺少部分功能模块的设计文档。</li><li>强化设计文档的完整性和规范性。</li></ul></li><li><p><strong>设计不充分</strong>：</p><ul><li>安全性、性能、影响范围等方面考虑不足。</li><li>加强设计评审，确保全面性和适应性。</li></ul></li></ol><h3 id="C-安装升级和联调-1"><a href="#C-安装升级和联调-1" class="headerlink" title="C. 安装升级和联调"></a>C. 安装升级和联调</h3><ol><li><p><strong>安装升级问题</strong>：</p><ul><li>依赖性和升级兼容性问题。</li><li>优化依赖管理和测试升级路径。</li></ul></li><li><p><strong>联调协作不足</strong>：</p><ul><li>各层面协作问题，如项目经理、开发等。</li><li>加强团队间沟通和协作流程。</li></ul></li></ol><h3 id="D-测试与部署-1"><a href="#D-测试与部署-1" class="headerlink" title="D. 测试与部署"></a>D. 测试与部署</h3><ol><li><p><strong>测试介入时间</strong>：</p><ul><li>测试可能介入太晚。</li><li>调整测试流程，确保及时介入和反馈。</li></ul></li><li><p><strong>打包部署效率低</strong>：</p><ul><li>打包部署周期长，影响工作效率。</li><li>提升打包部署环境，优化资源配置。</li></ul></li></ol><h3 id="E-技术支持与资源配置-1"><a href="#E-技术支持与资源配置-1" class="headerlink" title="E. 技术支持与资源配置"></a>E. 技术支持与资源配置</h3><ol><li><p><strong>加强技术支持</strong>：</p><ul><li>提供更好的硬件资源，如磁盘、CPU、内存。</li><li>确保低延迟高吞吐量的网络环境。</li></ul></li><li><p><strong>CI&#x2F;CD实践指导</strong>：</p><ul><li>需要更有效的CI&#x2F;CD实践。</li><li>项目经理和开发团队应协调人力和资源，确保流程的顺利实施。</li></ul></li></ol><hr><p>以上内容梳理了1.3.0版本在需求管理、开发过程、安装升级和联调、测试与部署、技术支持与资源配置方面遇到的主要问题，并提出了相应的改进措施。请根据实际情况进一步调整和完善这些内容。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. **团队的主要成就**：在过去的一段时间里，团队取得了哪些显著成果？<br>2. **挑战与困难**：团队在工作中遇到了哪些难题，以及是如何克服这些挑战的？<br>3. **个别成员表现**：是否有特别需要表扬或提及的团队成员？<br>4. **未来规划**：团队接下来有哪些计划或目标？<br>5. **感谢与鼓励**：对团队的感谢之词或鼓励的话语。<br>6. **其他补充信息**：任何您认为重要的信息，比如团队的特殊事件、重要里程碑等。<br><br><br><br>团队的主要成就：<br><br>1. 按照需求任务，完成 总控、引擎、插件 1.3.0 版本需求的研发<br>2. 规范了部分研发流程，并以微盘文档的形式以供团队学习，部分流程开展了培训。<br><br>挑战与困难：<br><br>见附录<br><br>个别成员表现：<br><br>1. 吴松达、贺泽： 安排的任务反馈不及时、请假没有按规定、考勤不好、情绪不稳定、日报周报等常常遗漏。但是承担的任务很多，范围很广，平时积极活泼，常常提出问题，思考解决方案。对应了人类珍贵的四种品质：爱思考 坚韧 社会性 有好奇心。<br>2. 韩志凯、范众星：沟通比较充分、稳重，负责的模块不出纰漏，善战者无赫赫之功，维护好一个模块将日常的工作做到极致也是非常值得肯定的。<br><br>未来规划：<br><br>1. 需要建立更规范的规章制度和流程规范。规章制度流程规范是组织内部管理和操作的核心组成部分，要确保有效性、透明性和适应性：需要做到<br><br>   **明确性（Clarity）**：规章制度应该清晰明确，易于理解。避免使用模糊不清的语言，确保所有相关人员都能准确理解其含义和应用方式。<br><br>   **一致性（Consistency）**：制度和流程应该在整个组织内保持一致。这有助于减少混淆，确保所有部门和员工按照相同的标准执行。<br><br>   **可访问性（Accessibility）**：员工应能轻松访问到相关的规章制度文档。这通常意味着将它们存放在中央、容易访问的位置，如内部网络或手册。<br><br>   **适用性（Applicability）**：制度应与组织的运营、文化和目标紧密相连。它们应该针对组织的具体情况设计，而不是简单地复制其他组织的模式。<br><br>   **合法性（Legality）**：所有规章制度必须遵守相关的法律和行业标准。它们不应与任何法律条文相冲突。<br><br>   **灵活性（Flexibility）**：制度应该有一定的灵活性，以适应不断变化的环境和需求。应当定期审查并根据需要进行调整。<br><br>   **可执行性（Enforceability）**：应该有明确的执行机制。员工需要知道，对于不遵守规章制度将会有何种后果。<br><br>   **透明性（Transparency）**：制定和修改规章制度的过程应公开透明，以便员工理解制度的目的和重要性。<br><br>   **目标导向（Goal-oriented）**：流程和规章应支持组织的总体目标和战略。<br><br>   **评估和反馈（Evaluation and Feedback）**：应定期评估制度的有效性，并对员工的反馈做出响应<br><br>   <br><br>   原因：<br><br>- **团队规模增长时**：随着团队规模的增长，原有的非正式或口头沟通方式可能不再有效。规章制度可以帮助确保信息的一致性和准确性，特别是在团队成员之间需要协作的情况下。<br>- **面临复杂项目时**：当项目涉及多个部门、多个阶段或高度复杂性时，明确的流程规范有助于保持项目的顺利进行，并确保各个环节协调一致。<br>- **引入新技术或方法时**：当团队采用新的技术、工具或开发方法（如敏捷开发）时，建立相关的规章制度可以帮助团队成员理解和适应这些新变化。<br>- **遵守行业标准和法律要求时**：在某些行业中，遵守特定的法律法规和标准是必须的。例如，在医疗、金融或政府项目中，规章制度和流程规范可以帮助确保合规。<br>- **提高效率和质量时**：为了提高工作效率和产品质量，团队可能需要引入标准化的工作流程和质量控制措施。<br>- **面对频繁的变更和迭代时**：在快速变化的市场环境中，规章制度可以帮助团队快速适应变化，同时保持工作的连贯性和效率。<br>- **实现知识共享和传承时**：随着团队成员的更迭，重要知识和经验的传承变得尤为重要。规章制度可以帮助新成员快速融入团队，理解工作流程和文化。<br>- **远程工作或分布式团队时**：对于远程工作或地理位置分散的团队，明确的规章制度和流程规范对于保持团队协调和高效合作至关重要。<br><br><br><br>2. 更细致的分工<br><br>研发岗位的组长和组员强调对于技术方面更多的参与，关注代码本身。<br><br>对于组长以上，应该做到对规章制度和流程规范，项目管理层面的把控，注意合理、可行、公平<br><br>3. 完成 1.4.0 版本需求<br>4. 优化端口策略<br><br>- 复用<br><br>- 尽量连续<br><br>  <br><br>5. 拥抱信创<br><br>- Envoy Polycube waf 等编译<br>- MySQL5.7 MongoDB HyperScan<br>- so 依赖库问题<br>- 组件依赖汇编<br><br><br><br><span class="hljs-params">##</span> 附录<br><br><span class="hljs-params">###</span> 1.3.0 版本问题整理<br><br><span class="hljs-params">###</span> 需求<br><br><span class="hljs-params">####</span> 需求文档质量差<br><br>各个模块完成的功能和目标没有梳理清楚，导致流程不合理、自相矛盾的情况屡屡发生。<br><br>需求文档应该在开发介入前评审完成，而不是让开发和需求同时进行<br><br>产品经理应该和需求来源方达成一致后<br><br>多个模块、界面设计风格不一致<br><br>存在很多无意义的功能、模块<br><br>设计功能、模块时未考虑对系统性能影响，导致影响越来越大，最终系统中部分的业务性能出现瓶颈，导致需要开发设计重构，需求重做。至今尚未解决性能问题。<br><br>需求文档没有经过拆分，一个版本一个需求文档，找到某一个功能的需求非常困难<br><br><span class="hljs-params">####</span> 需求变动频繁、随意<br><br>需求变动频繁，临近上线还经常看到群里有需求变更，甚至还添加新需求，版本需求临界点不清晰<br><br><span class="hljs-params">###</span> 开发<br><br><span class="hljs-params">####</span> 设计文档不全<br><br>这版本之前开发的功能模块开发的设计文档都是没有的，相当一部分人没有补齐<br><br><span class="hljs-params">####</span> 设计不充分<br><br>有些设计文档也有考虑不周的情况，安全性、性能、影响范围、测试建议、自测实现思路、兼容性（不同组件、不同版本）<br><br><span class="hljs-params">####</span> 安装升级问题<br><br><span class="hljs-params">#####</span> 安装升级问题<br><br>依赖<br><br>升级兼容性<br><br><span class="hljs-params">####</span> 联调<br><br>从各个层面，如何协作才能更好完成<br><br><span class="hljs-params">#####</span> 主管<br><br><span class="hljs-params">#####</span>  项目经理<br><br><span class="hljs-params">#####</span> 大组长<br><br><span class="hljs-params">#####</span> 开发<br><br><span class="hljs-params">###</span> 测试<br><br><span class="hljs-params">####</span> 测试介入时间是否及时<br><br>测试是否介入太晚？有时候看到测试提的bug是几周前就已经提测的需求了，这些问题按道理应该是需要提前发现提出的<br><br><span class="hljs-params">###</span> 打包部署<br><br><span class="hljs-params">####</span> 打包部署一次周期很长<br><br><span class="hljs-params">#####</span> 现象<br><br>打包部署一次时间很长，这个现象已经持续很久，急需解决。<br><br>超融合机器性能不好，部署周期过长，从打包到升级耗时往往超过1小时，期间如果出现包有问题的情况可能一个上午就过去了，甚至会出现几天没有一个有用包的情况出现<br><br><span class="hljs-params">#####</span> 解决<br><br><span class="hljs-params">######</span> 技术支持<br><br>更强大的技术支持，如打包机器用更好的磁盘、CPU、更多内存，集测环境机器网络延迟和吞吐量要满足低延迟高吞吐量要求。<br><br><span class="hljs-params">######</span> 架构、研发经理<br><br>CI/CD 实践指导<br><br><span class="hljs-params">######</span> 项目经理<br><br>指定并协调人力、时间资源<br><br><span class="hljs-params">######</span> 开发<br><br>- 开发人员跟打包部署测试人员要做充分沟通（提交新的代码）<br>- 在某一功能新开发时就充分考虑功能的扩展性、兼容性，在后续开发时首先在自己组件层面做好数据兼容，逻辑兼容，涉及多个组件交互的模块尽量解耦，尽早识别风险。如果遇到绕不过，需要其他组件配合实现的，在打包时跟相关开发和打包部署测试人员充分沟通后走流程。<br>- 数据提供方在设计完成后优先考虑数据结构交互部分的实现，如将 接口请求响应、API文档部分完成。<br><br><br><br><span class="hljs-params">##</span> <br><br><br><br><br><br><br>在这次版本发布之际，我首先要向团队中的同事们表达我的歉意。回顾这个版本的开发过程，我认识到自己在领导Go二组和可视化小组时出现了一些失误。特别是在风险管理方面，我没有及时收集并上报关键信息，导致问题的严重性没有被上级及时认识到，给团队带来了不必要的压力和挑战。<br><br>我要特别向可视化组的向阳、院红、琼婷、育孟，以及引擎安装的贺泽道歉。我的管理和技术上的不足影响了他们的绩效，尤其是在他们向我报告风险并提出解决方案时，我未能采取有效措施。他们在问题发生后积极参与解决，为团队做出了巨大贡献，是我学习的榜样。<br><br>同时，我也要向向阳致以深深的歉意。他加入团队后，不仅帮助我领导团队，还在可视化组独立后承担了重担，我相信他会成功完成项目。<br><br>对于C++组、测试组和项目经理们，我也表达我的歉意。在规范开发流程的过程中，我们之间发生了一些冲突，我对此感到后悔。我认识到这不是任何个人的过错，而是整个流程中的挑战。<br><br>我还需要向技术部的李福林、王总道歉。由于我的不足，技术部在客户那里面临了挑战，给团队增加了困难。<br><br>最后，我要向老板道歉。我没能完全达到您的期望，但请相信，团队中每个人都有出色的潜力和能力。作为领导者，我将承担主要的责任。<br><br>在此，我也要感谢那些在困难时刻仍然坚守岗位的团队成员，如志凯、立成、慧军、松达，他们的努力保持了项目的稳定。同时感谢思华、宋燚、周宇、福林、王总、桂华、刘总的支持和帮助。<br><br>“海阔凭鱼跃，天高任鸟飞。” 我期待我们所有人在石犀这片蓝天中自由翱翔、不断进取。<br><br><br><br>在这个版本发布后，我想先向一些项目中的同志道歉。原因是这样的，在这个版本开始时，我接手的Go二组和可视化小组是包含关系。桂华将小组责任交与我，但是我并未将其按质按量完成，在风险管控上，未让相关人员收集所有信息导致不能早早让上级意识到这是个严重的问题，以至于暴露出的问题让老板都惊讶。<br><br>我深切认识到，这确确实实是我的责任。在此，先是可视化组成员：向阳、院红、琼婷、育孟等，再是引擎安装的贺泽，第一，他们因为我能力上的不足导致在绩效上非常受影响。第二，重点道歉院红、琼婷、贺泽，在发现了风险后，他们向我提出过这些问题和详细信息，但是我没有实施有益的措施帮助。而后，他们非常积极的帮助补救形势而努力工作，他们是我学习的榜样。下面也要向向阳道歉：向阳进入团队后，一直为团队摆脱困境协助我带领团队，后面可视化独立成一个组去收拾我留下的烂摊子，我相信他会把项目完成好。第三，向 C++ 组成员、测试组和项目经理们道歉，在这个版本进行中，还有一件大事同步进行，就是规范项目各种开发流程，这期间很多次跟很多人发生冲突，可能表现为语言上冲突很严重，有时说完立刻就觉得很后悔，这可能并不是任何人的错，不应该有人为此承担责任的。第四，向技术部李福林、王总道歉，消耗了许多技术部资源但是我这边交付的需求不达标导致他们在客户那边很难维持关系，给我们技术部团队添了太多麻烦。第五，向老板道歉，我觉得我辜负了老板对我的信任，但是我想澄清的是，团队的表现不佳，并不代表团队中每个人都不好，最大的原因一定是带头实施的人员没做好。最后，我想郑重向我的上级道歉，虽然是我在道歉，但是最终犯错的结果、责任还是落在上级头上。<br><br>道歉后，我想感谢一些人，除了刚刚提到的院红、琼婷、贺泽、向阳外，还有一些团队成员，志凯、立成、慧军、松达，他们没有受到我的影响，为维持总控项目的基础稳定进行了出色的工作，是团队中最可敬的人。还有思华、宋燚、周宇、福林、王总、桂华、刘总，他们给予我许多信息上、资源上、时间上非常多的帮助。<br><br>海阔凭鱼跃，天高任鸟飞。希望大家在石犀这片蓝天中自由翱翔、一往无前。<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang入职考试数据库相关.md</title>
    <link href="/2023/11/22/mdstorage/domain/%E6%8B%9B%E8%81%98/Golang%E5%85%A5%E8%81%8C%E8%80%83%E8%AF%95%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
    <url>/2023/11/22/mdstorage/domain/%E6%8B%9B%E8%81%98/Golang%E5%85%A5%E8%81%8C%E8%80%83%E8%AF%95%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="Golang入职考试数据库相关"><a href="#Golang入职考试数据库相关" class="headerlink" title="Golang入职考试数据库相关"></a>Golang入职考试数据库相关</h2><h3 id="关键部分"><a href="#关键部分" class="headerlink" title="关键部分"></a>关键部分</h3><p>数据库基础与应用</p><h3 id="开放参考资料"><a href="#开放参考资料" class="headerlink" title="开放参考资料"></a>开放参考资料</h3><ul><li>“Go Programming Language” by Alan A. A. Donovan and Brian W. Kernighan</li><li>“High Performance MySQL” by Baron Schwartz, Peter Zaitsev, and Vadim Tkachenko</li><li>“Redis in Action” by Josiah L. Carlson</li><li>“MongoDB: The Definitive Guide” by Kristina Chodorow</li><li><a href="https://github.com/etcd-io/etcd">Etcd</a></li></ul><h3 id="入职考试范围（考察）"><a href="#入职考试范围（考察）" class="headerlink" title="入职考试范围（考察）"></a>入职考试范围（考察）</h3><ul><li>Golang数据库连接与操作基础</li><li>数据库设计原理</li><li>数据库性能优化</li><li>数据的增删改查（CRUD）操作</li><li>事务管理</li><li>错误处理与调试</li><li>数据库安全性</li></ul><h3 id="入职考试题目"><a href="#入职考试题目" class="headerlink" title="入职考试题目"></a>入职考试题目</h3><h4 id="Etcd"><a href="#Etcd" class="headerlink" title="Etcd"></a>Etcd</h4><ol><li><strong>Etcd使用</strong>: 描述在Golang中使用Etcd进行服务注册和发现的基本步骤。请提供代码示例来演示如何使用Etcd客户端库在Etcd中注册服务，并如何发现已注册的服务。</li><li><strong>Etcd的事务</strong>: 通过Etcd的事务功能解释乐观锁的概念，并提供一个Golang代码示例，说明如何使用Etcd实现分布式锁。</li></ol><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><ol><li><strong>MySQL性能优化</strong>: 在Golang应用程序中，有哪些方法可以优化MySQL查询的性能？请提供具体的策略和示例。</li><li><strong>MySQL事务处理</strong>: 用Golang编写一个示例程序，展示如何在MySQL中正确地实现事务处理，包括提交和回滚操作。</li></ol><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><ol><li><strong>Redis数据结构应用</strong>: 描述如何在Golang中使用Redis的不同数据结构来实现一个简单的排行榜系统。</li><li><strong>Redis持久化</strong>: Redis支持哪些持久化机制？请比较它们的优劣，并提供Golang中配置持久化的代码示例。</li></ol><h4 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h4><ol><li><strong>MongoDB查询优化</strong>: 介绍在Golang中如何优化MongoDB的查询性能，包括索引的使用和查询分析器的运用。</li><li><strong>MongoDB的聚合</strong>: 使用Golang提供一个MongoDB聚合操作的示例，如何计算集合中文档的平均值。</li></ol><h3 id="参考答案（伪代码）"><a href="#参考答案（伪代码）" class="headerlink" title="参考答案（伪代码）"></a>参考答案（伪代码）</h3><h4 id="Etcd-1"><a href="#Etcd-1" class="headerlink" title="Etcd"></a>Etcd</h4><p><strong>1. Etcd服务注册与发现：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    clientv3 <span class="hljs-string">&quot;go.etcd.io/etcd/client/v3&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    cli, err := clientv3.New(clientv3.Config&#123;<br>        Endpoints:   []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;localhost:2379&quot;</span>&#125;,<br>        DialTimeout: <span class="hljs-number">5</span> * time.Second,<br>    &#125;)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> cli.Close()<br><br>    <span class="hljs-comment">// 注册服务</span><br>    ctx, cancel := context.WithTimeout(context.Background(), time.Second)<br>    _, err = cli.Put(ctx, <span class="hljs-string">&quot;services/my-service/instance1&quot;</span>, <span class="hljs-string">&quot;http://10.0.0.1:8080&quot;</span>)<br>    cancel()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    <span class="hljs-comment">// 发现服务</span><br>    ctx, cancel = context.WithTimeout(context.Background(), time.Second)<br>    resp, err := cli.Get(ctx, <span class="hljs-string">&quot;services/my-service/&quot;</span>, clientv3.WithPrefix())<br>    cancel()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">for</span> _, ev := <span class="hljs-keyword">range</span> resp.Kvs &#123;<br>        log.Printf(<span class="hljs-string">&quot;%s : %s\n&quot;</span>, ev.Key, ev.Value)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. Etcd乐观锁和分布式锁：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    clientv3 <span class="hljs-string">&quot;go.etcd.io/etcd/client/v3&quot;</span><br>    <span class="hljs-string">&quot;go.etcd.io/etcd/client/v3/concurrency&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    cli, err := clientv3.New(clientv3.Config&#123;<br>        Endpoints:   []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;localhost:2379&quot;</span>&#125;,<br>        DialTimeout: <span class="hljs-number">5</span> * time.Second,<br>    &#125;)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> cli.Close()<br><br>    <span class="hljs-comment">// 创建session用于锁</span><br>    s, err := concurrency.NewSession(cli)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> s.Close()<br><br>    <span class="hljs-comment">// 创建一个分布式锁</span><br>    m := concurrency.NewMutex(s, <span class="hljs-string">&quot;/my-lock/&quot;</span>)<br><br>    <span class="hljs-comment">// 尝试获取锁</span><br>    <span class="hljs-keyword">if</span> err := m.Lock(context.Background()); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    log.Println(<span class="hljs-string">&quot;acquired lock&quot;</span>)<br><br>    <span class="hljs-comment">// 执行业务逻辑...</span><br><br>    <span class="hljs-comment">// 释放锁</span><br>    <span class="hljs-keyword">if</span> err := m.Unlock(context.Background()); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    log.Println(<span class="hljs-string">&quot;released lock&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="MySQL-1"><a href="#MySQL-1" class="headerlink" title="MySQL"></a>MySQL</h4><p><strong>1. MySQL性能优化：</strong></p><p>答案: 优化MySQL查询的性能可以通过以下方法实现：</p><ul><li>使用索引来加快搜索速度。</li><li>编写高效的SQL查询，避免不必要的数据加载。</li><li>使用分页来限制大量数据的检索。</li><li>使用连接池来管理和重用数据库连接。</li></ul><p>代码示例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 假设已有db *sql.DB连接</span><br><span class="hljs-comment">// 确保索引已创建，例如：CREATE INDEX idx_name ON users(name);</span><br><br>rows, err := db.Query(<span class="hljs-string">&quot;SELECT id, name FROM users WHERE name = ? LIMIT 10&quot;</span>, <span class="hljs-string">&quot;John Doe&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">defer</span> rows.Close()<br><br><span class="hljs-keyword">for</span> rows.Next() &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. MySQL事务处理：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 假设已有db *sql.DB连接</span><br><br>tx, err := db.Begin()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br><br>_, err = tx.Exec(<span class="hljs-string">&quot;UPDATE accounts SET balance = balance - ? WHERE id = ?&quot;</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    tx.Rollback()<br>    log.Fatal(err)<br>&#125;<br><br>_, err = tx.Exec(<span class="hljs-string">&quot;UPDATE accounts SET balance = balance + ? WHERE id = ?&quot;</span>, <span class="hljs-number">100</span>, <span class="hljs-number">2</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    tx.Rollback()<br>    log.Fatal(err)<br>&#125;<br><br>err = tx.Commit()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h4><p><strong>1. Redis排行榜系统：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;log&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/go-redis/redis&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    client := redis.NewClient(&amp;redis.Options&#123;<br>        Addr:     <span class="hljs-string">&quot;localhost:6379&quot;</span>,<br>        Password: <span class="hljs-string">&quot;&quot;</span>,<br>        DB:       <span class="hljs-number">0</span>,<br>    &#125;)<br><br>    <span class="hljs-comment">// 添加分数</span><br>   <br><br> client.ZAdd(<span class="hljs-string">&quot;leaderboard&quot;</span>, redis.Z&#123;<br>        Score:  <span class="hljs-number">100</span>,<br>        Member: <span class="hljs-string">&quot;user123&quot;</span>,<br>    &#125;)<br><br>    <span class="hljs-comment">// 获取排行榜</span><br>    result, err := client.ZRevRangeWithScores(<span class="hljs-string">&quot;leaderboard&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>).Result()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> result &#123;<br>        log.Printf(<span class="hljs-string">&quot;User: %v, Score: %v\n&quot;</span>, item.Member, item.Score)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. Redis持久化：</strong></p><p>答案: Redis支持RDB和AOF两种持久化机制。</p><ul><li>RDB：在指定的时间间隔内生成数据集的时间点快照。</li><li>AOF：记录服务器接收到的每个写操作，重启时通过重新执行这些命令来还原数据集。</li></ul><p>代码示例: 通常在Redis配置文件中设置，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs conf">appendonly yes<br>appendfsync everysec<br></code></pre></td></tr></table></figure><h4 id="MongoDB-1"><a href="#MongoDB-1" class="headerlink" title="MongoDB"></a>MongoDB</h4><p><strong>1. MongoDB查询优化：</strong></p><p>答案: 优化MongoDB的查询性能主要通过创建合适的索引来实现，此外还可以通过<code>explain</code>计划来分析查询。</p><p>代码示例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 假设已有collection *mongo.Collection连接</span><br><br><span class="hljs-comment">// 创建索引</span><br>indexModel := mongo.IndexModel&#123;<br>    Keys: bson.M&#123;<br>        <span class="hljs-string">&quot;fieldname&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 正序索引</span><br>    &#125;,<br>&#125;<br>_, err := collection.Indexes().CreateOne(context.Background(), indexModel)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br><br><span class="hljs-comment">// 查询并解释</span><br>result := collection.FindOne(context.Background(), bson.M&#123;<span class="hljs-string">&quot;fieldname&quot;</span>: <span class="hljs-string">&quot;value&quot;</span>&#125;).Explain()<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p><strong>2. MongoDB聚合操作：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 假设已有collection *mongo.Collection连接</span><br><br>pipeline := mongo.Pipeline&#123;<br>    bson.D&#123;&#123;<span class="hljs-string">&quot;$match&quot;</span>, bson.D&#123;&#123;<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>&#125;&#125;&#125;&#125;,<br>    bson.D&#123;&#123;<span class="hljs-string">&quot;$group&quot;</span>, bson.D&#123;&#123;<span class="hljs-string">&quot;_id&quot;</span>, <span class="hljs-string">&quot;$cust_id&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;total&quot;</span>, bson.D&#123;&#123;<span class="hljs-string">&quot;$sum&quot;</span>, <span class="hljs-string">&quot;$amount&quot;</span>&#125;&#125;&#125;&#125;&#125;&#125;,<br>&#125;<br><br>cur, err := collection.Aggregate(context.Background(), pipeline)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">defer</span> cur.Close(context.Background())<br><br><span class="hljs-keyword">for</span> cur.Next(context.Background()) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>请注意，这些答案需要根据实际应用场景和具体需求进行调整，以满足不同的业务逻辑。同时，实际代码实现需要与使用的Golang数据库驱动和库一致。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>招聘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>db</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装升级框架.md</title>
    <link href="/2023/11/22/mdstorage/domain/%E6%9E%B6%E6%9E%84/%E5%AE%89%E8%A3%85%E5%8D%87%E7%BA%A7%E6%A1%86%E6%9E%B6/"/>
    <url>/2023/11/22/mdstorage/domain/%E6%9E%B6%E6%9E%84/%E5%AE%89%E8%A3%85%E5%8D%87%E7%BA%A7%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="安装升级框架实施方案"><a href="#安装升级框架实施方案" class="headerlink" title="安装升级框架实施方案"></a>安装升级框架实施方案</h3><h4 id="中长期做安装升级框架，需要："><a href="#中长期做安装升级框架，需要：" class="headerlink" title="中长期做安装升级框架，需要："></a>中长期做安装升级框架，需要：</h4><p>指定一个主要负责人持续推进，横跨多个版本维度才能基本确定框架。</p><p>每个组件都在这个框架的范畴，需要贴合此框架的思路来做。所有的文档会在中长期持续补充。</p><h4 id="短期内做安装升级框架，需要："><a href="#短期内做安装升级框架，需要：" class="headerlink" title="短期内做安装升级框架，需要："></a>短期内做安装升级框架，需要：</h4><ol><li><strong>制定统一标准</strong>：团队可以协作制定一套统一的编码和设计标准。这些标准应该包括命名规范、代码结构、安装和升级流程等。</li><li><strong>设计审查会议</strong>：定期举行设计审查会议，讨论和审查当前的设计和实现，确保所有组件都遵循既定的标准和最佳实践。</li><li><strong>文档化</strong>：将规范和流程详细文档化，并确保所有团队成员都可以轻松访问和理解这些文档。</li><li><strong>使用模板和脚手架</strong>：为常见的任务和组件创建模板和脚手架，以减少重复工作和确保一致性。</li><li><strong>持续集成和自动化测试</strong>：利用持续集成工具和自动化测试来确保新代码的一致性和质量。</li><li><strong>代码审查</strong>：通过代码审查来确保代码遵循既定的标准和实践。</li><li><strong>培训和指导</strong>：对团队成员进行定期培训，确保他们了解和掌握项目规范和最佳实践。</li></ol>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
      <tag>安装</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么技术和管理总会有不可调和的矛盾.md</title>
    <link href="/2023/11/22/mdstorage/project/%E5%86%99%E4%BD%9C/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%80%E6%9C%AF%E5%92%8C%E7%AE%A1%E7%90%86%E6%80%BB%E4%BC%9A%E6%9C%89%E4%B8%8D%E5%8F%AF%E8%B0%83%E5%92%8C%E7%9A%84%E7%9F%9B%E7%9B%BE/"/>
    <url>/2023/11/22/mdstorage/project/%E5%86%99%E4%BD%9C/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%80%E6%9C%AF%E5%92%8C%E7%AE%A1%E7%90%86%E6%80%BB%E4%BC%9A%E6%9C%89%E4%B8%8D%E5%8F%AF%E8%B0%83%E5%92%8C%E7%9A%84%E7%9F%9B%E7%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>今日话题：为什么技术和管理总会有不可调和的矛盾？</p><p>评论一：讲真，技术和管理之间的矛盾，这可是职场里的古老话题了。技术大牛们通常都是专注于代码和产品，梦想着创造下一个炫酷的科技革命。他们的世界里，代码就是诗，算法就是音乐。然而，当管理层出场的时候，事情就变味了。管理者们更关注的是预算、时间表和市场表现，他们的乐谱上写的是利润和成本。于是乎，一场关于理想与现实的拉锯战就此上演。</p><p>评论二：技术人呐，天生就对“别人告诉我该做什么”有种天然的抗拒。他们热爱自由，追求创新。但管理者们往往要在更大的框架下考虑问题，这就需要规则和秩序。所以，当管理者们试图把技术牛人们的创意“装进盒子里”的时候，冲突就不可避免了。技术人看到的是一幅未完成的艺术品，而管理者看到的是一张还没画完就超出预算的画。</p><p>最后，我想说的是，技术和管理之间的矛盾其实也是一种平衡的体现。创新需要自由，但实现创新又需要资源和规划。这两者之间的矛盾，如果处理得当，反而能激发出更多的创造力和效率。所以，关键是找到一个能让双方都能接受的平衡点，让技术的创新精神和管理的有序性相辅相成，共同推动公司的发展。毕竟，在这个瞬息万变的时代，既有梦想的翅膀，又有脚踏实地的力量，才能飞得更远。</p>]]></content>
    
    
    
    <tags>
      
      <tag>话题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为云鲲鹏机器系统信息记录.md</title>
    <link href="/2023/11/22/mdstorage/project/sr/%E5%8D%8E%E4%B8%BA%E4%BA%91%E9%B2%B2%E9%B9%8F%E6%9C%BA%E5%99%A8%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/11/22/mdstorage/project/sr/%E5%8D%8E%E4%B8%BA%E4%BA%91%E9%B2%B2%E9%B9%8F%E6%9C%BA%E5%99%A8%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>石犀总控系统在一台云主机上没装上，进行问题排查和分析。</p><h4 id="主机信息"><a href="#主机信息" class="headerlink" title="主机信息"></a>主机信息</h4><p>CPU: Huawei Kunpeng…</p><p>实例类型： A加速型kai1s</p><p>当前规格：A加速型| kai1s.xlarge.1| 4vCPUs | 4GiB 1 HUAWEI Ascend 310</p><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/image-20231122143834854.png" alt="image-20231122143834854"></p><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/image-20231122143932651.png" alt="image-20231122143932651"></p><h4 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">Architecture:        aarch64<br>Byte Order:          Little Endian<br>CPU(s):              16<br>On-line CPU(s) list: 0-15<br>Thread(s) per core:  1<br>Core(s) per socket:  8<br>Socket(s):           2<br>NUMA node(s):        2<br>Vendor ID:           0x48<br>Model:               0<br>Stepping:            0x1<br>BogoMIPS:            200.00<br>L1d cache:           64K<br>L1i cache:           64K<br>L2 cache:            512K<br>L3 cache:            32768K<br>NUMA node0 CPU(s):   0-7<br>NUMA node1 CPU(s):   8-15<br>Flags:               fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp cpuid asimdrdm jscvt fcma dcpop asimddp<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># dmidecode 3.1</span><br>Getting SMBIOS data from sysfs.<br>SMBIOS 3.0.0 present.<br>Table at 0x23F770000.<br><br>Handle 0x0100, DMI <span class="hljs-built_in">type</span> 1, 27 bytes<br>System Information<br>        Manufacturer: OpenStack Foundation<br>        Product Name: OpenStack Nova<br>        Version: 13.2.1-20230609115315_4e0c600<br>        Serial Number: cc7cdba8-401e-428d-837d-41e3336e2e19<br>        UUID: CC7CDBA8-401E-428D-837D-41E3336E2E19<br>        Wake-up Type: Power Switch<br>        SKU Number: Not Specified<br>        Family: Virtual Machine<br><br>Handle 0x0300, DMI <span class="hljs-built_in">type</span> 3, 22 bytes<br>Chassis Information<br>        Manufacturer: Not Specified<br>        Type: Other<br>        Lock: Not Present<br>        Version: 1.0<br>        Serial Number: Not Specified<br>        Asset Tag: HUAWEICLOUD<br>        Boot-up State: Safe<br>        Power Supply State: Safe<br>        Thermal State: Safe<br>        Security Status: Unknown<br>        OEM Information: 0x00000000<br>        Height: Unspecified<br>        Number Of Power Cords: Unspecified<br>        Contained Elements: 0<br>        SKU Number: Not Specified<br><br>Handle 0x0400, DMI <span class="hljs-built_in">type</span> 4, 48 bytes<br>Processor Information<br>        Socket Designation: CPU 0<br>        Type: Central Processor<br>        Family: Other<br>        Manufacturer: QEMU<br>        ID: 00 00 00 00 00 00 00 00<br>        Version: 1.0<br>        Voltage: Unknown<br>        External Clock: Unknown<br>        Max Speed: 2000 MHz<br>        Current Speed: 2000 MHz<br>        Status: Populated, Enabled<br>        Upgrade: Other<br>        L1 Cache Handle: Not Provided<br>        L2 Cache Handle: Not Provided<br>        L3 Cache Handle: Not Provided<br>        Serial Number: Not Specified<br>        Asset Tag: Not Specified<br>        Part Number: Not Specified<br>        Core Count: 8<br>        Core Enabled: 8<br>        Thread Count: 1<br>        Characteristics: None<br><br>Handle 0x0401, DMI <span class="hljs-built_in">type</span> 4, 48 bytes<br>Processor Information<br>        Socket Designation: CPU 1<br>        Type: Central Processor<br>        Family: Other<br>        Manufacturer: QEMU<br>        ID: 00 00 00 00 00 00 00 00<br>        Version: 1.0<br>        Voltage: Unknown<br>        External Clock: Unknown<br>        Max Speed: 2000 MHz<br>        Current Speed: 2000 MHz<br>        Status: Populated, Enabled<br>        Upgrade: Other<br>        L1 Cache Handle: Not Provided<br>        L2 Cache Handle: Not Provided<br>        L3 Cache Handle: Not Provided<br>        Serial Number: Not Specified<br>        Asset Tag: Not Specified<br>        Part Number: Not Specified<br>        Core Count: 8<br>        Core Enabled: 8<br>        Thread Count: 1<br>        Characteristics: None<br><br>Handle 0x1000, DMI <span class="hljs-built_in">type</span> 16, 23 bytes<br>Physical Memory Array<br>        Location: Other<br>        Use: System Memory<br>        Error Correction Type: Multi-bit ECC<br>        Maximum Capacity: 16 GB<br>        Error Information Handle: Not Provided<br>        Number Of Devices: 1<br><br>Handle 0x1100, DMI <span class="hljs-built_in">type</span> 17, 40 bytes<br>Memory Device<br>        Array Handle: 0x1000<br>        Error Information Handle: Not Provided<br>        Total Width: Unknown<br>        Data Width: Unknown<br>        Size: 16384 MB<br>        Form Factor: DIMM<br>        Set: None<br>        Locator: DIMM 0<br>        Bank Locator: Not Specified<br>        Type: RAM<br>        Type Detail: Other<br>        Speed: Unknown<br>        Manufacturer: QEMU<br>        Serial Number: Not Specified<br>        Asset Tag: Not Specified<br>        Part Number: Not Specified<br>        Rank: Unknown<br>        Configured Clock Speed: Unknown<br>        Minimum Voltage: Unknown<br>        Maximum Voltage: Unknown<br>        Configured Voltage: Unknown<br><br>Handle 0x2000, DMI <span class="hljs-built_in">type</span> 32, 11 bytes<br>System Boot Information<br>        Status: No errors detected<br><br>Handle 0x0000, DMI <span class="hljs-built_in">type</span> 0, 26 bytes<br>BIOS Information<br>        Vendor: EFI Development Kit II / OVMF<br>        Version: 0.0.0<br>        Release Date: 02/06/2015<br>        Address: 0xE8000<br>        Runtime Size: 96 kB<br>        ROM Size: 64 kB<br>        Characteristics:<br>                BIOS characteristics not supported<br>                Targeted content distribution is supported<br>                UEFI is supported<br>                System is a virtual machine<br>        BIOS Revision: 0.0<br><br>Handle 0xFEFF, DMI <span class="hljs-built_in">type</span> 127, 4 bytes<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">processor        : 15<br>BogoMIPS        : 200.00<br>Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp cpuid asimdrdm jscvt fcma dcpop asimddp<br>CPU implementer        : 0x48<br>CPU architecture: 8<br>CPU variant        : 0x1<br>CPU part        : 0xd01<br>CPU revision        : 0<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@ecs-9dfc:~# lsblk<br>NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT<br>vda    252:0    0  100G  0 disk<br>├─vda1 252:1    0  512M  0 part /boot/efi<br>└─vda2 252:2    0 99.5G  0 part /<br>root@ecs-9dfc:~# lspci<br>00:00.0 Host bridge: Red Hat, Inc. QEMU PCIe Host bridge<br>00:01.0 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:01.1 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:01.2 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:01.3 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:01.4 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:01.5 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:01.6 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:01.7 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:02.0 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:02.1 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:02.2 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:02.3 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:02.4 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:02.5 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:02.6 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:02.7 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:03.0 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:03.1 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:03.2 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:03.3 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:03.4 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:03.5 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:03.6 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:03.7 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:04.0 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:04.1 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:04.2 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:04.3 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>00:04.4 PCI bridge: Red Hat, Inc. QEMU PCIe Root port<br>01:00.0 PCI bridge: Red Hat, Inc. Device 000e<br>02:01.0 USB controller: Intel Corporation 82801DB/DBM (ICH4/ICH4-M) USB2 EHCI Controller (rev 10)<br>02:02.0 Unclassified device [00ff]: Red Hat, Inc. Virtio memory balloon<br>02:03.0 Display controller: Red Hat, Inc. Virtio GPU (rev 01)<br>03:00.0 Ethernet controller: Red Hat, Inc. Virtio network device (rev 01)<br>04:00.0 SCSI storage controller: Red Hat, Inc. Virtio block device (rev 01)<br>05:00.0 Processing accelerators: Huawei Technologies Co., Ltd. Device d100 (rev 20)<br>06:00.0 Processing accelerators: Huawei Technologies Co., Ltd. Device d100 (rev 20)<br>07:00.0 Processing accelerators: Huawei Technologies Co., Ltd. Device d100 (rev 20)<br>08:00.0 Processing accelerators: Huawei Technologies Co., Ltd. Device d100 (rev 20)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@ecs-9dfc:~# fdisk -l<br>Disk /dev/vda: 100 GiB, 107374182400 bytes, 209715200 sectors<br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br>Disklabel <span class="hljs-built_in">type</span>: gpt<br>Disk identifier: 1AAC48CB-BE7A-495D-8BC2-EAECBD2B9071<br><br>Device       Start       End   Sectors  Size Type<br>/dev/vda1     2048   1050623   1048576  512M EFI System<br>/dev/vda2  1050624 209715166 208664543 99.5G Linux filesystem<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>machine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总控机器初始网络配置文档</title>
    <link href="/2023/11/21/mdstorage/project/sr/%E6%80%BB%E6%8E%A7%E6%9C%BA%E5%99%A8%E5%88%9D%E5%A7%8B%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/"/>
    <url>/2023/11/21/mdstorage/project/sr/%E6%80%BB%E6%8E%A7%E6%9C%BA%E5%99%A8%E5%88%9D%E5%A7%8B%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu-20-04-Server-初始网络配置文档"><a href="#Ubuntu-20-04-Server-初始网络配置文档" class="headerlink" title="Ubuntu 20.04 Server 初始网络配置文档"></a>Ubuntu 20.04 Server 初始网络配置文档</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4">网络配置步骤</a></li><li><a href="#%E9%99%84%E5%BD%95">附录</a></li></ol><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文档提供总控(Ubuntu 20.04 Server版)的基本网络配置指南。它将指导您完成设置静态IP地址、配置DNS服务器和测试网络连接等步骤。</p><h2 id="网络配置步骤"><a href="#网络配置步骤" class="headerlink" title="网络配置步骤"></a>网络配置步骤</h2><h3 id="1-动态-静态IP设置"><a href="#1-动态-静态IP设置" class="headerlink" title="1. 动态&#x2F;静态IP设置"></a>1. <strong>动态&#x2F;静态IP设置</strong></h3><h4 id="静态IP配置-总控必须确认是-ipv4-静态-IP"><a href="#静态IP配置-总控必须确认是-ipv4-静态-IP" class="headerlink" title="静态IP配置(总控必须确认是 ipv4 静态 IP)"></a>静态IP配置(总控必须确认是 ipv4 静态 IP)</h4><ul><li><p>打开Netplan配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> nano /etc/netplan/01-xxx.yaml<br></code></pre></td></tr></table></figure></li><li><p>在文件中设置静态IP地址、网关和DNS</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">network:</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">renderer:</span> <span class="hljs-string">networkd</span><br>  <span class="hljs-attr">ethernets:</span><br>    <span class="hljs-attr">eth0:</span><br>      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">no</span><br>      <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.100</span><span class="hljs-string">/24</span>]<br>      <span class="hljs-attr">gateway4:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><br>      <span class="hljs-attr">nameservers:</span><br>        <span class="hljs-attr">addresses:</span> [<span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>, <span class="hljs-number">4.4</span><span class="hljs-number">.4</span><span class="hljs-number">.4</span>]<br></code></pre></td></tr></table></figure></li><li><p>应用配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> netplan apply<br></code></pre></td></tr></table></figure></li></ul><h4 id="静态IP配置"><a href="#静态IP配置" class="headerlink" title="静态IP配置"></a>静态IP配置</h4><ul><li><p>禁用DHCP</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure></li><li><p>应用配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> netplan apply<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-网卡状态检查"><a href="#2-网卡状态检查" class="headerlink" title="2. 网卡状态检查"></a>2. <strong>网卡状态检查</strong></h3><ul><li><p>查看所有网络接口的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip addr show<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-防火墙配置"><a href="#3-防火墙配置" class="headerlink" title="3. 防火墙配置"></a>3. <strong>防火墙配置</strong></h3><h4 id="基本防火墙规则设置"><a href="#基本防火墙规则设置" class="headerlink" title="基本防火墙规则设置"></a>基本防火墙规则设置</h4><ul><li><p>查看当前规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> ufw status verbose<br></code></pre></td></tr></table></figure></li><li><p>禁用防火墙：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> ufw <span class="hljs-built_in">disable</span><br></code></pre></td></tr></table></figure></li><li><p>允许特定端口（例如，SSH）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> ufw allow 22/tcp<br></code></pre></td></tr></table></figure></li></ul><h3 id="路由配置（可选）"><a href="#路由配置（可选）" class="headerlink" title="路由配置（可选）"></a><strong>路由配置（可选）</strong></h3><ul><li><p>在Netplan配置文件中添加自定义路由（如果需要）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">routes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">to:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">/0</span><br>    <span class="hljs-attr">via:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><br>    <span class="hljs-attr">metric:</span> <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure></li><li><p>应用配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> netplan apply<br></code></pre></td></tr></table></figure></li></ul><h2 id="总控应用监听地址配置"><a href="#总控应用监听地址配置" class="headerlink" title="总控应用监听地址配置"></a>总控应用监听地址配置</h2><h3 id="sc"><a href="#sc" class="headerlink" title="sc"></a>sc</h3><p>目前总控安装前修改 IP 为正常流程，直接通过网络配置即可。而总控运行时修改 IP 目前并不支持，主要难点在于修改 IP 后，引擎不知道总控 IP 变更，数据推不到总控，sv 会拿不到数据。目前如果直接修改 IP 后，总控组件将运行正常，但 sv 的数据会不准，因为接收不到数据了。</p><p>在 2.2.1 版本会修改通信方向对这部分进行重构并重新形成方案来解决这个问题。  </p><h3 id="5-测试总控网络连接"><a href="#5-测试总控网络连接" class="headerlink" title="5. 测试总控网络连接"></a>5. <strong>测试总控网络连接</strong></h3><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>在修改网络配置之前，请确保您了解当前的网络环境和需求。</li><li>在远程修改网络配置时要特别小心，以免丢失连接。</li><li>在配置防火墙时，确保不要阻止关键服务的端口，如SSH（22端口）。</li><li>备份所有重要的配置文件，以便在出现问题时可以恢复。</li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="需要了解的命令行工具"><a href="#需要了解的命令行工具" class="headerlink" title="需要了解的命令行工具"></a>需要了解的命令行工具</h3><ul><li><code>ip</code>：用于显示和操纵路由、网络设备、接口和隧道的工具。</li><li><code>nano/vi/vim</code>：简单易用的文本编辑器。</li><li><code>netplan</code>：用于配置网络的工具，特别是在Ubuntu中。</li><li><code>ping</code>：测试网络连接的工具。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>network-configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一周看板-11.19.md</title>
    <link href="/2023/11/20/mdstorage/project/sr/%E4%B8%80%E5%91%A8%E7%9C%8B%E6%9D%BF/%E4%B8%80%E5%91%A8%E7%9C%8B%E6%9D%BF-11.19/"/>
    <url>/2023/11/20/mdstorage/project/sr/%E4%B8%80%E5%91%A8%E7%9C%8B%E6%9D%BF/%E4%B8%80%E5%91%A8%E7%9C%8B%E6%9D%BF-11.19/</url>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kanban"># 2023/11/13 Task List<br><br>## Todo<br>- https://github.com/mli/autocut 是什么<br>- on-premise 综述<br>- InfoQ 一周消息速递<br>- 搜书方法、主流格式文档转换方法、以图搜图、学习资料搜索<br><br>- meituan 对接、价格<br>- 关于授权时间一致性问题，与松达讨论，给出方案(授权涉及的时间后端接口返回应该做到：商城给到什么就返回什么时间格式)<br><br>- 周会 （1. 转测流程 2. 任务进度 3. 说说问题）<br><br>## In-Progress<br>- 总控软件设计说明书(重要不紧急)<br>- 修改IP构想文档、问题解决、文档组织(重要)<br><br>- 分支管理文档<br><br>- SC后端启动原理，启动协程，常驻协程，与文件系统的交互通道，网络通道，进程通信通道，系统权限使用情况，系统资源占用情况，可能的依赖关系。 中长期规划<br>- markdown 文档模板--操作手册<br>- 网络配置蓝图<br><br><br><br>## Completed<br>- AI生成内容的态度及如何让AI生成高质量内容<br>- typora crack <br>- mongoDB 时间偏移问题(先调研、布置任务修改配置文件，测试)<br>- openai 开发者大会(重要)<br>- 网卡工作原理<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么当代人幸福感越来越低.md</title>
    <link href="/2023/11/17/mdstorage/project/%E5%86%99%E4%BD%9C/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BD%93%E4%BB%A3%E4%BA%BA%E5%B9%B8%E7%A6%8F%E6%84%9F%E8%B6%8A%E6%9D%A5%E8%B6%8A%E4%BD%8E/"/>
    <url>/2023/11/17/mdstorage/project/%E5%86%99%E4%BD%9C/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BD%93%E4%BB%A3%E4%BA%BA%E5%B9%B8%E7%A6%8F%E6%84%9F%E8%B6%8A%E6%9D%A5%E8%B6%8A%E4%BD%8E/</url>
    
    <content type="html"><![CDATA[<p>今日话题：为什么当代人幸福感越来越低？</p><p>评论一：看看现在这社会，变化快得像变脸似的，让人应接不暇。你今天掌握了个新技能，明天可能就过时了。就像那些曾经火爆一时的小玩意儿，一下子就被淘汰了，连带着带动了一波员工下岗潮。在这种不停变化的社会里，每个人都像是在冰面上跳舞，一不小心就得滑倒。于是乎，焦虑就成了大家的日常，大家都在担心哪天自己会成为下一个被社会淘汰的对象。</p><p>评论二：然后呢，资本消费主义的大旗一挥，我们每个人都被卷入了一场看不见边际的消费战。从早到晚，我们被各种广告包围，告诉我们买这个会更快乐，买那个会更成功。于是，我们开始了无休止的购物大军，想通过买买买来找到幸福感。但等我们买完了，瞧瞧自己的银行账户，幸福感似乎并没有那么直观。</p><p>最后，还有阶级固化的问题。说直白点，就是钱赚得太难了。你赚得还算可以，可能不觉得有啥，但对于那些每天还得为三餐操心的人来说，幸福感更多的时候是奢侈品。现代社会，不管你多努力，有时候感觉都像是在原地踏步。这种无力感，自然就压低了幸福感。</p><p>最后，我想说的是，幸福感不仅仅是物质满足，更多的是来自于内心的平静和满足。在这个快节奏、高压力的社会里，找到属于自己的小确幸，学会欣赏生活中的小美好，也许就是提升幸福感的关键。毕竟，生活不只有眼前的苟且，还有诗和远方的云彩。</p>]]></content>
    
    
    
    <tags>
      
      <tag>talk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么很多男生宁可打游戏也不愿意追女生呢.md</title>
    <link href="/2023/11/17/mdstorage/project/%E5%86%99%E4%BD%9C/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E7%94%B7%E7%94%9F%E5%AE%81%E5%8F%AF%E6%89%93%E6%B8%B8%E6%88%8F%E4%B9%9F%E4%B8%8D%E6%84%BF%E8%BF%BD%E5%A5%B3%E7%94%9F/"/>
    <url>/2023/11/17/mdstorage/project/%E5%86%99%E4%BD%9C/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E7%94%B7%E7%94%9F%E5%AE%81%E5%8F%AF%E6%89%93%E6%B8%B8%E6%88%8F%E4%B9%9F%E4%B8%8D%E6%84%BF%E8%BF%BD%E5%A5%B3%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<p>今日话题：为什么很多男生宁可打游戏也不愿意追女生呢？</p><p>评论一：这个话题可真是热门，现在的男生啊，宁愿和虚拟世界里的角色谈恋爱，也不愿意去追现实中的女生。原因嘛，可能跟这个观点有关：追女生就像是在做一场投资，但这种投资的风险和回报很难预测。一些男生可能会想，我和她又不熟，凭什么要我无条件地付出？这种心态，就像是说，“在你成为我的女朋友之前，我愿意付出一点点，成了我女朋友之后，我自然会全力以赴。”</p><p>评论二：再说了，现在的男生不像以前那么单纯了，他们更懂得权衡和选择。打游戏，至少知道怎么玩能升级，怎么战斗能赢；而追女生呢，这规则可没那么明确，失败的概率还挺高。所以，不少男生可能就选择了更“安全”的打游戏。至于那些喊着“你得不停地跪舔才算真正努力”的声音，他们可能会觉得这有点太过了。</p><p>最后，我想说的是，每个人对爱情的态度和方式都不一样。追求爱情是人之常情，但也不能一味地强求。毕竟，在这个多元化的社会里，不是每个人都愿意或者能够马上投入到一段感情中去。有些人可能需要更多的时间去了解对方，有些人则可能更喜欢享受单身的自由。所以，不要太过于一概而论，让我们尊重每个人的选择和节奏。毕竟，幸福的形式有很多种，不一定非得是两个人手牵手走在一起。</p>]]></content>
    
    
    
    <tags>
      
      <tag>talk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么现在越来越多的人选择做直播.md</title>
    <link href="/2023/11/17/mdstorage/project/%E5%86%99%E4%BD%9C/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%A4%9A%E4%BA%BA%E9%80%89%E6%8B%A9%E7%9B%B4%E6%92%AD/"/>
    <url>/2023/11/17/mdstorage/project/%E5%86%99%E4%BD%9C/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%A4%9A%E4%BA%BA%E9%80%89%E6%8B%A9%E7%9B%B4%E6%92%AD/</url>
    
    <content type="html"><![CDATA[<p>今日话题：为什么现在越来越多的人选择做直播？</p><p>评论一：说起来做直播，这可真是个热门行业了。很多人看中的，首先就是那个低门槛和来钱快。你想啊，只要有部手机，一个小小的直播间，人人都能成为主播。不像其他行业，需要各种资质、技能或者资本。而且，如果运气好，一夜之间爆红，就能实现从草根到网红的华丽转变，这种魅力谁能抵挡？</p><p>评论二：不过，话说回来，真正通过直播挣大钱的人其实并不多。大部分所谓的“直播挣钱”，其实是来自于那些教人直播的人、卖课程的人，还有卖直播设备的人。他们四处宣传直播能挣钱，但其实很多时候，他们自己才是真正的赢家。就像是热潮中的淘金热，真正发财的，往往是卖铁锹的人。</p><p>最后，我想说的是，选择做直播当然是个人的自由，但在追求这个梦想的时候，也要保持清醒的头脑。不要被那些看似光鲜的表象迷惑，更不要轻信那些不切实际的“暴富课程”。真正的成功，是建立在坚持和实力上的，而不是一蹴而就的。在这个看似繁荣的直播浪潮中，保持一份冷静和理智，才是最重要的。毕竟，不是每个人都能成为直播界的流量王，但每个人都能在自己的领域里发光发热。</p>]]></content>
    
    
    
    <tags>
      
      <tag>talk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>做今日话题的思路.md</title>
    <link href="/2023/11/17/mdstorage/project/%E5%86%99%E4%BD%9C/%E4%BB%8A%E6%97%A5%E8%AF%9D%E9%A2%98%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    <url>/2023/11/17/mdstorage/project/%E5%86%99%E4%BD%9C/%E4%BB%8A%E6%97%A5%E8%AF%9D%E9%A2%98%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<p>做今日话题的思路</p><ol><li>不过多考虑话题本身的对错，考虑观众的接受度。</li></ol><p>对图不满意：</p><ol><li>换图（剪映、本地、网图）</li></ol><p>今日话题编写技巧</p><ol><li>今日话题： $标题</li><li>今日话题： $标题  \n 贴上知乎新论点，参考xxx，生成今日话题内容</li></ol><p>观众想看到的话题内容有哪些种类？</p><ul><li><p>认同感</p></li><li><p>角度新颖、同时让观众有些顿悟感</p></li><li><p>门槛低、来钱快</p></li><li><p>直播可能真正挣钱的人少，但是实际上教人直播挣钱的多，卖课卖器材的多，大部分说直播挣钱的都是那些人宣传的，实际上有些可能还会割韭菜</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>talk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>江边的晚上.md</title>
    <link href="/2023/11/17/mdstorage/project/%E5%86%99%E4%BD%9C/%E6%B1%9F%E8%BE%B9%E7%9A%84%E6%99%9A%E4%B8%8A/"/>
    <url>/2023/11/17/mdstorage/project/%E5%86%99%E4%BD%9C/%E6%B1%9F%E8%BE%B9%E7%9A%84%E6%99%9A%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<p>故事一：</p><p>去年的今天，在火车上，我接到疯子的电话，说，</p><p>“我已经在武汉车站等你了，你赶紧过来。”</p><p>“啊？可是我要回鄂州，难不成要提前下车？”</p><p>”别废话，赶紧过来。“</p><p>我嘴里骂骂咧咧，在武汉火车站下车，结果没在出站口看到他，打电话给他，他说他在武汉车站，不是火车站。我拖着大皮箱，一路打车一路骂，等到了武汉车站，一眼就看到了他。</p><p>”皮衣，皮裤，墨镜，带个帽子，不愧是你。要是人品跟你模样一半好就好了。“</p><p>故事二：</p><p>大二的时候，疯子打电话给我，</p><p>”去云南不？“</p><p>”哪儿？“</p><p>”问那么多干嘛，怕把你卖了？赶紧过来。“</p><p>见到穿着机长制服的他把我带到乘机人员位置坐下来后，我强忍着第一次登机的冲动，到了云南丽江。</p><p>…</p><p>故事二中，疯子介绍给我他当地的女朋友，阳光，善良，活泼，可爱。疯子说他很喜欢她，我们一起在丽江玩了很久。中途晚上他们俩去了其他景点玩，没跟我一起，也有打电话给我，让我提前下车的环节，有意无意之间给我找麻烦。故事一中，我们在江边找了旅店住了下来，他在酒吧大肆消费，表现了他洒脱的一面，回头，他告诉我，他没钱了。我们在江边坐了很久，他跟之前的女朋友分了很久了，他管不了那么多，只想要按照自己的想法生活，这是他跟我说的。</p><p>参考上面的文体风格，补充故事一，故事二中的内容。</p><p>去年的今天，在火车上，我接到疯子的电话，他说，“我已经在武汉车站等你了，你赶紧过来。”</p><p>“啊？可是我要回鄂州，难不成要提前下车？”我疑惑地问。</p><p>“别废话，赶紧过来。”他的声音听起来有些急切。</p><p>我嘴里骂骂咧咧，在武汉火车站下车，但在出站口并没有看到他。打电话过去，他说他在武汉车站，不是火车站。拖着大皮箱，我一路打车，一路骂，终于到了武汉车站，一眼就看到了他。</p><p>穿着皮衣，皮裤，戴着墨镜和帽子，疯子的模样一如既往地引人注目。“皮衣，皮裤，墨镜，带个帽子，不愧是你。要是人品跟你模样一半好就好了。”我半开玩笑地说。</p><p>疯子只是笑了笑，那种既狡黠又自信的笑。“我带你去个地方。”他说着，拉起我的手就往外走。</p><p>我们穿过繁忙的街道，来到了一条安静的河边。河水在灯光下波光粼粼，两岸的灯火倒映其中，显得格外迷人。</p><p>“这就是你的惊喜？”我问，心里虽然抱怨，但也不得不承认这里的景色确实美丽。</p><p>“不全是。”他说着，从口袋里掏出一个小盒子，递给我。“这是给你的。”</p><p>我打开盒子，里面是一枚精致的银戒指。简单却不失优雅，我有些愣住了。</p><p>“为什么给我这个？”我迷惑地问。</p><p>“因为，你是我最重要的朋友。”疯子的眼神里闪过一丝认真。“我总是给你添麻烦，但你始终在我身边。”</p><p>我感到一阵温暖和感动。疯子虽然常常令人头疼，但在关键时刻总是能感动人心。</p><p>我们在江边坐下，谈论着过去的种种。疯子讲述他的冒险，我分享我的日常。我们笑了又笑，直到夜深人静。</p><p>这就是我和疯子的友情，虽然有时疯狂，但却充满了真诚和温暖。</p>]]></content>
    
    
    
    <tags>
      
      <tag>write</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主机接入网络配置蓝图.md</title>
    <link href="/2023/11/16/mdstorage/domain/network/%E4%B8%BB%E6%9C%BA%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E8%93%9D%E5%9B%BE/"/>
    <url>/2023/11/16/mdstorage/domain/network/%E4%B8%BB%E6%9C%BA%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E8%93%9D%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>接入的主机并非是集群的一部分；</p><p>有关主机硬件、基础设施不需要这里来考虑搭建；</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在将服务器接入数据中心时，可以将关注点分为两大类：<strong>本机以外需要关注的项</strong> 和 <strong>本机网络配置关注的项</strong>。</p><h3 id="本机以外需要关注的项"><a href="#本机以外需要关注的项" class="headerlink" title="本机以外需要关注的项"></a>本机以外需要关注的项</h3><p>这些是与数据中心的基础设施、环境和外部网络相关的方面。</p><ol><li><p><strong>交换机和路由器</strong>：</p><ul><li>确保数据中心提供的交换机和路由器能满足您的网络需求（带宽、VLAN 支持、路由协议等）。</li></ul></li><li><p><strong>物理连接</strong>：</p><ul><li>使用适当的电缆连接服务器至数据中心的网络设备。验证端口速度和兼容性。</li></ul></li><li><p><strong>网络监控和管理</strong>：</p><ul><li>数据中心可能提供的网络监控工具和服务。</li><li>网络的远程管理和维护服务。</li></ul></li><li><p><strong>安全性和隔离</strong>：</p><ul><li>数据中心级别的安全措施（如防火墙、入侵检测系统）。</li><li>物理安全和访问控制。</li></ul></li><li><p><strong>冗余和灾难恢复</strong>：</p><ul><li>网络连接的冗余设计，例如备用电源和备用网络路径。</li><li>数据中心的备份和恢复策略。</li></ul></li><li><p><strong>合规性和标准</strong>：</p><ul><li>遵守数据中心的操作和安全标准。</li><li>法律合规性考量。</li></ul></li></ol><h3 id="本机网络配置关注的项"><a href="#本机网络配置关注的项" class="headerlink" title="本机网络配置关注的项"></a>本机网络配置关注的项</h3><p>这些项涉及服务器本身的网络设置和配置。</p><ol><li><p><strong>IP 地址配置</strong>：</p><ul><li>静态 IP 地址配置或 DHCP 设置。</li><li>子网掩码、默认网关和 DNS 服务器设置。</li></ul></li><li><p><strong>网络接口配置</strong>：</p><ul><li>网络接口卡（NIC）的配置，包括速率、双工模式等。</li><li>配置多个 NIC 以实现负载均衡或冗余。</li></ul></li><li><p><strong>安全配置</strong>：</p><ul><li>服务器防火墙规则的设置，以限制或允许特定的流量。</li><li>网络服务的安全配置，如 SSH、Web 服务器等。</li></ul></li><li><p><strong>性能优化</strong>：</p><ul><li>网络带宽的管理和优化。</li><li>针对特定应用的网络参数调整。</li></ul></li><li><p><strong>本地网络监控</strong>：</p><ul><li>安装和配置本地网络监控工具，如 Nagios、Zabbix 等，以监控网络性能和连接状态。</li></ul></li><li><p><strong>配置管理</strong>：</p><ul><li>使用配置管理工具确保网络配置的一致性和自动化。</li></ul></li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在接入数据中心时，这两类关注点都至关重要。本机网络配置关注的项着重于服务器自身的设置和操作，而本机以外需要关注的项则涉及到服务器与数据中心基础设施和服务的交互。正确处理这两方面的事项将确保服务器的顺畅运行和高效性能。</p><h2 id="本机网络配置"><a href="#本机网络配置" class="headerlink" title="本机网络配置"></a>本机网络配置</h2><h3 id="网络协议栈的第二层-数据链路层"><a href="#网络协议栈的第二层-数据链路层" class="headerlink" title="网络协议栈的第二层 - 数据链路层"></a>网络协议栈的第二层 - 数据链路层</h3><h4 id="关键组件和配置项"><a href="#关键组件和配置项" class="headerlink" title="关键组件和配置项"></a>关键组件和配置项</h4><ol><li><strong>网络接口卡（NIC）配置</strong>：<ul><li><strong>MAC 地址</strong>：每个 NIC 有一个独一无二的 MAC 地址，用于局域网内的通信。</li><li><strong>速度和双工模式</strong>：配置 NIC 的工作速度（如 1Gbps, 10Gbps 等）和双工模式（全双工或半双工）。</li></ul></li><li><strong>链路聚合（LACP）</strong>：<ul><li>如果服务器有多个 NIC，可以通过链路聚合提高冗余和带宽。</li></ul></li><li><strong>虚拟局域网（VLAN）</strong>：<ul><li><strong>VLAN 标签</strong>：配置 VLAN 标签来区分不同的网络流量。这对于隔离流量、增加安全性和改善网络性能很有用。</li></ul></li><li><strong>MTU（最大传输单元）</strong>：<ul><li>配置每个网络数据包的最大大小。过大或过小的 MTU 设置可能会影响性能。</li></ul></li><li><strong>以太网帧类型</strong>：<ul><li>如需要，配置特定类型的以太网帧（例如，标准帧、VLAN 帧等）。</li></ul></li></ol><h4 id="实施思路"><a href="#实施思路" class="headerlink" title="实施思路"></a>实施思路</h4><ol><li><p><strong>设备识别与文档化</strong>：</p><ul><li>识别并记录服务器的所有网络接口卡（NIC）。</li><li>确定这些 NIC 的 MAC 地址和支持的最大速度。</li></ul></li><li><p><strong>网络设计</strong>：</p><ul><li>根据业务需求设计 VLAN 架构。确定哪些服务器需要隔离在不同的 VLAN 中。</li><li>设计链路聚合策略来增加带宽和提供冗余。</li></ul></li><li><p><strong>配置网络接口</strong>：</p><ul><li>在操作系统中配置 NIC 的速度、双工模式和 MTU 设置。</li><li>为每个 NIC 配置 VLAN 标签（如果使用）。</li></ul></li><li><p><strong>链路聚合配置</strong>：</p><ul><li>如果使用多个 NIC，通过 LACP 或其他链路聚合协议配置聚合链路。</li></ul></li><li><p><strong>性能调优和测试</strong>：</p><ul><li>测试不同 MTU 大小对性能的影响。</li><li>通过网络测试工具（如 iperf）测试链路聚合的性能。</li></ul></li><li><p><strong>监控和维护</strong>：</p><ul><li>定期监控网络性能和链路状态。</li><li>调整配置以适应网络流量的变化和业务需求的发展。</li></ul></li></ol><h3 id="蓝图的制作"><a href="#蓝图的制作" class="headerlink" title="蓝图的制作"></a>蓝图的制作</h3><p>为了制作这样的蓝图，可以使用网络设计软件（如 Visio 或在线工具），展示以下内容：</p><ul><li>每个服务器的 NIC，包括其 MAC 地址、配置的速度和双工模式。</li><li>VLAN 的布局，包括每个 NIC 的 VLAN 标签。</li><li>链路聚合的配置，显示哪些 NIC 是聚合在一起的。</li><li>网络连接的总体布局，显示服务器如何连接到交换机和其他网络设备。</li></ul><p>这样的蓝图有助于清晰地理解和管理数据中心内的网络配置，确保高效和安全的网络通信。</p><pre><code class=" mermaid">graph LR    A[主机A] --&gt;|NIC配置| A_NIC[主机A NIC]    A_NIC --&gt;|VLAN| SW[交换机]    A_NIC --&gt;|链路聚合| SW    SW --&gt;|VLAN| B_NIC[主机B NIC]    SW --&gt;|链路聚合| B_NIC    B_NIC --&gt;|NIC配置| B[主机B]    A_NIC --&gt;|MTU| B_NIC    B_NIC --&gt;|MTU| A_NIC    style A fill:#f9f,stroke:#333,stroke-width:2px    style B fill:#f9f,stroke:#333,stroke-width:2px    style A_NIC fill:#fc0,stroke:#333,stroke-width:2px    style B_NIC fill:#fc0,stroke:#333,stroke-width:2px    style SW fill:#9f6,stroke:#333,stroke-width:2px</code></pre><h4 id="IP-地址配置"><a href="#IP-地址配置" class="headerlink" title="IP 地址配置"></a>IP 地址配置</h4><p>IP 地址配置是确保服务器在网络中能够正确通信的关键部分。它包括为服务器分配一个独特的 IP 地址，以及其他相关的网络设置。这里是详细的分析和实施思路：</p><ol><li><p><strong>选择 IP 地址分配方式</strong>：</p><ul><li><strong>静态 IP 地址</strong>：手动为服务器分配一个固定的 IP 地址。这通常用于确保服务器的地址不会改变，特别是对于提供持续服务的关键服务器（如数据库服务器、Web 服务器）。</li><li><strong>动态主机配置协议（DHCP）</strong>：通过数据中心的 DHCP 服务器自动为服务器分配 IP 地址。这适用于需要灵活管理和较少手动配置的环境。</li></ul></li><li><p><strong>确定 IP 地址和子网</strong>：</p><ul><li><strong>IP 地址</strong>：根据数据中心提供的 IP 地址范围选择一个地址。确保这个地址没有被其他设备使用。</li><li><strong>子网掩码</strong>：确定服务器所在的子网。子网掩码决定了网络中哪部分地址是网络地址，哪部分是主机地址。</li></ul></li><li><p><strong>配置默认网关</strong>：</p><ul><li>默认网关是服务器将数据发送到外部网络（如互联网）时使用的设备的 IP 地址。通常是数据中心路由器的地址。</li></ul></li><li><p><strong>设置 DNS 服务器</strong>：</p><ul><li>DNS 服务器用于解析域名到 IP 地址。可以使用数据中心提供的 DNS 服务器，或选择公共 DNS 服务（如 Google 的 8.8.8.8）。</li></ul></li></ol><h4 id="实施思路："><a href="#实施思路：" class="headerlink" title="实施思路："></a>实施思路：</h4><ol><li><p><strong>信息收集</strong>：</p><ul><li>从数据中心获取可用的 IP 地址范围、子网掩码、默认网关和 DNS 服务器信息。</li></ul></li><li><p><strong>计划 IP 地址分配</strong>：</p><ul><li>根据服务器的角色和需求选择静态 IP 或 DHCP。</li><li>如果选择静态 IP，确保地址不与数据中心中的其他设备冲突。</li></ul></li><li><p><strong>配置服务器网络设置</strong>：</p><ul><li>在服务器的操作系统中进入网络设置。</li><li>输入 IP 地址、子网掩码、默认网关和 DNS 服务器信息。</li><li>对于静态 IP，手动配置这些设置。对于 DHCP，确保服务器的网络接口设置为自动获取。</li></ul></li><li><p><strong>测试配置</strong>：</p><ul><li>使用如 <code>ping</code>、<code>traceroute</code> 等命令测试网络连接。</li><li>确保服务器能够访问内部网络和外部网络（如互联网）。</li></ul></li><li><p><strong>文档化和备份</strong>：</p><ul><li>记录服务器的网络配置信息。</li><li>在更改前备份当前的网络设置，以便在问题发生时快速恢复。</li></ul></li><li><p><strong>监控和维护</strong>：</p><ul><li>定期检查网络连接状态和性能。</li><li>确保 IP 地址分配策略与网络架构和业务需求保持一致。</li></ul></li></ol><p>通过这些步骤，可以确保服务器的 IP 地址配置正确无误，从而保障网络通信的稳定性和效率。</p><h2 id="VLAN-配置"><a href="#VLAN-配置" class="headerlink" title="VLAN 配置"></a>VLAN 配置</h2><p>虚拟局域网（VLAN）配置在多种场景下非常有用，主要是因为它能提供网络分割、增强安全性、提高网络性能和管理的灵活性。以下是一些典型的使用 VLAN 配置的场景：</p><h3 id="1-网络隔离和安全性"><a href="#1-网络隔离和安全性" class="headerlink" title="1. 网络隔离和安全性"></a>1. 网络隔离和安全性</h3><ul><li><strong>隔离敏感数据</strong>：在处理敏感数据（如金融信息、个人数据）的网络中，使用 VLAN 可以将这些数据的流量与其他网络流量隔离开来。</li><li><strong>安全区域划分</strong>：在需要不同安全级别的网络区域（如公共区域、管理区域、测试区域）中，VLAN 可用于创建物理上隔离的网络。</li></ul><h3 id="2-性能优化"><a href="#2-性能优化" class="headerlink" title="2. 性能优化"></a>2. 性能优化</h3><ul><li><strong>流量管理</strong>：通过 VLAN 划分，可以减少广播域的大小，从而减少不必要的网络流量和拥堵。</li><li><strong>优化关键应用性能</strong>：为关键业务或应用创建专用的 VLAN，以确保它们有足够的带宽和较低的延迟。</li></ul><h3 id="3-服务和应用分割"><a href="#3-服务和应用分割" class="headerlink" title="3. 服务和应用分割"></a>3. 服务和应用分割</h3><ul><li><strong>不同服务的逻辑分离</strong>：例如，将语音通信（VoIP）、视频会议和数据通信分配到不同的 VLAN，以优化服务质量和管理。</li><li><strong>多租户环境</strong>：在共享基础设施的环境中（如云服务提供商），使用 VLAN 来为不同的客户或租户划分网络。</li></ul><h3 id="4-成本节约和资源优化"><a href="#4-成本节约和资源优化" class="headerlink" title="4. 成本节约和资源优化"></a>4. 成本节约和资源优化</h3><ul><li><strong>物理网络设施的优化</strong>：通过 VLAN，可以在同一物理网络基础设施上创建多个逻辑网络，从而降低成本和简化网络管理。</li><li><strong>灵活的网络规划</strong>：VLAN 允许更加灵活地重新配置网络，而不需要进行昂贵和复杂的物理改动。</li></ul><h3 id="5-网络管理和简化部署"><a href="#5-网络管理和简化部署" class="headerlink" title="5. 网络管理和简化部署"></a>5. 网络管理和简化部署</h3><ul><li><strong>简化网络管理</strong>：通过 VLAN，可以更方便地管理和监控网络流量。</li><li><strong>部署新服务</strong>：当引入新的服务或应用时，可以通过添加新的 VLAN 来快速部署，而不影响现有网络结构。</li></ul><h3 id="6-合规性和政策执行"><a href="#6-合规性和政策执行" class="headerlink" title="6. 合规性和政策执行"></a>6. 合规性和政策执行</h3><ul><li><strong>遵守法规要求</strong>：某些行业标准或法规可能要求数据隔离，VLAN 提供了一个实现这一点的有效方法。</li><li><strong>政策执行</strong>：在需要对不同用户群或部门实施不同网络策略的场景中，VLAN 能够提供所需的网络分割。</li></ul><p>综上所述，VLAN 的使用在多种场合都非常有益，尤其是在需要安全性、性能优化、灵活的网络管理和成本效益的环境中。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network-configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网卡工作原理.md</title>
    <link href="/2023/11/16/mdstorage/domain/network/%E7%BD%91%E5%8D%A1%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <url>/2023/11/16/mdstorage/domain/network/%E7%BD%91%E5%8D%A1%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="网卡发送-接收数据包工作原理"><a href="#网卡发送-接收数据包工作原理" class="headerlink" title="网卡发送&#x2F;接收数据包工作原理"></a>网卡发送&#x2F;接收数据包工作原理</h2><h3 id="NIC发送-接收数据包的工作原理"><a href="#NIC发送-接收数据包的工作原理" class="headerlink" title="NIC发送&#x2F;接收数据包的工作原理"></a>NIC发送&#x2F;接收数据包的工作原理</h3><p>网络接口卡（NIC）是计算机与网络之间通信的桥梁。其基本工作原理如下：</p><h4 id="发送数据包"><a href="#发送数据包" class="headerlink" title="发送数据包"></a>发送数据包</h4><ol><li><p><strong>数据封装</strong>：当计算机需要发送数据时，操作系统先将数据封装成适合网络传输的格式，通常是以太网帧。这包括目标MAC地址、源MAC地址、数据负载和校验序列。</p></li><li><p><strong>数字信号转换</strong>：数据包（以太网帧）由NIC的硬件转换为数字信号。对于有线网络，这通常意味着将数据转换为电信号；对于无线网络，则转换为无线信号。</p></li><li><p><strong>物理传输</strong>：转换后的信号通过网络（如以太网电缆或无线媒介）发送到目标。</p></li></ol><h4 id="接收数据包"><a href="#接收数据包" class="headerlink" title="接收数据包"></a>接收数据包</h4><ol><li><p><strong>信号检测</strong>：NIC不断监测网络上的信号。当检测到数据传输时，NIC会接收信号。</p></li><li><p><strong>信号转换</strong>：NIC将接收到的物理信号（电信号或无线信号）转换回数字数据。</p></li><li><p><strong>数据解析</strong>：NIC检查数据包的完整性（如校验和）。如果数据包是发给本机的（即目标MAC地址与NIC的MAC地址匹配），NIC则将数据传递给操作系统进行进一步处理。</p></li></ol><h3 id="自动协商机制"><a href="#自动协商机制" class="headerlink" title="自动协商机制"></a>自动协商机制</h3><p>自动协商是网络设备用来自动确定连接速度和双工模式的一种机制。这个过程如下：</p><ol><li><p><strong>能力广播</strong>：当连接建立时，NIC向连接的网络设备（如交换机）发送一个特殊的帧，其中包含了它支持的速度和双工模式的列表。</p></li><li><p><strong>能力接收</strong>：交换机接收到这些信息后，也会发送一个类似的帧，告知自己支持的速度和双工模式。</p></li><li><p><strong>协商决定</strong>：NIC和交换机比较各自的能力列表，选择一个共同支持的最高速度和最佳双工模式。</p></li><li><p><strong>配置应用</strong>：一旦决定了速度和双工模式，NIC和交换机就会自动配置这些设置，并开始正常的数据传输。</p></li></ol><h3 id="可视化描述和实例"><a href="#可视化描述和实例" class="headerlink" title="可视化描述和实例"></a>可视化描述和实例</h3><p>假设有一个计算机（主机A）和一个交换机。主机A的NIC支持10&#x2F;100&#x2F;1000 Mbps 的速度和全双工模式，而交换机支持100&#x2F;1000 Mbps 的速度和全&#x2F;半双工模式。</p><pre><code class=" mermaid">sequenceDiagram    participant NIC    participant Switch    Note over NIC, Switch: 连接建立    NIC-&gt;&gt;Switch: 发送支持的速度和模式（10/100/1000 Mbps, 全双工）    Switch-&gt;&gt;NIC: 发送支持的速度和模式（100/1000 Mbps, 全/半双工）    Note over NIC, Switch: 协商选择1000 Mbps, 全双工    NIC-&gt;&gt;Switch: 配置1000 Mbps, 全双工    Switch-&gt;&gt;NIC: 配置1000 Mbps, 全双工</code></pre><p>在这个例子中，自动协商机制允许NIC和交换机选择它们共同支持的最高速度（1000 Mbps）和最佳双工模式（全双工），从而实现最优的网络性能。</p><p>在NIC发送&#x2F;接收数据包的过程中，多个模块协同工作以确保数据的有效传输。这些模块在各个操作步骤中的具体作用如下：</p><h3 id="1-发送数据包"><a href="#1-发送数据包" class="headerlink" title="1. 发送数据包"></a>1. 发送数据包</h3><h4 id="a-数据缓冲和处理模块"><a href="#a-数据缓冲和处理模块" class="headerlink" title="a. 数据缓冲和处理模块"></a>a. 数据缓冲和处理模块</h4><ul><li><strong>作用</strong>：这个模块负责临时存储待发送的数据，并将其准备成适合网络传输的格式。</li><li><strong>操作</strong>：当操作系统指示NIC发送数据时，数据缓冲和处理模块会接收数据，并根据需要的网络协议（如以太网协议）进行封装。这包括添加必要的头部信息，如目标和源MAC地址、以太网类型字段等。</li></ul><h4 id="b-数字信号处理器（DSP）"><a href="#b-数字信号处理器（DSP）" class="headerlink" title="b. 数字信号处理器（DSP）"></a>b. 数字信号处理器（DSP）</h4><ul><li><strong>作用</strong>：DSP负责将数字数据转换为适合于物理媒介的信号。</li><li><strong>操作</strong>：在数据封装完毕后，DSP将数字数据（以太网帧）转换成电信号（对于有线网络）或无线信号（对于无线网络）。</li></ul><h4 id="c-发送-接收接口"><a href="#c-发送-接收接口" class="headerlink" title="c. 发送&#x2F;接收接口"></a>c. 发送&#x2F;接收接口</h4><ul><li><strong>作用</strong>：这个模块管理着与物理网络媒介的直接接口。</li><li><strong>操作</strong>：处理过的信号通过这个接口发送出去。对于有线网络，这通常涉及电信号的传输；对于无线网络，则涉及无线频率的使用。</li></ul><h3 id="2-接收数据包"><a href="#2-接收数据包" class="headerlink" title="2. 接收数据包"></a>2. 接收数据包</h3><h4 id="a-接收-发送接口"><a href="#a-接收-发送接口" class="headerlink" title="a. 接收&#x2F;发送接口"></a>a. 接收&#x2F;发送接口</h4><ul><li><strong>作用</strong>：同样管理着与物理网络媒介的接口，但这次用于接收信号。</li><li><strong>操作</strong>：当网络上有数据传入时，这个接口会检测到信号并接收它。</li></ul><h4 id="b-数字信号处理器（DSP）-1"><a href="#b-数字信号处理器（DSP）-1" class="headerlink" title="b. 数字信号处理器（DSP）"></a>b. 数字信号处理器（DSP）</h4><ul><li><strong>作用</strong>：DSP在接收数据时负责将物理信号（电信号或无线信号）转换回数字数据。</li><li><strong>操作</strong>：接收到的信号经过DSP处理，转换成数字格式的数据包，以供进一步处理。</li></ul><h4 id="c-数据缓冲和处理模块"><a href="#c-数据缓冲和处理模块" class="headerlink" title="c. 数据缓冲和处理模块"></a>c. 数据缓冲和处理模块</h4><ul><li><strong>作用</strong>：处理接收到的数据包，检查其完整性并准备交给操作系统。</li><li><strong>操作</strong>：这个模块首先检查数据包的完整性（如通过校验和）。如果数据包是发往本机（即目标MAC地址与NIC的MAC地址匹配），则数据包被传递给操作系统进行进一步处理。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在发送数据包的过程中，数据缓冲和处理模块负责数据封装，数字信号处理器负责信号转换，而发送&#x2F;接收接口管理物理信号的传输。在接收数据包的过程中，这些模块执行相反的操作，确保数据包能够被正确接收和处理。NIC的这些模块共同确保了高效和可靠的网络通信。</p><pre><code class=" mermaid">graph TD    subgraph 发送数据包        OS[操作系统]        DBP[数据缓冲和处理模块]        DSP1[数字信号处理器（DSP）]        SRI[发送/接收接口]        NW[网络]        OS --&gt;|数据| DBP        DBP --&gt;|封装成以太网帧| DSP1        DSP1 --&gt;|转换为电/无线信号| SRI        SRI --&gt;|物理传输| NW    end    subgraph 接收数据包        NW2[网络]        SRI2[发送/接收接口]        DSP2[数字信号处理器（DSP）]        DBP2[数据缓冲和处理模块]        OS2[操作系统]        NW2 --&gt;|物理信号| SRI2        SRI2 --&gt;|接收信号| DSP2        DSP2 --&gt;|转换为数字数据| DBP2        DBP2 --&gt;|数据交付| OS2    end    style OS fill:#f9f,stroke:#333,stroke-width:2px    style OS2 fill:#f9f,stroke:#333,stroke-width:2px    style DBP fill:#fc0,stroke:#333,stroke-width:2px    style DBP2 fill:#fc0,stroke:#333,stroke-width:2px    style DSP1 fill:#9f6,stroke:#333,stroke-width:2px    style DSP2 fill:#9f6,stroke:#333,stroke-width:2px    style SRI fill:#bbf,stroke:#333,stroke-width:2px    style SRI2 fill:#bbf,stroke:#333,stroke-width:2px    style NW fill:#f96,stroke:#333,stroke-width:2px    style NW2 fill:#f96,stroke:#333,stroke-width:2px</code></pre><h2 id="网卡数据通信信号"><a href="#网卡数据通信信号" class="headerlink" title="网卡数据通信信号"></a>网卡数据通信信号</h2><h3 id="电信号"><a href="#电信号" class="headerlink" title="电信号"></a>电信号</h3><p>电信号是通过电缆（如双绞线或光纤）传输的信号。它们在有线网络中使用，具体特征包括：</p><ol><li><strong>物理媒介</strong>：通常通过铜线（在双绞线中）或光波（在光纤中）传输。</li><li><strong>信号类型</strong>：<ul><li>对于铜线，信号是电压变化。</li><li>对于光纤，信号是光脉冲。</li></ul></li><li><strong>传输速度</strong>：受到电缆类型和质量的影响。例如，Cat5e、Cat6、Cat7等不同类型的以太网电缆支持不同的传输速度。</li><li><strong>距离限制</strong>：电信号随距离增加而衰减。例如，标准以太网电缆的最大传输距离通常限制在100米内。</li><li><strong>干扰</strong>：可能受到电磁干扰（EMI）或射频干扰（RFI）的影响，特别是在未屏蔽的电缆中。</li></ol><h3 id="无线信号"><a href="#无线信号" class="headerlink" title="无线信号"></a>无线信号</h3><p>无线信号通过空气或真空传输，无需物理媒介。它们在无线网络中使用，特征包括：</p><ol><li><strong>传输媒介</strong>：通过空气或其他非物理媒介传播。</li><li><strong>信号类型</strong>：是电磁波，通常在射频（RF）范围内。</li><li><strong>频率范围</strong>：无线信号在特定的频率上操作，如2.4 GHz或5 GHz。</li><li><strong>覆盖范围</strong>：受到发射功率、接收灵敏度和环境因素（如墙壁、建筑物）的影响。覆盖范围可以从几米到数千米不等。</li><li><strong>干扰和衰减</strong>：可能受到其他无线设备、物理障碍物和环境因素的影响。在拥挤的频率带宽上，如2.4 GHz，干扰尤其常见。</li><li><strong>安全性</strong>：由于信号可以超出物理边界，无线网络通常需要额外的安全措施来防止未授权访问。</li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>电信号和无线信号各有特点，它们的选择取决于应用场景、传输距离、速度要求和环境条件。有线连接提供了更稳定和通常更快的连接，而无线连接则提供了更大的灵活性和移动性。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
      <tag>NIC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB与时间设置冲突.md</title>
    <link href="/2023/11/14/mdstorage/domain/db/MongoDB%E4%B8%8E%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE%E5%86%B2%E7%AA%81/"/>
    <url>/2023/11/14/mdstorage/domain/db/MongoDB%E4%B8%8E%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE%E5%86%B2%E7%AA%81/</url>
    
    <content type="html"><![CDATA[<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="https://www.mongodb.com/community/forums/t/new-clustertime-is-too-far-from-this-nodes-wall-clock-time/204403/1">社区帖子</a></p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>在 MongoDB 社区论坛的这篇帖子中，用户报告了一个问题，即在将其 Mac 日期手动设置为 2036 年后，再回到 2022 年时，MongoDB 出现了错误提示：“新的$clusterTime 与这个节点的墙上时钟时间相差太远”。为了解决这个问题，有两种可能的方案：</p><ol><li>将客户端的时间设置为与集群的时间相匹配。这可能是一个不切实际的解决方案，因为所有操作将被记录为在未来发生。</li><li>转储并恢复整个数据库，并将服务器的时间修正为正确的时间。</li></ol><p>该帖子指出，MongoDB 在分布式系统中确定操作顺序时使用 Lamport 时钟，Lamport 时钟具有时间戳始终增加的特性。在 MongoDB 6.0.3 中，Lamport 时钟对时间的前后移动有最大一年的容忍度。如果集群的任何部分的时间差超过一年，则会出现此错误。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="Lamport-时钟"><a href="#Lamport-时钟" class="headerlink" title="Lamport 时钟"></a>Lamport 时钟</h3><p>Lamport 时间戳是一种在分布式计算机系统中用来建立事件部分排序的逻辑时钟算法，由其创造者 Leslie Lamport 命名。这个算法的关键特点包括：</p><ol><li><p><strong>事件排序</strong>：它帮助确定分布式系统中事件的顺序，这些系统的节点或进程不完全同步。算法提供了一种方法，以数值方式捕获事件之间的“发生在之前”的关系。</p></li><li><p><strong>机制</strong>：分布式系统中的每个进程维护一个数值计数器（逻辑时钟）。规则包括：</p><ul><li>在每个本地事件之前增加计数器。</li><li>在每条发送的消息中包含计数器值。</li><li>收到消息时，将计数器更新为其当前值和接收消息中的时间戳中的较大值，然后增加 1。</li></ul></li><li><p><strong>概念性应用</strong>：这个逻辑时钟在进程间消息传递的上下文中具有意义。当一个进程收到消息时，它会与发送方的时钟重新同步，确保时间戳的有序进展。</p></li><li><p><strong>时间戳的唯一性</strong>：不同事件在同一进程中的时间戳永远不相等是必要的，这要求事件之间至少有一个时钟跳动。</p></li></ol><h2 id="处理方案"><a href="#处理方案" class="headerlink" title="处理方案"></a>处理方案</h2><ul><li>验证调整容忍度参数是否可以解决此问题</li><li>修改 MongoDB 启动参数</li><li>测试验证</li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>db</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typora_crack.md</title>
    <link href="/2023/11/14/mdstorage/resource/typora_pandoc_picgo/typora_crack/"/>
    <url>/2023/11/14/mdstorage/resource/typora_pandoc_picgo/typora_crack/</url>
    
    <content type="html"><![CDATA[<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="https://github.com/DiamondHunters/NodeInject_Hook_example">https://github.com/DiamondHunters/NodeInject_Hook_example</a></p><p><a href="https://github.com/abrance/NodeInject_Hook_example">https://github.com/abrance/NodeInject_Hook_example</a></p><h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><h3 id="Ubuntu22-04"><a href="#Ubuntu22-04" class="headerlink" title="Ubuntu22.04"></a>Ubuntu22.04</h3><p>typora 1.7.6</p><h3 id="win10"><a href="#win10" class="headerlink" title="win10"></a>win10</h3><p>todo</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/abrance/NodeInject_Hook_example.git<br>git <span class="hljs-built_in">clone</span> https://github.com/abrance/NodeInject.git<br><br><span class="hljs-comment"># 回退一个版本</span><br><span class="hljs-built_in">cd</span> NodeInject_Hook_example &amp;&amp; git reset --hard 81f8612<br><span class="hljs-built_in">cp</span> NodeInject_Hook_example/hook.js NodeInject/src/hooklog.js<br><br><span class="hljs-built_in">cd</span> NodeInject &amp;&amp; cargo build<br><span class="hljs-built_in">cd</span> NodeInject_Hook_example/license-gen &amp;&amp; cargo build<br><br><span class="hljs-built_in">cp</span> NodeInject/target/debug/node_inject /usr/share/typora<br><br><span class="hljs-comment"># 执行</span><br><span class="hljs-comment"># 第一步 执行注入</span><br><span class="hljs-built_in">cd</span> /usr/share/typora/ &amp;&amp; <span class="hljs-built_in">sudo</span> ./node_inject<br><span class="hljs-comment"># 看到下面结果为正常</span><br><span class="hljs-comment"># extracting node_modules.asar</span><br><span class="hljs-comment"># adding hook.js</span><br><span class="hljs-comment"># applying patch</span><br><span class="hljs-comment"># packing node_modules.asar</span><br><span class="hljs-comment"># done!</span><br><span class="hljs-comment"># 第二步 生成激活码</span><br><span class="hljs-built_in">sudo</span> NodeInject_Hook_example/license-gen/target/debug/license-gen<br><br><span class="hljs-comment"># 第三步 打开 typora 填入激活码激活</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>typora_pandoc_picgo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>crack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu设置DNS服务.md</title>
    <link href="/2023/11/13/mdstorage/domain/linux/ubuntu%E8%AE%BE%E7%BD%AEDNS%E6%9C%8D%E5%8A%A1/"/>
    <url>/2023/11/13/mdstorage/domain/linux/ubuntu%E8%AE%BE%E7%BD%AEDNS%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>Ubuntu 使用 <code>/etc/resolve.conf</code> 文件进行域名解析，该文件通常是 <code>/run/systemd/resolve/resolv.conf</code> 的软链接。直接编辑 <code>/etc/resolve.conf</code> 是不正确的，因为文件顶部有明确指示不要编辑，并且这些更改可能会被覆盖。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li><strong>编辑 <code>/etc/systemd/resolved.conf</code> 文件</strong>：在 <code>[Resolve]</code> 部分添加所需的 DNS 服务器地址，例如 <code>DNS=8.8.8.8 114.114.114.114</code>。</li><li><strong>重启域名解析服务</strong>：使用命令 <code>systemctl restart systemd-resolved</code> 和 <code>systemctl enable systemd-resolved</code> 来重启和启用服务。</li><li><strong>备份并重建软链接</strong>：备份 <code>/etc/resolve.conf</code> 文件，并设置 <code>/run/systemd/resolve/resolv.conf</code> 到 <code>/etc/resolve.conf</code> 的新软链接。</li></ol><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li><strong>systemd-resolved</strong>：用于管理域名解析服务。</li><li><strong>命令行工具</strong>：如 <code>systemctl</code>, <code>mv</code>, <code>ln</code> 等，用于执行服务操作和文件操作。</li></ul><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ul><li>在修改 DNS 设置时，确保正确编辑 <code>resolved.conf</code> 而非 <code>resolv.conf</code>。</li><li>重启服务和重新链接文件是关键步骤，以确保更改生效。</li><li>进行更改后，检查 <code>/etc/resolv.conf</code> 确认 DNS 地址已正确更新。</li></ul>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周报-11.10.md</title>
    <link href="/2023/11/13/mdstorage/project/sr/%E5%91%A8%E6%8A%A5-11.10/"/>
    <url>/2023/11/13/mdstorage/project/sr/%E5%91%A8%E6%8A%A5-11.10/</url>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kanban"># 2023/11/10 Task List<br><br>## Todo<br>- 总控授权许可文件验证开发确认(刚开始)<br>- https://github.com/mli/autocut 是什么<br>- on-premise 综述<br>- InfoQ 一周消息速递  <br>- 搜书方法、主流格式文档转换方法、以图搜图、学习资料搜索<br><br>- 周会 （1. 转测流程 2. 任务进度 3. 说说问题）<br><br>## In-Progress<br><br>- 总控软件设计说明书<br>- 松达：1. dam webhook 2. 授权进度<br><br>- 机器迁移环境搭建测试<br><br>## Completed<br>- 开发项目经理打包人员部署人员转测流程规范文档<br>- Iaas 综述<br>- 贺泽：透明部署任务<br>- 转测报告影响范围写作思路<br>- 定位 101.51 连不上的问题<br>- 环境迁移问题解决<br>- 总控开发分支维护文档<br>- Api网关的历史<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GNOME Tweaks Tool 在 Ubuntu 22.04 的安装与使用手册</title>
    <link href="/2023/11/13/mdstorage/resource/linux/gnome-tweaks%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/11/13/mdstorage/resource/linux/gnome-tweaks%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="GNOME-Tweaks-Tool-在-Ubuntu-22-04-的安装与使用手册（丰富版）"><a href="#GNOME-Tweaks-Tool-在-Ubuntu-22-04-的安装与使用手册（丰富版）" class="headerlink" title="GNOME Tweaks Tool 在 Ubuntu 22.04 的安装与使用手册（丰富版）"></a>GNOME Tweaks Tool 在 Ubuntu 22.04 的安装与使用手册（丰富版）</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><ul><li><strong>GNOME Tweaks Tool</strong>，一个强大的工具，用于自定义和优化 Ubuntu 的 GNOME 桌面环境。特别是在管理开机启动项方面，提供了简单的界面来控制哪些应用程序在登录时自动启动。</li></ul><h4 id="2-安装-GNOME-Tweaks-Tool"><a href="#2-安装-GNOME-Tweaks-Tool" class="headerlink" title="2. 安装 GNOME Tweaks Tool"></a>2. 安装 GNOME Tweaks Tool</h4><ul><li><strong>打开终端</strong>：按 <code>Ctrl + Alt + T</code>。</li><li><strong>更新软件包列表</strong>：输入 <code>sudo apt update</code> 并回车。</li><li><strong>安装 GNOME Tweaks</strong>：输入 <code>sudo apt install gnome-tweaks</code> 并回车。</li></ul><h4 id="3-打开-GNOME-Tweaks-Tool"><a href="#3-打开-GNOME-Tweaks-Tool" class="headerlink" title="3. 打开 GNOME Tweaks Tool"></a>3. 打开 GNOME Tweaks Tool</h4><ul><li>通过 <strong>活动概览</strong> 搜索并启动，或在终端输入 <code>gnome-tweaks</code>。</li></ul><h4 id="4-使用-GNOME-Tweaks-Tool"><a href="#4-使用-GNOME-Tweaks-Tool" class="headerlink" title="4. 使用 GNOME Tweaks Tool"></a>4. 使用 GNOME Tweaks Tool</h4><ul><li><strong>外观调整</strong>：更改主题、图标、光标等。</li><li><strong>桌面配置</strong>：调整桌面图标显示。</li><li><strong>字体设置</strong>：更改系统字体和大小。</li><li><strong>键盘和鼠标</strong>：调整行为和速度。</li><li><strong>窗口选项</strong>：更改标题栏按钮布局。</li><li><strong>工作区管理</strong>：设置虚拟工作区。</li></ul><h4 id="5-管理开机启动项"><a href="#5-管理开机启动项" class="headerlink" title="5. 管理开机启动项"></a>5. 管理开机启动项</h4><ul><li><strong>启动项</strong>：在 GNOME Tweaks 中选择“启动应用程序”。列出所有设置为在登录时启动的应用程序。</li><li><strong>添加或移除</strong>：添加新的启动项或移除现有的。点击“添加”并填写应用程序的名称和命令，或选择程序并点击“删除”以移除。</li><li><strong>编辑</strong>：对现有启动项进行编辑，如更改命令或延迟启动时间。</li></ul><h4 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h4><ul><li>更改设置可能需要注销或重启。</li><li>确保安装的扩展与 GNOME 版本兼容。</li></ul><h4 id="7-结论"><a href="#7-结论" class="headerlink" title="7. 结论"></a>7. 结论</h4><ul><li>GNOME Tweaks Tool 是 Ubuntu 用户的重要工具，特别适用于那些希望精细控制其桌面体验的用户。</li></ul><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>GNOME Tweaks Tool 提供了对 Ubuntu 22.04 系统的深度定制和管理能力，是高级用户的理想选择。上述指南将帮助您有效地安装和使用这一工具，充分利用 Ubuntu 系统的潜力。</p>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>gnome tweaks tool</tag>
      
      <tag>系统定制</tag>
      
      <tag>桌面管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chatgpt生成高质量内容.md</title>
    <link href="/2023/11/13/mdstorage/resource/openai/chatgpt%E7%94%9F%E6%88%90%E9%AB%98%E8%B4%A8%E9%87%8F%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/13/mdstorage/resource/openai/chatgpt%E7%94%9F%E6%88%90%E9%AB%98%E8%B4%A8%E9%87%8F%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="谷歌对于-AI-生成内容的态度及如何让-AI-生成高质量内容"><a href="#谷歌对于-AI-生成内容的态度及如何让-AI-生成高质量内容" class="headerlink" title="谷歌对于 AI 生成内容的态度及如何让 AI 生成高质量内容"></a>谷歌对于 AI 生成内容的态度及如何让 AI 生成高质量内容</h1><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5OTIzMzYyMA==&mid=2650080834&idx=1&sn=8195fdc685d5b73515923ac6c2911ee5&chksm=bf3f37798848be6f04bd80bbc46fe470824c99e691ab79c577b30b9af998be9026deb9b3e0ab&cur_album_id=2696276945558552577&scene=190#rd">如何让 AI 生成高质量内容</a></p><h2 id="归纳解读"><a href="#归纳解读" class="headerlink" title="归纳解读"></a>归纳解读</h2><p>在探索 AI 内容生成的领域中，两个核心要素显得尤为重要：对参考资料的依赖和格式指导的应用。这些要素不仅确保了内容的准确性和风格的一致性，而且在提升内容对搜索引擎的友好度方面发挥了重要作用。</p><p><strong>1. AI 内容生成依赖参考资料和格式指导</strong></p><ul><li><p><strong>依赖参考资料确保 AI 不凭空捏造信息</strong></p><p>为了确保 AI 生成的内容既准确又可靠，它必须依赖于可信的参考资料。这种依赖有助于避免 AI 在缺乏足够信息的情况下“凭空捏造”内容，从而保证信息的真实性和准确性。</p></li><li><p><strong>格式指导帮助 AI 沿用一致的文章风格</strong></p><p>通过采用明确的格式指导，可以确保 AI 生成的内容不仅在信息上准确，而且在风格上一致。这种方法有助于维持文章的结构性和连贯性，使得内容更易于读者理解和接受。</p></li></ul><p><strong>2. 结构化内容设计增强搜索引擎优化</strong></p><ul><li><p><strong>半结构化内容对搜索引擎更有吸引力</strong></p><p>结构化或半结构化的内容布局对于搜索引擎优化至关重要。这种内容布局不仅有助于搜索引擎更好地理解和索引页面内容，还提高了内容在搜索结果中的可见度。</p></li><li><p><strong>保持内容质量和一致性提升用户体验</strong></p><p>高质量的内容和一致的表现形式不仅对读者更有吸引力，也提升了整体的用户体验。这种质量和一致性的维持是通过对 AI 内容生成的持续监控和优化实现的，确保内容始终保持相关性和吸引力。</p></li></ul><p>通过综合运用这些策略和方法，可以有效地利用 AI 技术来生成高质量、高效能的内容，这对于内容创作者和数字营销专家来说具有重大意义。</p><hr><p>这个总结集中体现了文章的核心理念，并通过具体的支持点来阐述了如何有效地利用 AI 生成高质量内容。</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>使用提示词范文和具体指示确保 AI 生成内容的准确性和一致性。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">我有一个范文示例：<br><br><br>```<br>这里放范文<br>```<br>请学习这个范例，之后我每给你一个的 xxx，<br>你都返回这种格式的介绍内容，并且以“xxx”的口吻进行点评。<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>openai</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ai</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周会议程-11.10.md</title>
    <link href="/2023/11/10/mdstorage/project/sr/%E5%91%A8%E4%BC%9A%E8%AE%AE%E7%A8%8B-11.10/"/>
    <url>/2023/11/10/mdstorage/project/sr/%E5%91%A8%E4%BC%9A%E8%AE%AE%E7%A8%8B-11.10/</url>
    
    <content type="html"><![CDATA[<h1 id="周会议程"><a href="#周会议程" class="headerlink" title="周会议程"></a>周会议程</h1><h2 id="开场白"><a href="#开场白" class="headerlink" title="开场白"></a>开场白</h2><ul><li><strong>时间</strong>：2023&#x2F;11&#x2F;10</li><li><strong>地点</strong>：培训室</li><li><strong>参与人员</strong>：全体 Golang 组员</li><li><strong>会议主题</strong>：增强团队协作和项目开发管理回顾，转测流程注意项传达</li><li><strong>会议时长</strong>：1 小时内</li></ul><h2 id="一、-转测流程培训"><a href="#一、-转测流程培训" class="headerlink" title="一、 转测流程培训"></a>一、 转测流程培训</h2><ul><li><strong>目的</strong>：确保团队成员关注到细节，使实施时没有造成理解上的困难，沟通上更顺畅。</li><li><strong>内容</strong>：<ul><li>自测后和集成测试完成后需要通知项目经理，并在文档中修改需求状态，通知项目经理在企微的 <code>石犀总控小组</code> 群中通知。</li><li>唯一责任人（项目经理按情况指定）</li><li>转测报告影响范围</li></ul></li></ul><h2 id="二、-任务管理与评估"><a href="#二、-任务管理与评估" class="headerlink" title="二、 任务管理与评估"></a>二、 任务管理与评估</h2><h3 id="任务评估回顾"><a href="#任务评估回顾" class="headerlink" title="任务评估回顾"></a>任务评估回顾</h3><ul><li><strong>目标</strong>：识别评估过程中的问题，减少项目延期。</li><li><strong>议程</strong>：<ul><li>回顾上周的任务评估准确性</li><li>分析延期的任务和原因</li></ul></li></ul><h3 id="延期任务回顾"><a href="#延期任务回顾" class="headerlink" title="延期任务回顾"></a>延期任务回顾</h3><ul><li><p><strong>目标</strong>：分析导致延期的因素，寻找解决方案。</p></li><li><p><strong>议程</strong>：</p><ul><li>所有的需求功能都延期了（大家提一下原因，先不要分析原因）</li><li>总结延期原因<ul><li>插入新任务（调研和设计时没考虑清楚，决策得不合理）</li><li>任务没有理清楚</li><li>人员调动 （插件人员调动）</li><li>数据面延期导致无法联调延期</li><li>联调时间没把控好（缺失联调培训和流程）</li><li>需求变更</li><li>自测时间未能评估准确</li></ul></li></ul></li><li><p>（方案调整导致延期）</p></li><li><p>历史遗留问题，导致新功能延期</p></li></ul><h3 id="风险项回顾"><a href="#风险项回顾" class="headerlink" title="风险项回顾"></a>风险项回顾</h3><ul><li><strong>目标</strong>：分析和回顾当前的风险项，提前规划风险应对措施。</li><li><strong>议程</strong>：<ul><li>确定风险清单</li><li>分享风险管理策略</li></ul></li></ul><h3 id="本周改进点回顾"><a href="#本周改进点回顾" class="headerlink" title="本周改进点回顾"></a>本周改进点回顾</h3><ul><li><strong>目标</strong>：看到问题、争取改进<ul><li>每位团队成员分享两个他们认为本周做得不够好的点，限于描述现象，不涉及原因分析</li><li>收集所有问题点，用于未来的改进会议讨论<ul><li>联调时间前端资源不足</li><li>联调时间还是不准，环境准备阶段也需要花时间，零散事项很多</li><li>集成环境打包输出标准没有</li><li>联调人多后忙不过来</li><li>多关注禅道排期</li><li>业务数据主要是 生造的数据 、资源、支持<ul><li>产品需求时就考虑这些支持</li></ul></li><li>出包的频率想要更快一点</li><li>打包服务太慢了（要CICD），非常卡进度</li><li>透明部署、路由部署 资源紧缺，非常卡进度</li><li>集成环境部署周期太长了，一天出不了两个，办公室网慢死，传半个小时，集成环境资源太烂。</li><li>授权联调时间、卡流程的问题不能及时解决，导致联调延期</li><li>升级替换文件很多写死，固定替换 sv 二进制等，其他目录新增依赖没写上去。</li><li>升级包导入、升级文件替换要花时间调整。</li><li>升级没有签名校验、有安全风险</li><li>升级目前很多坑，影响思华这边项目周期</li><li>插件方面有很多问题，不知道怎么改了，想要重构，是否先补设计文档</li></ul></li></ul></li></ul><h2 id="事项宣布"><a href="#事项宣布" class="headerlink" title="事项宣布"></a>事项宣布</h2><ul><li><p>影响范围一定要写</p></li><li><p>每个需求唯一责任人要积极推动</p></li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><ul><li><strong>小结</strong>：目前大家不同程度都有延期，请延期的需求呢，该推进就推进，有阻塞的地方也要不停去跟进，尽量降低延期时间。已经转测了的，也不要松懈，将各种显而易见的问题清理出来优化了，将未完成的设计文档补全了，不要闲下来就发呆、玩手机、学一些项目无关的，对其他人不公平。</li><li><strong>行动项</strong>：分配任务，明确下一步行动计划。</li><li><strong>感谢</strong>：对团队的努力和贡献表示感谢。</li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="过往问题回顾"><a href="#过往问题回顾" class="headerlink" title="过往问题回顾"></a>过往问题回顾</h3><ul><li><p>人员调动，不合理</p></li><li><p>禅道任务项目管理没跟踪-更新</p></li><li><p>需求不合理、产品变更需求文档后未通知项目经理</p></li><li><p>岗位职责未清</p></li><li><p>联调时遇到问题、项目经理也需要反馈给到开发</p></li><li><p>企微已读不回</p></li><li><p>某功能开发的进度管理缺失</p></li><li><p>开发周期太短、评估时间长了会想压缩</p></li><li><p>禅道版本太低、gitlab、CICD、wiki 等基础设施简陋</p></li><li><p>调研拆细、分给大家</p></li><li><p>开发自测还要松达帮忙打包</p></li><li><p>开发不知道这套系统的部署</p></li><li><p>没有整个系统的操作指引</p></li><li><p>项目开发节奏太紧、项目版本的节点设置不合理</p></li><li><p>插件开发周期太紧、测试的 bug 需要排优先级</p></li><li><p>联调插件前期沟通没做好</p></li><li><p>代码不规范</p></li><li><p>代码 review 缺失</p></li><li><p>大家沟通不够</p><ul><li>反馈</li><li>回应</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>周会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总控开发分支维护.md</title>
    <link href="/2023/11/09/mdstorage/project/sr/%E6%80%BB%E6%8E%A7%E5%BC%80%E5%8F%91%E5%88%86%E6%94%AF%E7%BB%B4%E6%8A%A4/"/>
    <url>/2023/11/09/mdstorage/project/sr/%E6%80%BB%E6%8E%A7%E5%BC%80%E5%8F%91%E5%88%86%E6%94%AF%E7%BB%B4%E6%8A%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>目前石犀总控引擎软件系统中，只认为存在一条<strong>主线产品</strong>在往后演进，其中这个主线产品的发布即会对应发布分支，在多次发布后，即会产生多条发布分支，这就是主要的分支形态。</li><li>类似<strong>演示平台</strong>其实认为它是一个<strong>客户定制产品</strong>，每个客户定制产品和主线产品是同级关系，也就是说，假设客户定制产品和主线产品的发布频率完全一致的情况下，同一个组件的一个版本开发，将有多个发布分支在演进，如 release-v1.2.3 、zsj-release-v1.2.3。</li><li>注意总控、引擎的发布版本规则是不同的。</li><li>展望：当一个客户定制产品已经和主线产品异化太严重时，应该将属于它的 release 分支抽取独立为新组件。</li></ol><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li><strong>主分支（main）</strong>：主分支应始终保持可部署状态。所有从主分支衍生的分支最终都应合并回主分支。</li><li><strong>特性分支（feature branches）</strong>：用于开发新功能。每个特性分支应只关注一个具体的功能或修复。</li><li><strong>修复分支（fix branches）</strong>：用于处理生产环境中的紧急问题。修复后，应该将更改合并回主分支和所有受影响的当前活动分支。</li><li><strong>发布分支（release branches）</strong>：用于准备即将发布的版本。在此分支上，可以进行最后的调整、测试和 bug 修复。</li><li><strong>标签（tags）</strong>：用于标记重要的开发里程碑，如新版本发布。</li></ol><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol><li><strong>合并策略</strong>：在主分支和特性分支之间定期合并可以减少合并冲突。但应避免不必要的合并，因为它们可能带来问题而不是解决问题。</li><li><strong>版本控制</strong>：给新版本打标签（tag）可以帮助团队更好地管理版本和历史。标签创建后不应更改，以保持历史的准确性。</li><li><strong>分支生命周期</strong>：每个分支应有明确的创建和终结时间。长期存在的分支可能难以维护，容易产生过时的代码和合并冲突。</li><li><strong>紧急修复</strong>：紧急修复应在专门的分支上进行，并尽快合并回主要分支。这有助于快速部署修复，同时保持主要分支的稳定。</li><li><strong>代码审查</strong>：所有合并操作之前应有代码审查机制，确保新合并的代码符合质量标准。</li><li><strong>测试</strong>：每次合并之后都应执行自动化测试，以保证新代码的加入不会破坏现有功能。</li></ol><h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><h3 id="创建版本"><a href="#创建版本" class="headerlink" title="创建版本"></a>创建版本</h3><ul><li>每个版本必须从 main 中签出</li><li>每个版本从 main 中签出后需要做此版本初始化维护工作，包括维护后需要和 main merge 一次，防止后续merge 难度太大，因为 main 保存的框架是多个 release 分支共同所有的，很有可能很多代码需要废弃掉或是需要新增工具库</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><strong>一致性基础</strong>：从 <code>main</code> 分支签出每个版本确保了所有版本都基于统一的代码基础，这有助于保持代码库的一致性。</li><li><strong>稳定性</strong>：通常，<code>main</code> 分支被视为最稳定的分支，用作创建新 <code>release</code> 的基础可以减少引入未测试或不稳定代码的风险。</li><li><strong>追踪简单</strong>：从 <code>main</code> 分支签出版本意味着所有版本的起点都是明确和统一的，便于追踪每个版本的变更。</li><li><strong>集中管理</strong>：需要废弃或新增的代码和工具库的维护可以在 <code>main</code> 分支上进行，避免了在多个分支上重复相同的工作。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li><strong>可能的初期不稳定</strong>：虽然 <code>main</code> 应该是稳定的，但如果存在频繁的合并，<code>main</code> 可能会暂时包含一些尚未完全验证的代码，这可能导致从 <code>main</code> 签出的新版本需要更多的初期维护。</li><li><strong>维护工作量</strong>：如果 <code>main</code> 分支经常接收来自多个 <code>release</code> 分支的合并，那么每次从 <code>main</code> 创建新版本时都可能需要进行显著的清理和初始化工作。</li><li><strong>分支膨胀</strong>：如果每个新版本都从 <code>main</code> 签出，并且版本更新频繁，可能会导致大量的分支存在，增加了管理的复杂性。</li></ol><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ol><li><strong>保持 <code>main</code> 的纯净</strong>：尽可能只在 <code>main</code> 分支上进行稳定性和性能改进，而不是功能添加，这样新签出的版本就需要较少的初始化维护。</li><li><strong>清晰的版本策略</strong>：确保有一个清晰的策略来决定何时和为什么需要创建新版本，避免不必要的版本创建。</li><li><strong>自动化初始化工作</strong>：开发脚本或工具来自动化版本创建后的初始化工作，如代码清理、库更新等，以减轻人工负担。</li><li><strong>详细的变更日志</strong>：维护一个详尽的变更日志，记录从上一个稳定点到当前 <code>main</code> 分支的所有变更，这样在签出新版本时，开发者可以迅速识别和处理那些需要被废弃或新增的代码。</li><li><strong>代码审查和测试</strong>：在代码合并到 <code>main</code> 分支之前，实施严格的代码审查和测试流程，确保引入的变更都是稳定和可靠的。</li></ol><h3 id="定期合并"><a href="#定期合并" class="headerlink" title="定期合并"></a>定期合并</h3><ul><li>定一个周期，一个周期内每个 release 分支至少要和 main merge 一次，否则将导致 main 与众多分支太不一致</li></ul><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><pre><code class="hljs">保持一致性：定期合并有助于确保 main 分支与所有活跃的 release 分支保持一致，减少分支间的差异。简化合并：频繁的合并可以减小每次合并的规模，理论上可以减少合并冲突的可能性。及时发现问题：通过定期将更改合并回 main，可以更早地发现并解决集成问题。流程规范化：这种策略强制实施了一个规范化的流程，要求团队成员按时完成任务，这有助于保持项目进度。</code></pre><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><pre><code class="hljs">可能的过度集成：如果 release 分支还不稳定或者包含尚未准备好合并的功能，频繁的合并可能会导致 main 分支的不稳定。合并负担：定期合并可能会增加团队的工作负担，特别是如果存在多个活跃的 release 分支时。自动化测试的压力：频繁的合并需要强大的自动化测试支持，以确保不会引入新的错误。过度的流程化：过度的流程化可能会限制某些情况下的灵活性，因为并非所有的工作流程都能适应这种定期合并的模式。</code></pre><h4 id="结论与展望"><a href="#结论与展望" class="headerlink" title="结论与展望"></a>结论与展望</h4><ul><li><strong>灵活应用</strong>：应该根据实际情况灵活应用这个规则。如果某个 <code>release</code> 分支包含的是一个大变更，可能需要特别的处理，而不是简单的定期合并。</li><li><strong>强化自动化</strong>：增强自动化测试和构建流程，确保合并的过程尽可能无痛，并及时发现问题。</li><li><strong>监控分支差异</strong>：监控不同分支之间的差异，确保没有太大的偏离。</li><li><strong>及时通讯</strong>：确保团队成员之间有良好的沟通机制，合并时遇到的任何问题都应及时通知并寻求解决。</li></ul><h3 id="新版本启动前-tagging"><a href="#新版本启动前-tagging" class="headerlink" title="新版本启动前 tagging"></a>新版本启动前 tagging</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li><strong>版本追踪</strong>：标签为版本提供了明确的锚点，使得在项目的生命周期中能够轻松地检出特定的发布版本。</li><li><strong>回溯方便</strong>：如果在新版本发布之后发现问题，可以方便地回退到标签所指的提交进行 bug 修复。</li><li><strong>文档记录</strong>：标签可以包括额外的发布信息，如版本号、发布日期等，提供了更丰富的历史信息。</li><li><strong>构建和部署</strong>：自动化的构建和部署系统可以利用标签来触发特定版本的构建和部署。</li><li><strong>非线性开发流程</strong>：在采用 Git 流或其他分支策略时，标签帮助维护了一个清晰的、非线性的开发历史。</li><li><strong>热修复（Hotfixes）</strong>：如果需要对特定版本进行热修复，可以从相应的标签签出一个热修复分支，修复后再合并回主分支。</li></ol><h3 id="定期同步-tagging"><a href="#定期同步-tagging" class="headerlink" title="定期同步 tagging"></a>定期同步 tagging</h3><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ol><li><strong>维持代码同步</strong>：周期性地将 <code>release</code> 分支合并回 <code>main</code> 可以保持各个分支间的同步，减少未来合并时的冲突概率。</li><li><strong>固定集成点</strong>：这样做提供了一个固定的集成点，团队成员可以期待这些时间点，并准备他们的代码以确保合并时没有问题。</li><li><strong>改进稳定性</strong>：通过定期的合并和标记，<code>main</code> 分支始终保持最新且稳定的代码状态，确保了 <code>main</code> 分支的代码质量。</li><li><strong>简化版本追踪</strong>：每次合并后对 <code>main</code> 分支打标签，可以方便地跟踪各个周期的代码状态，这在识别问题和理解特定时间点的代码变更时特别有用。</li><li><strong>自动化触发点</strong>：标签可以作为自动化构建和部署流程的触发点，比如当你在 <code>main</code> 上打上标签时，可以自动开始构建和部署到测试环境。</li><li><strong>审计和合规性</strong>：在企业环境中，定期合并和标记可以提供审计跟踪，证明代码已经按照规定的流程进行了合并和测试。</li><li><strong>快速回滚</strong>：如果新引入的代码导致问题，可以使用标签快速找到稳定状态的代码进行回滚。</li><li><strong>里程碑文档化</strong>：对 <code>main</code> 分支的标记可以作为项目进度的里程碑，有助于文档化项目的发展历程。</li></ol><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>过度合并</strong>：如果 <code>release</code> 分支还不稳定或包含未完成的特性，过度频繁的合并可能会向 <code>main</code> 分支引入不稳定的代码。</li></ul><h2 id="事务和时机"><a href="#事务和时机" class="headerlink" title="事务和时机"></a>事务和时机</h2><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p><strong>现设定有下面关于分支管理的事务，并在下面对每个事务执行的时机和注意事项进行说明</strong></p><ol><li><strong>打标签</strong>：在每个重要的发行版或里程碑完成时打标签，比如完成一个稳定的开发周期或准备发布一个新版本。</li><li><strong>创建分支</strong>：当开始新功能开发、预备新版本发布，或需要紧急修复时创建新的分支。</li><li><strong>合并分支</strong>：功能完成且经过充分测试时，将特性分支合并到主分支；紧急修复完成后，立即合并到主分支和其他相关分支。</li><li><strong>定期维护</strong>：定期评估现有分支，删除不再需要的分支，合并长时间未更新的分支，以保持代码库的整洁和可管理性。</li><li><strong>紧急修复</strong>：一旦在生产环境中发现紧急问题，立即创建修复分支，开始修复工作，并按照紧急情况处理合并和部署。</li></ol><h3 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h3><h4 id="打标签（tagging）"><a href="#打标签（tagging）" class="headerlink" title="打标签（tagging）"></a>打标签（tagging）</h4><h5 id="main"><a href="#main" class="headerlink" title="main"></a>main</h5><ul><li>启动一个新版本时先打 tag， tag content: init version $version</li><li>定期维护所有发布分支和 main 分支，一次整体维护完之后打 tag</li></ul><h2 id="图表和图像"><a href="#图表和图像" class="headerlink" title="图表和图像"></a>图表和图像</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><pre><code class=" mermaid">    %%&#123;init: &#123; &#x27;logLevel&#x27;: &#x27;debug&#x27;, &#x27;theme&#x27;: &#x27;default&#x27; , &#x27;themeVariables&#x27;: &#123;        &#x27;gitBranchLabel0&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel1&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel2&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel3&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel4&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel5&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel6&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel7&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel8&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel9&#x27;: &#x27;#ffffff&#x27;  &#125; &#125; &#125;%%gitGraph  # 初始化组件代码仓库  checkout main  commit  branch feat-init  commit id: &quot;A1&quot; type: NORMAL  commit id: &quot;A2&quot; type: NORMAL  commit id: &quot;A3&quot; type: NORMAL  checkout main  merge feat-init    # 启动一个新版本时先打 tag 方便随后切分支  commit id: &quot;fix branch main timestamp1&quot; tag: &quot;init v1.2.3&quot;    # 签新版本分支，从 main 中  branch release-v1.2.3    # 签版本分支后先进行新分支的维护，并与 main 进行一次初步合并  commit id: &quot;v1.2.3 init&quot;  checkout main  merge release-v1.2.3  checkout release-v1.2.3    # feat-v1.2.3-1, fix-v1.2.3-x 同时进行，一个修复 bug，一个开发新功能  branch feat-v1.2.3-1  commit id: &quot;feat-v1.2.3-1 init&quot;    # release-v1.2.3 开始修复 A 功能 bug  branch fix-v1.2.3-x  commit id: &quot;fix-v1.2.3-x init&quot;  commit id: &quot;Fix A 1&quot;  commit id: &quot;Fix A 2&quot;  commit id: &quot;Fix A 3&quot;  checkout feat-v1.2.3-1    # release-v1.2.3 开发 B 功能   commit id: &quot;B1&quot;  commit id: &quot;B2&quot;  commit id: &quot;B3&quot;  checkout release-v1.2.3  merge feat-v1.2.3-1    # release-v1.2.3 提交修复 A 功能 bug  merge fix-v1.2.3-x    # 定期维护 release-v1.2.3 和 main 的关系，进行一次 merge  checkout main  merge release-v1.2.3  commit id: &quot;PeriodMerge $timestamp1&quot; tag: &quot;PeriodMerge $timestamp1&quot;  checkout release-v1.2.3    # release-v1.2.3 开发 C 功能  branch feat-v1.2.3-2  commit id: &quot;C1&quot;  commit id: &quot;C2&quot;  commit id: &quot;C3&quot;  checkout release-v1.2.3  merge feat-v1.2.3-2    # 定期维护 release-v1.2.3 和 main 的关系，进行一次 merge  checkout main  merge release-v1.2.3  commit id: &quot;PeriodMerge $timestamp2&quot; tag: &quot;PeriodMerge $timestamp2&quot;  checkout release-v1.2.3  commit id: &quot;something 1&quot;  commit id: &quot;something 2&quot;  # release-v1.2.3 继续维护 ... 直到维护周期结束  # 启动一个新版本时先打 tag 方便随后切分支  checkout main  commit id: &quot;fix branch main timestamp2&quot; tag: &quot;init v1.2.4&quot;    # 签版本分支，从 main 中  branch release-v1.2.4    # 签版本分支后先进行新分支的维护，并与 main 进行一次初步合并  commit id: &quot;v1.2.4 init&quot;  checkout main  merge release-v1.2.4  checkout release-v1.2.4  # release-v1.2.4 开始开发新功能  branch feat-v1.2.4-1  commit id: &quot;feat-v1.2.4-1 init&quot;  commit id: &quot;D1&quot;  commit id: &quot;D2&quot;  commit id: &quot;D3&quot;  checkout release-v1.2.4  merge feat-v1.2.4-1    # 这时生产 release-v1.2.3 出现 A 功能 bug4    # 先紧急解决 release-v1.2.3 问题，验证完合并代码  checkout release-v1.2.3  branch fix-v1.2.3-y  commit id: &quot;fix-v1.2.3-y init&quot;  commit id: &quot;Fix A 4 release-v1.2.3&quot;  checkout release-v1.2.3  merge fix-v1.2.3-y    # 再解决现有其他分支问题，目前 main 和 release-v1.2.4 也有同样的问题，想办法将 main 和 release-v1.2.4 分支中 A bug4 解决  # 方案：（不一定是这个方案，具体问题具体选择方案解决）直接合并 release-v1.2.3 和 release-v1.2.4 main 代码  # 方案 一： main release-v1.2.3 release-v1.2.4 关于 A 功能代码相似度较高，就直接合并代码  # 方案 二： release-v1.2.3 main 代码相似度低，main release-v1.2.4 相似度高 这种情况用上面方案  # 方案 三： release-v1.2.3 main release-v1.2.4 相似度都低，都分别 commit，等定期维护时 merge 分别维护 A 功能代码  # 方案 四： release-v1.2.3 release-v1.2.4 相似度高，与 main 相似度低，release 之间 merge，main 单独维护 A 功能代码（甚至去掉 A 功能代码）  checkout main  merge release-v1.2.3  merge release-v1.2.4    # release-v1.2.4 继续开发功能 E  checkout release-v1.2.4  branch feat-v1.2.4-2  commit id: &quot;feat-v1.2.4-2 init&quot;  commit id: &quot;E1&quot;  commit id: &quot;E2&quot;  commit id: &quot;E3&quot;  checkout release-v1.2.4  merge feat-v1.2.4-2    # 定期维护 release-v1.2.3 和 main 的关系，进行一次 merge  checkout main  merge release-v1.2.4  commit id: &quot;PeriodMerge $timestamp3&quot; tag: &quot;PeriodMerge $timestamp3&quot;    # 切分支继续开发 release-v1.2.4  checkout release-v1.2.4  branch feat-v1.2.4-3  commit id: &quot;feat-v1.2.4-3&quot;  commit id: &quot;D4&quot;  commit id: &quot;D5&quot;  commit id: &quot;D6&quot;  checkout release-v1.2.4  merge feat-v1.2.4-3  commit id: &quot;fix branch3 v1.2.3&quot;  # 定期维护所有分支 release-v1.2.4 和 main 的关系，进行一次 merge  checkout main  merge release-v1.2.3  merge release-v1.2.4  commit id: &quot;PeriodMerge $timestamp4&quot; tag: &quot;PeriodMerge$timestamp4&quot;    # 启动一个新版本时先打 tag 方便随后切分支  commit id: &quot;fix branch main $timestamp3&quot; tag: &quot;init v1.2.5&quot;    # 签分支启动版本 release-v1.2.5  branch release-v1.2.5  commit id: &quot;release-v1.2.5 init&quot;  checkout main  merge release-v1.2.5    # release-v1.2.5 上开发 F 功能  branch feat-v1.2.5-1  commit id: &quot;feat-v1.2.5-1 init&quot;  commit id: &quot;F1&quot;  # ,,,</code></pre><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><pre><code class=" mermaid">    %%&#123;init: &#123; &#x27;logLevel&#x27;: &#x27;debug&#x27;, &#x27;theme&#x27;: &#x27;default&#x27; , &#x27;themeVariables&#x27;: &#123;        &#x27;gitBranchLabel0&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel1&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel2&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel3&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel4&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel5&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel6&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel7&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel8&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel9&#x27;: &#x27;#ffffff&#x27;  &#125; &#125; &#125;%%gitGraph  # 初始化组件代码仓库  checkout main  commit  branch feat-init  commit id: &quot;A1&quot; type: NORMAL  commit id: &quot;A2&quot; type: NORMAL  commit id: &quot;A3&quot; type: NORMAL  checkout main  merge feat-init    # 启动一个新版本时先打 tag 方便随后切分支  commit id: &quot;fix branch main timestamp1&quot; tag: &quot;init v1.2.3&quot;    # 签新版本分支，从 main 中  branch release-v1.2.3    # 签版本分支后先进行新分支的维护，并与 main 进行一次初步合并  commit id: &quot;v1.2.3 init&quot;  checkout main  merge release-v1.2.3  checkout release-v1.2.3    # feat-v1.2.3-1, fix-v1.2.3-x 同时进行，一个修复 bug，一个开发新功能  branch feat-v1.2.3-1  commit id: &quot;feat-v1.2.3-1 init&quot;    # release-v1.2.3 开始修复 A 功能 bug  branch fix-v1.2.3-x  commit id: &quot;fix-v1.2.3-x init&quot;  commit id: &quot;Fix A 1&quot;  commit id: &quot;Fix A 2&quot;  commit id: &quot;Fix A 3&quot;  checkout feat-v1.2.3-1    # release-v1.2.3 开发 B 功能   commit id: &quot;B1&quot;  commit id: &quot;B2&quot;  commit id: &quot;B3&quot;  checkout release-v1.2.3  merge feat-v1.2.3-1    # release-v1.2.3 提交修复 A 功能 bug  merge fix-v1.2.3-x    # 定期维护 release-v1.2.3 和 main 的关系，进行一次 merge  checkout main  merge release-v1.2.3  commit id: &quot;PeriodMerge $timestamp1&quot; tag: &quot;PeriodMerge $timestamp1&quot;  checkout release-v1.2.3    # release-v1.2.3 开发 C 功能  branch feat-v1.2.3-2  commit id: &quot;C1&quot;  commit id: &quot;C2&quot;  commit id: &quot;C3&quot;  checkout release-v1.2.3  merge feat-v1.2.3-2    # 定期维护 release-v1.2.3 和 main 的关系，进行一次 merge  checkout main  merge release-v1.2.3  commit id: &quot;PeriodMerge $timestamp2&quot; tag: &quot;PeriodMerge $timestamp2&quot;  checkout release-v1.2.3  commit id: &quot;something 1&quot;  commit id: &quot;something 2&quot;  # release-v1.2.3 继续维护 ... 直到维护周期结束  # 启动一个新版本时先打 tag 方便随后切分支  checkout main  commit id: &quot;fix branch main timestamp2&quot; tag: &quot;init v1.2.4&quot;    # 签版本分支，从 main 中  branch release-v1.2.4    # 签版本分支后先进行新分支的维护，并与 main 进行一次初步合并  commit id: &quot;v1.2.4 init&quot;  checkout main  merge release-v1.2.4  checkout release-v1.2.4  # release-v1.2.4 开始开发新功能  branch feat-v1.2.4-1  commit id: &quot;feat-v1.2.4-1 init&quot;  commit id: &quot;D1&quot;  commit id: &quot;D2&quot;  commit id: &quot;D3&quot;  checkout release-v1.2.4  merge feat-v1.2.4-1    # 这时生产 release-v1.2.3 出现 A 功能 bug4    # 先紧急解决 release-v1.2.3 问题，验证完合并代码  checkout release-v1.2.3  branch fix-v1.2.3-y  commit id: &quot;fix-v1.2.3-y init&quot;  commit id: &quot;Fix A 4 release-v1.2.3&quot;  checkout release-v1.2.3  merge fix-v1.2.3-y    # 再解决现有其他分支问题，目前 main 和 release-v1.2.4 也有同样的问题，想办法将 main 和 release-v1.2.4 分支中 A bug4 解决  # 方案：（不一定是这个方案，具体问题具体选择方案解决）先解决 main 问题，再合并到 release-v1.2.4  # 方案 一： main release-v1.2.3 release-v1.2.4 关于 A 功能代码相似度较高，就直接合并代码  # 方案 二： release-v1.2.3 main 代码相似度低，main release-v1.2.4 相似度高 这种情况用上面方案  # 方案 三： release-v1.2.3 main release-v1.2.4 相似度都低，都分别 commit，等定期维护时 merge 分别维护 A 功能代码  # 方案 四： release-v1.2.3 release-v1.2.4 相似度高，与 main 相似度低，release 之间 merge，main 单独维护 A 功能代码（甚至去掉 A 功能代码）  checkout main  branch fix-main-A-4  commit id: &quot;fix-main-A-4 init&quot;  commit id: &quot;Fix A 4 main&quot;  checkout main  merge fix-main-A-4  merge release-v1.2.4    # release-v1.2.4 继续开发功能 E  checkout release-v1.2.4  branch feat-v1.2.4-2  commit id: &quot;feat-v1.2.4-2 init&quot;  commit id: &quot;E1&quot;  commit id: &quot;E2&quot;  commit id: &quot;E3&quot;  checkout release-v1.2.4  merge feat-v1.2.4-2    # 定期维护 release-v1.2.3 和 main 的关系，进行一次 merge  checkout main  merge release-v1.2.4  commit id: &quot;PeriodMerge $timestamp3&quot; tag: &quot;PeriodMerge $timestamp3&quot;    # 切分支继续开发 release-v1.2.4  checkout release-v1.2.4  branch feat-v1.2.4-3  commit id: &quot;feat-v1.2.4-3&quot;  commit id: &quot;D4&quot;  commit id: &quot;D5&quot;  commit id: &quot;D6&quot;  checkout release-v1.2.4  merge feat-v1.2.4-3  commit id: &quot;fix branch3 v1.2.3&quot;  # 定期维护所有分支 release-v1.2.4 和 main 的关系，进行一次 merge  checkout main  merge release-v1.2.3  merge release-v1.2.4  commit id: &quot;PeriodMerge $timestamp4&quot; tag: &quot;PeriodMerge$timestamp4&quot;    # 启动一个新版本时先打 tag 方便随后切分支  commit id: &quot;fix branch main $timestamp3&quot; tag: &quot;init v1.2.5&quot;    # 签分支启动版本 release-v1.2.5  branch release-v1.2.5  commit id: &quot;release-v1.2.5 init&quot;  checkout main  merge release-v1.2.5    # release-v1.2.5 上开发 F 功能  branch feat-v1.2.5-1  commit id: &quot;feat-v1.2.5-1 init&quot;  commit id: &quot;F1&quot;  # ,,,    </code></pre><h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h3><pre><code class=" mermaid">    %%&#123;init: &#123; &#x27;logLevel&#x27;: &#x27;debug&#x27;, &#x27;theme&#x27;: &#x27;default&#x27; , &#x27;themeVariables&#x27;: &#123;        &#x27;gitBranchLabel0&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel1&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel2&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel3&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel4&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel5&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel6&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel7&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel8&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel9&#x27;: &#x27;#ffffff&#x27;  &#125; &#125; &#125;%%gitGraph  # 初始化组件代码仓库  checkout main  commit  branch feat-init  commit id: &quot;A1&quot; type: NORMAL  commit id: &quot;A2&quot; type: NORMAL  commit id: &quot;A3&quot; type: NORMAL  checkout main  merge feat-init    # 启动一个新版本时先打 tag 方便随后切分支  commit id: &quot;fix branch main timestamp1&quot; tag: &quot;init v1.2.3&quot;    # 签新版本分支，从 main 中  branch release-v1.2.3    # 签版本分支后先进行新分支的维护，并与 main 进行一次初步合并  commit id: &quot;v1.2.3 init&quot;  checkout main  merge release-v1.2.3  checkout release-v1.2.3    # feat-v1.2.3-1, fix-v1.2.3-x 同时进行，一个修复 bug，一个开发新功能  branch feat-v1.2.3-1  commit id: &quot;feat-v1.2.3-1 init&quot;    # release-v1.2.3 开始修复 A 功能 bug  branch fix-v1.2.3-x  commit id: &quot;fix-v1.2.3-x init&quot;  commit id: &quot;Fix A 1&quot;  commit id: &quot;Fix A 2&quot;  commit id: &quot;Fix A 3&quot;  checkout feat-v1.2.3-1    # release-v1.2.3 开发 B 功能   commit id: &quot;B1&quot;  commit id: &quot;B2&quot;  commit id: &quot;B3&quot;  checkout release-v1.2.3  merge feat-v1.2.3-1    # release-v1.2.3 提交修复 A 功能 bug  merge fix-v1.2.3-x    # 定期维护 release-v1.2.3 和 main 的关系，进行一次 merge  checkout main  merge release-v1.2.3  commit id: &quot;PeriodMerge $timestamp1&quot; tag: &quot;PeriodMerge $timestamp1&quot;  checkout release-v1.2.3    # release-v1.2.3 开发 C 功能  branch feat-v1.2.3-2  commit id: &quot;C1&quot;  commit id: &quot;C2&quot;  commit id: &quot;C3&quot;  checkout release-v1.2.3  merge feat-v1.2.3-2    # 定期维护 release-v1.2.3 和 main 的关系，进行一次 merge  checkout main  merge release-v1.2.3  commit id: &quot;PeriodMerge $timestamp2&quot; tag: &quot;PeriodMerge $timestamp2&quot;  checkout release-v1.2.3  commit id: &quot;something 1&quot;  commit id: &quot;something 2&quot;  # release-v1.2.3 继续维护 ... 直到维护周期结束  # 启动一个新版本时先打 tag 方便随后切分支  checkout main  commit id: &quot;fix branch main timestamp2&quot; tag: &quot;init v1.2.4&quot;    # 签版本分支，从 main 中  branch release-v1.2.4    # 签版本分支后先进行新分支的维护，并与 main 进行一次初步合并  commit id: &quot;v1.2.4 init&quot;  checkout main  merge release-v1.2.4  checkout release-v1.2.4  # release-v1.2.4 开始开发新功能  branch feat-v1.2.4-1  commit id: &quot;feat-v1.2.4-1 init&quot;  commit id: &quot;D1&quot;  commit id: &quot;D2&quot;  commit id: &quot;D3&quot;  checkout release-v1.2.4  merge feat-v1.2.4-1    # 这时生产 release-v1.2.3 出现 A 功能 bug4    # 先紧急解决 release-v1.2.3 问题，验证完合并代码  checkout release-v1.2.3  branch fix-v1.2.3-y  commit id: &quot;fix-v1.2.3-y init&quot;  commit id: &quot;Fix A 4 release-v1.2.3&quot;  checkout release-v1.2.3  merge fix-v1.2.3-y    # 再解决现有其他分支问题，目前 main 和 release-v1.2.4 也有同样的问题，想办法将 main 和 release-v1.2.4 分支中 A bug4 解决  # 方案：（不一定是这个方案，具体问题具体选择方案解决）分别 commit，定期维护时维护 A 功能代码合并  # 方案 一： main release-v1.2.3 release-v1.2.4 关于 A 功能代码相似度较高，就直接合并代码  # 方案 二： release-v1.2.3 main 代码相似度低，main release-v1.2.4 相似度高 这种情况用上面方案  # 方案 三： release-v1.2.3 main release-v1.2.4 相似度都低，都分别 commit，等定期维护时 merge 分别维护 A 功能代码  # 方案 四： release-v1.2.3 release-v1.2.4 相似度高，与 main 相似度低，release 之间 merge，main 单独维护 A 功能代码（甚至去掉 A 功能代码）  checkout main  branch fix-main-A-4  commit id: &quot;fix-main-A-4 init&quot;  commit id: &quot;Fix A 4 main&quot;  checkout main  merge fix-main-A-4    checkout release-v1.2.4  branch fix-v1.2.4-x  commit id: &quot;fix-v1.2.4-x init&quot;  commit id: &quot;Fix A 4 v1.2.4&quot;  checkout release-v1.2.4  merge fix-v1.2.4-x    # release-v1.2.4 继续开发功能 E  checkout release-v1.2.4  branch feat-v1.2.4-2  commit id: &quot;feat-v1.2.4-2 init&quot;  commit id: &quot;E1&quot;  commit id: &quot;E2&quot;  commit id: &quot;E3&quot;  checkout release-v1.2.4  merge feat-v1.2.4-2    # 定期维护 release-v1.2.3 和 main 的关系，进行一次 merge  checkout main  merge release-v1.2.4  commit id: &quot;PeriodMerge $timestamp3&quot; tag: &quot;PeriodMerge $timestamp3&quot;    # 切分支继续开发 release-v1.2.4  checkout release-v1.2.4  branch feat-v1.2.4-3  commit id: &quot;feat-v1.2.4-3&quot;  commit id: &quot;D4&quot;  commit id: &quot;D5&quot;  commit id: &quot;D6&quot;  checkout release-v1.2.4  merge feat-v1.2.4-3  commit id: &quot;fix branch3 v1.2.3&quot;  # 定期维护所有分支 release-v1.2.4 和 main 的关系，进行一次 merge  checkout main  merge release-v1.2.3  merge release-v1.2.4  commit id: &quot;PeriodMerge $timestamp4&quot; tag: &quot;PeriodMerge$timestamp4&quot;    # 启动一个新版本时先打 tag 方便随后切分支  commit id: &quot;fix branch main $timestamp3&quot; tag: &quot;init v1.2.5&quot;    # 签分支启动版本 release-v1.2.5  branch release-v1.2.5  commit id: &quot;release-v1.2.5 init&quot;  checkout main  merge release-v1.2.5    # release-v1.2.5 上开发 F 功能  branch feat-v1.2.5-1  commit id: &quot;feat-v1.2.5-1 init&quot;  commit id: &quot;F1&quot;  # ,,,  </code></pre><h3 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h3><pre><code class=" mermaid">    %%&#123;init: &#123; &#x27;logLevel&#x27;: &#x27;debug&#x27;, &#x27;theme&#x27;: &#x27;default&#x27; , &#x27;themeVariables&#x27;: &#123;        &#x27;gitBranchLabel0&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel1&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel2&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel3&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel4&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel5&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel6&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel7&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel8&#x27;: &#x27;#ffffff&#x27;,        &#x27;gitBranchLabel9&#x27;: &#x27;#ffffff&#x27;  &#125; &#125; &#125;%%gitGraph  # 初始化组件代码仓库  checkout main  commit  branch feat-init  commit id: &quot;A1&quot; type: NORMAL  commit id: &quot;A2&quot; type: NORMAL  commit id: &quot;A3&quot; type: NORMAL  checkout main  merge feat-init    # 启动一个新版本时先打 tag 方便随后切分支  commit id: &quot;fix branch main timestamp1&quot; tag: &quot;init v1.2.3&quot;    # 签新版本分支，从 main 中  branch release-v1.2.3    # 签版本分支后先进行新分支的维护，并与 main 进行一次初步合并  commit id: &quot;v1.2.3 init&quot;  checkout main  merge release-v1.2.3  checkout release-v1.2.3    # feat-v1.2.3-1, fix-v1.2.3-x 同时进行，一个修复 bug，一个开发新功能  branch feat-v1.2.3-1  commit id: &quot;feat-v1.2.3-1 init&quot;    # release-v1.2.3 开始修复 A 功能 bug  branch fix-v1.2.3-x  commit id: &quot;fix-v1.2.3-x init&quot;  commit id: &quot;Fix A 1&quot;  commit id: &quot;Fix A 2&quot;  commit id: &quot;Fix A 3&quot;  checkout feat-v1.2.3-1    # release-v1.2.3 开发 B 功能   commit id: &quot;B1&quot;  commit id: &quot;B2&quot;  commit id: &quot;B3&quot;  checkout release-v1.2.3  merge feat-v1.2.3-1    # release-v1.2.3 提交修复 A 功能 bug  merge fix-v1.2.3-x    # 定期维护 release-v1.2.3 和 main 的关系，进行一次 merge  checkout main  merge release-v1.2.3  commit id: &quot;PeriodMerge $timestamp1&quot; tag: &quot;PeriodMerge $timestamp1&quot;  checkout release-v1.2.3    # release-v1.2.3 开发 C 功能  branch feat-v1.2.3-2  commit id: &quot;C1&quot;  commit id: &quot;C2&quot;  commit id: &quot;C3&quot;  checkout release-v1.2.3  merge feat-v1.2.3-2    # 定期维护 release-v1.2.3 和 main 的关系，进行一次 merge  checkout main  merge release-v1.2.3  commit id: &quot;PeriodMerge $timestamp2&quot; tag: &quot;PeriodMerge $timestamp2&quot;  checkout release-v1.2.3  commit id: &quot;something 1&quot;  commit id: &quot;something 2&quot;  # release-v1.2.3 继续维护 ... 直到维护周期结束  # 启动一个新版本时先打 tag 方便随后切分支  checkout main  commit id: &quot;fix branch main timestamp2&quot; tag: &quot;init v1.2.4&quot;    # 签版本分支，从 main 中  branch release-v1.2.4    # 签版本分支后先进行新分支的维护，并与 main 进行一次初步合并  commit id: &quot;v1.2.4 init&quot;  checkout main  merge release-v1.2.4  checkout release-v1.2.4  # release-v1.2.4 开始开发新功能  branch feat-v1.2.4-1  commit id: &quot;feat-v1.2.4-1 init&quot;  commit id: &quot;D1&quot;  commit id: &quot;D2&quot;  commit id: &quot;D3&quot;  checkout release-v1.2.4  merge feat-v1.2.4-1    # 这时生产 release-v1.2.3 出现 A 功能 bug4    # 先紧急解决 release-v1.2.3 问题，验证完合并代码  checkout release-v1.2.3  branch fix-v1.2.3-y  commit id: &quot;fix-v1.2.3-y init&quot;  commit id: &quot;Fix A 4 release-v1.2.3&quot;  checkout release-v1.2.3  merge fix-v1.2.3-y    # 再解决现有其他分支问题，目前 main 和 release-v1.2.4 也有同样的问题，想办法将 main 和 release-v1.2.4 分支中 A bug4 解决  # 方案：（不一定是这个方案，具体问题具体选择方案解决）合并 release-v1.2.3 和 release-v1.2.4, main 单独解决，定期维护时再解决部分冲突  # 方案 一： main release-v1.2.3 release-v1.2.4 关于 A 功能代码相似度较高，就直接合并代码  # 方案 二： release-v1.2.3 main 代码相似度低，main release-v1.2.4 相似度高 这种情况用上面方案  # 方案 三： release-v1.2.3 main release-v1.2.4 相似度都低，都分别 commit，等定期维护时 merge 分别维护 A 功能代码  # 方案 四： release-v1.2.3 release-v1.2.4 相似度高，与 main 相似度低，release 之间 merge，main 单独维护 A 功能代码（甚至去掉 A 功能代码）  checkout release-v1.2.4  merge release-v1.2.3  checkout main  branch fix-main-A-4  commit id: &quot;fix-main-A-4 init&quot;  commit id: &quot;Fix A 4 main&quot;  checkout main  merge fix-main-A-4    # release-v1.2.4 继续开发功能 E  checkout release-v1.2.4  branch feat-v1.2.4-2  commit id: &quot;feat-v1.2.4-2 init&quot;  commit id: &quot;E1&quot;  commit id: &quot;E2&quot;  commit id: &quot;E3&quot;  checkout release-v1.2.4  merge feat-v1.2.4-2    # 定期维护 release-v1.2.3 和 main 的关系，进行一次 merge  checkout main  merge release-v1.2.4  commit id: &quot;PeriodMerge $timestamp3&quot; tag: &quot;PeriodMerge $timestamp3&quot;    # 切分支继续开发 release-v1.2.4  checkout release-v1.2.4  branch feat-v1.2.4-3  commit id: &quot;feat-v1.2.4-3&quot;  commit id: &quot;D4&quot;  commit id: &quot;D5&quot;  commit id: &quot;D6&quot;  checkout release-v1.2.4  merge feat-v1.2.4-3  commit id: &quot;fix branch3 v1.2.3&quot;  # 定期维护所有分支 release-v1.2.4 和 main 的关系，进行一次 merge  checkout main  merge release-v1.2.3  merge release-v1.2.4  commit id: &quot;PeriodMerge $timestamp4&quot; tag: &quot;PeriodMerge$timestamp4&quot;    # 启动一个新版本时先打 tag 方便随后切分支  commit id: &quot;fix branch main $timestamp3&quot; tag: &quot;init v1.2.5&quot;    # 签分支启动版本 release-v1.2.5  branch release-v1.2.5  commit id: &quot;release-v1.2.5 init&quot;  checkout main  merge release-v1.2.5    # release-v1.2.5 上开发 F 功能  branch feat-v1.2.5-1  commit id: &quot;feat-v1.2.5-1 init&quot;  commit id: &quot;F1&quot;  # ,,,</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>转测报告影响范围写作思路.md</title>
    <link href="/2023/11/08/mdstorage/project/sr/%E8%BD%AC%E6%B5%8B%E6%8A%A5%E5%91%8A%E5%BD%B1%E5%93%8D%E8%8C%83%E5%9B%B4%E5%86%99%E4%BD%9C%E6%80%9D%E8%B7%AF/"/>
    <url>/2023/11/08/mdstorage/project/sr/%E8%BD%AC%E6%B5%8B%E6%8A%A5%E5%91%8A%E5%BD%B1%E5%93%8D%E8%8C%83%E5%9B%B4%E5%86%99%E4%BD%9C%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>影响范围通常描述了改动点可能影响到的系统其他部分，包括与改动点直接或间接相关的模块、功能、接口等。在编写转测报告的测试内容&#x2F;范围时，应包括一部分对可能受到影响的范围进行说明，以便测试团队能够进行充分的回归测试和验证。以下是如何编写影响范围的示例：</p><h3 id="影响范围："><a href="#影响范围：" class="headerlink" title="影响范围："></a>影响范围：</h3><p>本次转测所涉及的改动对以下系统部分可能产生影响：</p><ol><li><strong>前端用户界面：</strong><ul><li>改动的授权流程影响到前端界面交互，新增的授权申请，授权申请文件下载是新的交互方式。</li><li>改动的授权流程影响到前端界面的展示，变更授权文件导入为授权许可文件导入，授权许可文件的内容和授权许可文件导入后的前后端逻辑都发生了改变，务必要参考需求文档对照测试。</li></ul></li><li><strong>后端服务：</strong><ul><li>新增了授权申请，后端数据库新增了多个表来记录相关内容，从而可能影响到系统兼容性。</li><li>将授权文件机制改为授权许可文件机制后，数据结构发生重构，数据库中的字段也发生改变，后端的校验文件的逻辑也变更了，需要对照需求文档对照测试。</li><li>并发操作场景下，正常的功能操作可能会发生未知的结果，需要测试验证。</li></ul></li><li><strong>API接口：</strong><ul><li>优化的软件授权包机制，导致插件下发绑定接口发生了变化，需要测试插件下发绑定系列操作。</li><li>优化的软件授权包机制，导致引擎生成、展示、安装接口发生了变化，需要测试引擎展示、安装、升级包导入、授权许可文件导入系列操作。</li><li>变动的授权流程，导致权限控制的接口发生变更，测试用户权限方面的影响。</li></ul></li><li><strong>其他组件（系统）：</strong><ul><li>会影响到引擎安装组件的逻辑发生变更，需要测试相关组件内容变更。</li><li>会影响到引擎管理面的 webserver 对于引擎授权、插件授权方面。</li></ul></li><li><strong>系统性能：</strong><ul><li>授权流程中会触发系统各项信息采集，理论上增加了一部分计算逻辑和内存少量占用，但是优化了软件授权包的生成机制，所以预期呈现的资源占用表现是降低了。</li></ul></li><li><strong>版本升级兼容性：</strong><ul><li>授权流程调整后，从2.1.9版本升级成2.2.0版本就会立即进入授权失效的状态，要用户使用新的授权流程进行重新授权。不影响到用户的业务使用。</li></ul></li></ol><p>建议测试团队根据上述潜在的影响范围，制定详细的测试计划，并对影响较大的区域进行集中测试。此外，特别注意与这些区域相交互的边缘情况和异常流程，确保系统的健壮性和稳定性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>sr</tag>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运维的必要性.md</title>
    <link href="/2023/11/08/mdstorage/project/sr/%E8%BF%90%E7%BB%B4%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/"/>
    <url>/2023/11/08/mdstorage/project/sr/%E8%BF%90%E7%BB%B4%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h4 id="团队运维缺失案例"><a href="#团队运维缺失案例" class="headerlink" title="团队运维缺失案例"></a>团队运维缺失案例</h4><h5 id="团队资产管理"><a href="#团队资产管理" class="headerlink" title="团队资产管理"></a>团队资产管理</h5><ul><li>机器资产：目前是由项目经理和技术部建立一个群，需要提前申请机器，申请机器沟通繁琐。</li><li>证书资产：目前团队需要一个一个团队的证书 CA 机构来统一管理研发团队的证书，多次沟通推进困难。 </li><li>gitlab ：目前 CI&#x2F;CD 无法支持，产品质量降低、团队的自动化测试效率非常低。</li><li>禅道 ： 禅道项目管理无人打理，有很多不合理的地方，如项目版本的概念现在用独立的项目; 缺少风险管理，知识库、禅道的功能也不齐全，现在没人解决。</li></ul><h5 id="技术部某次问题："><a href="#技术部某次问题：" class="headerlink" title="技术部某次问题："></a>技术部某次问题：</h5><ul><li><p>把搭建好的总控和引擎搬到另外一个独立的环境后，总控的控制台无法访问，打不开</p></li><li><p>我需要实现的是这套环境搬到任何地方都可以直接用</p></li></ul><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/image-20231108103322506.png" alt="image-20231108103322506"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pandoc自定义图床和服务.md</title>
    <link href="/2023/11/08/mdstorage/resource/typora_pandoc_picgo/pandoc%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E5%BA%8A%E5%92%8C%E6%9C%8D%E5%8A%A1/"/>
    <url>/2023/11/08/mdstorage/resource/typora_pandoc_picgo/pandoc%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E5%BA%8A%E5%92%8C%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="自定义图床服务"><a href="#自定义图床服务" class="headerlink" title="自定义图床服务"></a>自定义图床服务</h2><ul><li>环境要求<ul><li>linux</li><li>golang</li></ul></li><li>代码</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>    <span class="hljs-comment">// 文件 key</span><br>    uploadFileKey = <span class="hljs-string">&quot;file&quot;</span><br>    <span class="hljs-comment">// 上传的图片保存根路径</span><br>    filePath = <span class="hljs-string">&quot;/data/repo/picpicgo/&quot;</span><br>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, uploadHandler)<br>    <span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:12798&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatalf(<span class="hljs-string">&quot;error to start http server:%s&quot;</span>, err.Error())<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uploadHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// 接受文件</span><br>    file, header, err := r.FormFile(uploadFileKey)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// ignore the error handler</span><br>    &#125;<br>    log.Printf(<span class="hljs-string">&quot;selected file name is %s&quot;</span>, header.Filename)<br>    authValue := r.Header.Get(<span class="hljs-string">&quot;Authorization&quot;</span>)<br>    <span class="hljs-keyword">if</span> (authValue != <span class="hljs-string">&quot;Basic eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjp7ImlkIjoxLCJsb2NhbGUiOiJlbiIsInZpZXdNb2RlIjoibW9zYWljIiwic2luZ2xlQ2xpY2siOmZhbHNlLCJwZXJtIjp7ImFkbWluIjp0cnVlLCJleGVjdXRlIjp0cnVlLCJjcmVhdGUiOnRydWUsInJlbmFtZSI6dHJ1ZSwibW9kaWZ5Ijp0cnVlLCJkZWxldGUiOnRydWUsInNoYXJlIjp0cnVlLCJkb3dubG9hZCI6dHJ1ZX0sImNvbW1hbmRzIjpbXSwibG9ja1Bhc3N3b3JkIjpmYWxzZSwiaGlkZURvdGZpbGVzIjpmYWxzZSwiZGF0ZUZvcm1hdCI6ZmFsc2V9LCJpc3MiOiJGaWxlIEJyb3dzZXIiLCJleHAiOjE2OTkzNTUyNTMsImlhdCI6MTY5OTM0ODA1M30.xOF_H27bkI2qL0ozpDGWCJKOToegAzZjIk6edFWqZC0&quot;</span>) &#123;<br>        log.Printf(<span class="hljs-string">&quot;auth fail&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    path := filePath + r.Header.Get(<span class="hljs-string">&quot;Uri&quot;</span>)<br>    createFile(path)<br>    imgPath := path + header.Filename<br>    log.Printf(<span class="hljs-string">&quot;path is %s&quot;</span>, path)<br><br>    <span class="hljs-comment">// 将文件拷贝到指定路径下，或者其他文件操作</span><br>    dst, err := os.Create(imgPath)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatalf(<span class="hljs-string">&quot;create file error :%s&quot;</span>, err.Error())<br>        <span class="hljs-comment">// ignore</span><br>    &#125;<br>    _, err = io.Copy(dst, file)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatalf(<span class="hljs-string">&quot;copy file error :%s&quot;</span>, err.Error())<br>        <span class="hljs-comment">// ignore</span><br>    &#125;<br>    log.Printf(<span class="hljs-string">&quot;upload success&quot;</span>)<br>    io.WriteString(w, <span class="hljs-string">&quot;&#123;\&quot;code\&quot;: 0, \&quot;data\&quot;: &#123;\&quot;url\&quot;: \&quot;&quot;</span> + (r.Header.Get(<span class="hljs-string">&quot;ImgHost&quot;</span>) + r.Header.Get(<span class="hljs-string">&quot;Uri&quot;</span>) + header.Filename ) + <span class="hljs-string">&quot;\&quot;&#125;&#125;&quot;</span>)<br>&#125;<br><br><br><span class="hljs-comment">//调用os.MkdirAll递归创建文件夹</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createFile</span><span class="hljs-params">(filePath <span class="hljs-type">string</span>)</span></span>  <span class="hljs-type">error</span>  &#123;<br>    <span class="hljs-keyword">if</span> !isExist(filePath) &#123;<br>        err := os.MkdirAll(filePath,os.ModePerm)<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 判断所给路径文件/文件夹是否存在(返回true是存在)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isExist</span><span class="hljs-params">(path <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    _, err := os.Stat(path)    <span class="hljs-comment">//os.Stat获取文件信息</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> os.IsExist(err) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>service</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs systemd">[Unit]<br>Description=picgo-server<br><br>[Service]<br>ExecStart=/opt/picgo-server/picgo-server<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><h2 id="pandoc-自定义图床"><a href="#pandoc-自定义图床" class="headerlink" title="pandoc 自定义图床"></a>pandoc 自定义图床</h2><ul><li>web-uploader 1.1.1 下载安装<ul><li>插件设置 -&gt; 搜索下载即可</li></ul></li><li>web-uploader 配置<ul><li><a href="https://mafgwo.cn/2021/01/16/2010_PicGo%E7%94%A8golang%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E5%BA%8A%E4%B8%8A%E4%BC%A0%E6%9C%8D%E5%8A%A1/">参考链接</a> </li><li>API 地址 ： <a href="http://119.91.145.27:12798/">http://119.91.145.27:12798/</a></li><li>POST参数名 ： file</li><li>JSON路径 ： data.url （这个是上传接口返回值的 url 的值，对照上面代码就明白了）</li><li>自定义请求头 ： {“Authorization”:”Basic eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjp7ImlkIjoxLCJsb2NhbGUiOiJlbiIsInZpZXdNb2RlIjoibW9zYWljIiwic2luZ2xlQ2xpY2siOmZhbHNlLCJwZXJtIjp7ImFkbWluIjp0cnVlLCJleGVjdXRlIjp0cnVlLCJjcmVhdGUiOnRydWUsInJlbmFtZSI6dHJ1ZSwibW9kaWZ5Ijp0cnVlLCJkZWxldGUiOnRydWUsInNoYXJlIjp0cnVlLCJkb3dubG9hZCI6dHJ1ZX0sImNvbW1hbmRzIjpbXSwibG9ja1Bhc3N3b3JkIjpmYWxzZSwiaGlkZURvdGZpbGVzIjpmYWxzZSwiZGF0ZUZvcm1hdCI6ZmFsc2V9LCJpc3MiOiJGaWxlIEJyb3dzZXIiLCJleHAiOjE2OTkzNTUyNTMsImlhdCI6MTY5OTM0ODA1M30.xOF_H27bkI2qL0ozpDGWCJKOToegAzZjIk6edFWqZC0”, “uri”: “”, “imgHost”: “<a href="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/%22%7D">http://119.91.145.27:12799/api/public/dl/p8KdAUHH/&quot;}</a>    (对照上面代码就明白了)</li><li>自定义 Body ： 无</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>typora_pandoc_picgo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mermaid.md</title>
    <link href="/2023/11/04/mdstorage/domain/%E6%96%87%E6%A1%A3/mermaid/"/>
    <url>/2023/11/04/mdstorage/domain/%E6%96%87%E6%A1%A3/mermaid/</url>
    
    <content type="html"><![CDATA[<h2 id="mindmap"><a href="#mindmap" class="headerlink" title="mindmap"></a>mindmap</h2><p>不支持样式微调：如线条颜色、节点颜色</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
      <tag>mermaid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周会议程-11.3.md</title>
    <link href="/2023/11/03/mdstorage/project/sr/%E5%91%A8%E4%BC%9A%E8%AE%AE%E7%A8%8B-11.3/"/>
    <url>/2023/11/03/mdstorage/project/sr/%E5%91%A8%E4%BC%9A%E8%AE%AE%E7%A8%8B-11.3/</url>
    
    <content type="html"><![CDATA[<h1 id="周会议程"><a href="#周会议程" class="headerlink" title="周会议程"></a>周会议程</h1><h2 id="开场白"><a href="#开场白" class="headerlink" title="开场白"></a>开场白</h2><ul><li><strong>时间</strong>：2023&#x2F;11&#x2F;3</li><li><strong>地点</strong>：培训室</li><li><strong>参与人员</strong>：全体 Golang 组员</li><li><strong>会议主题</strong>：增强团队协作和项目开发管理回顾</li><li><strong>会议时长</strong>：1 小时内</li></ul><h2 id="一、-转测流程培训"><a href="#一、-转测流程培训" class="headerlink" title="一、 转测流程培训"></a>一、 转测流程培训</h2><ul><li><strong>目的</strong>：确保团队成员理解并能够有效实施软件的转测流程。</li><li><strong>内容</strong>：<ul><li>流程概述</li><li>关键步骤详解</li><li>常见问题及解决方案</li></ul></li></ul><h2 id="二、-任务管理与评估"><a href="#二、-任务管理与评估" class="headerlink" title="二、 任务管理与评估"></a>二、 任务管理与评估</h2><h3 id="2-1-任务评估回顾"><a href="#2-1-任务评估回顾" class="headerlink" title="2.1 任务评估回顾"></a>2.1 任务评估回顾</h3><ul><li><strong>目标</strong>：识别评估过程中的问题，减少项目延期。</li><li><strong>议程</strong>：<ul><li>回顾上周的任务评估准确性</li><li>分析延期的任务和原因（不深入讨论个别任务）</li></ul></li></ul><h3 id="2-2-变动的评估项"><a href="#2-2-变动的评估项" class="headerlink" title="2.2 变动的评估项"></a>2.2 变动的评估项</h3><ul><li><strong>目标</strong>：提高团队评估新变动的能力。</li><li><strong>议程</strong>：<ul><li>梳理新加入的任务和变动<ul><li>授权包改动（需求、合理性决定）</li></ul></li><li>探讨如何准确评估这些变动的影响</li></ul></li></ul><h3 id="2-3-延期任务回顾"><a href="#2-3-延期任务回顾" class="headerlink" title="2.3 延期任务回顾"></a>2.3 延期任务回顾</h3><ul><li><p><strong>目标</strong>：分析导致延期的因素，寻找解决方案。</p></li><li><p><strong>议程</strong>：</p><ul><li>总结延期原因<ul><li><p>插入新任务（调研和设计时没考虑清楚，决策得不合理）</p></li><li><p>任务没有理清楚</p></li><li><p>人员调动 （插件人员调动）</p></li><li><p>数据面延期导致无法联调延期</p></li><li><p>联调时间没把控好（缺失联调培训和流程）</p></li><li><p>需求变更</p></li><li><p>自测时间未能评估准确</p></li></ul></li></ul></li></ul><h3 id="2-4-风险项回顾"><a href="#2-4-风险项回顾" class="headerlink" title="2.4 风险项回顾"></a>2.4 风险项回顾</h3><ul><li><strong>目标</strong>：分析和回顾当前的风险项，提前规划风险应对措施。</li><li><strong>议程</strong>：<ul><li>确定风险清单</li><li>分享风险管理策略</li></ul></li></ul><h3 id="2-5-本周改进点回顾"><a href="#2-5-本周改进点回顾" class="headerlink" title="2.5 本周改进点回顾"></a>2.5 本周改进点回顾</h3><ul><li><strong>目标</strong>：看到问题、争取改进</li><li><ul><li><p>每位团队成员分享两个他们认为本周做得不够好的点，限于描述现象，不涉及原因分析</p></li><li><p>收集所有问题点，用于未来的改进会议讨论</p></li><li><ul><li><p>人员调动，不合理</p></li><li><p>禅道任务项目管理没跟踪-更新</p></li><li><p>需求不合理、产品变更需求文档后未通知项目经理</p></li><li><p>岗位职责未清</p></li><li><p>联调时遇到问题、项目经理也需要反馈给到开发</p></li><li><p>企微已读不回</p></li><li><p>某功能开发的进度管理缺失</p></li><li><p>开发周期太短、评估时间长了会想压缩</p></li><li><p>禅道版本太低、gitlab、CICD、wiki 等基础设施简陋</p></li><li><p>调研拆细、分给大家</p></li><li><p>开发自测还要松达帮忙打包</p></li><li><p>开发不知道这套系统的部署</p></li><li><p>没有整个系统的操作指引</p></li><li><p>项目开发节奏太紧、项目版本的节点设置不合理</p></li><li><p>插件开发周期太紧、测试的 bug 需要排优先级</p></li><li><p>联调插件前期沟通没做好</p></li><li><p>代码不规范</p></li><li><p>代码 review 缺失</p></li><li></li><li><p>大家沟通不够</p><ul><li>反馈</li><li>回应</li></ul></li></ul></li></ul></li></ul><h2 id="事项宣布"><a href="#事项宣布" class="headerlink" title="事项宣布"></a>事项宣布</h2><ul><li><p>紧急生产任务响应</p><p>当发生生产问题时，不论时间地点，需要及时响应，尽量配合到达公司或是去客户现场。下班时间算调休。（1. 餐补、补助等 2. 值班表是否需要）</p></li><li><p>下发问题项响应</p><p>当下发了问题项时到人后，定位到是自己责任的，反馈给项目经理确定解决时间，定位到非自己责任的，需要反馈项目经理讲明，不能不是自己问题就什么都不回。</p></li><li><p>下版本加强禅道项目周期管理</p></li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><ul><li><strong>小结</strong>：回顾会议要点，强调学习和改进的重要性。</li><li><strong>行动项</strong>：分配任务，明确下一步行动计划。</li><li><strong>感谢</strong>：对团队的努力和贡献表示感谢。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>周会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>风险清单.md</title>
    <link href="/2023/11/03/mdstorage/project/sr/%E9%A3%8E%E9%99%A9%E6%B8%85%E5%8D%95/"/>
    <url>/2023/11/03/mdstorage/project/sr/%E9%A3%8E%E9%99%A9%E6%B8%85%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h1 id="风险管理计划"><a href="#风险管理计划" class="headerlink" title="风险管理计划"></a>风险管理计划</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><h3 id="1-1-目的"><a href="#1-1-目的" class="headerlink" title="1.1 目的"></a>1.1 目的</h3><p>说明风险管理计划的目标，以及如何帮助项目团队识别、评估和控制风险。</p><h3 id="1-2-范围"><a href="#1-2-范围" class="headerlink" title="1.2 范围"></a>1.2 范围</h3><p>定义本风险管理计划适用的项目范围和阶段。</p><h3 id="1-3-参考文献"><a href="#1-3-参考文献" class="headerlink" title="1.3 参考文献"></a>1.3 参考文献</h3><p>列出编制风险管理计划时参考的文件或标准。</p><h2 id="2-风险管理方法"><a href="#2-风险管理方法" class="headerlink" title="2. 风险管理方法"></a>2. 风险管理方法</h2><h3 id="2-1-方法论"><a href="#2-1-方法论" class="headerlink" title="2.1 方法论"></a>2.1 方法论</h3><p>描述将采用的风险管理方法论，包括风险识别、评估、响应计划、监测和控制。</p><h3 id="2-2-工具和技术"><a href="#2-2-工具和技术" class="headerlink" title="2.2 工具和技术"></a>2.2 工具和技术</h3><p>列出用于风险管理的工具和技术。</p><h2 id="3-角色和责任"><a href="#3-角色和责任" class="headerlink" title="3. 角色和责任"></a>3. 角色和责任</h2><h3 id="3-1-风险管理团队"><a href="#3-1-风险管理团队" class="headerlink" title="3.1 风险管理团队"></a>3.1 风险管理团队</h3><p>确定风险管理团队的成员及其职责。</p><h3 id="3-2-责任分配"><a href="#3-2-责任分配" class="headerlink" title="3.2 责任分配"></a>3.2 责任分配</h3><p>说明项目团队内每个人在风险管理过程中的角色和责任。</p><h2 id="4-风险识别"><a href="#4-风险识别" class="headerlink" title="4. 风险识别"></a>4. 风险识别</h2><h3 id="4-1-风险分类"><a href="#4-1-风险分类" class="headerlink" title="4.1 风险分类"></a>4.1 风险分类</h3><h4 id="需求风险"><a href="#需求风险" class="headerlink" title="需求风险"></a>需求风险</h4><p>​    需求的频繁变更导致的工作重复。<br>​    不明确或模糊的需求。<br>​    错误或遗漏的需求。</p><h4 id="沟通与协作风险"><a href="#沟通与协作风险" class="headerlink" title="沟通与协作风险:"></a>沟通与协作风险:</h4><p>​    团队成员间、团队与其他团队、团队与利益相关者之间的沟通障碍。<br>​    对外部团队或组织的依赖导致的沟通障碍。</p><h4 id="技术风险"><a href="#技术风险" class="headerlink" title="技术风险"></a>技术风险</h4><p>​    采用新技术或工具可能导致的问题。<br>​    与现有系统的集成问题。<br>​    性能、安全性和可靠性问题。</p><h4 id="人员风险"><a href="#人员风险" class="headerlink" title="人员风险:"></a>人员风险:</h4><p>​    关键人员的离职或长期（&gt;2天）缺席。<br>​    团队成员技能或经验不足。</p><h4 id="时间与资源风险"><a href="#时间与资源风险" class="headerlink" title="时间与资源风险:"></a>时间与资源风险:</h4><p>​    评估不准确，导致时间不足。<br>​    资源（如开发者或设备）不足或不可用。<br>​    对其他团队或外部组织的依赖导致的延迟。</p><h4 id="质量风险"><a href="#质量风险" class="headerlink" title="质量风险:"></a>质量风险:</h4><p>​    代码或产品中的缺陷。<br>​    不足的测试或不恰当的测试策略。<br>​    缺乏合适的质量保证措施。</p><h3 id="4-2-风险登记册"><a href="#4-2-风险登记册" class="headerlink" title="4.2 风险登记册"></a>4.2 风险登记册</h3><ul><li>授权包逻辑改动，需要重构部分代码，自测和对接工作量较大 – 吴松达 11&#x2F;2</li><li>授权功能改动较大，可能无法在3号无法完成整体流程的完整性测试 – 袁松壑 11&#x2F;2</li><li>授权生成授权包机制进行了优化，可能会影响一点引擎安装方面进度 – xiaoy 11&#x2F;2</li><li>需求遗漏告警日志开关，影响告警合并策略的判断逻辑 – 韩志凯 10&#x2F;31</li><li>对接事项过多，对接时长过长，挤兑开发时间  – 11&#x2F;1 吴松达</li><li>授权功能开发有严重的逾期风险 – 吴松达 11&#x2F;1</li><li>waf插件其他人不知何时完成配合整体提测时间未知 – 11&#x2F;1 范众星</li><li>通知内容发生需求变更，目前整体进度有些滞后  – 韩志凯 10&#x2F;31</li></ul><ol start="2"><li>api风险和业务健康告警sv侧需要推迟两天左右开始 – 韩志凯 10&#x2F;31</li></ol><h1 id="风险管理计划-1"><a href="#风险管理计划-1" class="headerlink" title="风险管理计划"></a>风险管理计划</h1><h2 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><h3 id="1-1-目的-1"><a href="#1-1-目的-1" class="headerlink" title="1.1 目的"></a>1.1 目的</h3><p>本风险管理计划的目标是确保项目团队能够有效识别、评估和控制项目中的风险，以避免潜在的负面影响。</p><h3 id="1-2-范围-1"><a href="#1-2-范围-1" class="headerlink" title="1.2 范围"></a>1.2 范围</h3><p>本计划覆盖从项目启动到交付的所有阶段，重点是授权功能的重构、测试和优化过程。</p><h3 id="1-3-参考文献-1"><a href="#1-3-参考文献-1" class="headerlink" title="1.3 参考文献"></a>1.3 参考文献</h3><ul><li>项目开发流程标准</li><li>代码审查规范</li></ul><h2 id="2-风险管理方法-1"><a href="#2-风险管理方法-1" class="headerlink" title="2. 风险管理方法"></a>2. 风险管理方法</h2><h3 id="2-1-方法论-1"><a href="#2-1-方法论-1" class="headerlink" title="2.1 方法论"></a>2.1 方法论</h3><p>项目团队将采用迭代识别、分析、响应和监控风险的方法，确保及时识别新风险，并对既定风险做出有效响应。</p><h3 id="2-2-工具和技术-1"><a href="#2-2-工具和技术-1" class="headerlink" title="2.2 工具和技术"></a>2.2 工具和技术</h3><ul><li>风险登记册</li><li>项目管理软件</li><li>定期风险评审会议</li></ul><h2 id="3-角色和责任-1"><a href="#3-角色和责任-1" class="headerlink" title="3. 角色和责任"></a>3. 角色和责任</h2><h3 id="3-1-风险管理团队-1"><a href="#3-1-风险管理团队-1" class="headerlink" title="3.1 风险管理团队"></a>3.1 风险管理团队</h3><ul><li>吴松达 - 授权功能重构与自测</li><li>袁松壑 - 授权功能完整性测试</li><li>xiaoy - 总控项目周期进度监控</li><li>宋燚 - 引擎、API项目周期进度监控</li><li>韩志凯 - 告警日志开关需求和通知内容变更管理</li><li>范众星 - 引擎插件进度协调</li><li>丁院红 - 可视化模块负责人</li><li>朱琼婷 - 可视化部分模块开发</li><li>黄育梦 - HA功能负责人、API盘点功能开发</li><li>蔡向阳 - 技术顾问、API盘点功能开发</li><li>岑思华 - 技术顾问、授权|镜像交付部分功能设计调研</li></ul><h3 id="3-2-责任分配-1"><a href="#3-2-责任分配-1" class="headerlink" title="3.2 责任分配"></a>3.2 责任分配</h3><p>每位团队成员负责监控和管理指定的风险领域，并在定期的风险评审会议中报告风险状态。</p><h2 id="4-风险识别-1"><a href="#4-风险识别-1" class="headerlink" title="4. 风险识别"></a>4. 风险识别</h2><ul><li><h3 id="4-1-风险分类-1"><a href="#4-1-风险分类-1" class="headerlink" title="4.1 风险分类"></a>4.1 风险分类</h3><h4 id="需求风险-1"><a href="#需求风险-1" class="headerlink" title="需求风险"></a>需求风险</h4><p>​    需求的频繁变更导致的工作重复。<br>​    不明确或模糊的需求。<br>​    错误或遗漏的需求。</p><h4 id="沟通与协作风险-1"><a href="#沟通与协作风险-1" class="headerlink" title="沟通与协作风险:"></a>沟通与协作风险:</h4><p>​    团队成员间、团队与其他团队、团队与利益相关者之间的沟通障碍。<br>​    对外部团队或组织的依赖导致的沟通障碍。</p><h4 id="技术风险-1"><a href="#技术风险-1" class="headerlink" title="技术风险"></a>技术风险</h4><p>​    采用新技术或工具可能导致的问题。<br>​    与现有系统的集成问题。<br>​    性能、安全性和可靠性问题。</p><h4 id="人员风险-1"><a href="#人员风险-1" class="headerlink" title="人员风险:"></a>人员风险:</h4><p>​    关键人员的离职或长期（&gt;2天）缺席。<br>​    团队成员技能或经验不足。</p><h4 id="时间与资源风险-1"><a href="#时间与资源风险-1" class="headerlink" title="时间与资源风险:"></a>时间与资源风险:</h4><p>​    评估不准确，导致时间不足。<br>​    资源（如开发者或设备）不足或不可用。<br>​    对其他团队或外部组织的依赖导致的延迟。</p><h4 id="质量风险-1"><a href="#质量风险-1" class="headerlink" title="质量风险:"></a>质量风险:</h4><p>​    代码或产品中的缺陷。<br>​    不足的测试或不恰当的测试策略。<br>​    缺乏合适的质量保证措施。</p></li></ul><h3 id="4-2-风险登记册-1"><a href="#4-2-风险登记册-1" class="headerlink" title="4.2 风险登记册"></a>4.2 风险登记册</h3><p>风险登记册将被用来记录下述风险的详细信息。</p><h2 id="5-风险分析"><a href="#5-风险分析" class="headerlink" title="5. 风险分析"></a>5. 风险分析</h2><h3 id="5-1-定性分析"><a href="#5-1-定性分析" class="headerlink" title="5.1 定性分析"></a>5.1 定性分析</h3><p>所有风险将根据发生的可能性和影响进行评级和排序。</p><h3 id="5-2-定量分析"><a href="#5-2-定量分析" class="headerlink" title="5.2 定量分析"></a>5.2 定量分析</h3><p>将根据风险的严重性进行成本和时间的影响评估。</p><h2 id="6-风险响应计划"><a href="#6-风险响应计划" class="headerlink" title="6. 风险响应计划"></a>6. 风险响应计划</h2><h3 id="6-1-响应策略"><a href="#6-1-响应策略" class="headerlink" title="6.1 响应策略"></a>6.1 响应策略</h3><p>为列出的风险制定以下响应策略：</p><ul><li><strong>授权包逻辑改动和自测：</strong> 增派资源，实施代码重构的同时并行开展自测。</li><li><strong>完整性测试无法完成：</strong> 增加日常沟通频次，及早识别测试障碍，实施敏捷测试方法。</li><li><strong>授权生成优化影响进度：</strong> 安排冗余时间缓冲，定期跟进进度。</li><li><strong>需求遗漏与对接事项多：</strong> 进行需求复审，确保所有事项被纳入计划，优化对接流程。</li><li><strong>waf插件进度不确定：</strong> 与相关团队紧密沟通，明确进度和交付期限。</li><li><strong>api风险和业务健康告警延迟：</strong> 制定备用计划，提前安排资源准备。</li></ul><h3 id="6-2-应急计划"><a href="#6-2-应急计划" class="headerlink" title="6.2 应急计划"></a>6.2 应急计划</h3><p>对于无法避免的风险</p><p>，制定明确的应急计划，包括资源重新分配、进度调整和功能降级。</p><h2 id="7-风险监控"><a href="#7-风险监控" class="headerlink" title="7. 风险监控"></a>7. 风险监控</h2><h3 id="7-1-监控计划"><a href="#7-1-监控计划" class="headerlink" title="7.1 监控计划"></a>7.1 监控计划</h3><p>定期评审风险登记册，监控风险的变化并更新响应策略。</p><h3 id="7-2-审核计划"><a href="#7-2-审核计划" class="headerlink" title="7.2 审核计划"></a>7.2 审核计划</h3><p>项目管理办公室(PMO)将每两周审计一次风险管理活动。</p><h2 id="8-报告"><a href="#8-报告" class="headerlink" title="8. 报告"></a>8. 报告</h2><h3 id="8-1-报告模板"><a href="#8-1-报告模板" class="headerlink" title="8.1 报告模板"></a>8.1 报告模板</h3><p>风险报告将包括所有已识别风险的状态更新。</p><h3 id="8-2-报告频率"><a href="#8-2-报告频率" class="headerlink" title="8.2 报告频率"></a>8.2 报告频率</h3><p>风险报告将在每次风险评审会议后生成并分发给所有项目干系人。</p><h2 id="9-附录"><a href="#9-附录" class="headerlink" title="9. 附录"></a>9. 附录</h2><h3 id="9-1-风险登记册"><a href="#9-1-风险登记册" class="headerlink" title="9.1 风险登记册"></a>9.1 风险登记册</h3><table><thead><tr><th>风险ID</th><th>风险描述</th><th>影响</th><th>概率</th><th>负责人</th><th>响应策略</th><th>状态</th></tr></thead><tbody><tr><td>1</td><td>授权包逻辑改动，需要重构代码</td><td>高</td><td>高</td><td>吴松达</td><td>增派资源并行自测</td><td>监控中</td></tr><tr><td>2</td><td>授权功能大改动，可能影响完整性测试</td><td>高</td><td>中</td><td>袁松壑</td><td>增加日常沟通，提前测试</td><td>待处理</td></tr><tr><td>3</td><td>授权生成优化，影响引擎安装进度</td><td>中</td><td>高</td><td>xiaoy</td><td>定期进度更新，安排缓冲时间</td><td>监控中</td></tr><tr><td>4</td><td>遗漏告警日志开关，影响判断逻辑</td><td>中</td><td>高</td><td>韩志凯</td><td>需求复审，优化流程</td><td>已识别</td></tr><tr><td>5</td><td>对接事项多，影响开发时间</td><td>中</td><td>中</td><td>吴松达</td><td>优化对接流程，提高沟通效率</td><td>已识别</td></tr><tr><td>6</td><td>授权功能开发逾期风险</td><td>高</td><td>高</td><td>吴松达</td><td>制定缓冲计划，增派资源</td><td>待处理</td></tr><tr><td>7</td><td>waf插件进度不明确</td><td>中</td><td>高</td><td>范众星</td><td>沟通明确交付时间，进度监控</td><td>监控中</td></tr><tr><td>8</td><td>通知内容需求变更，进度滞后</td><td>中</td><td>中</td><td>韩志凯</td><td>需求变更管理，进度调整</td><td>待处理</td></tr><tr><td>9</td><td>api和业务告警开始推迟</td><td>中</td><td>中</td><td>韩志凯</td><td>提前安排资源，备用计划启动</td><td>待处理</td></tr></tbody></table><p>状态：“待处理”、“监控中”、“已解决”等。</p><h3 id="9-2-风险管理流程图"><a href="#9-2-风险管理流程图" class="headerlink" title="9.2 风险管理流程图"></a>9.2 风险管理流程图</h3><p>(此处可以插入一个风险管理的流程图，以便于团队理解流程。</p>]]></content>
    
    
    
    <tags>
      
      <tag>风险管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总控详细设计说明书.md</title>
    <link href="/2023/11/03/mdstorage/project/sr/sc/%E6%80%BB%E6%8E%A7%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E%E4%B9%A6/"/>
    <url>/2023/11/03/mdstorage/project/sr/sc/%E6%80%BB%E6%8E%A7%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="1-1-编写目的"><a href="#1-1-编写目的" class="headerlink" title="1.1 编写目的"></a>1.1 编写目的</h3><p>本文档的编写目的是详细阐述总控系统的软件架构、数据结构、接口设计、以及具体模块的实现细节。它旨在为项目开发团队提供清晰、详尽的设计细节，确保编码工作能够按照既定的设计方案高效执行，并为后期的维护和升级提供文档支持。</p><p>同时，此文档也是向项目利益相关者传达如何从技术层面满足业务需求的桥梁。此外，若项目规模较为简单或层次不多，本文档中的详细设计内容可以与概要设计说明书合并编写，以避免不必要的重复和冗余。</p><h3 id="1-2-背景"><a href="#1-2-背景" class="headerlink" title="1.2 背景"></a>1.2 背景</h3><p>A. 待开发软件系统名称：石犀总控系统。</p><p>B. 系统基本概念：石犀总控系统是一种企业级的流量集中管理和控制软件，并用于监控和管理计算资源、网络、存储。系统设计为 on-premise 部署模型，可能会成为 Iaas 服务模型，为终端用户提供一个简洁的操作界面和强大的后台引擎，实现资源的高效分配和自动化管理。</p><p>C. 开发项目组名称：石犀研发组。</p><h3 id="1-3-参考资料"><a href="#1-3-参考资料" class="headerlink" title="1.3 参考资料"></a>1.3 参考资料</h3><ol><li>《云原生安全：攻防实践与体系构建》 刘文懋</li></ol><h3 id="1-4-术语定义及说明"><a href="#1-4-术语定义及说明" class="headerlink" title="1.4 术语定义及说明"></a>1.4 术语定义及说明</h3><ul><li><p><strong>总控系统 (StoneRhino Control System)</strong>: 该系统是本项目开发的核心软件组件，它负责统筹管理各种引擎和插件的操作，确保系统整体运行的效率和安全性。</p></li><li><p><strong>流量引擎 (Traffic Engine)</strong>: 流量引擎主要负责网络流量的路由和转发。它处理入站和出站的数据流量，根据预定义的规则和策略，确保数据包正确快速地达到目的地。</p></li><li><p><strong>边车引擎 (Sidecar Engine)</strong>: 边车引擎负责在微服务架构中收集链路追踪信息。它通常作为每个服务实例的附属部分运行，提供对网络通信的透明监控和控制，以及故障排除和性能分析的能力。</p></li><li><p><strong>路由引擎 (Routing Engine)</strong>: 路由引擎提供软件路由器功能，它决定数据包的最优路径，处理网络地址转换和流量管理。它允许在不同网络和子网间进行高效的数据传输。</p></li><li><p><strong>插件 (Plugin)</strong>: 插件是一种软件组件，设计为在不需要修改主体程序代码的情况下增加新的功能。它们在总控系统中扮演重要角色，使得系统可以通过添加插件来扩展新的功能或提升现有功能的性能。</p></li><li><p><strong>授权 (Authorization)</strong>: 授权是指在系统中实施的一种安全机制，它确保只有被授权的个体可以执行特定操作或访问特定资源。在总控系统中，授权过程是验证用户或系统是否具备执行某个请求操作的权限的过程。</p></li></ul><h2 id="2-设计概述"><a href="#2-设计概述" class="headerlink" title="2 设计概述"></a>2 设计概述</h2><h3 id="2-1-任务和目标"><a href="#2-1-任务和目标" class="headerlink" title="2.1 任务和目标"></a>2.1 任务和目标</h3><p>本详细设计说明书的主要任务是确保总控系统的设计符合项目的业务需求和性能指标，同时满足系统的扩展性、可维护性和安全性需求。设计的最终目标是提供一个详细的系统实现蓝图，包括数据结构、模块构造、接口设计以及数据流和控制流等方面的设计细节。</p><h4 id="2-1-1-需求概述"><a href="#2-1-1-需求概述" class="headerlink" title="2.1.1 需求概述"></a>2.1.1 需求概述</h4><p>所开发的总控系统旨在提供一个高效、安全且可靠的网络流量控制和服务监控解决方案。主要业务需求包括但不限于：</p><ul><li>网络流量的智能路由和负载均衡</li><li>微服务架构中的服务发现与链路追踪</li><li>系统级别的性能监控与日志管理</li><li>高度可配置的授权与安全机制</li></ul><p>系统性能需求包括：</p><ul><li>高吞吐量和低延迟的数据处理能力</li><li>稳定的服务响应时间，即使在负载峰值时也要保持性能</li><li>高可用性和故障转移能力</li></ul><h4 id="2-1-2-运行环境概述"><a href="#2-1-2-运行环境概述" class="headerlink" title="2.1.2 运行环境概述"></a>2.1.2 运行环境概述</h4><p>总控系统将支持跨平台部署，运行环境需求如下：</p><ul><li><strong>操作系统</strong>: 支持主流操作系统 Ubuntu 等</li></ul><p>系统配置要求将根据性能测试结果进一步定义。</p><h4 id="2-1-3-条件与限制"><a href="#2-1-3-条件与限制" class="headerlink" title="2.1.3 条件与限制"></a>2.1.3 条件与限制</h4><p>系统设计受到以下条件和限制的约束：</p><ul><li>必须遵守相关的数据保护和隐私法规</li><li>系统的扩展性和可维护性不应受限于特定的硬件或平台</li><li>性能优化不得牺牲系统的安全性和稳定性</li><li>系统必须能够快速适应不断变化的业务需求</li><li>项目进度上必须符合预定的里程碑和交付日期</li></ul><h4 id="2-1-4-详细设计方法和工具"><a href="#2-1-4-详细设计方法和工具" class="headerlink" title="2.1.4 详细设计方法和工具"></a>2.1.4 详细设计方法和工具</h4><p>详细设计将采用面向对象的设计方法，并利用UML（统一建模语言）进行数据建模和流程描述。选用的CASE（计算机辅助软件工程）工具包括但不限于Visual Paradigm，以支持各种UML图表的创建，如类图、序列图和活动图等。数据流程图和业务流程图将使用BPMN（业务流程模型和符号）标准进行描述。所有设计工作将严格遵循业界标准和最佳实践。</p><p>设计团队将使用版本控制系统 Git 来管理源代码，确保设计开发过程的协同和追溯性。此外，设计阶段还将采用静态代码分析和持续集成工具，以提高代码质量和设计实现的一致性。</p><pre><code class=" mermaid">graph TD    subgraph 总控系统逻辑架构图        A[客户端] --访问/控制--&gt; B[总控]        B --&gt; C[流量引擎/API网关]        M[用户] --请求流量--&gt; C[流量引擎/API网关]        B --&gt; P[路由引擎]        B --&gt; Q[边车引擎]        B --&gt; D[插件]        B --&gt; E[可视化模块]        C --&gt; F[高可用集群]        E --&gt; I[引擎/插件流量数据可观测性]        F --&gt; E        subgraph 高可用服务集群            F --&gt; J[应用服务1]            F --&gt; N[应用服务2]            F --&gt; O[应用服务3]        end        J --&gt;|返回|M    end    subgraph 可视化平台        I --&gt; K[数据分析和报告]        D --&gt; L[其他服务接口]    end        classDef default fill:#f9f,stroke:#333,stroke-width:4px;    classDef engine fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5;    classDef cluster fill:#ffc,stroke:#333,stroke-width:2px;    classDef module fill:#cfc,stroke:#333,stroke-width:2px;    classDef database fill:#cfc,stroke:#333,stroke-width:2px;    classDef services fill:#ff9,stroke:#333,stroke-width:2px;    classDef visualization fill:#fa9,stroke:#333,stroke-width:2px;        class A,B default;    class C,D engine;    class F cluster;    class E module;    class J,K,L,N,O services;    class I visualization;        style J stroke:#333,stroke-width:2px,stroke-dasharray: 3, 3    style N stroke:#333,stroke-width:2px,stroke-dasharray: 3, 3    style O stroke:#333,stroke-width:2px,stroke-dasharray: 3, 3</code></pre><pre><code class=" mermaid">---title: 总控逻辑架构图---graph LR    subgraph 总控    direction TBsubgraph 用户接口层direction TBDataSV[数据可视]APIAsset[API可视]SysInfo[系统信息]SEInfo[引擎信息]ObjectInfo[对象信息]UserInfo[用户信息]endsubgraph 业务层direction LRAPI[API]subgraph SCDashboard[SC]Auth[授权管理]User[用户管理]Object[对象管理]System[系统管理]SVClient[可视化]subgraph 引擎管理SEInstallerClient[引擎安装]服务搭建endendsubgraph SVServer[SV]数据可视API可视业务可视插件可视endsubgraph Install-ManageSEInstall[流量引擎安装]SidecarSE[边车引擎在线、离线安装]路由引擎安装引擎节点管理endendsubgraph 数据层Redis[(Redis)]SCEtcd[(Etcd)]NSQ([NSQ])MySQL[(MySQL)]MongoDB[(MongoDB)]FS(((FS)))endendsubgraph 引擎                subgraph SEAppLayer[业务层]        direction TB        subgraph SE-M_cluster        subgraph SE-M        Webserver        adminDam        adminHA        adminKA        semGRL[global-rate-limit]        kube-ApiServer        semInstallAgent[Install-Agent]        semNexus[Nexus]        end        end                subgraph SE-S_cluster        subgraph SE-S        dataHA:::Yellow        dataKA        sesInstallAgent[Install-Agent]        sesNexus[Nexus]                end        end                subgraph SE-W_cluster        subgraph SE-W        sewWorkDam[workDam]        dataWorker        Polycube        Envoy        sewGRL[global-rate-limit]        sewInstallAgent[Install-Agent]        sewNexus[Nexus]                end        end                end                subgraph SEDataLayer[数据层]        SEEtcd[(ETCD)]        SEFS(((FS)))        end            end         服务搭建 --&gt; Webserver    API &lt;====&gt; SCDashboard    API &lt;====&gt; 用户接口层    SVClient -.-&gt; SVServer    SEInstallerClient -.-&gt; Install-Manage    Install-Manage &lt;--&gt; semInstallAgent &amp; sesInstallAgent &amp; sewInstallAgent    Envoy --&gt; sewWorkDam --&gt; 数据可视    业务可视 --&gt; Envoy    linkStyle 1,2 stroke:blue,stroke-width:8px,color:black;    linkStyle 5,6,7 stroke:red,stroke-width:8px,color:black;    style SEDataLayer fill:#FFEBB5classDef Yellow fill:#f96    </code></pre><h2 id="3-系统详细需求分析"><a href="#3-系统详细需求分析" class="headerlink" title="3 系统详细需求分析"></a>3 系统详细需求分析</h2><p>主要对系统级的需求进行分析。首先应对需求分析提出的企业需求进一步确认，并对由于情况变化而带来的需求变化进行较为详细的分析。</p><p>3.1 详细需求分析<br>包括：<br>详细功能需求分析<br>详细性能需求分析<br>详细资源需求分析<br>详细系统运行环境及限制条件分析</p><p>3.2 详细系统运行环境及限制条件分析接口需求分析<br>包括：<br>系统接口需求分析<br>现有硬、软件资源接口需求分析<br>引进硬、软件资源接口需求分析</p><h2 id="4-总体方案确认"><a href="#4-总体方案确认" class="headerlink" title="4 总体方案确认"></a>4 总体方案确认</h2><p>着重解决系统总体结构确认及界面划分问题。 </p><p>4.1 系统总体结构确认<br>对系统组成、逻辑结构及层次进行确认，对应用系统、支撑系统及各自实现的功能进行确认，细化集成设计及系统工作流程，特别要注意因软件的引进造成的系统本身结构和公司其他系统的结构变化。包括：<br>●系统组成、逻辑结构及层次确认<br>●应用系统结构确认<br>●支撑系统结构确认<br>●系统集成确认<br>●系统工作流程确认</p><p>4.2 系统详细界面划分</p><p>4.2.1 应用系统与支撑系统的详细界面划分<br>应用系统与支撑系统之间的界面包括系统主服务器与其他服务器的服务范围及访问方式，网络及数据库对应用系统的支撑方式，全局数据的管理与存取方式等。</p><p>4.2.2 系统内部详细界面划分<br>系统各功能之间的界面包括覆盖范围，模块间功能调用涉及到的系统模块及方法，全局数据格式，系统性能要求等。</p><h2 id="5-系统详细设计"><a href="#5-系统详细设计" class="headerlink" title="5 系统详细设计"></a>5 系统详细设计</h2><p>5.1 系统结构设计及子系统划分<br>对系统的组成及逻辑结构进行设计前确认。<br>划分系统功能模块或子系统（如果有或者有必要，特别是大型的软件系统）。</p><p>5.2 系统功能模块详细设计<br>按结构化设计方法，在系统功能逐层分解的基础上，对系统各功能模块或子系统进行设计。此为详细设计的主要部分之一。<br>用层次图描述系统的总体结构、功能分解及各个模块之间的相互调用关系和信息交互，用IPO图或其他方法描述各模块完成的功能。 以上建议采用HIPO图进行功能分解与模块描述，更高的要求建议采用IDEF0方法进行功能模型设计。<br>详细设计应用系统的各个构成模块完成的功能及其相互之间的关系，用IPO或结构图描述各模块的组成结构、算法、模块间的接口关系，以及需求、功能和模块三者之间的交叉参照关系。<br>每个模块的描述说明可参照以下格式：<br>模块编号：<br>模块名称：<br>输入：<br>处理：<br>算法描述：<br>输出：<br>其中处理和算法描述部分主要采用伪码或具体的程序语言完成。<br>对详细设计更高的要求建议用IDEF0图进行各功能模块的设计。<br>如果对软件需进行二次开发（包括功能扩展、功能改造、用户界面改造等），则相应的设计工作应该设立子课题完成。</p><p>5.3 系统界面详细设计<br>系统界面说明应用系统软件的各种接口。整个系统的其他接口（如系统硬件接口、通讯接口等）在相应的部分说明。</p><p>5.3.1 外部界面设计<br>根据系统界面划分进行系统外部界面设计，对系统的所有外部接口（包括功能和数据接口）进行设计。</p><p>5.3.2 内部界面设计<br>设计系统内部各功能模块间的调用关系和数据接口。</p><p>5.3.3 用户界面设计<br>规定人机界面的内容、界面风格、调用方式等，包括所谓的表单设计、报表设计和用户需要的打印输出等设计。此部分内容可能比较多。</p><h2 id="6-数据库系统设计"><a href="#6-数据库系统设计" class="headerlink" title="6 数据库系统设计"></a>6 数据库系统设计</h2><p>此数据库设计可单独成册，尤其对大型的数据库应用系统，即有一个单独的《数据库设计说明书》。</p><p>6.1 设计要求</p><p>6.2 信息模型设计<br>确定系统信息的类型（实体或视图），确定系统信息实体的属性、关键字及实体之间的联系，详细描述数据库和结构设计，数据元素及属性定义，数据关系模式，数据约束和限制。</p><p>6.3 数据库设计</p><p>6.3.1 设计依据<br>说明数据被访问的频度和流量，最大数据存储量，数据增长量，存储时间等数据库设计依据。</p><p>6.3.2 数据库选型</p><p>6.3.3 数据库种类及特点<br>说明系统内应用的数据库种类、各自的特点、数量及如何实现互联，数据如何传递。</p><p>6.3.4 数据库逻辑结构<br>说明数据库概念模式向逻辑模式转换所采用的方法论及工具，完成数据库概念模式向逻辑模式的转换。详细列出所使用的数据结构中每个数据项、记录和文件的标识、定义、长度及它们之间的相互关系。此节内容为数据库设计的主要部分。</p><p>6.3.5 物理结构设计<br>列出所使用的数据结构中每个数据项的存储要求、访问方法、存取单位和存取物理关系等。建立系统程序员视图，包括：<br>●数据在内存中的安排，包括对索引区、缓冲区的设计；<br>●所使用的外存设备及外存空间的组织，包括索引区、数据块的组织与划分；<br>●访问数据的方式方法。</p><p>6.3.6 数据库安全<br>说明数据的共享方式，如何保证数据的安全性及保密性。</p><p>6.3.7 数据字典<br>编写详细的数据字典。 对数据库设计中涉及到的各种项目，如数据项、记录、系、文卷模式、子模式等一般要建立起数据字典，以说明它们的标识符、同义名及有关信息。</p><h2 id="7-信息编码设计"><a href="#7-信息编码设计" class="headerlink" title="7 信息编码设计"></a>7 信息编码设计</h2><p>7.1 代码结构设计<br>确认信息分类编码总体方案，进行分类代码结构设计。</p><p>7.2 代码编写<br>按代码结构编写信息代码</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>档案.md</title>
    <link href="/2023/11/02/mdstorage/arch/%E6%A1%A3%E6%A1%88/"/>
    <url>/2023/11/02/mdstorage/arch/%E6%A1%A3%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>记录项目中的人、物、事</p>]]></content>
    
    
    <categories>
      
      <category>arch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云安全审计：挑战和新兴方法.md</title>
    <link href="/2023/11/02/mdstorage/domain/cloud/%E4%BA%91%E5%AE%89%E5%85%A8%E5%AE%A1%E8%AE%A1%EF%BC%9A%E6%8C%91%E6%88%98%E5%92%8C%E6%96%B0%E5%85%B4%E6%96%B9%E6%B3%95/"/>
    <url>/2023/11/02/mdstorage/domain/cloud/%E4%BA%91%E5%AE%89%E5%85%A8%E5%AE%A1%E8%AE%A1%EF%BC%9A%E6%8C%91%E6%88%98%E5%92%8C%E6%96%B0%E5%85%B4%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<ol><li><p><strong>标题和源头</strong>:</p><ul><li>明确每条资讯的标题和来源，这将帮助您快速识别资讯的主题和信任度。</li></ul></li><li><p><strong>日期和作者</strong>:</p><ul><li>记录资讯的发布日期和作者，以了解资讯的时效性和作者的背景。</li></ul></li><li><p><strong>摘要</strong>:</p><ul><li>创建一个简短的摘要，概述资讯的主要内容和观点。这将帮助您快速回顾资讯的核心信息。</li></ul></li><li><p><strong>关键点和数据</strong>:</p><ul><li>列举资讯中的关键点和重要数据。使用列表或者子标题来组织这些信息，以便于阅读和查找。</li></ul></li><li><p><strong>图表和图片</strong>:</p><ul><li>如果资讯中包含了有用的图表或图片，考虑将它们保存并插入到您的资讯摘要中。</li></ul></li><li><p><strong>个人评价和思考</strong>:</p><ul><li>记录您对资讯的看法和思考，包括它如何影响您的项目或职责，以及您可能采取的任何后续行动。</li></ul></li><li><p><strong>相关链接和参考资料</strong>:</p><ul><li>提供资讯原文的链接，以及任何相关的背景资料或参考资料的链接。</li></ul></li><li><p><strong>标签和分类</strong>:</p><ul><li>使用标签和分类来组织您的资讯摘要，以便于后期按照主题或类型进行搜索和查找。</li></ul></li><li><p><strong>后续行动和提醒</strong>:</p><ul><li>如果资讯内容需要您采取某些后续行动，记录这些行动并设置提醒，以确保您不会忘记。</li></ul></li><li><p><strong>保存和归档</strong>:</p><ul><li>保存您的资讯摘要到适当的文件夹或数字笔记应用程序中，并按照 PARA 方法的分类标准进行归类。</li></ul></li></ol><h3 id="标题和源头"><a href="#标题和源头" class="headerlink" title="标题和源头"></a>标题和源头</h3><ul><li>InfoQ<a href="https://www.infoq.com/articles/cloud-security-auditing-challenges-and-emerging-approaches/">资讯</a></li><li>云安全审计：挑战和新兴方法</li><li>Cloud Security Auditing: Challenges and Emerging Approaches</li></ul><h3 id="日期和作者"><a href="#日期和作者" class="headerlink" title="日期和作者"></a>日期和作者</h3><ul><li>2023&#x2F;11&#x2F;2</li><li><a href="https://www.infoq.com/profile/John-Kissell/">John Kissell</a> Jungwoo Ryoo</li></ul><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ul><li>云计算是一种模型，用于实现对可配置计算资源（例如，网络、服务器、存储、应用程序和服务）的共享池的无处不在、方便、按需的网络访问，这些资源可以通过最少的管理工作或服务提供商交互快速配置和发布。1 从本质上讲，云计算可以被描述为使用通过网络提供的计算资源（包括硬件和软件），需要用户和提供商之间的最少交互。</li><li>云中通常实现三种服务模型：软件即服务 （SaaS）、平台即服务 （PaaS） 和基础架构即服务 （IaaS）。在每一种服务类型中，安全性都是一个重大挑战。安全审核为各种组织提供了清晰且可识别的资源访问跟踪。</li><li>传统的 IT 审计通常分为两大类：内部审计和外部审计。内部审计是指由组织自己的员工完成的工作，涉及非常具体的组织流程，主要关注优化和风险管理。外部审计从外部视角了解组织满足各种法律法规要求的能力。组织使用传统的 IT 审计来评估诸如授权用户的可用性以及数据存储和传输的完整性和机密性等问题。</li><li>当组织的 IT 资源迁移到云时会发生什么？由于云计算允许跨大型域的多个用户，因此它暴露了新的安全问题，例如特定于云的信任问题。这些威胁给安全审计带来了新的挑战，但云倡导者正在应对这些威胁。例如，<a href="http://www.cloudsecurityalliance.org/">云安全联盟</a> （CSA） 等组织正在敦促标准化云的可靠性、完整性和可用性审计。</li><li>在本文中，我们将重点介绍将云安全审计与传统 IT 安全审计实践区分开来的挑战。这些挑战说明了在现有或新兴的安全审计标准中对云安全审计的特殊规定的重要性。</li></ul><h3 id="关键点和数据"><a href="#关键点和数据" class="headerlink" title="关键点和数据"></a>关键点和数据</h3><ul><li><h4 id="挑战点"><a href="#挑战点" class="headerlink" title="挑战点"></a>挑战点</h4><p>云基础架构是服务组织、云服务提供商 （CSP） 和最终用户之间不断进行三方协商的结果，以确保生产力，同时保持合理的安全性。CSP 应保护数据免受安全威胁，同时允许客户端通过 Internet 服务访问任何地方。此外，客户组织必须验证云计算企业是否有助于实现其业务目标、目的和未来需求。</p><ul><li>云安全审计必须解决传统 IT 安全审计中通常无法处理的独特问题。最直接和最明显的挑战在于审计师获得足够的云计算知识。有效的云安全审计师必须熟悉云计算术语，并具备云系统构成和交付方法的工作知识。这些知识可确保审计人员关注在云安全审计过程中可能更重要的安全因素，包括<ul><li>透明度;</li><li>加密;</li><li>主机托管;</li><li>以及规模、范围和复杂性</li></ul></li></ul></li><li><h4 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h4><p>透明度使组织能够更轻松地识别潜在的安全风险和威胁</p><ul><li>一个好的云安全审计会质疑 CSP 是否在安全控制和最终用户访问之间提供了坚实的 <strong>平衡</strong>。<ul><li>员工可能需要在家中或出差时访问云。CSP 是否允许此类访问，是否可以阻止其他人冒充合法用户？</li><li>更重要的是，CSP 是否愿意对其访问控制机制保持透明？</li></ul></li><li>需要披露的细节<ul><li>客户端需要知道谁在处理数据，知道数据在系统上的确切位置。</li><li>数据隐私、数据安全、匿名、电信容量、责任、可靠性和政府监控的透明度</li><li>关键企业系统的未报告后门可能会对组织造成毁灭性的损害</li></ul></li></ul></li><li><h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><p>客户端可以在将其所有数据发送到云提供商之前在内部加密，但这种方法会带来系统管理员滥用其权限的风险。将加密留给 CSP 也不是万无一失的：其存储系统的漏洞也可能意味着其加密和解密工具的漏洞。</p><ul><li><p>传统 IT 基础设施问题</p><p>数据加密和数据访问哪个更重要？如果整个数据池都是静态加密的，组织如何在不解密所有数据的情况下快速有效地查询数据？由于其繁重的计算要求，加密可能并不总是最有效的解决方案。只有在不经常访问敏感数据（例如，存档的工资单信息）的情况下，静态加密才成为可行的选择。</p></li><li><p>云基础架构问题</p><ul><li>静态数据是否应该加密？默认情况下，CSP 通常提供加密（例如 Amazon 的简单存储服务 （S3），这可能会导致双重加密（一次由 CSU 加密，一次由 CSP 加密）。相比之下，亚马逊的弹性计算云服务默认不提供加密，由客户自行决定。第三方服务（如 <a href="http://www.ciphercloud.com/">CipherCloud</a>）允许客户端在将数据发送到 CSP 之前对数据进行加密。传输中的数据通常使用安全套接字层等技术进行加密。假设 CSU 仅依赖 CSP 进行加密，它必须允许 CSP 控制其加密和解密机制，并有权访问其存储的所有数据（例如 S3）。</li><li>这不是一种安全的做法，因为如果云的一部分受到损害，所有加密数据也可能受到损害。因此，更希望在 CSP 无法触及的地方进行加密和解密。但是，加密和解密云存储数据是否值得在云之外使用额外的计算资源？可能，但完全同态加密方面较新的创新允许加密查询搜索加密文本，而无需搜索引擎解密。4 这种类型的加密有可能解决传统 IT 和云基础设施中静态加密数据的安全问题</li><li>努力达到隐私的平衡：审计师希望对他们的查询保密，而被审计组织希望保护其所有加密数据的隐私。审计员可以访问组织的数据以完成他们的工作; 他们有权访问，但不能复制或删除任何内容。</li><li>CSP 可能不愿意或无法披露某些加密信息，即使在审核情况下也是如此。为了帮助缓解这一特定于云的问题，支付卡行业 （PCI） 数据安全标准 （DSS） 云特别兴趣小组 （SIG） 强烈建议加密密钥和加密算法信息“独立于云服务进行存储和管理”。</li></ul></li></ul></li><li><h4 id="主机托管"><a href="#主机托管" class="headerlink" title="主机托管"></a>主机托管</h4><p>云计算的核心优势是多个用户组织可以共享一个服务组织的物理系统。虽然这是一种很好的降低成本的方法，但共享技术基础设施也会导致同样严重的安全问题。至关重要的是，CSP 必须防止用户系统获得对物理硬件的管理访问权限，以防止滥用服务和访问其他客户的数据。</p><ul><li><p>IaaS 经常遇到此问题; 为了解决这个问题，CSP 求助于将虚拟机 （VM） 与物理计算硬件隔离开来的虚拟机管理程序。目前使用的虚拟机管理程序示例包括 Xen（开源），VMWare（专有），Microsoft 的虚拟服务器，基于内核的虚拟机（KVM），IBM 的 PowerVM 以及许多其他包含 Intel 和 AMD 架构的虚拟机。安全审计问题就是由这种情况引起的：在云系统中组织或建立虚拟机管理程序的方法有无数种，每种方法都有自己的优点、缺点和优先级。</p></li><li><p>CSP 不仅要平衡虚拟机管理程序和托管系统的业务需求，还要平衡安全问题。尽管显然需要对托管的结构和安全性进行标准化，但尚无官方标准。甚至 PCI DSS 也没有列出有关这些不断发展的问题的专门标准。但是，PCI DSS Cloud SIG 为多租户制定了一些建议。5 它提供了三个示例云分段环境：用于每个客户端的持卡人数据的传统独立服务器、专用于每个客户端及其持卡人数据的虚拟化服务器，以及在单独的逻辑分区和单独的数据库管理映像中运行的应用程序，这些应用程序不共享磁盘存储等资源。</p></li><li><p>考虑到云-虚拟机管理程序的众多组合和不同程度的云采用，对云系统的 PCI DSS 式评估必须包括对所有 CSP 的单独检查。为了强调适当的托管安全性的重要性，PCI DSS Cloud SIG 发布了以下关于多租户的声明：“如果没有充分的分段，共享基础设施的所有客户端以及 CSP 都需要被验证为 PCI-DSS 合规性，以便确保任何一个客户端符合环境的合规性。</p></li></ul></li><li><h4 id="规模、范围和复杂性"><a href="#规模、范围和复杂性" class="headerlink" title="规模、范围和复杂性"></a>规模、范围和复杂性</h4><ol><li><p><strong>规模增加</strong>：</p><ul><li>由于一台物理机上通常托管多个虚拟机，导致需要审核的主机数量大大增加，可能使 IT 人员和审计人员感到压力很大。</li><li>通过标准化（例如，使用经过安全验证的主虚拟机映像），可以使审计过程变得更为顺畅和快速，尽管云计算元素的规模较大。</li></ul></li><li><p><strong>审计范围变化</strong>：</p><ul><li>云计算引入了新的技术类型，例如虚拟机管理程序、虚拟交换机和虚拟防火墙，这些都需要被包括在审计的范围内。</li><li>共置问题可能导致虚拟机之间的隔离漏洞，使得 CSU 对其虚拟机与其他组织（包括竞争对手）的虚拟机相邻感到不安。</li></ul></li><li><p><strong>系统复杂性增加</strong>：</p><ul><li>由于规模和范围的增加，系统的复杂性也随之增加，需要分配比传统 IT 审计更多的时间和资源来应对这种复杂性。</li></ul></li><li><p><strong>多地区数据中心的合规性挑战</strong>：</p><ul><li>CSP 能够将组织的数据和信息存储在位于多个国家&#x2F;地区的数据中心，每个国家&#x2F;地区都有不同的法律和法规，这对云安全审计员来说是一个挑战。</li><li>客户组织的合规性要求不再受 CSU 物理位置的约束，审计人员需要确定 CSP 存储 CSU 数据和信息的位置，同时考虑由于多租户环境导致的托管增加了物理数据和信息存储位置的重要性。</li></ul></li></ol><p>通过以上分析，可以看出云计算环境相比传统 IT 环境在审计方面带来了更多的挑战和考量，需要更多的资源和技术来确保安全和合规。</p></li><li><h4 id="需要考虑的领域"><a href="#需要考虑的领域" class="headerlink" title="需要考虑的领域"></a>需要考虑的领域</h4><p>云计算提供了大量可以在任何地方访问的服务。但是，不同领域的某些业务领域会有各自不同的需求。数据类型也可能因域而异，为确保数据安全而强制执行的法律和法规要求也可能有所不同。因此，一刀切的审计可能无法满足专业审计应有的所有需求。领域定制审计是理想的解决方案。</p><ul><li><p>医疗</p><p>医疗领域拥有高度敏感和机密的信息，但必须允许审计员、患者、药房和其他机构（如医院）访问。无论是在法律上还是在道德上，复杂的身份验证方法对于医疗云都尤为重要。任何违规行为都可能给医疗机构及其患者造成巨大损失。</p><p>从法律上讲，医疗领域被要求达到非常高的标准，一旦发生违规，将面临巨额的补偿和惩罚性成本。</p></li><li><p>银行</p><p>银行拥有大量与用户全天候从各种设备访问服务相关的流量。银行不仅必须不断更新信息，还必须确保这些信息的安全，并可供所有想要访问的客户使用。</p><p>尽管完美的安全性是不可能的，但安全系统必须能够抵御和响应违规行为，尤其是当数十亿美元和大量银行账户面临风险时。相对较大的银行云面临的一个大问题是确保客户信息不会被盗或出售。我们认为，保障措施需要是双重的。首先，存储在云中的数据应该被加密。其次，对它的访问应受到网上银行客户端设置的权限的限制。</p><p>对在本地（或银行总部）存储数据的银行进行传统的 IT 审计通常不需要担心其他银行会访问数据。但是，当多个银行机构使用相同的云基础设施时，存在额外的风险，包括竞争对手无意中访问银行数据的可能性。此外，一家银行的安全漏洞可能会导致其他银行的账户被破坏。</p></li><li><p>政府</p><p>审计的三个关键领域是操作可见性、变更控制流程和事件响应。运营可见性要求 CSP 向机构提交自动数据馈送以及系统性能的定期证据和年度报告。更改控制过程限制了 CSP 进行可能影响 FedRAMP 要求的策略更改的能力。最后，事件响应处理云系统中可能出现的新风险或漏洞，并在发生违规时保护政府信息免遭泄露。例如，如果攻击危及政府计算机并导致军事机密泄露，事件响应团队应立即阻止信息泄露并防止任何进一步的损害。</p></li></ul></li><li><h4 id="新兴方法"><a href="#新兴方法" class="headerlink" title="新兴方法"></a>新兴方法</h4><ul><li><p>关于云安全审计标准化的三个主要思想流派。</p><ul><li>一种信念是，我们根本不需要新的标准。由于大多数传统的 IT 审计标准在设计上都是技术中立的，因此现有标准仍然具有相关性。审计师负责自行开发他们在云计算方面的专业知识，并通过简单地这样做来获得见解。</li><li>另一派思想是保持众所周知的 IT 安全审计标准的技术中立性，但用特定于云的信息来补充它们，例如，在进行典型的云安全审计时要寻找或避免什么。</li><li>最后，一些受访者希望开发一个全新的标准，专门用于云安全审计。</li></ul><p>在我们看来，补充方法是一个很好的折衷方案</p><p>ISO 27000 系列是使用最广泛的 IT 安全审计标准之一，但是，对于使用云的组织，ISO 27001 和 ISO 27002 只能提供有限的支持。在撰写本文时，ISO 正在开发一种新的特定于云的安全标准——ISO&#x2F;国际电工委员会 （IEC） 27017——来解决这个问题</p></li></ul></li></ul><h3 id="图表和图片"><a href="#图表和图片" class="headerlink" title="图表和图片"></a>图表和图片</h3><h3 id="个人评价和思考"><a href="#个人评价和思考" class="headerlink" title="个人评价和思考"></a>个人评价和思考</h3><p>这篇资讯明确对云计算等概念进行准确的描述，这些是理解这篇资讯内容的前提; 对论题进行了清晰的描述，这是理解的思路; 对各重点难点关键点既有整体性概述，也有独立的讨论，做到了面面俱到。里面的事例非常典型，对安全方面的理解很深，一针见血地提出问题的本质。最后对解决问题也进行了概要描述，虽然不充足，但也提供了一个解决问题的思路和方向。</p><h3 id="相关链接和参考资料"><a href="#相关链接和参考资料" class="headerlink" title="相关链接和参考资料"></a>相关链接和参考资料</h3><h3 id="标签和分类"><a href="#标签和分类" class="headerlink" title="标签和分类"></a>标签和分类</h3><h3 id="后续行动和提醒"><a href="#后续行动和提醒" class="headerlink" title="后续行动和提醒"></a>后续行动和提醒</h3>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cloud</tag>
      
      <tag>security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI和读书方法.md</title>
    <link href="/2023/11/02/mdstorage/domain/knowledge/AI%E5%92%8C%E8%AF%BB%E4%B9%A6%E6%96%B9%E6%B3%95/"/>
    <url>/2023/11/02/mdstorage/domain/knowledge/AI%E5%92%8C%E8%AF%BB%E4%B9%A6%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="四步读书法"><a href="#四步读书法" class="headerlink" title="四步读书法"></a>四步读书法</h2><h3 id="归纳解读内容效果"><a href="#归纳解读内容效果" class="headerlink" title="归纳解读内容效果"></a>归纳解读内容效果</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs tex">归纳解读《好的想法从哪里来》<br><br>作者 Steven Johnson 深入探讨了思想的解剖学，探索为什么某些环境能够培养创意和创新。这本书识别了在特定的有助于想法产生的肥沃环境中可以观察到的模式和特性。<br><br>肥沃环境的特性：这些能产生开创性想法的肥沃环境，共享了几个特性。它们一次标记了多个创意的规模。这些环境更重视开放性和连通性，而不是促进竞争。这挑战了竞争是创新的唯一驱动力的传统观点。与其保护思想，不如连接它们。过度保护或孤立的想法会抑制创新。相反，当它们可以连接、合并，并通过跨越概念边界而演化时，想法的真正潜力才能被实现。创新通常不是源于突然的灵感，而是来自于渐进的、连接的过程。<br><br>想法和拼凑：想法并非凭空产生。它们是由现有的组件构建的，就像拼凑者使用现有的材料组装新的创造一样。材料越多样，创新的可能性越广。这强化了收集多样输入可以显著增强创新过程的观念。<br><br>物理环境和网络：一个人所处的环境可以大大影响他们的创意。创新的空间使个体暴露于各种各样的想法和概念，这类似于珊瑚礁如何循环并重新发明其生态系统。思想的网络像一个蜂群，不断地演化和塑造，随着它们的增长而呈现出新的形式。<br><br>缓慢的直觉和记录的力量：与即时的启示不同，许多伟大的想法随着时间的推移而慢慢成熟。这些&quot;缓慢的直觉&quot;需要培养。培养它们最有效的方法之一是写下它们。这种做法，通过查尔斯·达尔文的详尽的笔记习惯为例，使大脑得以重访、完善和连接休眠的直觉。<br><br>常见书籍和数字档案：在启蒙时代，知识分子维护了&quot;常见的&quot;书籍来收集知识。同样，在数字时代，创建有关引人入胜的引用或思考的个人仓库可以促进&quot;私人偶然性&quot;。在数字化和分类知识中，偶然地发现意想不到的联系或遗忘的笔记是同样有价值的。<br><br>在组织中培养创新：传统的头脑风暴，受到时间和空间的限制，通常不能同步和开发互联的直觉。为了培养创新，组织应建立持续的信息网络，让直觉持续、分散和交叉。这确保了头脑风暴始终是一个不断演化的过程，而不是一个静态的事件。<br><br>物理空间和创新的热点：历史上，像18世纪的英国咖啡馆或弗洛伊德的沙龙这样的地方曾是创新的孕育地。这些空间，经常自然产生，允许不同的领域碰撞和合并。这使人想起都市理论家简·雅各布斯的观点，即较旧、被重新利用的空间往往成为新想法和创意的坩埚。<br><br>错误在创新中的作用：讽刺的是，有些噪音和错误的环境经常产生更多的开创性想法。无组织的神经网络可能是更高智力的标志。同样，在小组讨论中引入某些错误或异议的观点可以导致更多的原创连接。因此，接受错误，而不是追求完美，可能有助于创新。<br><br>连接和偶然性：最终，这本书得出了一个强大的观点，即&quot;机会偏爱连接的头脑&quot;。正是通过这些计划内的和偶然的连接，伟大的想法常常出现。通过解码想法的诞生和演化，约翰逊的《好的想法从哪里来》为任何希望培养创意的人提供了宝贵的见解，无论是在个人还是组织层面。<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Tiago Forte提出的利用ChatGPT完成书籍摘要的“四步法”主要针对的问题是如何通过有效的方法对书籍内容进行总结和整理，以深入理解书籍的核心内容并快速创建有价值的内容摘要。该方法通过以下四个主要步骤来实现这个目标：</p><ol><li><p><strong>阅读并导出重点</strong>:</p><ul><li><strong>选择与阅读书籍</strong>：这是开始理解书籍内容的基础步骤，同时选择适合的书籍也是至关重要的。</li><li><strong>高亮重要段落</strong>：通过高亮重要的段落或句子，可以帮助读者标记他们认为最重要的信息。</li><li><strong>导出高亮内容</strong>：利用工具，如Readwise，将高亮的内容导出以聚集所有重要信息，并为下一步的内容精炼做准备。</li></ul></li><li><p><strong>精炼重点内容</strong>:</p><ul><li><strong>初步筛选</strong>：由于保存的高亮内容可能非常庞大，所以需要进行初步的筛选，以确保只有最重要的内容被保留。</li><li><strong>使用渐进式总结技巧</strong>：通过进一步的评估和筛选，确保只有最重要、最有影响力的点被纳入总结。</li></ul></li><li><p><strong>创建大纲</strong>:</p><ul><li><strong>整理主要观点</strong>：将先前精选的点根据重要性和相关性整理成一个清晰的结构，包括主要观点和支持点。</li><li><strong>格式化和调整结构</strong>：确保创建一个清晰的层次结构，以帮助ChatGPT更好地理解主要信息和辅助信息。</li></ul></li><li><p><strong>使用ChatGPT</strong>:</p><ul><li><strong>准备输入给ChatGPT的内容</strong>：将整理好的大纲复制，准备粘贴到ChatGPT的输入界面中。</li><li><strong>使用特定的提示语</strong>：通过使用特定的提示（<strong>以下内容是我读书时做的阅读标注。请你输出一篇对书籍&lt;填写书名&gt;的归纳解读， 请尽可能多地使用我提供的阅读标注， 并同时参考网络上的信息源。</strong>），指导ChatGPT如何处理提供的信息，以生成更符合要求的书籍总结。</li></ul></li></ol><p>这个方法允许读者不仅能够深入理解书籍的核心内容，还能利用ChatGPT的能力，以相对较少的时间和努力，创建出结构清晰、内容全面的书籍摘要。同时，通过结合读者自己的理解和ChatGPT的数据库，可以生成比单独使用ChatGPT更全面的书籍总结。</p><h3 id="评估标准"><a href="#评估标准" class="headerlink" title="评估标准"></a>评估标准</h3><ul><li>总结的时间</li><li>内容的质量和深度</li><li>总结更长、详细、具体</li><li>总结包含更多的支持点、例子</li></ul><h3 id="文件模板"><a href="#文件模板" class="headerlink" title="文件模板"></a>文件模板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">书籍名称: ____________________________________________________________<br><br>## 第一步: 阅读并导出重点<br>- 阅读日期: ______________<br>- 阅读工具 (例如 Kindle, Readwise): ______________<br>- 高亮的重要段落或句子:<br>  1. _______________________________________________________<br>  2. _______________________________________________________<br>  3. _______________________________________________________<br>  ...<br>- 导出高亮内容至: _____________________________________________<br><br>## 第二步: 精炼重点内容<br>- 初步筛选的重要点:<br>  1. _______________________________________________________<br>  2. _______________________________________________________<br>  3. _______________________________________________________<br>  ...<br>- 渐进式总结的结果:<br>  1. _______________________________________________________<br>  2. _______________________________________________________<br>  3. _______________________________________________________<br>  ...<br><br>## 第三步: 创建大纲<br>- 主要观点与支持点:<br>  1. 主要观点: _______________________________________________<br>     - 支持点: _______________________________________________<br>     - 支持点: _______________________________________________<br>  2. 主要观点: _______________________________________________<br>     - 支持点: _______________________________________________<br>     - 支持点: _______________________________________________<br>  ...<br>- 格式化和调整结构的备注: _________________________________________<br><br>## 第四步: 使用 ChatGPT<br>- 准备输入给 ChatGPT 的内容:<br>  ____________________________________________________________<br>  ____________________________________________________________<br>  ...<br>- 特定的提示语: _______________________________________________<br>- ChatGPT 生成的总结:<br>  ____________________________________________________________<br>  ____________________________________________________________<br>  ...<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>knowledge</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>知识管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>技术资讯摘要获取.md</title>
    <link href="/2023/11/02/mdstorage/domain/knowledge/%E6%8A%80%E6%9C%AF%E8%B5%84%E8%AE%AF%E6%91%98%E8%A6%81%E8%8E%B7%E5%8F%96/"/>
    <url>/2023/11/02/mdstorage/domain/knowledge/%E6%8A%80%E6%9C%AF%E8%B5%84%E8%AE%AF%E6%91%98%E8%A6%81%E8%8E%B7%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<h2 id="资讯规整思路"><a href="#资讯规整思路" class="headerlink" title="资讯规整思路"></a>资讯规整思路</h2><p>每条技术资讯的内容组织可以按照一定的结构和格式来进行，以便于快速摘取重要信息和后期回顾。下面是一个可能的组织思路和步骤：</p><ol><li><p><strong>标题和源头</strong>:</p><ul><li>明确每条资讯的标题和来源，这将帮助您快速识别资讯的主题和信任度。</li></ul></li><li><p><strong>日期和作者</strong>:</p><ul><li>记录资讯的发布日期和作者，以了解资讯的时效性和作者的背景。</li></ul></li><li><p><strong>摘要</strong>:</p><ul><li>创建一个简短的摘要，概述资讯的主要内容和观点。这将帮助您快速回顾资讯的核心信息。</li></ul></li><li><p><strong>关键点和数据</strong>:</p><ul><li>列举资讯中的关键点和重要数据。使用列表或者子标题来组织这些信息，以便于阅读和查找。</li></ul></li><li><p><strong>图表和图片</strong>:</p><ul><li>如果资讯中包含了有用的图表或图片，考虑将它们保存并插入到您的资讯摘要中。</li></ul></li><li><p><strong>个人评价和思考</strong>:</p><ul><li>记录您对资讯的看法和思考，包括它如何影响您的项目或职责，以及您可能采取的任何后续行动。</li></ul></li><li><p><strong>相关链接和参考资料</strong>:</p><ul><li>提供资讯原文的链接，以及任何相关的背景资料或参考资料的链接。</li></ul></li><li><p><strong>标签和分类</strong>:</p><ul><li>使用标签和分类来组织您的资讯摘要，以便于后期按照主题或类型进行搜索和查找。</li></ul></li><li><p><strong>后续行动和提醒</strong>:</p><ul><li>如果资讯内容需要您采取某些后续行动，记录这些行动并设置提醒，以确保您不会忘记。</li></ul></li><li><p><strong>保存和归档</strong>:</p><ul><li>保存您的资讯摘要到适当的文件夹或数字笔记应用程序中，并按照PARA方法的分类标准进行归类。</li></ul></li></ol><p>这种组织思路可以帮助您创建结构清晰、内容完整的技术资讯摘要，使您能够有效地管理和利用收集到的资讯，同时也为您提供了一个系统地回顾和分析资讯的框架。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>knowledge</category>
      
    </categories>
    
    
    <tags>
      
      <tag>资讯</tag>
      
      <tag>信息</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>资料规整.md</title>
    <link href="/2023/11/02/mdstorage/domain/knowledge/%E8%B5%84%E6%96%99%E8%A7%84%E6%95%B4/"/>
    <url>/2023/11/02/mdstorage/domain/knowledge/%E8%B5%84%E6%96%99%E8%A7%84%E6%95%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="具体事例"><a href="#具体事例" class="headerlink" title="具体事例"></a>具体事例</h3><p>根据PARA方法，管理和归纳每天摄入的最新技术领域资讯可能涉及到多个类别。以下是一些具体的步骤和建议，以帮助您决定如何组织这些文件并确定将它们放入哪个文件夹：</p><ol><li><p><strong>确定目标和责任</strong>：</p><ul><li>首先明确您收集和整理技术资讯的目的。如果这是为了完成某个具体的项目，那么应该将其归类为“项目”；如果这是您长期的职责或兴趣所在，那么应该将其归类为“领域”。</li></ul></li><li><p><strong>创建文件夹和子文件夹</strong>：</p><ul><li>根据您的目标和责任，选择适当的PARA类别，并在该类别的文件夹内创建一个新的子文件夹，例如命名为“技术资讯摘要”。</li><li>在“技术资讯摘要”文件夹内，您可以创建更多的子文件夹来组织不同类型或来源的技术资讯，例如按照资讯的主题或发布日期进行分类。</li></ul></li><li><p><strong>收集和整理资讯</strong>：</p><ul><li>每天浏览和收集最新的技术资讯，并将相关的文件和链接保存到“技术资讯摘要”文件夹中的相应子文件夹内。</li><li>您可以创建文档来归纳和总结每天或每周的重要技术资讯，并将这些文档保存在相应的子文件夹内。</li></ul></li><li><p><strong>利用数字工具</strong>：</p><ul><li>考虑使用数字笔记应用程序和RSS阅读器等工具来自动化收集和整理技术资讯的流程。</li><li>例如，您可以使用RSS阅读器订阅您感兴趣的技术博客和新闻网站，然后将重要的文章保存到您的数字笔记应用程序中，并按照PARA方法的分类标准进行归类。</li></ul></li><li><p><strong>定期回顾和更新</strong>：</p><ul><li>定期回顾您的“技术资讯摘要”文件夹，更新和优化您的资讯收集和整理流程，以确保它们始终符合您的需求和目标。</li><li>当某些技术资讯不再相关或活动时，您可以将它们移动到“档案”类别的文件夹中，以便未来参考。</li></ul></li></ol><p>通过这种方式，您可以系统地管理和归纳您每天摄入的技术领域资讯，并确保能够快速找到和回顾重要的信息。同时，这也有助于您保持对最新技术趋势的了解，并支持您的项目和职责。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>PARA 方法（项目、领域、资源、档案）是一种有效的知识和信息管理框架，它能帮助您更有条理地组织和管理您的资料。以下是使用PARA方法整理资料的一些步骤和建议：</p><ol><li><p><strong>了解PARA的基本概念</strong>：</p><ul><li><strong>项目（Projects）</strong>：具有明确目标和截止日期的短期活动。</li><li><strong>领域（Areas）</strong>：需要持续维护和关注的长期活动或责任。</li><li><strong>资源（Resources）</strong>：能帮助您完成项目和领域活动的资料和工具。</li><li><strong>档案（Archives）</strong>：不再活动但可能需要参考的资料。</li></ul></li><li><p><strong>创建PARA文件结构</strong>：</p><ul><li>在您的电脑、网络驱动器或云存储服务中，为每个PARA类别创建单独的文件夹。</li><li>在每个类别的文件夹下，创建子文件夹来组织特定的项目、领域、资源或档案。</li></ul></li><li><p><strong>分类和整理现有资料</strong>：</p><ul><li>检查您当前的所有资料，将它们分类为项目、领域、资源或档案，并将它们移动到相应的PARA文件夹中。</li></ul></li><li><p><strong>持续维护PARA结构</strong>：</p><ul><li>定期检查您的项目和领域，确保它们仍然符合您的目标和优先事项。</li><li>更新资源和档案，以确保它们是最新和相关的。</li></ul></li><li><p><strong>利用数字工具</strong>：</p><ul><li>考虑使用数字笔记应用程序（如Evernote或Notion）和任务管理工具（如Trello或Asana）来维护您的PARA结构。</li><li>这些工具通常允许您创建文件夹、标签和其他组织结构，以帮助您管理项目、领域、资源和档案。</li></ul></li><li><p><strong>培养良好的信息管理习惯</strong>：</p><ul><li>培养将新资料立即分类到相应PARA类别的习惯。</li><li>定期回顾和清理您的PARA结构，以保持其清晰和有效。</li></ul></li></ol><p>通过上述步骤和建议，您可以按照PARA方法来整理和管理您的资料，从而帮助您和您的团队更有效地管理承诺和目标。同时，您可能还需要根据自己的具体需求和工作流程，对PARA方法做出一些定制和调整，以确保它能为您提供最大的帮助。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>knowledge</category>
      
    </categories>
    
    
    <tags>
      
      <tag>资料</tag>
      
      <tag>查找</tag>
      
      <tag>整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发项目经理打包人员部署人员转测流程规范.md</title>
    <link href="/2023/11/02/mdstorage/project/sr/%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E7%BB%8F%E7%90%86%E6%89%93%E5%8C%85%E4%BA%BA%E5%91%98%E9%83%A8%E7%BD%B2%E4%BA%BA%E5%91%98%E8%BD%AC%E6%B5%8B%E6%B5%81%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    <url>/2023/11/02/mdstorage/project/sr/%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E7%BB%8F%E7%90%86%E6%89%93%E5%8C%85%E4%BA%BA%E5%91%98%E9%83%A8%E7%BD%B2%E4%BA%BA%E5%91%98%E8%BD%AC%E6%B5%8B%E6%B5%81%E7%A8%8B%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<pre><code class=" mermaid">sequenceDiagram    participant Dev as 开发人员    participant PM as 项目经理    participant Packer as 打包人员    participant Deployer as 部署人员    Dev-&gt;&gt;PM: 代码自测通过，合并代码到生产分支，填充 changelog    Dev-&gt;&gt;PM: 通知需要申请自测的功能，修改状态为申请自测    PM-&gt;&gt;Packer: 收集功能清单，请求打包    Packer-&gt;&gt;Dev: 确认changelog，进行打包    Packer-&gt;&gt;Deployer: 提供安装包    Deployer-&gt;&gt;Dev: 部署并通知    Dev-&gt;&gt;PM: 在集成环境自测，由唯一责任人通知可转测，修改状态为可转测    PM-&gt;&gt;PM: 组织审查    PM-&gt;&gt;PM: 提供可转测清单给测试组，更新状态为已提测    </code></pre><p>转测流程：</p><ol><li>已经在本地环境联调自测通过后的功能，代码合并到 生产分支(如220) 分支 (合并后changelog<br><a href="https://doc.weixin.qq.com/sheet/e3_AWAAXgY4AIAkixXQUzkTxyFao05Pn?scode=ABwA9Qd2ABExUgQDouAfMATQabAPc&tab=uky3co">https://doc.weixin.qq.com/sheet/e3_AWAAXgY4AIAkixXQUzkTxyFao05Pn?scode=ABwA9Qd2ABExUgQDouAfMATQabAPc&amp;tab=uky3co</a><br>也填上，合并代码时间以gitlab上的时间为准，具体到分钟) ;</li><li>申请开发组集成环境进行自测：通知项目经理有哪些功能需要申请自测，<br><a href="https://doc.weixin.qq.com/sheet/e3_AfMATQabAPcmB9RMV6qRbyk6cEooJ?scode=ABwA9Qd2ABEFNtm9fyAfMATQabAPc&tab=BB08J2">https://doc.weixin.qq.com/sheet/e3_AfMATQabAPcmB9RMV6qRbyk6cEooJ?scode=ABwA9Qd2ABEFNtm9fyAfMATQabAPc&amp;tab=BB08J2</a><br>，在转测报告表中填写，除了截图&#x2F;自测报告的其他内容（这是需要到集成环境才能输出的产品），并把“转测状态”改为“申请自测”；</li><li>项目经理收集“申请自测”的功能清单，提供并通知打包人员统一打包，打包人员确认changelog提交符合规范，进行打包；</li><li>输出安装包，打包人员通知并提供给开发组安装部署人员，进行安装部署到开发组集成自测环境后，群里通知；</li><li>每个开发人员到集成环境再自测一次，填写转测报告截图&#x2F;输出自测报告；</li><li>每个需求测试通过后（多人任务下的唯一责任人），群里 (推荐)或其他方式通知项目经理，并把转测报告表中的“转测状态”改为“可转测”；</li><li>项目经理组织审查</li><li>项目经理以邮件的方式把“可转测”清单提供并通知测试组，要求测试组安排测试；后把“转测状态”改为“已提测”；</li></ol><p>关于自测报告：<br>前端自测报告在转测报告总表录入；涉及到后端的任务（前后端&amp;纯后端）务必也要严格按要求输出测试报告，所有后端开发人员务必严格执行，内容大纲参考以下模板，<br><a href="https://doc.weixin.qq.com/doc/w3_AIgA6waJABctK6W7TtQS5qL5EY7nP?scode=ABwA9Qd2ABEP6sW17FAfMATQabAPc">https://doc.weixin.qq.com/doc/w3_AIgA6waJABctK6W7TtQS5qL5EY7nP?scode=ABwA9Qd2ABEP6sW17FAfMATQabAPc</a><br>报告命名：分支-需求&#x2F;BUG-ID-时间-gitlab账号.docx<br>报告存放目录（微盘）：[研发部资料]&#x2F;总控引擎版本迭代&#x2F;v1.3.0&#x2F;执行阶段&#x2F;开发类文档&#x2F;自测报告</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>on-premise综述.md</title>
    <link href="/2023/11/02/mdstorage/domain/cloud/apigateway/on-premise%E7%BB%BC%E8%BF%B0/"/>
    <url>/2023/11/02/mdstorage/domain/cloud/apigateway/on-premise%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p>“On-premises”（现场或本地部署）是指企业在其自己的物理位置（例如公司的数据中心）中部署和管理IT基础设施和应用程序，而不是将它们托管在云服务提供商的数据中心。这种部署模型具有一些独特的特点和优势，但也带来了一些挑战。以下是关于on-premises部署模型的详细解释：</p><ol><li><p><strong>控制和定制</strong>：</p><ul><li>企业拥有对其IT基础设施和应用程序的完全控制，可以根据自身的需求和偏好进行定制。这包括选择硬件配置、网络架构、安全控制等。</li></ul></li><li><p><strong>数据安全和合规</strong>：</p><ul><li>企业可以保持对数据的完全控制，并确保数据符合所有适用的法律和合规要求。这对于需要遵守严格数据保护法律的企业和行业（例如医疗保健和金融服务）尤为重要。</li></ul></li><li><p><strong>性能和延迟</strong>：</p><ul><li>由于基础设施位于企业的物理位置，通常可以实现较低的网络延迟和较高的性能。这对于需要实时处理和低延迟的应用程序和服务尤为重要。</li></ul></li><li><p><strong>资本支出（CapEx）</strong>：</p><ul><li>On-premises部署通常需要较高的初始资本投资，用于购买和安装硬件、软件和其他基础设施组件。这与云部署的运营支出（OpEx）模型形成了对比。</li></ul></li><li><p><strong>运营和维护</strong>：</p><ul><li>企业需要负责所有运营和维护任务，包括硬件维修、软件更新、安全补丁应用、监控和故障排除等。这可能需要投入较多的时间和资源。</li></ul></li><li><p><strong>灵活性和可扩展性</strong>：</p><ul><li>在本地部署模型中，增加或减少资源可能会比较困难和耗时，因为它可能需要购买新的硬件或重新配置现有的系统。</li></ul></li><li><p><strong>技术遗留和兼容性</strong>：</p><ul><li>企业可以继续使用现有的技术和应用程序，而无需进行重大的迁移或升级。这可以减少迁移风险和成本，但也可能限制了对新技术的采用和创新。</li></ul></li><li><p><strong>资源利用率</strong>：</p><ul><li>本地部署可能会导致资源利用率较低，因为资源可能在非高峰时段闲置，而且可能很难根据需求快速调整资源分配。</li></ul></li></ol><h2 id="优劣势"><a href="#优劣势" class="headerlink" title="优劣势"></a>优劣势</h2><p>在比较On-premise（本地）部署模型与其他部署模型（例如公有云、私有云和混合云）时，可以从多个维度分析它们的优势和劣势：</p><h3 id="On-premise部署模型："><a href="#On-premise部署模型：" class="headerlink" title="On-premise部署模型："></a>On-premise部署模型：</h3><h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><ol><li><strong>控制和定制</strong>：企业拥有对硬件和软件的完全控制，能够定制基础设施以满足特定的需求和标准。</li><li><strong>数据安全和合规</strong>：保持数据在本地，更容易满足某些行业和地区的严格数据保护和合规要求。</li><li><strong>性能和延迟</strong>：由于网络距离较短，通常可以实现较低的延迟和较高的性能。</li><li><strong>技术遗留和兼容性</strong>：能够支持现有的应用程序和技术，减少迁移风险和成本。</li></ol><h4 id="劣势："><a href="#劣势：" class="headerlink" title="劣势："></a>劣势：</h4><ol><li><strong>高初始成本</strong>：需要较大的资本投资来购买和安装硬件、软件和网络设施。</li><li><strong>运营和维护负担</strong>：企业需要负责所有的运营、维护和升级任务，可能需要投入大量时间和资源。</li><li><strong>缺乏灵活性和可扩展性</strong>：增加或减少资源可能需要更多的时间和努力，因为它可能需要购买新的硬件或重新配置现有系统。</li><li><strong>资源利用率可能较低</strong>：可能难以根据需求快速调整资源分配，可能会导致资源在非高峰时段闲置。</li></ol><h3 id="公有云部署模型："><a href="#公有云部署模型：" class="headerlink" title="公有云部署模型："></a>公有云部署模型：</h3><h4 id="优势：-1"><a href="#优势：-1" class="headerlink" title="优势："></a>优势：</h4><ol><li><strong>按需付费</strong>：按使用量付费，无需大量初始投资。</li><li><strong>灵活性和可扩展性</strong>：能够快速地扩展或缩减资源以应对需求变化。</li><li><strong>减轻运营负担</strong>：云服务提供商负责基础设施的运营和维护，让企业可以专注于核心业务。</li><li><strong>访问先进技术</strong>：通常可以快速访问最新的技术和服务，无需自行部署和管理。</li></ol><h4 id="劣势：-1"><a href="#劣势：-1" class="headerlink" title="劣势："></a>劣势：</h4><ol><li><strong>可能的安全和合规风险</strong>：数据存储在外部服务提供商的数据中心，可能会面临安全和合规风险。</li><li><strong>可能的性能问题</strong>：网络延迟可能较高，特别是对于实时或延迟敏感的应用程序。</li><li><strong>长期成本</strong>：虽然初始成本较低，但长期的运营支出可能会累积，特别是对于大规模的部署。</li></ol><h3 id="私有云和混合云部署模型："><a href="#私有云和混合云部署模型：" class="headerlink" title="私有云和混合云部署模型："></a>私有云和混合云部署模型：</h3><h4 id="优势：-2"><a href="#优势：-2" class="headerlink" title="优势："></a>优势：</h4><ol><li><strong>灵活性和控制</strong>：结合了本地和公有云的优势，提供了灵活性和控制权。</li><li><strong>安全和合规</strong>：可以根据需要在本地和云之间移动数据和应用程序以满足安全和合规要求。</li><li><strong>资源优化</strong>：可以在本地保留关键应用程序和数据，同时利用公有云的资源和服务。</li></ol><h4 id="劣势：-2"><a href="#劣势：-2" class="headerlink" title="劣势："></a>劣势：</h4><ol><li><strong>复杂性</strong>：管理和运营可能更复杂，因为需要跨多个环境协调资源和服务。</li><li><strong>可能的高成本</strong>：可能需要投资于额外的管理工具和技能，以有效地管理混合云环境。</li></ol><p>每种部署模型都有其适用的场景和考虑因素。企业应根据自身的业务需求、技术能力和长期战略来选择最适合自己的部署模型。</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>在研发On-premise（现场或本地部署）模型的软件产品时，开发者需要注意一系列的因素以确保软件能够在客户的本地环境中顺利运行并满足他们的需求。以下是一些主要的考虑点：</p><ol><li><p><strong>系统兼容性</strong>：</p><ul><li>需要确保软件能够在不同的操作系统、硬件和网络配置上运行。</li><li>考虑创建多平台的安装程序，以确保软件能够在多种操作系统和环境中安装和运行。</li></ul></li><li><p><strong>可配置性和定制性</strong>：</p><ul><li>提供丰富的配置选项，以便客户能够根据自己的环境和需求调整软件的设置。</li><li>提供API和插件机制，以便客户能够扩展软件的功能或集成其他系统。</li></ul></li><li><p><strong>安装和部署</strong>：</p><ul><li>创建清晰、简单的安装和配置指南，以便客户能够容易地部署软件。</li><li>考虑提供自动化的安装和配置工具，以简化部署过程。</li></ul></li><li><p><strong>数据安全和合规</strong>：</p><ul><li>实现强大的安全控制，例如访问控制、加密和审计，以保护客户数据的安全。</li><li>提供必要的合规工具和报告，以便客户能够满足法律和行业标准的要求。</li></ul></li><li><p><strong>性能和可扩展性</strong>：</p><ul><li>优化软件的性能，确保它能够在不同规模的环境中高效运行。</li><li>提供必要的工具和选项，以便客户能够扩展软件的能力以应对增长的需求。</li></ul></li><li><p><strong>监控和维护</strong>：</p><ul><li>提供日志、监控和诊断工具，以便客户能够监控软件的状态和性能。</li><li>提供清晰的错误消息和文档，以便客户能够解决问题和进行维护。</li></ul></li><li><p><strong>升级和更新</strong>：</p><ul><li>设计简单、安全的升级和更新机制，以便客户能够容易地获取和安装软件的新版本。</li><li>提供版本控制和回滚机制，以便在升级出现问题时能够恢复到之前的状态。</li></ul></li><li><p><strong>技术支持和文档</strong>：</p><ul><li>提供详细、清晰的用户文档和技术支持，以便客户能够最大限度地利用软件。</li><li>建立有效的技术支持和反馈渠道，以便客户能够获取帮助和提供反馈。</li></ul></li><li><p><strong>许可和付费模型</strong>：</p><ul><li>设计清晰、公平的许可和付费模型，以便客户能够理解软件的成本和价值。</li></ul></li><li><p><strong>测试和质量保证</strong>：</p><ul><li>在实际的本地环境中进行充分的测试，以确保软件的稳定性和可靠性。</li><li>提供测试工具和环境，以便客户能够验证软件在他们的环境中的行为和性能。</li></ul></li></ol><p>通过考虑上述因素，开发者可以创建一个强大、可靠和易于使用的On-premise软件产品，同时满足客户的需求和期望。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>cloud/apigateway</category>
      
    </categories>
    
    
    <tags>
      
      <tag>deploy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云原生综述.md</title>
    <link href="/2023/11/02/mdstorage/domain/cloud/apigateway/%E4%BA%91%E5%8E%9F%E7%94%9F%E7%BB%BC%E8%BF%B0/"/>
    <url>/2023/11/02/mdstorage/domain/cloud/apigateway/%E4%BA%91%E5%8E%9F%E7%94%9F%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><p>云原生是一种构建和运行应用程序的<strong>方法</strong>，它利用了云计算的优势。云原生应用程序是为云设计的，而不仅仅是在云中运行。以下是云原生的一些核心要素和定义：</p><ol><li><p><strong>微服务架构</strong>：</p><ul><li>云原生应用通常采用微服务架构，将应用程序分解为一组小型、独立和可部署的服务，每个服务都有明确的业务功能，可以独立地开发、部署和扩展。</li></ul></li><li><p><strong>容器化</strong>：</p><ul><li>云原生应用通常使用容器技术（如Docker）来封装和运行服务。容器提供了一个轻量级、一致和可移植的运行时环境。</li></ul></li><li><p><strong>编排和自动化</strong>：</p><ul><li>云原生应用使用编排系统（如Kubernetes）来自动化部署、管理和扩缩容。这种自动化能力使应用能够快速响应负载变化，并提高系统的可靠性和效率。</li></ul></li><li><p><strong>持续交付和持续集成（CI&#x2F;CD）</strong>：</p><ul><li>云原生文化强调使用持续交付和持续集成的方法，以实现快速、可靠和持续的代码交付和更新。</li></ul></li><li><p><strong>基于云的资源和服务</strong>：</p><ul><li>云原生应用利用云基础设施提供的资源和服务，如计算、存储和网络资源，以及云平台提供的其他服务（如数据库、消息队列和监控）。</li></ul></li><li><p><strong>可观测性</strong>：</p><ul><li>云原生应用具有全面的监控、日志记录和诊断能力，以支持实时的系统状态监控、错误检测和问题诊断。</li></ul></li><li><p><strong>弹性和可恢复性</strong>：</p><ul><li>云原生应用设计时考虑到系统的弹性和可恢复性，能够自动应对不同的负载情况，并在组件失败时保持良好的恢复能力。</li></ul></li></ol><p>综上所述，云原生是一种利用云计算特性来构建、运行和优化应用程序的方法和理念，它强调微服务、容器化、自动化和可观测性等，以实现应用程序的高效、可靠和快速交付。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>cloud/apigateway</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AWS综述.md</title>
    <link href="/2023/11/02/mdstorage/domain/cloud/enterprise_organization/AWS%E7%BB%BC%E8%BF%B0/"/>
    <url>/2023/11/02/mdstorage/domain/cloud/enterprise_organization/AWS%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><p>Amazon Web Services（AWS）是Amazon的子公司，提供了一个广泛且不断发展的云计算平台。以下是关于AWS的详细介绍：</p><ol><li><p><strong>概述</strong>：</p><ul><li>AWS是全球最全面且广泛采用的云服务平台，提供超过200种完全功能的服务，这些服务来自全球的数据中心。数百万客户，包括快速成长的创业公司、大型企业和主要政府机构，都在使用AWS以降低成本、提高敏捷性并加速创新【100†(aws.amazon.com)】。</li><li>AWS提供按需、按实际使用付费的云计算平台和API，服务对象包括个人、公司和政府【101†(Wikipedia)】。</li><li>AWS的云计算平台包括基础设施即服务(IaaS)、平台即服务(PaaS)和软件即服务(SaaS)等多种云服务【102†(TechTarget)】。</li></ul></li><li><p><strong>服务</strong>：</p><ul><li>AWS提供了一系列全球云产品，包括计算、存储、数据库、网络和内容交付、分析、机器学习、安全、身份和合规等，这些服务帮助组织更快地移动、降低IT成本并实现扩展【103†(aws.amazon.com)】。</li></ul></li><li><p><strong>历史</strong>：</p><ul><li>AWS始于2006年，最初提供IT基础设施服务，现在被公认为云计算。云计算的一大好处是可以用低变动成本替换前期的资本基础设施费用，这些变动成本随着业务规模的变化而变化。通过云，企业无需提前几周或几个月计划和采购服务器及其他IT基础设施，而是可以在几分钟内立即启动数百或数千台服务器，从而更快地交付结果【107†(docs.aws.amazon.com)】。</li></ul></li><li><p><strong>全球影响</strong>：</p><ul><li>如今，AWS在全球190个国家为数十万家企业提供高度可靠、可扩展和低成本的云基础设施平台【107†(docs.aws.amazon.com)】。</li></ul></li></ol><p>AWS通过其丰富的云服务和全球影响力，为各种规模的企业和组织提供了快速创新和发展的可能性。通过AWS，用户可以以更低的成本、更高的效率和更大的灵活性来运行和扩展他们的应用和服务。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>cloud/enterprise_organization</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CloudSecurityAlliance.md</title>
    <link href="/2023/11/02/mdstorage/domain/cloud/enterprise_organization/CloudSecurityAlliance/"/>
    <url>/2023/11/02/mdstorage/domain/cloud/enterprise_organization/CloudSecurityAlliance/</url>
    
    <content type="html"><![CDATA[<h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><p>Cloud Security Alliance (CSA) 是一个全球领先的非营利组织，专注于定义和提升对云计算环境安全最佳实践的认识。以下是关于CSA的一些详细信息：</p><ol><li><p><strong>组织目标和活动</strong>：</p><ul><li>CSA的主要目标是确保云计算环境的安全。它通过定义最佳实践和提高相关认识来实现这一目标【85†(CSA官网)】。</li><li>CSA提供了各种资源和培训，包括云安全认证、最新的云安全研究、以及与STAR（安全信任保证和风险管理）合规性的改进方法【92†(CSA官网)】。</li></ul></li><li><p><strong>会员和全球影响</strong>：</p><ul><li>CSA拥有大约60名全职和合同员工，以及数千名活跃的志愿者，他们参与研究、工作组和各地的章节活动【86†(维基百科)】。</li></ul></li><li><p><strong>教育和认证</strong>：</p><ul><li>CSA提供的教育和认证项目包括云安全知识证书（CCSK）、云审计知识证书（CCAK）和STAR注册等，旨在提高组织的安全和合规性，同时也为行业和国家提供了构建自己的云保证生态系统的工具和指南【92†(CSA官网)】。</li></ul></li><li><p><strong>研究和战略倡议</strong>：</p><ul><li>CSA通过其研究组和战略倡议探讨了包括云保证、核心云、未来云等多个方面的主题，涉及零信任、量子安全、人工智能等创新技术和策略，旨在帮助组织应对当前的云安全挑战，并为未来的云和网络安全塑造未来【92†(CSA官网)】。</li></ul></li><li><p><strong>合作和合作关系</strong>：</p><ul><li>CSA与行业实践者、协会、政府以及其企业和个人会员合作，推动云计算安全最佳实践的研究，同时利用云技术保护其他形式的计算【88†(TechTarget)】。</li></ul></li></ol><p>通过以上信息，可以看出CSA是一个致力于通过教育、认证和研究来提高云安全意识和实践的重要组织。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>cloud/enterprise_organization</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cloud</tag>
      
      <tag>security</tag>
      
      <tag>organization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Iaas综述.md</title>
    <link href="/2023/11/01/mdstorage/domain/cloud/Iaas%E7%BB%BC%E8%BF%B0/"/>
    <url>/2023/11/01/mdstorage/domain/cloud/Iaas%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>IaaS（基础设施即服务）的背景和发展与云计算技术的崛起密切相关。下面是 IaaS 背景的一些重要方面：</p><ol><li><p><strong>云计算的崛起</strong>：</p><ul><li>云计算技术的出现为 IaaS 提供了基础。在 2000 年代初，随着虚拟化技术的发展和互联网的普及，云计算开始成为可能。它允许企业和个人通过网络访问计算资源，而无需购买和维护物理硬件。</li></ul></li><li><p><strong>虚拟化技术</strong>：</p><ul><li>虚拟化技术是 IaaS 的核心组成部分。它允许在单个物理服务器上运行多个虚拟机，每个虚拟机都有自己的操作系统和应用程序。虚拟化降低了计算资源的成本，并增加了资源利用率。</li></ul></li><li><p><strong>早期的云服务提供商</strong>：</p><ul><li>早期的云服务提供商（如 Amazon Web Services 和 Google Cloud Platform）开始提供 IaaS 服务，使企业能够按需租用计算资源。这减少了企业的资本支出，并提供了更大的灵活性。</li></ul></li><li><p><strong>标准化和开源运动</strong>：</p><ul><li>云计算标准的制定和开源云计算项目（如 OpenStack）的发展为 IaaS 的发展提供了推动力。标准化使得云服务提供商能够提供兼容和可交互操作的服务，而开源项目为企业提供了构建和管理自己的 IaaS 平台的工具。</li></ul></li><li><p><strong>企业的云迁移和数字化转型</strong>：</p><ul><li>众多企业开始寻求通过云计算实现数字化转型。IaaS 成为许多企业的首选，因为它提供了对基础设施的高度控制，并能够容易地集成现有的系统和应用程序。</li></ul></li><li><p><strong>法规和合规要求</strong>：</p><ul><li>随着数据隐私和安全法规的增加，IaaS 提供商开始加强安全和合规控制，以满足客户的需求。同时，IaaS 也帮助企业更容易地满足各种法律和行业标准的要求。</li></ul></li><li><p><strong>持续的技术创新</strong>：</p><ul><li>随着技术的不断发展，例如容器化和服务网格，IaaS 也在不断创新，提供更多高级功能和更好的性能，以满足现代企业的需求。</li></ul></li></ol><p>IaaS 的发展反映了云计算技术的持续进步和企业数字化转型的需求。它为企业提供了一个灵活、可扩展和可管理的基础设施平台，使他们能够快速适应市场变化和业务需求。</p><h2 id="知识基石"><a href="#知识基石" class="headerlink" title="知识基石"></a>知识基石</h2><p>成为 IaaS（基础设施即服务）领域的专家需要具备广泛和深入的知识和技能。以下是一些核心的知识领域和建议：</p><ol><li><p><strong>虚拟化技术</strong>：</p><ul><li>熟悉虚拟化技术的原理和实践，包括服务器虚拟化、网络虚拟化和存储虚拟化。</li><li>熟悉主流的虚拟化平台和工具，如 VMware, Microsoft Hyper-V 和 KVM。</li></ul></li><li><p><strong>云计算基础</strong>：</p><ul><li>了解云计算的基本概念、架构和服务模型（IaaS、PaaS 和 SaaS）。</li><li>了解云计算的部署模型，如公有云、私有云和混合云。</li></ul></li><li><p><strong>网络和安全</strong>：</p><ul><li>熟悉网络基础设施和协议，包括 IP 地址、子网、路由和负载均衡。</li><li>了解网络安全的基本原则和实践，包括防火墙、VPN、身份验证和授权。</li></ul></li><li><p><strong>存储技术</strong>：</p><ul><li>熟悉不同类型的存储技术和架构，包括块存储、文件存储和对象存储。</li><li>了解存储性能优化、数据备份和恢复的基本方法。</li></ul></li><li><p><strong>操作系统和中间件</strong>：</p><ul><li>熟悉常见的操作系统（如 Linux 和 Windows）及其管理。</li><li>了解常见的中间件组件和服务，如数据库、消息队列和应用服务器。</li></ul></li><li><p><strong>自动化和编程</strong>：</p><ul><li>熟悉基本的编程和脚本语言，如 Python 和 Shell。</li><li>了解基本的自动化工具和框架，如 Ansible、Terraform 和 Kubernetes。</li></ul></li><li><p><strong>监控和优化</strong>：</p><ul><li>熟悉常见的监控工具和方法，以及如何分析和优化系统性能。</li><li>了解如何诊断和解决常见的性能和可靠性问题。</li></ul></li><li><p><strong>架构设计和最佳实践</strong>：</p><ul><li>了解如何设计和优化 IaaS 架构，以满足不同的性能、可靠性和安全要求。</li><li>熟悉云计算和 IaaS 领域的最佳实践和推荐指南。</li></ul></li><li><p><strong>持续学习和实践</strong>：</p><ul><li>保持对新技术和行业趋势的关注，并不断学习和实践。</li><li>获取相关的认证和培训，如 AWS Certified Solutions Architect 或 Google Cloud Certified Professional Cloud Architect。</li></ul></li><li><p><strong>项目管理和沟通技巧</strong>：</p><ul><li>熟悉基本的项目管理和沟通技巧，以便能够有效地与团队和客户合作。</li><li>了解如何解释和传达复杂的技术概念和解决方案。</li></ul></li></ol><p>通过学习上述知识和技能，积累实际经验，并参与相关的项目和社区活动，你将能够逐渐成为 IaaS 领域的专家。同时，保持对新技术和行业动态的持续关注，以及不断的学习和实践，是成为该领域专家的关键。</p>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typora_pandoc_picgo安装.md</title>
    <link href="/2023/11/01/mdstorage/resource/typora_pandoc_picgo/pandoc%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/11/01/mdstorage/resource/typora_pandoc_picgo/pandoc%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><ul><li><p>申请 person token</p><p>github 里面需要 repo 权限即可</p></li><li><p>仓库名</p><p>abrance&#x2F;ImageStorage 这样即可</p></li><li><p>分支名</p><p>master</p></li></ul><h3 id="typora"><a href="#typora" class="headerlink" title="typora"></a>typora</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">申请 person token<br><br>github 里面需要 repo 权限即可<br></code></pre></td></tr></table></figure><h3 id="pandoc"><a href="#pandoc" class="headerlink" title="pandoc"></a>pandoc</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">仓库名<br></code></pre></td></tr></table></figure><h3 id="picgo"><a href="#picgo" class="headerlink" title="picgo"></a>picgo</h3><ul><li><p>下载 AppImage 后缀的文件</p></li><li><p>给予可执行权限</p></li><li><p>运行</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>typora_pandoc_picgo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown 安装</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typora_pandoc_picgo安装.md</title>
    <link href="/2023/11/01/mdstorage/resource/typora_pandoc_picgo/typora_pandoc_picgo%E5%AE%89%E8%A3%85/"/>
    <url>/2023/11/01/mdstorage/resource/typora_pandoc_picgo/typora_pandoc_picgo%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h3 id="Ubuntu22-04"><a href="#Ubuntu22-04" class="headerlink" title="Ubuntu22.04"></a>Ubuntu22.04</h3><ul><li><p>typora</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># or run:</span><br><span class="hljs-comment"># sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span><br>wget -qO - https://typora.io/linux/public-key.asc | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/apt/trusted.gpg.d/typora.asc<br><br><span class="hljs-comment"># add Typora&#x27;s repository</span><br><span class="hljs-built_in">sudo</span> add-apt-repository <span class="hljs-string">&#x27;deb https://typora.io/linux ./&#x27;</span><br><span class="hljs-built_in">sudo</span> apt-get update<br><br><span class="hljs-comment"># install typora</span><br><span class="hljs-built_in">sudo</span> apt-get install typora<br></code></pre></td></tr></table></figure></li><li><p>pandoc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget <span class="hljs-variable">$deb_package_uri</span><br><span class="hljs-built_in">sudo</span> dpkg -i <span class="hljs-variable">$deb_package</span><br></code></pre></td></tr></table></figure></li><li><p>picgo</p><ul><li>下载 AppImage 后缀的文件</li><li>给予可执行权限</li><li>运行</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>typora_pandoc_picgo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown install</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typora使用.md</title>
    <link href="/2023/11/01/mdstorage/resource/typora_pandoc_picgo/typora%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/11/01/mdstorage/resource/typora_pandoc_picgo/typora%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="导入和导出"><a href="#导入和导出" class="headerlink" title="导入和导出"></a>导入和导出</h3><h4 id="word"><a href="#word" class="headerlink" title="word"></a>word</h4><ul><li><p>导入</p><p>文件 -&gt; 导入</p><p>可将 pandoc 支持识别的都识别出来</p></li><li><p>导出</p><p>文件 -&gt; 导出</p><p>可将 pandoc支持导出功能发挥</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>typora_pandoc_picgo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
      <tag>word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typora插件.md</title>
    <link href="/2023/11/01/mdstorage/resource/typora_pandoc_picgo/typora%E6%8F%92%E4%BB%B6/"/>
    <url>/2023/11/01/mdstorage/resource/typora_pandoc_picgo/typora%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="插件概述"><a href="#插件概述" class="headerlink" title="插件概述"></a>插件概述</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><a href="https://github.com/obgnail/typora_plugin#%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E">github typora plugin use</a></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><a href="https://github.com/obgnail/typora_plugin#%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E">使用</a></p><h3 id="常用插件快捷键"><a href="#常用插件快捷键" class="headerlink" title="常用插件快捷键"></a>常用插件快捷键</h3><ul><li>C-S-B  中英间隔 1 space</li><li>C-j 搜索</li><li>鼠标右键 插件功能</li></ul><h3 id="常用插件功能"><a href="#常用插件功能" class="headerlink" title="常用插件功能"></a>常用插件功能</h3><ul><li>文件模板</li><li>kanban 功能</li><li>标签页（记得只保留一个，多了会出现现实问题）</li><li>markdown 格式检查</li></ul><h3 id="插件开关配置"><a href="#插件开关配置" class="headerlink" title="插件开关配置"></a>插件开关配置</h3><ul><li>linux<ul><li>右键 -&gt; 非常用插件 -&gt; 右键菜单 -&gt; 打开插件配置文件</li><li>settings.default.toml 里的配置 拷贝 到 settings.user.toml 中，将对应插件的 （sudo gedit settings.user.toml）启用插件 ENABLE &#x3D; false&#x2F;true</li><li>（建议关闭标签页管理插件window_tab，经常有问题）</li></ul></li><li>windows</li></ul>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>typora_pandoc_picgo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>plugin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typora配置.md</title>
    <link href="/2023/11/01/mdstorage/resource/typora_pandoc_picgo/typora%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/11/01/mdstorage/resource/typora_pandoc_picgo/typora%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="偏好设置"><a href="#偏好设置" class="headerlink" title="偏好设置"></a>偏好设置</h3><ul><li><p>导出</p><ul><li>默认导出的文件夹 -&gt; 同一目录下</li><li>pandoc路径 -&gt; $ where pandoc</li><li>导出后打开导出目录</li></ul></li><li><p>图片上传设置</p><ul><li>图像 -&gt; 上传服务设定 -&gt;  <ul><li>上传服务 ： PicGo(app)</li><li>PicGo路径  ： $picgo_appimage_uri</li><li>验证图像上传选项</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>resource</category>
      
      <category>typora_pandoc_picgo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
      <tag>convert</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>api网关综述.md</title>
    <link href="/2023/11/01/mdstorage/domain/cloud/apigateway/api%E7%BD%91%E5%85%B3%E7%BB%BC%E8%BF%B0/"/>
    <url>/2023/11/01/mdstorage/domain/cloud/apigateway/api%E7%BD%91%E5%85%B3%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="API-网关的历史"><a href="#API-网关的历史" class="headerlink" title="API 网关的历史"></a>API 网关的历史</h2><p>流量治理和 API 网关之间的关系密切且互补。它们在网络和软件架构领域中的应用可以增强系统的稳定性、可用性和性能。以下是流量治理和 API 网关之间的主要关系及其在网络和软件开发领域中的应用：</p><ol><li><p><strong>功能交叉</strong>：</p><ul><li><strong>API 网关</strong> 提供了一个集中的入口点，用于处理进出微服务架构的所有请求。它可以执行请求的路由、认证、授权、监控以及其他一些功能。</li><li><strong>流量治理</strong> 是管理网络流量的一种方法，它包括负载均衡、流量分配、限流、熔断和流量监控等功能。</li></ul></li><li><p><strong>流量控制</strong>：</p><ul><li><strong>API 网关</strong> 可以实现流量治理的某些功能，例如通过限流和负载均衡来管理不同服务之间的流量，确保系统的稳定运行。</li><li><strong>流量治理</strong> 通常在 API 网关中实现，以确保对服务的访问是可控且合理的，防止系统过载并保持高可用性。</li></ul></li><li><p><strong>安全和监控</strong>：</p><ul><li><strong>API 网关</strong> 能够提供一定的安全防护，例如通过身份验证和授权来保护后端服务。同时，它也可以通过日志和监控来提供对系统流量的实时视图。</li><li><strong>流量治理</strong> 通过监控网络流量和实施安全策略，也能够增强系统的安全性。</li></ul></li><li><p><strong>性能优化</strong>：</p><ul><li><strong>API 网关</strong> 和 <strong>流量治理</strong> 可以通过缓存、请求优化和响应转换等方式，帮助优化系统的性能。</li></ul></li><li><p><strong>故障处理</strong>：</p><ul><li>通过在 <strong>API 网关</strong> 中实现 <strong>流量治理</strong> 的熔断机制，可以在后端服务发生故障时保持系统的可用性，通过重试、回退和重定向等策略来处理失败的请求。</li></ul></li><li><p><strong>集中式管理</strong>：</p><ul><li>通过 <strong>API 网关</strong>，可以实现对多个服务和流量的集中式管理，这在微服务架构中尤为重要。</li></ul></li></ol><p>综上所述，流量治理和 API 网关是相互补充的，它们共同作用于网络和软件架构领域，以确保系统的稳定性、可用性和性能。在实际应用中，API 网关通常会集成流量治理的功能，为微服务架构提供统一、可控且高效的网络流量管理解决方案。</p><h2 id="API-网关的过去、现在和未来"><a href="#API-网关的过去、现在和未来" class="headerlink" title="API 网关的过去、现在和未来"></a>API 网关的过去、现在和未来</h2><ol><li><p><strong>标题和源头</strong>:</p><ul><li><a href="https://www.infoq.com/articles/past-present-future-api-gateways/">infoQ</a></li></ul></li><li><p><strong>日期和作者</strong>:</p><ul><li>记录资讯的发布日期和作者，以了解资讯的时效性和作者的背景。</li></ul></li><li><p><strong>摘要</strong>:</p><ul><li>创建一个简短的摘要，概述资讯的主要内容和观点。这将帮助您快速回顾资讯的核心信息。</li></ul></li><li><p><strong>关键点和数据</strong>:</p><p>早期的互联网</p><ul><li>web 应用的体系结构为经典的 n 层体系结构，由数据库层、应用程序层和表示层组成。n 层体系结构是水平可扩展的 – 随着流量的增加，可以添加更多应用程序体系结构和表示层的实例。</li><li>将应用程序或表示层的多个实例连接到 Internet 需要数据中心边缘的第一次迭代：负载平衡器。在这个时代，负载均衡器负责在应用程序的不同实例之间路由流量，确保高可用性和可扩展性。负载平衡器通常是一种硬件设备。</li><li>2001 年 HAProxy 的发布开始普及软件负载平衡器的概念</li></ul><p>网络 2.0</p><ul><li>Darcy DiNucci 在 2 年创造了 Web 0.1999 一词，指的是互联网从单向媒介演变为用户参与网站的双向媒介。Web 2.0 网站不是被动的内容消费者，而是让用户积极贡献和相互参与。AJAX（异步 JavaScript 和 XML）开发技术变得无处不在。通过将数据交换与表示分离，AJAX 为最终用户创造了更丰富的用户体验。这种架构还创建了许多“聊天”客户端，因为这些客户端会不断地从 Web 应用程序发送和接收数据。</li><li>电子商务开始起飞，信用卡信息的安全传输首次成为主要问题。Netscape 引入了安全套接字层 （SSL），后来演变为传输层安全 （TLS），以确保客户端和服务器之间的安全连接。</li><li>网络的这些转变 - 加密通信和许多长期连接请求 - 推动了边缘从标准硬件&#x2F;软件负载平衡器向更专业的应用交付控制器（ADC）的演变。ADC 包括各种所谓的应用程序加速功能，包括 SSL 卸载、缓存和压缩。这种功能的增加意味着配置复杂性的增加。出现了各种专有配置标准，例如 VCL、SSI。负载均衡器不再只是负载均衡！</li></ul><p>网络规模时代</p><ul><li><strong>扩展问题</strong>：2010 年代初期，许多云优先公司的用户群呈指数级增长。这些公司背后的软件最初是使用易于使用的 Web 框架（如 Ruby on Rails 和 Django）构建为单体 Web 应用程序。随着他们的用户群膨胀到天文数字，这些公司发现网络规模问题确实是一种不同类型的问题，它决定了不同的架构。</li><li><strong>单体架构重构</strong>： Twitter、Facebook 和 New Relic 等公司开始将关键功能从其单体架构中重构为独立部署的服务。通过将关键业务功能部署为服务，这些组织能够独立扩展和管理其整个应用程序的不同方面。流向这些独立服务的流量通过单体架构进行路由。对路由的任何更改都意味着开发人员经常不得不重新部署整个单体。这成为变革速度的瓶颈。</li></ul><p>API 网关的兴起</p><ul><li><strong>从单体到微服务</strong>：早期的技术公司在从单体应用向微服务架构转变时，发现原先的单体应用主要承担路由功能。</li><li><strong>API 网关的诞生</strong>：这个观察促成了 API 网关的开发，API 网关承担了原单体中的路由功能，并为整个应用提供了一个共同的外观（facade）。</li><li><strong>集中化跨服务功能</strong>：API 网关集中了跨应用的公共功能，如速率限制、身份验证和路由。</li><li><strong>减少重复功能</strong>：这种集中化减少了在每个单独服务中所需的重复功能的数量，优化了整个服务架构。</li></ul><p>云原生时代：微服务</p><ul><li><p>API 网关为适应微服务架构的需求而不断演进，其现代化的关键点包括：</p><ul><li><strong>支持跨应用层面的关注点</strong>：如身份验证、速率限制、API 发布和指标收集。</li><li><strong>集成了流量管理功能</strong>：这些功能在传统的应用交付控制器中常见，包括高级负载均衡、缓存以及自动重试和超时等。</li><li><strong>支持实时服务发现</strong>：在诸如 Kubernetes 或无服务器环境这样短暂的环境中部署微服务时，实时发现每个微服务实例的网络位置至关重要。</li></ul></li></ul><p>全周期开发：云原生工作流</p><ul><li><strong>拥抱全生命周期开发</strong><ul><li><strong>缩放发布和部署</strong><ul><li>部署是在生产基础结构上安装代码更新的过程。发布是向实际生产用户公开代码更新的过程。虽然组织可以将部署和发布视为一个操作（所谓的“就地发布”模型），但这会向生产用户暴露实际的部署风险。例如，缺少必需的配置参数可能会导致最终用户在就地释放模型中出现可见的中断。通过将这两个阶段分开，部署风险永远不会暴露给最终用户。</li><li>数据中心网关在发布中起着至关重要的作用。通过控制流向特定版本微服务的流量，网关负责向最终用户实际发布更新。此外，网关服务支持增量发布策略，例如金丝雀发布（随着时间的推移，一定比例的流量用于新的更新）或蓝&#x2F;绿部署。全周期开发团队需要对网关进行控制，以便编排发布。这些控制包括路由（哪个版本的服务应该接收生产流量）以及更细粒度的控制，例如加权路由（金丝雀版本需要）和流量镜像（为测试目的创建服务测试版本的流量副本）。通过使开发团队能够管理发布和部署，组织能够扩展这些流程以支持高度复杂的应用程序。</li></ul></li><li><strong>监视服务范围</strong><ul><li>网关通过分析流入和流出微服务的所有流量，提供对微服务行为的可视化分析。这使网关能够报告延迟、吞吐量和错误率等指标，从而深入了解应用程序运行状况。通过使用 OpenTracing 等标准在请求数据上引入相关标识符，实现了这种功能。最后，网关堆栈收集的所有这些指标都可配置的可视化工具向这些全周期开发团队公开。</li></ul></li></ul></li></ul><p>网关策略管理</p><ul><li><p>关键点和重点概述：</p><ul><li><strong>网关管理传统问题</strong>：传统上，网关的所有组件都由运维管理，而运维界面对于全周期开发团队中的应用开发者并不友好。</li><li><strong>独立操作的网关组件</strong>：网关组件通常独立操作，缺乏统一的操作界面。</li><li><strong>全周期开发者的需求</strong>：全周期开发者不是全职运维人员，他们需要能够为特定需求操作网关设备。</li><li><strong>Kubernetes 生态系统的指导</strong>：Kubernetes 模型中，用户用通用的 YAML 配置语言声明他们的意图，通过声明性模型实现策略的代码化，可通过源代码控制系统（如 GitOps）进行管理。</li><li><strong>声明性模型的好处</strong>：提供审计能力、版本控制和透明性。</li><li><strong>分散的策略支持</strong>：多个策略文件被聚合为整个集群的全局策略配置。</li><li><strong>API 网关模型的采纳</strong>：API 网关采纳了这种模型，例如 Azure Application Gateway 和 Kong 的入口控制器。</li><li><strong>向边缘扩展声明性配置模型</strong>：对于全周期开发团队至关重要，每个团队可以独立维护自己的网关策略，并与微服务代码一起在源代码控制中进行管理。</li></ul></li></ul></li><li><p><strong>图表和图片</strong>:</p><ul><li><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/1past-present-future-api-gateways-1-1589273542703.jpg" alt="img"></p></li><li><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/1past-present-future-api-gateways-3-1589273542183.jpg" alt="img"></p></li><li><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/1past-present-future-api-gateways-4-1589273541821.jpg" alt="img"></p></li><li><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/1past-present-future-api-gateways-5-1589273542447.jpg" alt="img"></p></li><li><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/1past-present-future-api-gateways-6-1589273541384.jpg" alt="img"></p></li></ul></li><li><p><strong>个人评价和思考</strong>:</p><ul><li>这篇文章是关于对 API 网关的综述性文档，对其发展历史中重要的节点部分作了简要描述，通过部分事例使读者能窥见 API网关所要解决的问题和发展的因果，写作思路和内容都非常有参考价值。</li></ul></li><li><p><strong>相关链接和参考资料</strong>:</p><ul><li>无</li></ul></li><li><p><strong>标签和分类</strong>:</p><ul><li>API网关</li><li>API gateway</li></ul></li><li><p><strong>后续行动和提醒</strong>:</p><ul><li>后续整理现代 API网关方面的模块清单</li></ul></li><li><p><strong>保存和归档</strong>:</p><ul><li>略</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>domain</category>
      
      <category>cloud/apigateway</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ideavim使用.md</title>
    <link href="/2023/01/03/mdstorage/ideavim%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/01/03/mdstorage/ideavim%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>vim</tag>
      
      <tag>idea</tag>
      
      <tag>jetbrains</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么越来越多的人选择养猫</title>
    <link href="/2001/11/18/mdstorage/project/%E5%86%99%E4%BD%9C/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%A4%9A%E7%9A%84%E4%BA%BA%E5%85%BB%E7%8C%AB/"/>
    <url>/2001/11/18/mdstorage/project/%E5%86%99%E4%BD%9C/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%A4%9A%E7%9A%84%E4%BA%BA%E5%85%BB%E7%8C%AB/</url>
    
    <content type="html"><![CDATA[<p>今日话题：为什么越来越多的人选择养猫？</p><p>评论一：现在养猫，简直成了一种潮流。不管是在社交媒体上，还是现实生活中，到处都能看到萌萌的猫咪和它们的铲屎官。原因嘛？首先得说，猫咪的确很可爱，那高冷的小眼神，忽冷忽热的性格，简直就是拽得掉渣的网红。再加上它们自给自足，不像狗狗那样需要高强度的陪伴和照顾，对于忙碌的现代人来说，是个不错的选择。</p><p>评论二：另外，别忘了，现代人的压力大得惊人，需要找个渠道释放压力。猫咪就像是一个行走的“压力球”，你看它们懒洋洋地躺在那儿，或者优雅地舔毛，心情都会变得平和。不用花太多精力照顾，回到家看到它们，就能感受到一天的疲惫烟消云散。</p><p>最后，我想说的是，养猫成为一种潮流，其实也反映了现代人内心深处的某种渴望：在快节奏的生活中找到一份宁静，和一个温暖的小生命共享平凡而真实的日常。猫咪给了我们简单纯粹的快乐，这也许就是越来越多人选择养猫的原因吧。毕竟，在这个复杂的世界里，有时候我们只需要一个小小的喵星人来陪伴。</p>]]></content>
    
    
    
    <tags>
      
      <tag>写作</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
