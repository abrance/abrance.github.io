

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="xiaoy">
  <meta name="keywords" content="">
  
    <meta name="description" content="[ Socket与系统调用深度分析 ](https:&#x2F;&#x2F;www.cnblogs.com&#x2F;RichardTAO&#x2F;p&#x2F;12070548.html “发布于2019-12-19 22:08”) 目录  系统调用 系统调用的过程 示例分析 Socket系统调用分析 sock_map_fd sock_create     实验代码分析 服务器端 InitializeService方法 ServiceStar">
<meta property="og:type" content="article">
<meta property="og:title" content="Socket的封装.md">
<meta property="og:url" content="https://abrance.github.io/2024/05/09/mdstorage/domain/network/Socket%E7%9A%84%E5%B0%81%E8%A3%85/index.html">
<meta property="og:site_name" content="Xiaoy">
<meta property="og:description" content="[ Socket与系统调用深度分析 ](https:&#x2F;&#x2F;www.cnblogs.com&#x2F;RichardTAO&#x2F;p&#x2F;12070548.html “发布于2019-12-19 22:08”) 目录  系统调用 系统调用的过程 示例分析 Socket系统调用分析 sock_map_fd sock_create     实验代码分析 服务器端 InitializeService方法 ServiceStar">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://abrance.github.io/Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219215912966-312816293.jpg">
<meta property="og:image" content="https://abrance.github.io/Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220313106-160394591.png">
<meta property="og:image" content="https://abrance.github.io/Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220327771-703485049.png">
<meta property="og:image" content="https://abrance.github.io/Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220337160-1475253107.png">
<meta property="og:image" content="https://abrance.github.io/Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220353159-565830860.png">
<meta property="og:image" content="https://abrance.github.io/Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220422911-665150556.png">
<meta property="og:image" content="https://abrance.github.io/Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220442073-678615520.png">
<meta property="og:image" content="https://abrance.github.io/Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220038758-277367624.png">
<meta property="og:image" content="https://abrance.github.io/Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220104626-1320211378.png">
<meta property="og:image" content="https://abrance.github.io/Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220110932633-776686874.png">
<meta property="og:image" content="https://abrance.github.io/Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220112841339-722490150.png">
<meta property="og:image" content="https://abrance.github.io/Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220119325-1227384307.png">
<meta property="og:image" content="https://abrance.github.io/Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220135410-1102664032.png">
<meta property="og:image" content="https://abrance.github.io/Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220113820375-991637153.png">
<meta property="og:image" content="https://abrance.github.io/Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220114004900-39215539.png">
<meta property="og:image" content="https://abrance.github.io/Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220114310702-177767569.png">
<meta property="og:image" content="https://abrance.github.io/Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220114430988-1788804597.png">
<meta property="og:image" content="https://abrance.github.io/Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220115302859-2131351471.png">
<meta property="article:published_time" content="2024-05-08T16:00:00.000Z">
<meta property="article:modified_time" content="2024-09-06T07:14:51.939Z">
<meta property="article:author" content="xiaoy">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://abrance.github.io/Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219215912966-312816293.jpg">
  
  
  
  <title>Socket的封装.md - Xiaoy</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"abrance.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>xiaoy</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Socket的封装.md"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-05-09 00:00" pubdate>
          2024年5月9日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          4.8k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          41 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Socket的封装.md</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Socket与系统调用深度分析-https-www-cnblogs-com-RichardTAO-p-12070548-html-“发布于"><a href="#Socket与系统调用深度分析-https-www-cnblogs-com-RichardTAO-p-12070548-html-“发布于" class="headerlink" title="[ Socket与系统调用深度分析 ](https://www.cnblogs.com/RichardTAO/p/12070548.html “发布于"></a>[ Socket与系统调用深度分析 ](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/RichardTAO/p/12070548.html">https://www.cnblogs.com/RichardTAO/p/12070548.html</a> “发布于</h1><p>2019-12-19 22:08”)</p>
<p>目录</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/RichardTAO/p/12070548.html#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">系统调用</a><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/RichardTAO/p/12070548.html#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B">系统调用的过程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/RichardTAO/p/12070548.html#%E7%A4%BA%E4%BE%8B%E5%88%86%E6%9E%90">示例分析</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/RichardTAO/p/12070548.html#socket%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%88%86%E6%9E%90">Socket系统调用分析</a><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/RichardTAO/p/12070548.html#sock_map_fd">sock_map_fd</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/RichardTAO/p/12070548.html#sock_create">sock_create</a></li>
</ul>
</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/RichardTAO/p/12070548.html#%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90">实验代码分析</a><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/RichardTAO/p/12070548.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF">服务器端</a><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/RichardTAO/p/12070548.html#initializeservice%E6%96%B9%E6%B3%95">InitializeService方法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/RichardTAO/p/12070548.html#servicestart%E6%96%B9%E6%B3%95">ServiceStart方法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/RichardTAO/p/12070548.html#recvmsg%E4%B8%8Esendmsg%E6%96%B9%E6%B3%95">RecvMsg与SendMsg方法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/RichardTAO/p/12070548.html#servicestop%E4%B8%8Eshutdownservice%E6%96%B9%E6%B3%95">ServiceStop与ShutdownService方法</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/RichardTAO/p/12070548.html#%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/RichardTAO/p/12070548.html#%E8%B7%9F%E8%B8%AAsocket%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">跟踪socket相关系统调用的内核处理函数</a><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/RichardTAO/p/12070548.html#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96">系统调用初始化</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/RichardTAO/p/12070548.html#socket%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">socket相关的系统调用</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/RichardTAO/p/12070548.html#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li>
</ul>
<h1 id="1-0-系统调用"><a href="#1-0-系统调用" class="headerlink" title="1 |**0**系统调用"></a><strong><em>1</em></strong> |**<em>0</em>**<strong>系统调用</strong></h1><h2 id="1-1-系统调用的过程"><a href="#1-1-系统调用的过程" class="headerlink" title="1 |**1**系统调用的过程"></a><strong><em>1</em></strong> |**<em>1</em>**<strong>系统调用的过程</strong></h2><p>系统调用的过程如下：</p>
<ul>
<li>用户程序</li>
<li>C库（API）：INT 0x80</li>
<li>system_call</li>
<li>系统调用服务例程</li>
<li>内核程序</li>
</ul>
<blockquote>
<p>说明：</p>
<ol>
<li>我们常说的用户 API 其实就是系统提供的 C 库；</li>
<li>系统调用是通过软中断指令 INT 0x80 实现的，而这条 INT 0x80 指令就被封装在 C 库的函数中。</li>
<li>INT 0x80 这条指令的执行会让系统跳转到一个预设的内核空间地址，它指向系统调用处理程序，即 system_call 函数</li>
</ol>
</blockquote>
<p>下图为系统调用具体的流程。</p>
<p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219215912966-312816293.jpg"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219215912966-312816293.jpg" srcset="/img/loading.gif" lazyload></a></p>
<p>值得一提的是：系统调用处理程序 system_call 并不是系统调用服务例程。</p>
<p>系统调用服务例程是对一个具体的系统调用的内核实现函数，而系统调用处理程序是在执行系统调用服务例程之前的一个引导过程，是针对 INT 0x80<br>这条指令，面向所有的系统调用的。</p>
<p>简单来讲，执行任何系统调用，都是先通过调用 C 库中的函数，这个函数里面就会有软中断 INT 0x80 语句，然后转到执行系统调用处理程序<br>system_call，system_call 再根据具体的系统调用号转到执行具体的系统调用服务例程。</p>
<hr>
<blockquote>
<p>那么，system_call 函数是怎么找到具体的系统调用服务例程的呢？</p>
</blockquote>
<p>答案是：通过系统调用号查找系统调用表 sys_call_table。</p>
<p>软中断指令 INT 0x80 执行时，系统调用号会被放入 eax 寄存器中，system_call 函数可以读取 eax 寄存器获取，然后将其乘以<br>4，生成偏移地址，然后以 sys_call_table 为基址，基址加上偏移地址，就可以得到具体的系统调用服务例程的地址了！</p>
<p>然后就可以根据这个地址找到对应的系统调用服务例程了。</p>
<hr>
<blockquote>
<p>系统调用可以被进程抢占、进入阻塞状态</p>
</blockquote>
<p>其原因在于：</p>
<p>系统调用通过软中断 INT 0x80 陷入内核，跳转到系统调用处理程序 system_call<br>函数，然后执行相应的服务例程。但是由于是代表用户进程，所以这个执行过程并不属于中断上下文，而是进程上下文。</p>
<p>因此，系统调用执行过程中，可以访问用户进程的许多信息，可以被其他进程抢占，可以休眠。<br>当系统调用完成后，把控制权交回到发起调用的用户进程前，内核会有一次调度。如果发现有优先级更高的进程或当前进程的时间片用完，那么会选择优先级更高的进程或重新选择进程执行。</p>
<h2 id="1-2-示例分析"><a href="#1-2-示例分析" class="headerlink" title="1 |**2**示例分析"></a><strong><em>1</em></strong> |**<em>2</em>**<strong>示例分析</strong></h2><p>了解系统调用的过程之后，我们举个例子来分析用户态是如何陷入到内核态的。</p>
<p>由于本次实验的目的是调研<code>socket</code>相关的系统调用，因此我们以一个<code>bind</code>绑定事件作为例子。</p>
<p>__</p>
<pre><code class="hljs"># include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MY_SOCK_PATH &quot;/somepath&quot;
#define LISTEN_BACKLOG 50

#define handle_error(msg) \
    do &#123; perror(msg); exit(EXIT_FAILURE); &#125; while (0)

int main(int argc, char *argv[])
&#123;
    int sfd, cfd;
    struct sockaddr_un my_addr, peer_addr;
    socklen_t peer_addr_size;

    sfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sfd == -1)
        handle_error(&quot;socket&quot;);

    memset(&amp;my_addr, 0, sizeof(struct sockaddr_un));
                        /* Clear structure */
    my_addr.sun_family = AF_UNIX;
    strncpy(my_addr.sun_path, MY_SOCK_PATH,
            sizeof(my_addr.sun_path) - 1);

    if (bind(sfd, (struct sockaddr *) &amp;my_addr,
            sizeof(struct sockaddr_un)) == -1)
        handle_error(&quot;bind&quot;);

   if (listen(sfd, LISTEN_BACKLOG) == -1)
       handle_error(&quot;listen&quot;);
</code></pre>
<blockquote>
<p>在用户态我们调用了<code>bind</code>函数，它声明在<code>&lt;sys/socket.h&gt;</code>。</p>
</blockquote>
<p>__</p>
<pre><code class="hljs">/* Give the socket FD the local address ADDR (which is LEN bytes long).  */
extern int bind (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len)
     __THROW;
</code></pre>
<p>我们之前提到过，用户态进程只需要调用库函数即可，而不用管这个函数是如何实现的。</p>
<blockquote>
<p><code>linux</code>中这些具体函数的实现则由<code>glibc</code>统一提供。它定义在<code>glibc-2.23/sysdeps/unix/sysv/linux/bind.c</code></p>
</blockquote>
<p>__</p>
<pre><code class="hljs">int __bind (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len)
&#123;
#ifdef __ASSUME_BIND_SYSCALL
  return INLINE_SYSCALL (bind, 3, fd, addr.__sockaddr__, len);
#else
  return SOCKETCALL (bind, fd, addr.__sockaddr__, len, 0, 0, 0);
#endif
&#125;
weak_alias (__bind, bind)
</code></pre>
<p>在<code>syscall</code>之前需要先将参数传入寄存器。</p>
<p>之前，如我们之前分析的一样：使用0x80中断去陷入内核，并将返回值存放到eax寄存器中，通常0表示成功。</p>
<blockquote>
<p>syscall的name为<code>__NR_##name</code>，在本例中即为<code>__NR_bind</code>。</p>
</blockquote>
<p>其定义在<code>/usr/include/asm/unistd_64.h</code>中。</p>
<p>__</p>
<pre><code class="hljs"># define __NR_bind 49
#define __NR_listen 50
#define __NR_getsockname 51
</code></pre>
<p><strong>这样，用户态和内核态通过系统调用号（49）来确定本次系统调用是哪个功能。</strong></p>
<h2 id="1-3-Socket系统调用分析"><a href="#1-3-Socket系统调用分析" class="headerlink" title="1 |**3**Socket系统调用分析"></a><strong><em>1</em></strong> |**<em>3</em>**<strong>Socket系统调用分析</strong></h2><blockquote>
<p>Socket系统调用主要完成socket的创建，必要字段的初始化，关联传输控制块，绑定文件等任务，完成返回socket绑定的文件描述符。</p>
</blockquote>
<p>socket的调用关系如下：</p>
<p>__</p>
<pre><code class="hljs">/** * sys_socket
 *   |--&gt;sock_create
 *   |      |--&gt;__sock_create
 *   |            |--&gt;inet_create           
 *   |--&gt;sock_map_fd
 */
</code></pre>
<h3 id="sock-map-fd"><a href="#sock-map-fd" class="headerlink" title="sock_map_fd"></a>sock_map_fd</h3><p>该函数的主要功能在于：负责分配文件，并实现与socket的绑定。</p>
<p>__</p>
<pre><code class="hljs">/* 套接口与文件描述符绑定 */
static int sock_map_fd(struct socket *sock, int flags)
&#123;
    struct file *newfile;
    /* 获取未使用的文件描述符 */
    int fd = get_unused_fd_flags(flags);
    if (unlikely(fd &lt; 0))
        return fd;
 
    /* 分配socket文件 */
    newfile = sock_alloc_file(sock, flags, NULL);
    if (likely(!IS_ERR(newfile))) &#123;
        /* fd和文件进行绑定 */
        fd_install(fd, newfile);
        return fd;
    &#125;
 
    /* 释放fd */
    put_unused_fd(fd);
    return PTR_ERR(newfile);
&#125;
</code></pre>
<h3 id="sock-create"><a href="#sock-create" class="headerlink" title="sock_create"></a>sock_create</h3><p>其主要功能为：负责创建<code>socket</code>，并进行必要的初始化工作。</p>
<p>__</p>
<pre><code class="hljs">int sock_create(int family, int type, int protocol, struct socket **res)
&#123;
    return __sock_create(current-&gt;nsproxy-&gt;net_ns, family, type, protocol, res, 0);
&#125;
</code></pre>
<p>之后，<code>sock_create</code>调用<code>__socket_create</code>函数来进行必要的检查项，并创建和初始化<code>socket</code>。</p>
<p>在<code>__socket_create</code>函数中，调用对应协议族的<code>pf-&gt;create</code>函数来创建传输控制块，并且与socket进行关联。</p>
<p>__</p>
<pre><code class="hljs">/* 创建socket */
int __sock_create(struct net *net, int family, int type, int protocol,
             struct socket **res, int kern)
&#123;
    int err;
    struct socket *sock;
    const struct net_proto_family *pf;

    /*
     *      Check protocol is in range
     */
    /* 检查协议族 */
    if (family &lt; 0 || family &gt;= NPROTO)
        return -EAFNOSUPPORT;

    /* 检查类型 */
    if (type &lt; 0 || type &gt;= SOCK_MAX)
        return -EINVAL;

    /* Compatibility.

       This uglymoron is moved from INET layer to here to avoid
       deadlock in module load.
     */
    /* ipv4协议族的packet已经废除，检测到，则替换成packet协议族 */
    if (family == PF_INET &amp;&amp; type == SOCK_PACKET) &#123;
        pr_info_once(&quot;%s uses obsolete (PF_INET,SOCK_PACKET)\n&quot;,
                 current-&gt;comm);
        family = PF_PACKET;
    &#125;

    /* 安全模块检查套接口 */
    err = security_socket_create(family, type, protocol, kern);
    if (err)
        return err;

    /*
     *    Allocate the socket and allow the family to set things up. if
     *    the protocol is 0, the family is instructed to select an appropriate
     *    default.
     */
    /* 分配socket，内部和inode已经绑定 */
    sock = sock_alloc();
    if (!sock) &#123;
        net_warn_ratelimited(&quot;socket: no more sockets\n&quot;);
        return -ENFILE;    /* Not exactly a match, but its the
                   closest posix thing */
    &#125;

    /* 设定类型 */
    sock-&gt;type = type;

#ifdef CONFIG_MODULES
    /* Attempt to load a protocol module if the find failed.
     *
     * 12/09/1996 Marcin: But! this makes REALLY only sense, if the user
     * requested real, full-featured networking support upon configuration.
     * Otherwise module support will break!
     */
    if (rcu_access_pointer(net_families[family]) == NULL)
        request_module(&quot;net-pf-%d&quot;, family);
#endif

    rcu_read_lock();
    /* 找到协议族 */
    pf = rcu_dereference(net_families[family]);
    err = -EAFNOSUPPORT;
    if (!pf)
        goto out_release;

    /*
     * We will call the -&gt;create function, that possibly is in a loadable
     * module, so we have to bump that loadable module refcnt first.
     */
     /* 增加模块的引用计数 */
    if (!try_module_get(pf-&gt;owner))
        goto out_release;

    /* Now protected by module ref count */
    rcu_read_unlock();

    /* 调用协议族的创建函数 */
    err = pf-&gt;create(net, sock, protocol, kern);
    if (err &lt; 0)
        goto out_module_put;

    /*
     * Now to bump the refcnt of the [loadable] module that owns this
     * socket at sock_release time we decrement its refcnt.
     */
    if (!try_module_get(sock-&gt;ops-&gt;owner))
        goto out_module_busy;

    /*
     * Now that we&#39;re done with the -&gt;create function, the [loadable]
     * module can have its refcnt decremented
     */
    module_put(pf-&gt;owner);
    err = security_socket_post_create(sock, family, type, protocol, kern);
    if (err)
        goto out_sock_release;
    *res = sock;

    return 0;

out_module_busy:
    err = -EAFNOSUPPORT;
out_module_put:
    sock-&gt;ops = NULL;
    module_put(pf-&gt;owner);
out_sock_release:
    sock_release(sock);
    return err;

out_release:
    rcu_read_unlock();
    goto out_sock_release;
&#125;
EXPORT_SYMBOL(__sock_create);
</code></pre>
<p>对于<code>PF_INET</code>协议族来讲，上述的<code>pf-&gt;create</code>函数将调用<code>inet_create</code>函数。</p>
<p>熟悉设备驱动的同学应该都知道这些操作被定义在<code>file_operations</code>结构中。</p>
<p>__</p>
<pre><code class="hljs">static const struct net_proto_family inet_family_ops = &#123;
    .family = PF_INET,
    .create = inet_create,
    .owner    = THIS_MODULE,
&#125;;
</code></pre>
<p>最后，在<code>inet_create</code>函数中完成创建传输控制块，并且将socket与传输控制块进行关联。至于该函数代码这里不再展开分析。</p>
<h1 id="2-0-实验代码分析"><a href="#2-0-实验代码分析" class="headerlink" title="2 |**0**实验代码分析"></a><strong><em>2</em></strong> |**<em>0</em>**<strong>实验代码分析</strong></h1><p>在<a target="_blank" rel="noopener" href="https://www.cnblogs.com/RichardTAO/p/12021971.html">上一次实验</a>中，我们已经将老师提供的客户端以及服务器端的程序集成到了<code>MenuOS</code>中，可以在<code>qemu</code>虚拟机中使用<code>replyhi</code>和<code>hello</code>两个命令。</p>
<p>但是对于这两个程序的内部实现还没有深入分析，这里我们通过阅读代码来找出这两个程序在执行时所使用到的<code>Socket API</code>。</p>
<h2 id="2-1-服务器端"><a href="#2-1-服务器端" class="headerlink" title="2 |**1**服务器端"></a><strong><em>2</em></strong> |**<em>1</em>**<strong>服务器端</strong></h2><blockquote>
<p>首先，分析一下服务器端的代码。</p>
<p>在我们使用<code>replyhi</code>命令时，会执行<code>main.c</code>文件中的StartReplyhi函数。</p>
</blockquote>
<p>__</p>
<pre><code class="hljs">MenuConfig( &quot;replyhi&quot;, &quot;Reply hi TCP Service&quot;, StartReplyhi);
</code></pre>
<blockquote>
<p>继续阅读<code>StartReplyhi</code>函数的代码。</p>
<p>可以发现，在满足连接条件的判断语句中，程序继续调用了Replyhi函数。</p>
</blockquote>
<p>__</p>
<pre><code class="hljs">int StartReplyhi(int argc, char *argv[])
&#123;
    int pid;
    /* fork another process */
    pid = fork();
    if (pid &lt; 0)
    &#123;
        /* error occurred */
        fprintf(stderr, &quot;Fork Failed!&quot;);
        exit(-1);
    &#125;
    else if (pid == 0)
    &#123;
        /*	 child process 	*/
        Replyhi();
        printf(&quot;Reply hi TCP Service Started!\n&quot;);
    &#125;
    else
    &#123;
        /* 	parent process	 */
        printf(&quot;Please input hello...\n&quot;);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>查看<code>Replyhi</code>函数的实现。</p>
<p>在函数中总共调用了六个方法，从字面意思来看，不难推测出它们的具体含义分别是：初始化服务、启动服务、接收消息、发送消息、停止服务以及关闭服务。</p>
<p>这些方法都在头文件<code>syswrapper.h</code>中定义。</p>
<p>下面将对这些方法逐一展开分析。</p>
</blockquote>
<p>__</p>
<pre><code class="hljs">int Replyhi()
&#123;
    char szBuf[MAX_BUF_LEN] = &quot;\0&quot;;
    char szReplyMsg[MAX_BUF_LEN] = &quot;hi\0&quot;;
    InitializeService();
    while (1)
    &#123;
        ServiceStart();
        RecvMsg(szBuf);
        SendMsg(szReplyMsg);
        ServiceStop();
    &#125;
    ShutdownService();
    return 0;
&#125;
</code></pre>
<h3 id="InitializeService方法"><a href="#InitializeService方法" class="headerlink" title="InitializeService方法"></a>InitializeService方法</h3><p>__</p>
<pre><code class="hljs"># define InitializeService()                             \
        PrepareSocket(IP_ADDR,PORT);                    \
        InitServer();
</code></pre>
<p>可以看到，在头文件中使用宏定义的方式将其具体实现私有化。</p>
<blockquote>
<p>根据第一部分的socket创建过程分析，我们可以很自然地理解<code>PrepareSocket</code>函数就是用于创建服务器端socket：在定义了<code>serveraddr</code>中的协议族、端口、IP地址信息后，通过<code>socket</code>这一系统调用完成服务器端socket的创建，并返回文件描述符信息。</p>
</blockquote>
<blockquote>
<p><code>InitServer</code>函数则是调用<code>bind</code>和<code>PrepareSocket</code>函数中得到的文件描述符完成绑定，绑定成功后，服务器进入监听状态，即等待客户端的连接，通过调用<code>listen</code>来实现监听。</p>
</blockquote>
<p>__</p>
<pre><code class="hljs"># define PrepareSocket(addr,port)                        \
        int sockfd = -1;                                \
        struct sockaddr_in serveraddr;                  \
        struct sockaddr_in clientaddr;                  \
        socklen_t addr_len = sizeof(struct sockaddr);   \
        serveraddr.sin_family = AF_INET;                \
        serveraddr.sin_port = htons(port);              \
        serveraddr.sin_addr.s_addr = inet_addr(addr);   \
        memset(&amp;serveraddr.sin_zero, 0, 8);             \
        sockfd = socket(PF_INET,SOCK_STREAM,0);
        
#define InitServer()                                    \
        int ret = bind( sockfd,                         \
                        (struct sockaddr *)&amp;serveraddr, \
                        sizeof(struct sockaddr));       \
        if(ret == -1)                                   \
        &#123;                                               \
            fprintf(stderr,&quot;Bind Error,%s:%d\n&quot;,        \
                            __FILE__,__LINE__);         \
            close(sockfd);                              \
            return -1;                                  \
        &#125;                                               \
        listen(sockfd,MAX_CONNECT_QUEUE); 
</code></pre>
<p>因此，在初始化服务中我们所使用到的<code>Socket API</code>共有三个，分别为：<strong>socket，bind，listen</strong> 。</p>
<h3 id="ServiceStart方法"><a href="#ServiceStart方法" class="headerlink" title="ServiceStart方法"></a>ServiceStart方法</h3><blockquote>
<p>在调用初始化服务方法之后，我们完成了服务器端socket的创建、绑定以及监听。</p>
<p>因此，在该方法的实现中，我们所实现的是接收客户端所发出的连接请求，通过调用<code>accept</code>来实现，可以看到该函数的参数中<code>clientaddr</code>则标明服务器与哪个客户端进行连接。</p>
</blockquote>
<p>__</p>
<pre><code class="hljs"># define ServiceStart()                                  \
        int newfd = accept( sockfd,                     \
                    (struct sockaddr *)&amp;clientaddr,     \
                    &amp;addr_len);                         \
        if(newfd == -1)                                 \
        &#123;                                               \
            fprintf(stderr,&quot;Accept Error,%s:%d\n&quot;,      \
                            __FILE__,__LINE__);         \
        &#125;   
</code></pre>
<p>因此，在启动服务中我们所使用到的<code>Socket API</code>只有一个：<strong>accept</strong> 。</p>
<h3 id="RecvMsg与SendMsg方法"><a href="#RecvMsg与SendMsg方法" class="headerlink" title="RecvMsg与SendMsg方法"></a>RecvMsg与SendMsg方法</h3><blockquote>
<p>与客户端经历三次握手建立TCP连接之后，就可以与客户端进行消息的发送与接收。</p>
<p>代码的实现与之前类似，其过程就不再赘述。不过，需要注意的是在这两个方法中，都包含<code>newfd</code>这个参数，此参数是客户端与服务器建立连接时所获得的返回值，也就是说这个值标识了这条TCP连接，确认了消息发送、接收的双方。</p>
</blockquote>
<p>__</p>
<pre><code class="hljs"># define RecvMsg(buf)                                    \
       ret = recv(newfd,buf,MAX_BUF_LEN,0);             \
       if(ret &gt; 0)                                      \
       &#123;                                                \
            printf(&quot;recv \&quot;%s\&quot; from %s:%d\n&quot;,          \
            buf,                                        \
            (char*)inet_ntoa(clientaddr.sin_addr),      \
            ntohs(clientaddr.sin_port));                \
       &#125;

#define SendMsg(buf)                                    \
        ret = send(newfd,buf,strlen(buf),0);            \
        if(ret &gt; 0)                                     \
        &#123;                                               \
            printf(&quot;send \&quot;hi\&quot; to %s:%d\n&quot;,            \
            (char*)inet_ntoa(clientaddr.sin_addr),      \
            ntohs(clientaddr.sin_port));                \
        &#125;
</code></pre>
<p>因此，在消息接收与发送中我们所使用到的<code>Socket API</code>共有两个：<strong>recv，send</strong> 。</p>
<h3 id="ServiceStop与ShutdownService方法"><a href="#ServiceStop与ShutdownService方法" class="headerlink" title="ServiceStop与ShutdownService方法"></a>ServiceStop与ShutdownService方法</h3><blockquote>
<p>这两个方法都用于终止连接，因此在代码中所调用的API也都是<code>close</code>。</p>
</blockquote>
<p>__</p>
<pre><code class="hljs"># define ShutdownService()                               \
        close(sockfd);
        
#define ServiceStop()                                   \
        close(newfd);
</code></pre>
<p>因此，在停止和关闭服务中我们所使用到的<code>Socket API</code>为：<strong>close</strong> 。</p>
<h2 id="2-2-客户端"><a href="#2-2-客户端" class="headerlink" title="2 |**2**客户端"></a><strong><em>2</em></strong> |**<em>2</em>**<strong>客户端</strong></h2><blockquote>
<p>同样的，在我们使用<code>hello</code>命令时，程序会调用Hello函数。</p>
</blockquote>
<p>__</p>
<pre><code class="hljs">MenuConfig( &quot;hello&quot;, &quot;Hello TCP Client&quot;, Hello);
</code></pre>
<blockquote>
<p>在Hello函数中，我们又见到了消息发送和接收这两个方法的“身影”。</p>
</blockquote>
<p>__</p>
<pre><code class="hljs">int Hello(int argc, char *argv[])
&#123;
    char szBuf[MAX_BUF_LEN] = &quot;\0&quot;;
    char szMsg[MAX_BUF_LEN] = &quot;hello\0&quot;;
    OpenRemoteService();
    SendMsg(szMsg);
    RecvMsg(szBuf);
    CloseRemoteService();
    return 0;
&#125;
</code></pre>
<p>其调用的方法内部实现与服务器端类似，这里我们给出结论：</p>
<p>客户端所使用到的Socket API有：<strong>socket， connect，send，recv，close</strong> 。</p>
<hr>
<h1 id="3-0-跟踪socket相关系统调用的内核处理函数"><a href="#3-0-跟踪socket相关系统调用的内核处理函数" class="headerlink" title="3 |**0**跟踪socket相关系统调用的内核处理函数"></a><strong><em>3</em></strong> |**<em>0</em>**<strong>跟踪socket相关系统调用的内核处理函数</strong></h1><h2 id="3-1-系统调用初始化"><a href="#3-1-系统调用初始化" class="headerlink" title="3 |**1**系统调用初始化"></a><strong><em>3</em></strong> |**<em>1</em>**<strong>系统调用初始化</strong></h2><p>系统调用初始化的过程：</p>
<blockquote>
<ul>
<li>在32位系统中：<code>start_kernel -&gt; trap_init -&gt; idt_setup_traps -&gt; 0x80</code></li>
<li>在64位系统中：<code>start_kernel -&gt; trap_init -&gt; cpu_init -&gt; syscall_init</code></li>
</ul>
</blockquote>
<p>为了验证这个初始化过程是否正确，我们使用上一次实验使用过的<code>gdb</code>进行调试。</p>
<p>由于我们上次实验构建的是32位的MenuOS系统，因此我们在<code>start_kernel</code>， <code>trap_init</code>以及<br><code>idt_setup_traps</code>这三个函数打上断点来完成验证。</p>
<blockquote>
<p>命令</p>
</blockquote>
<p>__</p>
<pre><code class="hljs">sudo qemu -kernel ../linux -5.0.1/arch/x86/boot/bzImage -initrd ../rootfs.img -append  nokaslr -s -S #启动

# 新建终端
gdb #进入gdb命令行
file ../LinuxKernel/linux-5.0.1/vmlinux #在gdb界面中targe remote之前加载符号表
target remote:1234 # 建立gdb和gdbserver之间的连接
break start_kernel # 设置断点1
break trap_init # 设置断点2
break idt_setup_traps # 设置断点3
</code></pre>
<p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220313106-160394591.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220313106-160394591.png" srcset="/img/loading.gif" lazyload></a></p>
<p>接着，我们可以使用<code>continue</code>命令让<code>qemu</code>虚拟机继续运行起来。</p>
<p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220327771-703485049.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220327771-703485049.png" srcset="/img/loading.gif" lazyload></a></p>
<p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220337160-1475253107.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220337160-1475253107.png" srcset="/img/loading.gif" lazyload></a></p>
<p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220353159-565830860.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220353159-565830860.png" srcset="/img/loading.gif" lazyload></a></p>
<p>为避免出现断点捕捉顺序与断点设置顺序相关的情况发生，这里我故意将后两个函数的断点设置顺序调换了一下。</p>
<p>而结果如我们之前分析的一样，我们捕获到了三个断点，并且这三个断点的捕捉顺序正是系统调用初始化过程所经历的顺序。</p>
<h2 id="3-2-socket相关的系统调用"><a href="#3-2-socket相关的系统调用" class="headerlink" title="3 |**2**socket相关的系统调用"></a><strong><em>3</em></strong> |**<em>2</em>**<strong>socket相关的系统调用</strong></h2><p>通过查阅<a target="_blank" rel="noopener" href="https://github.com/mengning/linux/blob/master/arch/x86/entry/syscalls/syscall_32.tbl">32位的系统调用表</a>，我们发现与<code>socket</code>相关的系统调用分为以下两种：</p>
<blockquote>
<ul>
<li>sys_socketcall</li>
</ul>
<p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220422911-665150556.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220422911-665150556.png" srcset="/img/loading.gif" lazyload></a></p>
<ul>
<li>socket api对应的单独系统调用</li>
</ul>
<p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220442073-678615520.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220442073-678615520.png" srcset="/img/loading.gif" lazyload></a></p>
</blockquote>
<p>通过查阅资料我们发现：</p>
<p><code>sys_socketcall()</code>是内核中为 socket 设置的<code>总入口 </code>，也就是说，在调用socket其他相关的<code>API</code>时都需要先调用sys_socketcall()。</p>
<p>而在前一章中的<code>实验代码分析</code>中，我们对于已经集成到<code>MenuOS</code>中<code>replyhi</code>和<code>hello</code>命令所对应的客户端、服务器端程序进行了分析，并且已经得出结论，即这两个命令在执行时所使用到的<code>Socket API</code>。分别为：</p>
<p>__</p>
<pre><code class="hljs">服务器端：socket，bind，listen，accept，recv，send，close 客户端：socket，connect，send，recv，close
</code></pre>
<p>理清楚了<code>socket</code>相关的系统调用之后，下面我们同样通过<code>gdb</code>调试的方法来验证我们的分析是否正确。</p>
<blockquote>
<p>命令</p>
</blockquote>
<p>__</p>
<pre><code class="hljs">break sys_socketcall # 设置断点
continue 
</code></pre>
<p>经过调试，我们捕捉到了该断点，并通过<code>list</code>命令找到了<code>sys_socketcall</code>系统调用所对应的内核处理函数<code>SYSCALL_DEFINE2(socketcall, int, call, unsigned long __user *, args)</code>。</p>
<p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220038758-277367624.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220038758-277367624.png" srcset="/img/loading.gif" lazyload></a></p>
<p>那么，下面简要的分析以下这个<a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?h=v5.0.1">内核处理函数</a>。</p>
<p>__</p>
<pre><code class="hljs">/* *	System call vectors.
 *
 *	Argument checking cleaned up. Saved 20% in size.
 *  This function doesn&#39;t need to set the kernel lock because
 *  it is set by the callees.
 */

SYSCALL_DEFINE2(socketcall, int, call, unsigned long __user *, args)
&#123;
    unsigned long a[AUDITSC_ARGS];
    unsigned long a0, a1;
    int err;
    unsigned int len;

    if (call &lt; 1 || call &gt; SYS_SENDMMSG)
        return -EINVAL;
    call = array_index_nospec(call, SYS_SENDMMSG + 1);

    len = nargs[call];
    if (len &gt; sizeof(a))
        return -EINVAL;

    /* copy_from_user should be SMP safe. */
    if (copy_from_user(a, args, len))
        return -EFAULT;

    err = audit_socketcall(nargs[call] / sizeof(unsigned long), a);
    if (err)
        return err;

    a0 = a[0];
    a1 = a[1];

    switch (call) &#123;
    case SYS_SOCKET:
        err = __sys_socket(a0, a1, a[2]);
        break;
    case SYS_BIND:
        err = __sys_bind(a0, (struct sockaddr __user *)a1, a[2]);
        break;
    case SYS_CONNECT:
        err = __sys_connect(a0, (struct sockaddr __user *)a1, a[2]);
        break;
    case SYS_LISTEN:
        err = __sys_listen(a0, a1);
        break;
    case SYS_ACCEPT:
        err = __sys_accept4(a0, (struct sockaddr __user *)a1,
                    (int __user *)a[2], 0);
        break;
    case SYS_GETSOCKNAME:
        err =
            __sys_getsockname(a0, (struct sockaddr __user *)a1,
                      (int __user *)a[2]);
        break;
    case SYS_GETPEERNAME:
        err =
            __sys_getpeername(a0, (struct sockaddr __user *)a1,
                      (int __user *)a[2]);
        break;
    case SYS_SOCKETPAIR:
        err = __sys_socketpair(a0, a1, a[2], (int __user *)a[3]);
        break;
    case SYS_SEND:
        err = __sys_sendto(a0, (void __user *)a1, a[2], a[3],
                   NULL, 0);
        break;
    case SYS_SENDTO:
        err = __sys_sendto(a0, (void __user *)a1, a[2], a[3],
                   (struct sockaddr __user *)a[4], a[5]);
        break;
    case SYS_RECV:
        err = __sys_recvfrom(a0, (void __user *)a1, a[2], a[3],
                     NULL, NULL);
        break;
    case SYS_RECVFROM:
        err = __sys_recvfrom(a0, (void __user *)a1, a[2], a[3],
                     (struct sockaddr __user *)a[4],
                     (int __user *)a[5]);
        break;
    case SYS_SHUTDOWN:
        err = __sys_shutdown(a0, a1);
        break;
    case SYS_SETSOCKOPT:
        err = __sys_setsockopt(a0, a1, a[2], (char __user *)a[3],
                       a[4]);
        break;
    case SYS_GETSOCKOPT:
        err =
            __sys_getsockopt(a0, a1, a[2], (char __user *)a[3],
                     (int __user *)a[4]);
        break;
    case SYS_SENDMSG:
        err = __sys_sendmsg(a0, (struct user_msghdr __user *)a1,
                    a[2], true);
        break;
    case SYS_SENDMMSG:
        err = __sys_sendmmsg(a0, (struct mmsghdr __user *)a1, a[2],
                     a[3], true);
        break;
    case SYS_RECVMSG:
        err = __sys_recvmsg(a0, (struct user_msghdr __user *)a1,
                    a[2], true);
        break;
    case SYS_RECVMMSG:
        if (IS_ENABLED(CONFIG_64BIT) || !IS_ENABLED(CONFIG_64BIT_TIME))
            err = __sys_recvmmsg(a0, (struct mmsghdr __user *)a1,
                         a[2], a[3],
                         (struct __kernel_timespec __user *)a[4],
                         NULL);
        else
            err = __sys_recvmmsg(a0, (struct mmsghdr __user *)a1,
                         a[2], a[3], NULL,
                         (struct old_timespec32 __user *)a[4]);
        break;
    case SYS_ACCEPT4:
        err = __sys_accept4(a0, (struct sockaddr __user *)a1,
                    (int __user *)a[2], a[3]);
        break;
    default:
        err = -EINVAL;
        break;
    &#125;
    return err;
&#125;
</code></pre>
<p>其核心代码在于<code>switch...case</code>中，可以看到在函数执行时它会按照参数<code>call</code>的值去调用不同的内核处理程序，如<code>__sys_socket</code>，<code>__sys_bind</code>等。至于call的值，<code>SYS_SOCKET</code>对应值为1，下面的<code>case</code>条件所对应的call值则以此递增。</p>
<p>这样，我们就很容易理解为什么说<code>sys_socketcall()</code>是内核中为 socket 设置的总入口。</p>
<p>接着，我们将<code>Socket API</code>所对应的各个内核处理函数打上断点。</p>
<blockquote>
<p>命令</p>
</blockquote>
<p>__</p>
<pre><code class="hljs">break  __sys_socket
break  __sys_bind
break  __sys_listen
break  __sys_connect
break  __sys_accept4
break  __sys_recvmsg
break  __sys_sendmsg
break  __sys_recvfrom
break  __sys_sendto
break  __sys_shutdown
</code></pre>
<p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220104626-1320211378.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220104626-1320211378.png" srcset="/img/loading.gif" lazyload></a></p>
<p>然后，使用<code>continue</code>命令来康康我们是否能够捕获到这些断点。</p>
<p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220110932633-776686874.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220110932633-776686874.png" srcset="/img/loading.gif" lazyload></a></p>
<p>可以发现在初始化的过程中我们共捕获到6次断点，分别是三次<code>sys_socketcall()</code>和三次<code>__sys_socket</code>。</p>
<p>都是三次，有这么巧合吗？另外，我们可以发现捕获顺序的规律总是先<code>sys_socketcall()</code>后捕获<code>__sys_socket</code>。</p>
<p>其实，我们之前已经提到过：<code>sys_socketcall()</code>是内核为socket设置的总入口，我们需要先进入到这个总入口，然后根据<code>call</code>值来进入不同的分支去调用对应的内核处理函数，这也就是为什么我们捕获断点时有上面的规律。</p>
<p>通过<code>qemu</code>虚拟机中的提示信息，该初始化的过程其实主要完成的是对网卡的配置与启动。</p>
<hr>
<p>继续。</p>
<p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220112841339-722490150.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220112841339-722490150.png" srcset="/img/loading.gif" lazyload></a></p>
<p>在又一次捕获到<code>sys_socketcall()</code>且此时call值为1时，我们发现gdb调试界面停止，</p>
<p>这时，按照之前服务器端代码分析的思路，我们需要在<code>MenuOS</code>系统输入<code>replyhi</code>命令来创建socket。</p>
<p>在输入命令之后，gdb调试继续。并且再次捕获断点时可以看到我们捕获到了<code>__sys_socket</code>，即调用了该内核处理函数完成了我们服务器端socket的创建。</p>
<hr>
<p>继续捕获断点：</p>
<p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220119325-1227384307.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220119325-1227384307.png" srcset="/img/loading.gif" lazyload></a></p>
<p>与之前分析的一样，需要先进入<code>sys_socketcall()</code>这个总入口；</p>
<p>然后通过我们之前在源代码分析中看到的<strong>switch结构</strong> ，根据<code>call=2</code>的信息，可以知道它进入了<code>case SYS_BIND</code>这个分支；</p>
<p>继续使用<code>continue</code>命令可以看到，我们捕获到了<code>__sys_bind</code>这个断点，即确实按照分支的语句调用了所对应的内核处理函数，在这里，我们所调用的是socket的绑定函数。</p>
<p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220135410-1102664032.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191219220135410-1102664032.png" srcset="/img/loading.gif" lazyload></a></p>
<hr>
<p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220113820375-991637153.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220113820375-991637153.png" srcset="/img/loading.gif" lazyload></a></p>
<p>这一次，我们捕获到<code>__sys_accept4</code>，按照服务器端代码的思路，我们知道此时服务器准备好接收客户端的请求。</p>
<p>在<code>qemu</code>虚拟机中输入<code>hello</code>命令，来创建客户端socket。</p>
<p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220114004900-39215539.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220114004900-39215539.png" srcset="/img/loading.gif" lazyload></a></p>
<p>没错，在经历<code>sys_socketcall()</code>总入口之后我们再一次使用<code>__sys_socket</code>完成了客户端socket的创建。</p>
<hr>
<p>同理，我们捕获到<code>__sys_connect</code>断点，该内核处理函数完成了客户端与服务器端的连接。</p>
<p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220114310702-177767569.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220114310702-177767569.png" srcset="/img/loading.gif" lazyload></a></p>
<p>接着，我们会捕捉到收发消息相关的一系列系统调用，而与此同时，在<code>qemu</code>虚拟机中，我们也能够看到服务器与客户端交互的情况。</p>
<p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220114430988-1788804597.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220114430988-1788804597.png" srcset="/img/loading.gif" lazyload></a></p>
<p>之后捕获断点我们又会<strong>重新创建</strong> 一个客户端socket。</p>
<p>其原因在于<code>Replyhi</code>的实现中使用到了while循环，即服务器端不会主动关闭服务，而是不断等待新的客户端连接，然后与其进行交互。实现的是一个简单的多线程功能。</p>
<p><a href="./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220115302859-2131351471.png"><img src="/./Socket%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90_files/1314885-20191220115302859-2131351471.png" srcset="/img/loading.gif" lazyload></a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Socket的封装.md</div>
      <div>https://abrance.github.io/2024/05/09/mdstorage/domain/network/Socket的封装/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>xiaoy</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年5月9日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/05/09/mdstorage/domain/network/conn%E7%9A%84%E5%B0%81%E8%A3%85%E5%92%8C%E5%AE%9E%E7%8E%B0/" title="conn的封装和实现.md">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">conn的封装和实现.md</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/05/09/mdstorage/domain/network/%E4%B8%BB%E6%9C%BA%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91qemu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="主机路由转发qemu虚拟机网络.md">
                        <span class="hidden-mobile">主机路由转发qemu虚拟机网络.md</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  



  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
