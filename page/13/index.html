
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Xiaoy</title>
    <meta name="author" content="xiaoy" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>XIAOY</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;XIAOY</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div
        id="home-background"
        ref="homeBackground"
        data-images="/images/background.jpg"
    ></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Xiaoy</h1>
                <h3>xiaoy blog</h3>
                <h5></h5>
            </div>
        </span>
    </div>
</div>
<div
    id="home-posts-wrap"
    ref="homePostsWrap"
    true
>
    <div id="home-posts">
        

<div class="post">
    <a href="/2024/04/10/mdstorage/domain/k8s/apiserver%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3/">
        <h2 class="post-title">apiserver问题和解决.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/domain/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                domain
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/4/10
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="apiserver-cr-的-size-由什么决定？"><a href="#apiserver-cr-的-size-由什么决定？" class="headerlink" title="apiserver cr 的 size 由什么决定？"></a>apiserver cr 的 size 由什么决定？</h3><p><code>kube-apiserver</code> 的参数主要集中在API行为的配置、认证授权、日志记录、以及与其他组件的交互等方面。</p>
<p>对于控制请求大小，Kubernetes 主要依靠的是请求超时设置、客户端请求限速（Rate Limiting）、以及其他API服务器的高级配置，但没有直接限制请求体大小的参数。这种控制机制更多地依赖于整体架构设计和在Ingress或API网关层面的配置，而不是单个<code>kube-apiserver</code>的参数。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/apiserver/" style="color: #ffa2c4">apiserver</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/etcd/" style="color: #00bcd4">etcd</a>
        </span>
        
    </div>
    <a href="/2024/04/10/mdstorage/domain/k8s/apiserver%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/04/10/mdstorage/domain/%E9%AB%98%E5%8F%AF%E7%94%A8/ipvs/">
        <h2 class="post-title">ipvs.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/domain/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                domain
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/4/10
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="1-VS-DR-模式"><a href="#1-VS-DR-模式" class="headerlink" title="1 VS&#x2F;DR 模式"></a>1 VS&#x2F;DR 模式</h2><p>参考链接 <code>http://zh.linuxvirtualserver.org/node/28</code></p>
<p>描述的是使用虚拟服务器&#x2F;直接路由（VS&#x2F;DR）模式的网络体系结构。在这种模式下，负载均衡的实现依赖于一个调度器（通常是一个专用设备或服务器，负责流量的分发）和多个实际的后端服务器（组成服务器组，用于处理请求）。下面是对这段描述的逐句解读：</p>
<ol>
<li><p><strong>调度器和服务器组都必须在物理上有一个网卡通过不分段的局域网相连</strong>：这意味着调度器和所有的后端服务器都需要连接到同一个局域网（LAN）中，并且这个网络应该是未分段的，即它们之间的通信不应该通过路由器进行路由。这通常通过直接连接到同一个交换机或高速HUB来实现。</p>
</li>
<li><p><strong>即通过交换机或者高速的HUB相连，中间没有隔有路由器</strong>：进一步强调了调度器和服务器之间连接的物理特性，明确指出不能有路由器介入，因为路由器会分段网络，从而干扰直接路由模式的工作原理。</p>
</li>
<li><p><strong>VIP地址为调度器和服务器组共享</strong>：VIP（Virtual IP）地址是设置在调度器上的IP地址，用于接收外部对虚拟服务的请求。在VS&#x2F;DR模式中，这个VIP也被配置在每个后端服务器上，但方式有所不同。</p>
</li>
<li><p><strong>调度器配置的VIP地址是对外可见的，用于接收虚拟服务的请求报文</strong>：调度器使用VIP地址来接收来自客户端的所有请求。对外界来说，这个VIP地址代表了负载均衡服务的入口点。</p>
</li>
<li><p><strong>所有的服务器把VIP地址配置在各自的Non-ARP网络设备上，它对外面是不可见的</strong>：在后端服务器上，VIP地址被配置为一个“非ARP响应”地址。这意味着虽然服务器上配置了VIP，但它不会对网络上的ARP请求（用于解析IP地址到物理MAC地址的协议请求）回应VIP的MAC地址，从而使得VIP对外不可见，仅在内部使用。</p>
</li>
<li><p><strong>只是用于处理目标地址为VIP的网络请求</strong>：虽然后端服务器对于外部ARP请求不响应VIP地址，它们仍然会处理目的IP地址为VIP的数据包。这是通过直接路由模式实现的，调度器将外部请求直接转发到合适的后端服务器，而服务器知道如何处理发往VIP的请求，因为它们被配置为接收这些请求。</p>
</li>
</ol>
<p>VS&#x2F;DR模式通过共享VIP地址，并在调度器和服务器间使用直接路由的方式，实现了对外提供一个单一访问点的负载均衡服务。调度器负责接收所有外部请求并将它们分发到后端服务器，而后端服务器处理这些请求，但对外界隐藏它们的存在，确保整个过程的透明性和高效性。</p>
<p>在VS&#x2F;DR（Virtual Server via Direct Routing）模式下，调度器和服务器组都必须通过一个物理网卡连接到未分段的局域网中，这种设计有几个关键原因：</p>
<h3 id="1-高效的数据传输"><a href="#1-高效的数据传输" class="headerlink" title="1. 高效的数据传输"></a>1. 高效的数据传输</h3><p>通过直接在局域网内路由数据包，可以最小化延迟和增加数据传输的效率。如果介入了路由器或网络被分段，那么数据包在到达最终目的地之前需要经过额外的跳转，这会增加处理请求的时间。</p>
<h3 id="2-简化的网络配置"><a href="#2-简化的网络配置" class="headerlink" title="2. 简化的网络配置"></a>2. 简化的网络配置</h3><p>在一个未分段的局域网中，所有设备都处于同一个广播域内。这简化了网络配置，因为调度器和服务器可以直接通信，无需通过路由器或其他网络设备。这也意味着所有服务器都可以直接使用VIP地址接收流量，而无需复杂的路由规则来指导数据包的流向。</p>
<h3 id="3-减少ARP问题"><a href="#3-减少ARP问题" class="headerlink" title="3. 减少ARP问题"></a>3. 减少ARP问题</h3><p>在VS&#x2F;DR模式下，调度器使用VIP接收外部请求，但后端服务器配置为不对外广播VIP的ARP应答，以避免引起ARP冲突。如果网络被分段，且通过路由器连接，就无法有效控制ARP广播，可能导致网络混乱。在一个统一的局域网内，更容易管理和控制ARP行为，确保只有调度器响应VIP的ARP请求。</p>
<h3 id="4-保持高可用性"><a href="#4-保持高可用性" class="headerlink" title="4. 保持高可用性"></a>4. 保持高可用性</h3><p>通过将所有服务器连接到同一个局域网，可以更容易地监控服务器状态并进行健康检查。这对于维持服务的高可用性至关重要。如果服务器分布在不同的网络段，监控和维护的复杂度将大大增加。</p>
<h3 id="5-支持透明处理请求"><a href="#5-支持透明处理请求" class="headerlink" title="5. 支持透明处理请求"></a>5. 支持透明处理请求</h3><p>在VS&#x2F;DR模式下，后端服务器处理请求后直接将响应返回给客户端，而不是通过调度器。这要求客户端到服务器的路径和服务器到客户端的路径是直接的，即所谓的“直接路由”。这种设计确保了高效处理请求并减少了调度器的负载。</p>
<p>综上所述，将调度器和服务器组通过未分段的局域网连接是为了确保数据传输的高效性、简化网络配置、减少网络协议（如ARP）可能导致的问题、保持服务的高可用性，以及支持高效直接的请求处理流程。这是VS&#x2F;DR模式设计的核心部分，旨在提供高性能和高可用性的负载均衡解决方案。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/lvs/" style="color: #00a596">lvs</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/ipvs/" style="color: #00bcd4">ipvs</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/" style="color: #03a9f4">高可用</a>
        </span>
        
    </div>
    <a href="/2024/04/10/mdstorage/domain/%E9%AB%98%E5%8F%AF%E7%94%A8/ipvs/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/04/09/mdstorage/domain/%E8%99%9A%E6%8B%9F%E5%8C%96/docker/">
        <h2 class="post-title">容器.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/domain/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                domain
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/4/9
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>参考链接：<code>https://u.sb/debian-install-docker/</code></p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><h4 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h4><ul>
<li>–rm     运行后自动删除，常用于测试</li>
<li>–net&#x3D;host     使用宿主机网络拓扑</li>
<li>-e $env_opt&#x3D;$value      设置环境变量</li>
<li>-d          后台运行，避免退出</li>
<li>-it          开启交互式命令行</li>
<li>-v $host_dir:$container_dir         挂载卷</li>
<li>-p  $host_port:$container_port       端口映射</li>
<li>-name $name   为容器起名</li>
<li>-dns $addr    指定 dns 地址</li>
<li>–privileged     赋予 root 权限</li>
<li>–cap-add SYS_ADMIN    赋予更高权限</li>
</ul>
<h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><p>背景是 docker 源国内访问不了，使用代理访问 docker 源</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><pre><code class="Bash">#sudo mkdir /etc/systemd/system/docker.service.d &amp;&amp; cd $_
sudo mkdir /tmp/temp &amp;&amp; cd $_
cat &lt;&lt; EOF &gt; proxy.conf
[Service] 
Environment=&quot;HTTP_PROXY=http://127.0.0.1:7890&quot; 
Environment=&quot;HTTPS_PROXY=http://127.0.0.1:7890&quot;
EOF
</code></pre>
<pre><code class="text">
xiaoy@debian12:/etc/docker$ cat ~/.docker/config.json 
&#123;
 &quot;proxies&quot;:
 &#123;
   &quot;default&quot;:
   &#123;
     &quot;httpProxy&quot;: &quot;http://172.17.0.1:7890&quot;,
     &quot;httpsProxy&quot;: &quot;http://172.17.0.1:7890&quot;,
     &quot;noProxy&quot;: &quot;localhost,172.17.0.1/16,127.0.0.1,192.168.30.1/16,*.ouryun.cn&quot;
   &#125;
 &#125;
&#125;
</code></pre>
<p>设置完此文件后, 所有 docker 容器中的 http_proxy no_proxy 都会被设置为这个值, 目前未找到在 dockerfile 中修改 http_proxy 值的方法, 只能在 docker run 时设置 -e http_proxy&#x3D;”” 来设置</p>
<h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><p><code>docker create</code> 命令用于创建一个新的容器，但并不会自动启动该容器。这个命令允许你在不启动容器的情况下定义容器的配置和资源，这样你可以稍后使用 <code>docker start</code> 命令来启动容器。</p>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code class="bash">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]
</code></pre>
<ul>
<li><strong>IMAGE</strong>: 要基于哪个镜像创建容器。</li>
<li><strong>COMMAND</strong>: 容器启动时要执行的命令（可选）。</li>
<li><strong>[ARG…]</strong>: 传递给命令的参数（可选）。</li>
</ul>
<h4 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h4><p>以下是一些常用的 <code>docker create</code> 选项：</p>
<ul>
<li><strong>-a, –attach</strong>: 附加到 STDIN, STDOUT, STDERR。</li>
<li><strong>–add-host</strong>: 添加自定义主机名到 IP 映射（例如 <code>--add-host=hostname:IP</code>）。</li>
<li><strong>–name</strong>: 指定容器的名称。</li>
<li><strong>-e, –env</strong>: 设置环境变量（例如 <code>-e &quot;MY_VAR=my_value&quot;</code>）。</li>
<li><strong>-p, –publish</strong>: 映射主机的端口到容器的端口（例如 <code>-p 8080:80</code>）。</li>
<li><strong>-v, –volume</strong>: 挂载主机目录或数据卷到容器（例如 <code>-v /host/path:/container/path</code>）。</li>
<li><strong>–network</strong>: 指定容器连接的网络（默认是 <code>bridge</code> 网络）。</li>
<li><strong>–restart</strong>: 设置容器的重启策略（例如 <code>--restart=always</code>）。</li>
<li><strong>–cpus</strong>: 限制容器使用的 CPU 数量。</li>
<li><strong>–memory</strong>: 限制容器使用的内存（例如 <code>--memory=512m</code>）。</li>
<li><strong>–entrypoint</strong>: 覆盖镜像的默认入口点。</li>
<li><strong>–workdir</strong>: 设置容器内的工作目录。</li>
<li><strong>–hostname</strong>: 设置容器的主机名。</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ol>
<li><p><strong>创建一个简单的容器</strong>：</p>
<p>创建一个基于 <code>ubuntu</code> 镜像的容器，但不启动它：</p>
<pre><code class="bash">docker create ubuntu
</code></pre>
<p>这个命令会返回一个容器 ID，可以用于后续的操作。</p>
</li>
<li><p><strong>创建一个指定名称的容器</strong>：</p>
<p>创建一个名为 <code>my_container</code> 的容器：</p>
<pre><code class="bash">docker create --name my_container ubuntu
</code></pre>
</li>
<li><p><strong>创建容器并设置环境变量和端口映射</strong>：</p>
<p>创建一个容器，设置环境变量并将主机的 8080 端口映射到容器的 80 端口：</p>
<pre><code class="bash">docker create --name my_web_server -e &quot;ENV=production&quot; -p 8080:80 nginx
</code></pre>
</li>
<li><p><strong>创建容器并挂载卷</strong>：</p>
<p>创建一个容器，并将主机目录挂载到容器内：</p>
<pre><code class="bash">docker create --name my_data_container -v /host/data:/container/data ubuntu
</code></pre>
</li>
<li><p><strong>创建容器并指定网络</strong>：</p>
<p>创建一个容器，并将其连接到指定的 Docker 网络：</p>
<pre><code class="bash">docker create --name my_networked_container --network my_network alpine
</code></pre>
</li>
</ol>
<h3 id="与-docker-run-的区别"><a href="#与-docker-run-的区别" class="headerlink" title="与 docker run 的区别"></a>与 <code>docker run</code> 的区别</h3><p><code>docker create</code> 只创建容器，不启动它，而 <code>docker run</code> 同时创建并启动容器。<code>docker create</code> 适用于你需要预先配置容器，然后稍后根据需要启动它的场景。</p>
<h4 id="典型的使用场景"><a href="#典型的使用场景" class="headerlink" title="典型的使用场景"></a>典型的使用场景</h4><ul>
<li><strong>预配置容器</strong>：你可以先创建容器，然后在需要时启动它们，而无需每次都重新创建。</li>
<li><strong>批量启动容器</strong>：在批量启动容器之前，可以先批量创建容器，然后根据需要分别启动它们。</li>
<li><strong>资源预分配</strong>：在实际启动容器之前，你可以通过创建容器来预先分配资源（如网络、卷等），以确保环境准备就绪。</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/%E5%AE%89%E8%A3%85/" style="color: #03a9f4">安装</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/docker/" style="color: #00a596">docker</a>
        </span>
        
    </div>
    <a href="/2024/04/09/mdstorage/domain/%E8%99%9A%E6%8B%9F%E5%8C%96/docker/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/04/08/mdstorage/domain/rust/%E5%80%9F%E7%94%A8/">
        <h2 class="post-title">借用.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/domain/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                domain
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/4/8
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="借用"><a href="#借用" class="headerlink" title="借用"></a>借用</h2><p>Rust 中的借用（borrowing）是一种使得程序能够通过引用访问数据，而不取得数据的所有权的机制。这对于 Rust 的内存安全特性至关重要。借用分为两种：不可变借用和可变借用。以下是两种借用的简单示例：</p>
<h3 id="不可变借用"><a href="#不可变借用" class="headerlink" title="不可变借用"></a>不可变借用</h3><p>不可变借用允许你读取数据但不能修改它。你可以有多个不可变引用指向同一数据，因为它们都不会改变数据。</p>
<pre><code class="rust">fn main() &#123;
    let s = String::from(&quot;hello&quot;);

    // 不可变借用
    let len = calculate_length(&amp;s);

    println!(&quot;The length of &#39;&#123;&#125;&#39; is &#123;&#125;.&quot;, s, len);
&#125;

// `s` 是对 `String` 的不可变引用
fn calculate_length(s: &amp;String) -&gt; usize &#123;
    s.len()
    // s 在这里离开作用域，但因为它并不拥有所引用的数据，
    // 所以什么也不会发生
&#125;
</code></pre>
<p>在这个例子中，<code>calculate_length</code> 函数通过不可变引用接受一个字符串。它可以读取字符串的长度，但不能修改字符串本身。</p>
<h3 id="可变借用"><a href="#可变借用" class="headerlink" title="可变借用"></a>可变借用</h3><p>与不可变借用不同，可变借用允许你修改数据。在任何给定时刻，你只能拥有一个数据的可变引用（这防止了数据竞争），除非使用特定的并发类型。</p>
<pre><code class="rust">fn main() &#123;
    let mut s = String::from(&quot;hello&quot;);

    // 可变借用
    change(&amp;mut s);

    println!(&quot;Changed string is &#39;&#123;&#125;&#39;.&quot;, s);
&#125;

// `s` 是对 `String` 的可变引用
fn change(s: &amp;mut String) &#123;
    s.push_str(&quot;, world&quot;);
    // s 在这里离开作用域并释放借用，但不会释放数据本身，
    // 因为它并不拥有数据
&#125;
</code></pre>
<p>在这个例子中，<code>change</code> 函数通过可变引用接受一个字符串，并修改它。需要注意的是，<code>s</code> 在 <code>main</code> 函数中被声明为可变的（<code>mut s</code>），因为我们需要通过引用修改它。</p>
<p>Rust 的这种借用系统能够在编译时防止数据竞争、悬垂引用和其他内存安全问题，是 Rust 内存安全保证的核心部分。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/rust/" style="color: #ff7d73">rust</a>
        </span>
        
    </div>
    <a href="/2024/04/08/mdstorage/domain/rust/%E5%80%9F%E7%94%A8/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/04/07/mdstorage/project/sr/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0/%E7%AE%A1%E7%90%86%E9%9D%A2HA%E6%94%B9%E9%80%A0%E7%AD%94%E7%96%91/">
        <h2 class="post-title">管理面HA改造答疑.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/4/7
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="Keepalived-概述"><a href="#Keepalived-概述" class="headerlink" title="Keepalived 概述"></a>Keepalived 概述</h2><p>Keepalived 为 Linux 系统提供了负载均衡和高可用能力。负载均衡的能力来自 Linux 内核中的 LVS 项目模块 IPVS（IP Virtual Server）。</p>
<p>Keepalived 运行在 Linux 系统中，它会启动内核中的 LVS 服务来创建虚拟服务器。比如我们在两台服务器上都启动了一个 Keepalived 服务，然后 LVS 会虚拟化出来一个 IP（VIP），但是只有一个 Keepalived 会接管这个 VIP，就是说客户端的请求只会到 Master Keepalived 节点上。这样流量就只会到一台 keepalived 上了，然后 keepalived 可以配置几台真实的服务 IP 地址和端口，通过负载调度算法将流量分摊到这些服务上。对于另外一台 Backup Keepalived 节点，它是待机状态，没有流量接入的。</p>
<p>Keepalived 使用 C 语言编写的开源软件项目，项目的目的主要是简化 LVS 项目的配置并增强 LVS 的稳定性。简单来说，Keepalived 就是对 LVS 的扩展增强。管理面没有 LVS,所以管理面 HA 其实存在的意义不大。</p>
<pre><code class="mermaid">---
title: 部署视图
---

graph TD;
    subgraph LAN[&quot;局域网&quot;]
        switch[(&quot;交换机&quot;)]
    end
    subgraph Internet[&quot;互联网&quot;]
        userDevice1((&quot;用户设备1&quot;))
        userDevice2((&quot;用户设备2&quot;))
        router[(&quot;路由器&quot;)]
        userDevice1 --&gt; router
        userDevice2 --&gt; router
        router --&gt; switch
    end
    subgraph Servers[&quot;服务器集群&quot;]
        master[(&quot;主服务器&quot;)]
        backup1[(&quot;备份服务器1&quot;)]
        backup2[(&quot;备份服务器2&quot;)]
        switch --&gt; master
        switch --&gt; backup1
        switch --&gt; backup2
    end
    VIP((&quot;虚拟IP&quot;)) -.-&gt; master
    master -. &quot;故障转移&quot; .-&gt; backup1
    master -. &quot;故障转移&quot; .-&gt; backup2
    classDef default fill:#1E90FF,stroke:#333,stroke-width:2px;
    classDef network fill:#708090,stroke:#333,stroke-width:2px;
    class LAN,Internet,Servers network;
</code></pre>
<ul>
<li><strong>用户</strong>通过互联网访问服务，请求先到达路由器，然后通过交换机转发。</li>
<li><strong>主服务器</strong>拥有虚拟IP（VIP），作为对外服务的唯一入口点。</li>
<li><strong>备份服务器</strong>准备在主服务器发生故障时接管VIP，保证服务的持续可用性。</li>
<li><strong>虚拟IP（VIP）</strong>指向主服务器，但在需要时可以快速迁移到备份服务器。</li>
<li>故障转移的逻辑被表示为从主服务器指向备份服务器的箭头。</li>
</ul>
<pre><code class="mermaid">---
title: 故障转移视图
---
graph TD;
    subgraph Internet[&quot;互联网&quot;]
        userDevice1((&quot;用户设备1&quot;))
        userDevice2((&quot;用户设备2&quot;))
        router[(&quot;路由器&quot;)]
        userDevice1 --&gt;|请求服务| VIP
        userDevice2 --&gt;|请求服务| VIP
    end
    subgraph LAN[&quot;局域网&quot;]
        switch[(&quot;交换机&quot;)]
        VIP((&quot;虚拟IP&quot;)) --&gt; switch
    end
    subgraph Servers[&quot;服务器集群&quot;]
        master[(&quot;主服务器&quot;)]
        backup1[(&quot;备份服务器1&quot;)]
        backup2[(&quot;备份服务器2&quot;)]
        switch --&gt; master
        switch --&gt; backup1
        switch --&gt; backup2
    end
    VIP -. &quot;当前指向&quot; .-&gt; master
    master -. &quot;故障时转移至&quot; .-&gt; backup1
    backup1 -. &quot;故障时转移至&quot; .-&gt; backup2
    classDef default fill:#1E90FF,stroke:#333,stroke-width:2px;
    classDef network fill:#708090,stroke:#333,stroke-width:2px;
    class Internet,LAN,Servers network;
</code></pre>
<h3 id="Keepalived-在传统高可用架构下的位置"><a href="#Keepalived-在传统高可用架构下的位置" class="headerlink" title="Keepalived 在传统高可用架构下的位置"></a>Keepalived 在传统高可用架构下的位置</h3><pre><code class="mermaid">---
title: 传统高可用架构部署视图
---
graph TD;
    subgraph Internet[&quot;互联网&quot;]
        userDevice1((&quot;用户设备1&quot;))
        userDevice2((&quot;用户设备2&quot;))
        userDevice1 --&gt;|请求服务| VIP
        userDevice2 --&gt;|请求服务| VIP
    end
    subgraph LAN[&quot;局域网&quot;]
        switch[(&quot;交换机&quot;)]
        VIP((&quot;虚拟IP&quot;)) --&gt; switch
    end
    subgraph LB_Cluster[&quot;负载均衡器集群(LVS)&quot;]
        LVS_Master[(&quot;LVS 主节点&quot;)]
        LVS_Backup1[(&quot;LVS 备份节点1&quot;)]
        LVS_Backup2[(&quot;LVS 备份节点2&quot;)]
        switch --&gt; LVS_Master
        switch ----&gt; LVS_Backup1
        switch ----&gt; LVS_Backup2
    end
    subgraph Keepalived_Cluster[&quot;Keepalived 集群&quot;]
        Keepalived_Master[(&quot;Keepalived 主&quot;)]
        Keepalived_Backup1[(&quot;Keepalived 备份1&quot;)]
        Keepalived_Backup2[(&quot;Keepalived 备份2&quot;)]
        LVS_Master --&gt; Keepalived_Master
        LVS_Backup --&gt; Keepalived_Backup1
        LVS_Backup --&gt; Keepalived_Backup2
    end
    subgraph Backend_Servers[&quot;后端服务器&quot;]
        server1[(&quot;服务器1&quot;)]
        server2[(&quot;服务器2&quot;)]
        server3[(&quot;服务器3&quot;)]
        LVS_Master --&gt; server1
        LVS_Master --&gt; server2
        LVS_Master --&gt; server3
    end
    VIP -. &quot;当前指向&quot; .-&gt; LVS_Master
    LVS_Master -. &quot;故障时转移至&quot; .-&gt; LVS_Backup
    Keepalived_Master -. &quot;管理&quot; .-&gt; LVS_Master
    Keepalived_Backup1 -. &quot;备用管理&quot; .-&gt; LVS_Backup
    Keepalived_Backup2 -. &quot;备用管理&quot; .-&gt; LVS_Backup
    classDef default fill:#1E90FF,stroke:#333,stroke-width:2px;
    classDef network fill:#708090,stroke:#333,stroke-width:2px;
    class Internet,LAN,LB_Cluster,Keepalived_Cluster,Backend_Servers network;
</code></pre>
<ul>
<li><strong>用户设备</strong>通过互联网向虚拟IP（VIP）发送服务请求。</li>
<li><strong>虚拟IP（VIP）</strong>由Keepalived管理，并指向LVS的主节点。</li>
<li><strong>LVS的主节点</strong>和备份节点构成了负载均衡器集群，负责将请求分发到后端服务器。</li>
<li><strong>Keepalived集群</strong>包括主节点和备份节点，用于管理LVS集群的高可用性，确保在LVS主节点发生故障时能够将VIP快速迁移到备份节点。</li>
<li><strong>后端服务器</strong>接收来自LVS主节点的请求，并处理这些请求。</li>
</ul>
<h2 id="改造前引擎高可用机制数据流向"><a href="#改造前引擎高可用机制数据流向" class="headerlink" title="改造前引擎高可用机制数据流向"></a>改造前引擎高可用机制数据流向</h2><pre><code class="mermaid">---
title: 改造前引擎高可用机制数据流向
---
graph TD;
    subgraph Internet[&quot;互联网&quot;]
        userDevice1((&quot;客户设备1&quot;))
        userDevice2((&quot;客户设备2&quot;))
        router_public[(&quot;公网路由器|防火墙&quot;)]
        userDevice1 --&gt;|访问总控| router_public
        userDevice2 --&gt;|访问总控| router_public
    end
    subgraph PublicNetwork[&quot;公网可访问网络&quot;]
        switch_public[(&quot;公网交换机&quot;)]
        router_public --&gt; switch_public
    end
    subgraph SC[总控]
        sc[(sc)]
        sv[(sv)]
        switch_public --&gt; sc
    end
    subgraph DataCenter[&quot;数据中心网络&quot;]
        router_datacenter[(&quot;数据中心路由器|防火墙&quot;)]
        switch_datacenter[(&quot;数据中心交换机&quot;)]
        router_datacenter --&gt; switch_datacenter
    end
    subgraph SEM[管理面]
        VIP((虚拟IP))
        subgraph SEMNode1[管理面节点1]
            other_comp1[(管理面组件)]
        end
        subgraph SEMNode2[管理面节点2]
            other_comp2[(管理面组件)]
        end
        subgraph SEMNode3[管理面节点3]
            other_comp3[(管理面组件)]
        end
        subgraph KeepalivedSEM[管理面Keepalived]
            keepalived_master_SEM[(&quot;Keepalived 主&quot;)]
            keepalived_backup_SEM[(&quot;Keepalived 备份&quot;)]
            keepalived_master_SEM --&gt; keepalived_backup_SEM
            keepalived_backup_SEM -.-&gt; keepalived_master_SEM
        end
        other_comp1 &lt;--&gt;|服务搭建等管理工作| keepalived_master_SEM
        VIP -.-&gt; other_comp1 -. &quot;故障转移&quot; .-&gt; keepalived_backup_SEM
    end
    subgraph SES[调度集群]
        VIP_SES((业务VIP表))
        subgraph SES_LVS[调度LVS]
            LVS_SES_Master[(&quot;LVS 主节点&quot;)]
            lvs_policy((策略管理))
            LVS_SES_Backup[(&quot;LVS 备份节点&quot;)]
            LVS_SES_Master --&gt;|调度请求| LVS_SES_Backup
            LVS_SES_Backup -.-&gt;|故障转移| LVS_SES_Master
            LVS_SES_Master -.-&gt; lvs_policy
        end
        subgraph KeepalivedSES[调度Keepalived]
            keepalived_master_SES[(&quot;Keepalived 主&quot;)]
            keepalived_backup_SES[(&quot;Keepalived 备份&quot;)]
            keepalived_master_SES --&gt; keepalived_backup_SES
            keepalived_backup_SES -.-&gt; keepalived_master_SES
        end
        VIP_SES -.-&gt; LVS_SES_Master
        LVS_SES_Master --&gt; keepalived_master_SES
    end
    subgraph SEW[工作集群]
        subgraph Backend_Servers1[&quot;工作节点集群&quot;]
            envoy1[(&quot;Envoy&quot;)]
            polycuber1[(&quot;Polycuber&quot;)]
        end
        subgraph Backend_Servers2[&quot;工作节点集群&quot;]
            envoy2[(&quot;Envoy&quot;)]
            polycuber2[(&quot;Polycuber&quot;)]
        end
        subgraph Backend_Servers3[&quot;工作节点集群&quot;]
            envoy3[(&quot;Envoy&quot;)]
            polycuber3[(&quot;Polycuber&quot;)]
        end
    end

    subgraph UserServer[业务服务集群]
        subgraph ServerCluster1[&quot;业务服务集群1&quot;]
            node1[(node)]
            node2[(node)]
        end
        subgraph ServerCluster2[&quot;业务服务集群2&quot;]
            node3[(node)]
        end
        subgraph ServerCluster3[&quot;业务服务集群3&quot;]
            node4[(node)]
        end
    end
    subgraph UserSpace[&quot;用户|服务访问流量&quot;]
        user1((用户访问))
        frontend((前端业务))
    end
    other_comp1 --&gt; |管理| SES
    other_comp1 ---&gt; |管理| SEW

    LVS_SES_Master --业务流量转发--&gt; envoy1 &amp; envoy2 &amp; envoy3
    user1 &amp; frontend --&gt; VIP_SES
    envoy1 --&gt;|反向代理| node1 &amp; node2 &amp; node3
    envoy2 --&gt;|重定向| node4
    envoy3 &lt;--&gt;direct_response[直接响应] 
    switch_public --&gt;|接受来自SC的流量| router_datacenter
    switch_datacenter --&gt; VIP

    classDef network fill:#bbf,stroke:#333,stroke-width:2px;
    class Internet,PublicNetwork,DataCenter network;
    
    class Internet internet
    class PublicNetwork publicNet;
    class DataCenter dataCenter;
    class SEM management;
    class SES scheduling;
    class SEW workCluster;
    class UserServer userService;
    class UserSpace userAccess;
    classDef internet fill:#bde0fe,stroke:#333,stroke-width:2px;
    classDef publicNet fill:#fed7b2,stroke:#333,stroke-width:2px;
    classDef dataCenter fill:#d4a5a5,stroke:#333,stroke-width:4px;
    classDef management fill:#fbcfe8,stroke:#333,stroke-width:2px;
    classDef scheduling fill:#fef08a,stroke:#333,stroke-width:2px;
    classDef workCluster fill:#bbf7d0,stroke:#333,stroke-width:2px;
    classDef userService fill:#d9f99d,stroke:#333,stroke-width:2px;
    classDef userAccess fill:#a7f3d0,stroke:#333,stroke-width:2px;
    classDef flowLine stroke:#2563eb,stroke-width:2px,stroke-dasharray: 5, 5;
    linkStyle 3,4,17,18,29,30 stroke:#db2777,stroke-width:12px;
    linkStyle 19,20,21,22,23,24,25,26 stroke:#2563eb,stroke-width:2px,stroke-width:8px ;
</code></pre>
<h2 id="改造后引擎高可用机制数据流向"><a href="#改造后引擎高可用机制数据流向" class="headerlink" title="改造后引擎高可用机制数据流向"></a>改造后引擎高可用机制数据流向</h2><pre><code class="mermaid">---
title: 改造后引擎高可用机制数据流向
---
graph TD;
    subgraph Internet[&quot;互联网&quot;]
        userDevice1((&quot;客户设备1&quot;))
        userDevice2((&quot;客户设备2&quot;))
        router_public[(&quot;公网路由器|防火墙&quot;)]
        userDevice1 --&gt;|访问总控| router_public
        userDevice2 --&gt;|访问总控| router_public
    end
    subgraph PublicNetwork[&quot;公网可访问网络&quot;]
        switch_public[(&quot;公网交换机&quot;)]
        router_public --&gt; switch_public
    end
    subgraph SC[总控]
        sc_m_nic((管理口))
        sc[(sc)]
        sv[(sv)]
        sc_core[(sc-core)]
        switch_public &lt;-.-&gt; sc_m_nic --&gt; sc_core
        sc &amp; sv -.-&gt; sc_core
    end
    subgraph DataCenter[&quot;数据中心网络&quot;]
        router_datacenter[(&quot;数据中心路由器|防火墙&quot;)]
        switch_datacenter[(&quot;数据中心交换机&quot;)]
        router_datacenter &lt;-.-&gt; switch_datacenter
    end
    subgraph SEM[管理面]
        subgraph SEMNode1[管理面节点1]
            m_nic1((管理口))
            other_comp1[(管理面组件流量入口)]
            controller1[(管理面组件)]
            apiserver_node1[apiserver]
            m_nic1 &lt;-.-&gt; other_comp1
            other_comp1 --&gt; controller1 --&gt; apiserver_node1
        end
        subgraph SEMNode2[管理面节点2]
            m_nic2((管理口))
            other_comp2[(管理面组件流量入口)]
            controller2[(管理面组件)]
            apiserver_node2[apiserver]
            m_nic2 &lt;-.-&gt; other_comp2
            other_comp2 --&gt; controller2 --&gt; apiserver_node2
        end
        subgraph SEMNode3[管理面节点3]
            m_nic3((管理口))
            other_comp3[(管理面组件流量入口)]
            controller3[(管理面组件)]
            apiserver_node3[apiserver]
            m_nic3 &lt;-.-&gt; other_comp3
            other_comp3 --&gt; controller3 --&gt; apiserver_node3
        end
        subgraph Apiserver[Apiserver集群]
            apiserver1[(Apiserver)]
            apiserver2[(Apiserver)]
            apiserver3[(Apiserver)]
        end
        apiserver_node1 -.- apiserver1
        apiserver_node2 -.- apiserver2
        apiserver_node3 -.- apiserver3
    end
    subgraph SES[调度集群]
        VIP_SES((业务VIP表))
        subgraph SES_LVS[调度LVS]
            subgraph SESNode1
                ses_m_nic1((管理口))
                ses_d_nic1((业务口))
                LVS_SES_Master[(&quot;LVS 主节点&quot;)]
                lvs_policy((策略管理))
                ses_m_nic1 -.- lvs_policy
            end
            subgraph SESNode2
                ses_m_nic2((管理口))
                ses_d_nic2((业务口))
                LVS_SES_Backup[(&quot;LVS 备份节点&quot;)]
            end
            
            LVS_SES_Master --&gt;|调度请求| LVS_SES_Backup
            LVS_SES_Backup -.-&gt;|故障转移| LVS_SES_Master
            LVS_SES_Master -.-&gt; lvs_policy
        end
        subgraph KeepalivedSES[调度Keepalived]
            keepalived_master_SES[(&quot;Keepalived 主&quot;)]
            keepalived_backup_SES[(&quot;Keepalived 备份&quot;)]
            keepalived_master_SES --&gt; keepalived_backup_SES
            keepalived_backup_SES -.-&gt; keepalived_master_SES
        end
        VIP_SES -.- ses_d_nic1 --&gt; LVS_SES_Master
        LVS_SES_Master --&gt; keepalived_master_SES
    end
    subgraph SEW[工作集群]
        subgraph Backend_Servers1[&quot;工作节点集群&quot;]
            sew_m_nic1((管理口))
            sew_d_nic1((业务口))
            envoy1[(&quot;Envoy&quot;)]
            polycuber1[(&quot;Polycuber&quot;)]
            sew_m_nic1 &amp; sew_d_nic1 -.- envoy1
        end
        subgraph Backend_Servers2[&quot;工作节点集群&quot;]
            sew_m_nic2((管理口))
            sew_d_nic2((业务口))
            envoy2[(&quot;Envoy&quot;)]
            polycuber2[(&quot;Polycuber&quot;)]
            sew_m_nic2 &amp; sew_d_nic2 -.- envoy2
        end
        subgraph Backend_Servers3[&quot;工作节点集群&quot;]
            sew_m_nic3((管理口))
            sew_d_nic3((业务口))
            envoy3[(&quot;Envoy&quot;)]
            polycuber3[(&quot;Polycuber&quot;)]
            sew_m_nic3 &amp; sew_d_nic3 -.- envoy3
        end
    end

    subgraph UserServer[业务服务集群]
        subgraph ServerCluster1[&quot;业务服务集群1&quot;]
            node1[(node)]
            node2[(node)]
        end
        subgraph ServerCluster2[&quot;业务服务集群2&quot;]
            node3[(node)]
        end
        subgraph ServerCluster3[&quot;业务服务集群3&quot;]
            node4[(node)]
        end
    end
    subgraph UserSpace[&quot;用户|服务访问流量&quot;]
        user1((用户访问))
        frontend((前端业务))
    end
    ses_m_nic1 &amp; SEW ---&gt; Apiserver
    m_nic1 &amp; m_nic2 &amp; m_nic3 &lt;-.-&gt; switch_datacenter

    LVS_SES_Master --业务流量转发--&gt; sew_d_nic1 &amp; sew_d_nic2 &amp; sew_d_nic3
    user1 &amp; frontend --&gt; VIP_SES
    envoy1 --&gt;|反向代理| node1 &amp; node2 &amp; node3
    envoy2 --&gt;|重定向| node4
    envoy3 &lt;--&gt; direct_response[直接响应] 
    router_datacenter &lt;-.-&gt;|放通dst为sc的流| switch_public

    classDef network fill:#bbf,stroke:#333,stroke-width:2px;
    class Internet,PublicNetwork,DataCenter network;
    
    class Internet internet
    class PublicNetwork publicNet;
    class DataCenter dataCenter;
    class SEM management;
    class SES scheduling;
    class SEW workCluster;
    class UserServer userService;
    class UserSpace userAccess;
    classDef internet fill:#bde0fe,stroke:#333,stroke-width:2px;
    classDef publicNet fill:#fed7b2,stroke:#333,stroke-width:2px;
    classDef dataCenter fill:#d4a5a5,stroke:#333,stroke-width:4px;
    classDef management fill:#fbcfe8,stroke:#333,stroke-width:2px;
    classDef scheduling fill:#fef08a,stroke:#333,stroke-width:2px;
    classDef workCluster fill:#bbf7d0,stroke:#333,stroke-width:2px;
    classDef userService fill:#d9f99d,stroke:#333,stroke-width:2px;
    classDef userAccess fill:#a7f3d0,stroke:#333,stroke-width:2px;
    classDef flowLine stroke:#2563eb,stroke-width:2px,stroke-dasharray: 5, 5;
    linkStyle 0 stroke:#db2777,stroke-width:12px;
    linkStyle 0 stroke:#2563eb,stroke-width:2px,stroke-width:8px;
    linkStyle 0 stroke:#db2777,stroke-width:12px,color:red;
</code></pre>
<ul>
<li><strong>用户设备</strong>通过互联网访问总控。它们首先连接到<strong>公网路由器</strong>，然后通过<strong>公网交换机</strong>到达总控节点。</li>
<li><strong>总控节点</strong>被部署在一个公网可访问的网络内，允许来自互联网的访问。</li>
<li><strong>数据中心网络</strong>内包括引擎集群（管理面、调度集群、工作集群），它们通过<strong>数据中心路由器</strong>和<strong>数据中心交换机</strong>连接。</li>
<li><strong>管理面集群</strong>中的节点通过Keepalived实现高可用性，使用虚拟IP（VIP）为入口点。</li>
<li>VIP用于路由请求到<strong>调度集群</strong>，然后调度集群将任务分配给<strong>工作集群</strong>进行处理。</li>
</ul>
<h2 id="改造后物理架构"><a href="#改造后物理架构" class="headerlink" title="改造后物理架构"></a>改造后物理架构</h2><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/sr_mmrefactor_before.png" alt="通信链路改造前静态拓扑"></p>
<p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/sr_mmrefactor_after_network.png" alt="通信链路改造后静态拓扑"></p>
<p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/sr_mmrefactor_sem1.png" alt="a"></p>
<p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/sr_mmrefactor_ses.png" alt="sr_mmrefactor_ses"></p>
<p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/sr_mmrefactor_sew.png" alt="通信链路改造-工作节点故障转移"></p>
<h2 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h2><h3 id="云服务场景"><a href="#云服务场景" class="headerlink" title="云服务场景"></a>云服务场景</h3><p>公有云服务中一般 VIP 需要单独开，给服务部署带来更多要求。</p>
<h3 id="灾难恢复"><a href="#灾难恢复" class="headerlink" title="灾难恢复"></a>灾难恢复</h3><p>Keepalived主要设计用于单个数据中心或地理位置相近的网络中的高可用性。网络波动大、延时波动大的情况下，Keepalived 会出现频繁切主现象。</p>
<h3 id="监控日志管理"><a href="#监控日志管理" class="headerlink" title="监控日志管理"></a>监控日志管理</h3><p>虽然Keepalived提供基本的日志记录功能，但在复杂系统中，集成更先进的监控和日志分析通常是必需的，团队中没有修改 Keepalived 代码能力。</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>Vrrp 协议本身是未加密的通信，并且可能在用户网络中与已有的组播冲突 （224.0.0.18）</p>
<h3 id="功能限制"><a href="#功能限制" class="headerlink" title="功能限制"></a>功能限制</h3><p>Keepalived 是做服务器层面高可用，不可能在此基础上做应用高可用。</p>
<h3 id="复杂"><a href="#复杂" class="headerlink" title="复杂"></a>复杂</h3><p>对于一些简单的高可用性需求，Keepalived的功能和配置可能显得过于复杂，特别是在没有负载均衡需求时。 </p>
<h3 id="技术栈不匹配"><a href="#技术栈不匹配" class="headerlink" title="技术栈不匹配"></a>技术栈不匹配</h3><p>Keepalived 使用 ANSI C 编写，引擎管理面使用 Golang，技术栈上不匹配，后期不能维护</p>
<h3 id="Web界面适配困难"><a href="#Web界面适配困难" class="headerlink" title="Web界面适配困难"></a>Web界面适配困难</h3><p>只提供文本文件进行配置。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://keepalived-doc.readthedocs.io/zh-cn/latest/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1.html">https://keepalived-doc.readthedocs.io/zh-cn/latest/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1.html</a></li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/sr/" style="color: #00bcd4">sr</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/ha/" style="color: #00a596">ha</a>
        </span>
        
    </div>
    <a href="/2024/04/07/mdstorage/project/sr/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0/%E7%AE%A1%E7%90%86%E9%9D%A2HA%E6%94%B9%E9%80%A0%E7%AD%94%E7%96%91/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/03/29/mdstorage/domain/linux/awk/">
        <h2 class="post-title">awk.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/domain/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                domain
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/29
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="处理文件"><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h2><p><code>awk &#39;&#39; $file_path</code></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code class="bash">extract_hosts_to_cluster_info() &#123;
    local hosts_file=$1
    local cluster_info=$(awk &#39;/^\s*[^#]/ &amp;&amp; $2 ~ /.srhino.svc.local$/ &amp;&amp; $2 !~ /^s/ &amp;&amp; $2 !~ /^localhost/ &#123;sub(/\.srhino\.svc\.local$/, &quot;&quot;, $2); print $2&quot;=http://&quot;$1&quot;:2380&quot;&#125;&#39; $&#123;hosts_file&#125; | paste -sd,)
    echo $cluster_info
&#125;
</code></pre>
<p><strong>awk</strong></p>
<ul>
<li><code>awk</code> 是一个强大的文本处理工具，用于模式扫描和处理。</li>
<li>使用 <code>/^\s*[^#]/</code> 来选择那些不以 <code>#</code> 开头的行，忽略了空白行和注释行。</li>
<li><code>$2 ~ /.srhino.svc.local$/</code> 确保第二个字段以 <code>.srhino.svc.local</code> 结尾。</li>
<li><code>$2 !~ /^s/</code> 确保第二个字段不是以 <code>s</code> 开头的。</li>
<li><code>$2 !~ /^localhost/</code> 排除任何以 <code>localhost</code> 开头的字段。</li>
<li><code>&#123;sub(/\.srhino\.svc\.local$/, &quot;&quot;, $2); print $2&quot;=http://&quot;$1&quot;:2380&quot;&#125;</code> 首先用 <code>sub()</code> 函数删除字段中的 <code>.srhino.svc.local</code> 后缀，然后打印修改后的第二个字段和第一个字段（IP 地址）的组合，格式为 <code>&lt;hostname&gt;=http://&lt;ip&gt;:2380</code>。</li>
</ul>
<p><strong>paste</strong></p>
<ul>
<li><code>paste</code> 命令用于合并文件或标准输入的行。</li>
<li><code>-s</code> 选项将所有输入行合并为单行。</li>
<li><code>-d,</code> 设定字段间的分隔符为逗号 <code>,</code>。</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/awk/" style="color: #ff7d73">awk</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/paste/" style="color: #ffa2c4">paste</a>
        </span>
        
    </div>
    <a href="/2024/03/29/mdstorage/domain/linux/awk/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/03/28/mdstorage/domain/k8s/etcdctl%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/">
        <h2 class="post-title">etcdctl常用指令.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/domain/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                domain
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><pre><code class="bash"># 查看指定 endpoint 状态信息
./etcdctl endpoint status --endpoints=192.168.122.26:2379  -wtable

# 查看 cluster 所有 集群状态信息
./etcdctl endpoint status --endpoints=192.168.122.26:2379 --cluster  -wtable

ETCDCTL_API=3 etcdctl --endpoints=http://192.168.122.124:2379 endpoint status --cluster --write-out=table

# 查看 集群成员信息
./etcdctl member list --endpoints=192.168.122.26:2379 -wtable
</code></pre>
<h2 id="如果-member-add-失败后-启动参数需要加上-force-new-cluster"><a href="#如果-member-add-失败后-启动参数需要加上-force-new-cluster" class="headerlink" title="如果 member add 失败后, 启动参数需要加上 -force-new-cluster"></a>如果 member add 失败后, 启动参数需要加上 -force-new-cluster</h2><ol>
<li>先删除 data&#x2F;member 目录</li>
<li>重启 etcd 启动参数需要加上 -force-new-cluster<br><a target="_blank" rel="noopener" href="https://loverhythm1990.github.io/2022/06/08/etcd-force-newcluster/#force-new-cluster">https://loverhythm1990.github.io/2022/06/08/etcd-force-newcluster/#force-new-cluster</a></li>
</ol>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/etcd/" style="color: #ffa2c4">etcd</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/etcdctl/" style="color: #00a596">etcdctl</a>
        </span>
        
    </div>
    <a href="/2024/03/28/mdstorage/domain/k8s/etcdctl%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/03/28/mdstorage/domain/%E6%96%87%E6%A1%A3/mermaid%E6%97%B6%E5%BA%8F%E5%9B%BE/">
        <h2 class="post-title">mermaid时序图.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/domain/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                domain
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>时序图用于表示复杂的时序逻辑演示</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><pre><code class="Text">sequenceDiagram
    participant node1
    participant node2
    
    node1-&gt;&gt;node2: 实线表示发送消息
    node2--&gt;&gt;node1: 虚线表示响应
    
    %% todo alt ，par 语法
</code></pre>
<pre><code class="mermaid">sequenceDiagram
    participant node1
    participant node2
    
    node1-&gt;&gt;node2: 实线表示发送消息
    node2--&gt;&gt;node1: 虚线表示响应
    
    %% todo alt ，par 语法
    
</code></pre>
<h2 id="时序图风格示例参考"><a href="#时序图风格示例参考" class="headerlink" title="时序图风格示例参考"></a>时序图风格示例参考</h2><pre><code class="Text">sequenceDiagram
    participant manager as Manager
    participant node1 as node1
    participant node2 as node2
    participant node3 as node3


    manager-&gt;&gt;node1: 建立集群
    activate node1
    node1-&gt;&gt;node1: new cluster node1
    node1--&gt;&gt;manager: 
    deactivate node1
    
    manager-&gt;&gt;node2: 新增节点2
    activate node2
    Note over node1,node2: 环境变量中 cluster: node1,node2
    node2-&gt;&gt;node1: member add node2
    node1--&gt;&gt;node2: 
    node2-&gt;&gt;node2: node2 start （existing cluster, cluster: node1,node2）
    node2--&gt;&gt;manager: 
    deactivate node2
    
    manager-&gt;&gt;node3: 新增节点3
    activate node3
    Note over node1,node3: 环境变量中 cluster: node1,node2,node3
    alt request endpoints
        node3-&gt;&gt;node1: member add node3
        node1--&gt;&gt;node3: 
    else
        node3-&gt;&gt;node2: member add node3
        node2--&gt;&gt;node3: 
    end
    node3-&gt;&gt;node3: node3 start（existing cluster, cluster: node1,node2,node3）
    node3--&gt;&gt;manager: 响应
    deactivate node3
</code></pre>
<pre><code class="mermaid">sequenceDiagram
    participant manager as Manager
    participant node1 as node1
    participant node2 as node2
    participant node3 as node3


    manager-&gt;&gt;node1: 建立集群
    activate node1
    node1-&gt;&gt;node1: new cluster node1
    node1--&gt;&gt;manager: 
    deactivate node1
    
    manager-&gt;&gt;node2: 新增节点2
    activate node2
    Note over node1,node2: 环境变量中 cluster: node1,node2
    node2-&gt;&gt;node1: member add node2
    node1--&gt;&gt;node2: 
    node2-&gt;&gt;node2: node2 start （existing cluster, cluster: node1,node2）
    node2--&gt;&gt;manager: 
    deactivate node2
    
    manager-&gt;&gt;node3: 新增节点3
    activate node3
    Note over node1,node3: 环境变量中 cluster: node1,node2,node3
    alt request endpoints
        node3-&gt;&gt;node1: member add node3
        node1--&gt;&gt;node3: 
    else
        node3-&gt;&gt;node2: member add node3
        node2--&gt;&gt;node3: 
    end
    node3-&gt;&gt;node3: node3 start（existing cluster, cluster: node1,node2,node3）
    node3--&gt;&gt;manager: 响应
    deactivate node3
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/mermaid/" style="color: #ffa2c4">mermaid</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/%E6%97%B6%E5%BA%8F%E5%9B%BE/" style="color: #00a596">时序图</a>
        </span>
        
    </div>
    <a href="/2024/03/28/mdstorage/domain/%E6%96%87%E6%A1%A3/mermaid%E6%97%B6%E5%BA%8F%E5%9B%BE/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/03/27/mdstorage/domain/golang/gomodule%E6%8A%80%E5%B7%A7/">
        <h2 class="post-title">gomodule技巧.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/domain/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                domain
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/27
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="replace-将本地目录映射为-package"><a href="#replace-将本地目录映射为-package" class="headerlink" title="replace 将本地目录映射为 package"></a>replace 将本地目录映射为 package</h2><pre><code class="go">replace (
    go.etcd.io/etcd/api/v3 =&gt; ./api
    go.etcd.io/etcd/client/pkg/v3 =&gt; ./client/pkg
    go.etcd.io/etcd/client/v2 =&gt; ./client/internal/v2
    go.etcd.io/etcd/client/v3 =&gt; ./client/v3
    go.etcd.io/etcd/etcdctl/v3 =&gt; ./etcdctl
    go.etcd.io/etcd/etcdutl/v3 =&gt; ./etcdutl
    go.etcd.io/etcd/pkg/v3 =&gt; ./pkg
    go.etcd.io/etcd/server/v3 =&gt; ./server
    go.etcd.io/etcd/tests/v3 =&gt; ./tests
) 
</code></pre>
<p>替换指令用于将依赖库<code>go.etcd.io/etcd</code>的不同部分替换为本地目录中的相应路径。例如，当项目需要<code>go.etcd.io/etcd/api/v3</code>这个模块时，Go工具链会从本地的<code>./api</code>目录而不是远程仓库加载它。</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li>方便迭代</li>
<li>代码存放路径与导包路径无关（前提是功能独立且封装良好）</li>
<li>大型项目中适用</li>
<li>重构项目时适用</li>
</ul>
<h3 id="go-mod-download"><a href="#go-mod-download" class="headerlink" title="go mod download"></a>go mod download</h3><p><code>go mod download</code> 是 Go 工具链中与模块管理相关的命令。它的主要作用是下载依赖项并将它们存储在本地模块缓存中。以下是 <code>go mod download</code> 的详细解释：</p>
<h3 id="go-mod-download-命令概述"><a href="#go-mod-download-命令概述" class="headerlink" title="go mod download 命令概述"></a><code>go mod download</code> 命令概述</h3><p><code>go mod download</code> 命令用于下载当前模块依赖项的所有模块版本（包括直接和间接依赖）并将它们存储在本地模块缓存中。这些模块会被存储在 Go 的模块缓存目录下，通常位于 <code>$GOPATH/pkg/mod</code> 或 <code>$HOME/go/pkg/mod</code>。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><p><strong>下载所有依赖</strong>:</p>
<ul>
<li>当你在开发项目时，使用 <code>go mod download</code> 可以提前下载并缓存所有依赖模块，确保后续的编译或构建过程不再需要联网下载依赖。</li>
</ul>
</li>
<li><p><strong>离线构建</strong>:</p>
<ul>
<li>你可以在有网络的环境下执行 <code>go mod download</code>，然后在没有网络的环境下进行构建。因为所有的依赖已经被下载并存储在本地缓存中。</li>
</ul>
</li>
<li><p><strong>模块缓存管理</strong>:</p>
<ul>
<li><code>go mod download</code> 会下载所有依赖模块到本地缓存中，即使这些依赖还没有被实际使用。这可以帮助开发者提前解决依赖问题。</li>
</ul>
</li>
</ol>
<h3 id="命令选项和用法"><a href="#命令选项和用法" class="headerlink" title="命令选项和用法"></a>命令选项和用法</h3><ul>
<li><p><strong>下载当前模块所有依赖</strong>:</p>
<pre><code class="bash">go mod download
</code></pre>
<p>这个命令会根据当前模块的 <code>go.mod</code> 文件，下载该模块所有的依赖项，包括直接和间接依赖。</p>
</li>
<li><p><strong>下载特定模块</strong>:</p>
<pre><code class="bash">go mod download &lt;module&gt;
</code></pre>
<p>如果你只想下载特定的模块或版本，可以在命令后面加上模块路径和可选的版本号。例如：</p>
<pre><code class="bash">go mod download github.com/some/module@v1.2.3
</code></pre>
<p>这个命令会下载 <code>github.com/some/module</code> 模块的 <code>v1.2.3</code> 版本并将其存储到本地缓存中。</p>
</li>
<li><p><strong>只解析不下载</strong>:</p>
<p>如果你只想解析 <code>go.mod</code> 文件但不实际下载依赖项，可以使用 <code>-json</code> 标志：</p>
<pre><code class="bash">go mod download -json
</code></pre>
<p>这会输出所有依赖的详细信息（包括模块名、版本、是否在本地缓存中等），但不会下载任何模块。</p>
</li>
</ul>
<h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><ol>
<li><p><strong>读取 <code>go.mod</code> 文件</strong>:</p>
<ul>
<li><code>go mod download</code> 首先读取项目根目录中的 <code>go.mod</code> 文件，获取该模块的依赖列表。</li>
</ul>
</li>
<li><p><strong>解析依赖树</strong>:</p>
<ul>
<li>它解析依赖树，确定哪些模块和版本需要下载。这包括直接依赖和间接依赖（即你的依赖项所依赖的模块）。</li>
</ul>
</li>
<li><p><strong>下载模块</strong>:</p>
<ul>
<li>对于每个模块，<code>go mod download</code> 会尝试从模块代理或版本控制系统（如 GitHub）下载模块的源码包，并将其解压存储到本地缓存中。</li>
</ul>
</li>
<li><p><strong>更新本地缓存</strong>:</p>
<ul>
<li>下载完成后，模块的源码包和构建缓存会被存储在 <code>$GOPATH/pkg/mod</code> 或 <code>$HOME/go/pkg/mod</code> 目录下。</li>
</ul>
</li>
</ol>
<h3 id="关联命令"><a href="#关联命令" class="headerlink" title="关联命令"></a>关联命令</h3><ul>
<li><p><strong><code>go mod tidy</code></strong>:</p>
<ul>
<li>这个命令会移除 <code>go.mod</code> 文件中未使用的依赖，并下载缺失的依赖项。它确保 <code>go.mod</code> 和 <code>go.sum</code> 文件的依赖记录是最小且正确的。</li>
</ul>
</li>
<li><p><strong><code>go mod vendor</code></strong>:</p>
<ul>
<li>这个命令会将所有依赖的源码复制到 <code>vendor</code> 目录中，这样可以保证构建过程只依赖本地的 <code>vendor</code> 目录，而不依赖网络或模块缓存。</li>
</ul>
</li>
<li><p><strong><code>go mod verify</code></strong>:</p>
<ul>
<li>这个命令会验证本地模块缓存中的模块是否匹配 <code>go.sum</code> 文件中的校验和，确保依赖的模块未被篡改。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>go mod download</code> 是 Go 模块管理中一个重要的工具，它帮助开发者预先下载所有依赖模块，以便离线构建或在网络不稳定的环境中工作。通过缓存机制，它还加快了编译和构建的速度，确保每次构建都能使用正确版本的依赖。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/golang/" style="color: #ff7d73">golang</a>
        </span>
        
    </div>
    <a href="/2024/03/27/mdstorage/domain/golang/gomodule%E6%8A%80%E5%B7%A7/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/03/27/mdstorage/domain/k8s/etcd%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD/">
        <h2 class="post-title">etcd集群安装卸载.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/domain/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                domain
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/27
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="集群安装脚本"><a href="#集群安装脚本" class="headerlink" title="集群安装脚本"></a>集群安装脚本</h2><pre><code class="bash"># 函数：创建必要的目录结构
create_directories() &#123;
    mkdir -p &quot;$@&quot;
&#125;

# 创建etcd配置文件
create_etcd_config() &#123;
  local config_file=$1
  local node_name=$2
  local data_dir=$3
  local wal_dir=$4
  local client_url=$5
  local peer_url=$6
    local cluster_token=$7
    local cluster=$8
    local new_opt=$&#123;9&#125;
  
  cat &lt;&lt; EOF &gt; &quot;$config_file&quot;
ETCD_OPTS=&quot;--name $node_name \\
--max-request-bytes 10485760 \\
--data-dir $data_dir \\
--wal-dir $wal_dir \\
--advertise-client-urls $client_url \\
--listen-client-urls $client_url \\
--listen-peer-urls $peer_url \\
--initial-advertise-peer-urls $peer_url \\
--initial-cluster-token $&#123;cluster_token&#125; \\
--initial-cluster $&#123;cluster&#125; \\
--initial-cluster-state $&#123;new_opt&#125;&quot;
EOF
&#125;

reload_and_start_etcd() &#123;
  systemctl daemon-reload
  systemctl start etcd
&#125;

# 函数：配置并启动etcd服务
create_etcd_service() &#123;
  local service_file=$1
  local config_path=$2
  local etcd_executable=$3
  
  cat &lt;&lt; EOF &gt; &quot;$service_file&quot;
[Unit]
Description=Etcd For Kubernetes
Wants=network-online.target
After=network.target network-online.target

[Service]
EnvironmentFile=$config_path
ExecStart=$etcd_executable \$ETCD_OPTS
Restart=always

[Install]
WantedBy=multi-user.target
EOF
&#125;

get_etcd_from_local() &#123;
  local source_path=$1
  local target_dir=$2

  if [ ! -f &quot;$source_path&quot; ]; then
    echo &quot;Source etcd binary does not exist at $&#123;source_path&#125;.&quot;
    exit 1
  fi

  echo &quot;Copying etcd binary from $&#123;source_path&#125; to $&#123;target_dir&#125;...&quot;
  if cp &quot;$source_path&quot; &quot;$&#123;target_dir&#125;/etcd&quot;; then
    chmod +x &quot;$&#123;target_dir&#125;/etcd&quot;
    echo &quot;Successfully copied and prepared etcd binary.&quot;
  else
    echo &quot;Failed to copy etcd binary from $&#123;source_path&#125;.&quot;
    exit 1
  fi
&#125;

get_etcd_from_remote() &#123;
  local bin_dir=$1
  local ftpserver=$2
  local http_user=$3
  local http_passwd=$4

  echo &quot;Downloading etcd binary from $&#123;ftpserver&#125;...&quot;
  if wget -P &quot;$bin_dir&quot; --http-user=&quot;$http_user&quot; --http-passwd=&quot;$http_passwd&quot; &quot;$&#123;ftpserver&#125;/repo/kubernetes/etcd&quot;; then
    chmod +x &quot;$&#123;bin_dir&#125;/etcd&quot;
    echo &quot;Successfully downloaded and prepared etcd binary.&quot;
  else
    echo &quot;Failed to download etcd binary from $&#123;ftpserver&#125;.&quot;
    exit 1
  fi
&#125;

get_etcd() &#123;
  local option=$1
  local target_dir=$2
  local source_path_or_url=$3
  local http_user=$4 # 仅 remote 时需要
  local http_passwd=$5 # 仅 remote 时需要

  case &quot;$option&quot; in
    &quot;local&quot;)
      get_etcd_from_local &quot;$source_path_or_url&quot; &quot;$target_dir&quot;
      ;;
    &quot;remote&quot;)
      get_etcd_from_remote &quot;$target_dir&quot; &quot;$source_path_or_url&quot; &quot;$http_user&quot; &quot;$http_passwd&quot;
      ;;
    *)
      echo &quot;Invalid option: $option. Please choose &#39;local&#39; or &#39;remote&#39;.&quot;
      exit 1
      ;;
  esac
&#125;

list_etcd_members() &#123;
  local server_url=$1

  # todo --user --cert --key 
  curl -X POST &quot;$&#123;server_url&#125;/v3/cluster/member/list&quot; \
    -H &quot;Content-Type: application/json&quot; \
    -d &#39;&#123;&#125;&#39;
&#125;

add_etcd_member_by_curl() &#123;
  local server_url=$1
  local peer_url=$2

  # 构造请求体
  local data=$(cat &lt;&lt;EOF
&#123;
  &quot;peerURLs&quot;: [&quot;$peer_url&quot;]
&#125;
EOF
)

  # 发送请求
  curl -X POST &quot;$&#123;server_url&#125;/v3/cluster/member/add&quot; \
       -H &quot;Content-Type: application/json&quot; \
       -d &quot;$data&quot;
&#125;


# 主函数：安装etcd集群节点
install_etcd_cluster_node() &#123;
  local node_name=$1
  local node_ip=$2
  local cluster_ips=$3
    local new_opt=$4

  local data_dir=&quot;/opt/k8s/data&quot;
  local wal_dir=&quot;/opt/k8s/wal&quot;
  local bin_dir=&quot;/opt/k8s/bin&quot;
  local work_dir=&quot;/opt/k8s/work&quot;
  local ftpserver=&quot;http://119.91.145.27:12800&quot;
  local http_user=&quot;team&quot;
  local http_passwd=&quot;xdmybl&quot;
  local config_file=&quot;$&#123;work_dir&#125;/etcd.conf&quot;
  local service_file=&quot;/lib/systemd/system/etcd.service&quot;
  local etcd_executable=&quot;$&#123;bin_dir&#125;/etcd&quot;
    local etcd_src_path=&quot;/opt/etcd&quot;
    local cluster_gs=&quot;cluster_token1&quot;

    local client_url=&quot;http://$&#123;node_ip&#125;:2379&quot;
    local listen_peer_url=&quot;http://$&#123;node_ip&#125;:2380&quot;

  # 创建所需目录
  create_directories &quot;$data_dir&quot; &quot;$wal_dir&quot; &quot;$bin_dir&quot; &quot;$work_dir&quot;

  create_etcd_config &quot;$config_file&quot; &quot;$node_name&quot; &quot;$data_dir&quot; &quot;$wal_dir&quot; &quot;$client_url&quot; &quot;$&#123;listen_peer_url&#125;&quot; &quot;$&#123;cluster_gs&#125;&quot; &quot;$&#123;cluster_ips&#125;&quot; $&#123;new_opt&#125;
    
  create_etcd_service &quot;$service_file&quot; &quot;$config_file&quot; &quot;$etcd_executable&quot;	
  # 下载etcd二进制文件
    get_etcd &quot;local&quot; &quot;$bin_dir&quot; &quot;$etcd_src_path&quot;
  reload_and_start_etcd
  # 配置并启动etcd服务
&#125;

extract_hosts_to_cluster_info() &#123;
                local hosts_file=$1
                local cluster_info=$(awk &#39;/^\s*[^#]/ &amp;&amp; $2 ~ /.srhino.svc.local$/ &amp;&amp; $2 !~ /^s/ &amp;&amp; $2 !~ /^localhost/ &#123;sub(/\.srhino\.svc\.local$/, &quot;&quot;, $2); print $2&quot;=http://&quot;$1&quot;:2380&quot;&#125;&#39; $&#123;hosts_file&#125; | paste -sd,)
                echo $cluster_info
&#125;
</code></pre>
<h3 id="安装三节点（建立三节点），适用于创建集群时，直接声明集群三节点"><a href="#安装三节点（建立三节点），适用于创建集群时，直接声明集群三节点" class="headerlink" title="安装三节点（建立三节点），适用于创建集群时，直接声明集群三节点"></a>安装三节点（建立三节点），适用于创建集群时，直接声明集群三节点</h3><h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><pre><code class="mermaid">sequenceDiagram
    participant Manager as Manager
    participant Node1 as node1
    participant Node2 as node2
    participant Node3 as node3

    par 建立新集群
        Manager-&gt;&gt;Node1: new cluster: node1, node2, node3
        Manager-&gt;&gt;Node2: new cluster: node1, node2, node3
        Manager-&gt;&gt;Node3: new cluster: node1, node2, node3
    and 相应节点响应
        Node1--&gt;&gt;Manager: 响应
        Node2--&gt;&gt;Manager: 响应
        Node3--&gt;&gt;Manager: 响应
    end
    Note over Manager,Node3: etcd 初始集群建立完成

</code></pre>
<pre><code class="bash">#!/bin/bash

# 并发执行三节点安装
ssh -n root@192.168.122.26 &quot;cd /opt &amp;&amp; ./install_cluster.sh&quot; &amp;
ssh -n root@192.168.122.35 &quot;cd /opt &amp;&amp; ./install_cluster.sh&quot; &amp;
ssh -n root@192.168.122.238 &quot;cd /opt &amp;&amp; ./install_cluster.sh&quot; &amp;

wait
</code></pre>
<pre><code class="bash">#!/bin/bash

source ./install_cluster_lib.sh 
# first node param
#local_ip=&quot;ouryun.node2.com&quot;
local_ip=&quot;192.168.122.26&quot;
local_host=&quot;node1&quot;
# 三节点都需要是 new
new_opt=&quot;new&quot;
# 这里包含集群信息
cluster_info=&quot;node1=http://192.168.122.26:2380,node2=http://192.168.122.35:2380,node3=http://192.168.122.237:2380&quot;

# 使用示例
# install_etcd_cluster_node &quot;node1&quot; &quot;192.168.1.1&quot; &quot;node1=http://192.168.1.1:2380,node2=http://192.168.1.2:2380,node3=http://192.168.1.3:2380&quot;
install_etcd_cluster_node $local_host $local_ip &quot;$&#123;cluster_info&#125;&quot;  $&#123;new_opt&#125;
</code></pre>
<h3 id="安装三节点（先创建一个节点的集群，再加入-node2-，再加入-node3），适用于往已有集群加入新节点"><a href="#安装三节点（先创建一个节点的集群，再加入-node2-，再加入-node3），适用于往已有集群加入新节点" class="headerlink" title="安装三节点（先创建一个节点的集群，再加入 node2 ，再加入 node3），适用于往已有集群加入新节点"></a>安装三节点（先创建一个节点的集群，再加入 node2 ，再加入 node3），适用于往已有集群加入新节点</h3><h4 id="时序图-1"><a href="#时序图-1" class="headerlink" title="时序图"></a>时序图</h4><pre><code class="mermaid">sequenceDiagram
    participant manager as Manager
    participant Node1 as node1
    participant Node2 as node2
    participant Node3 as node3


    manager-&gt;&gt;Node1: 建立集群
    activate Node1
    Node1-&gt;&gt;Node1: new cluster node1
    Node1--&gt;&gt;manager: 
    deactivate Node1
    
    manager-&gt;&gt;Node2: 新增节点2
    activate Node2
    Note over Node1,Node2: 环境变量中 cluster: node1,node2
    Node2-&gt;&gt;Node1: member add node2
    Node1--&gt;&gt;Node2: 
    Node2-&gt;&gt;Node2: node2 start （existing cluster, cluster: node1,node2）
    Node2--&gt;&gt;manager: 
    deactivate Node2
    
    manager-&gt;&gt;Node3: 新增节点3
    activate Node3
    Note over Node1,Node3: 环境变量中 cluster: node1,node2,node3
    alt request endpoints
        Node3-&gt;&gt;Node1: member add node3
        Node1--&gt;&gt;Node3: 
    else
        Node3-&gt;&gt;Node2: member add node3
        Node2--&gt;&gt;Node3: 
    end
    Node3-&gt;&gt;Node3: node3 start（existing cluster, cluster: node1,node2,node3）
    Node3--&gt;&gt;manager: 响应
    deactivate Node3
</code></pre>
<pre><code class="bash"># install_etcd_first.sh
#!/bin/bash

source ./install_cluster_lib.sh 
# first node param
local_ip=&quot;192.168.122.26&quot;
local_host=&quot;node1&quot;
new_opt=&quot;new&quot;
# 这里包含集群信息
existing_node_info=&quot;&quot;

# 使用示例
# install_etcd_cluster_node &quot;node1&quot; &quot;192.168.1.1&quot; &quot;node1=http://192.168.1.1:2380,node2=http://192.168.1.2:2380,node3=http://192.168.1.3:2380&quot;

install_etcd_cluster_node $local_host $local_ip &quot;$&#123;local_host&#125;=http://$&#123;local_ip&#125;:2380&quot; $&#123;new_opt&#125;
</code></pre>
<pre><code class="bash"># install_etcd_other.sh

# other node param

source ./install_cluster_lib.sh 

local_ip=&quot;192.168.122.35&quot;
local_host=&quot;node2&quot;
new_opt=&quot;existing&quot;
existing_node_info=&quot;node1=http://192.168.122.26:2380&quot;

# 使用示例
# install_etcd_cluster_node &quot;node1&quot; &quot;192.168.1.1&quot; &quot;node1=http://192.168.1.1:2380,node2=http://192.168.1.2:2380,node3=http://192.168.1.3:2380&quot;
install_etcd_cluster_node $local_host $local_ip &quot;$&#123;existing_node_info&#125;,$&#123;local_host&#125;=http://$&#123;local_ip&#125;:2380&quot; $&#123;new_opt&#125;
</code></pre>
<h3 id="新增集群节点"><a href="#新增集群节点" class="headerlink" title="新增集群节点"></a>新增集群节点</h3><pre><code class="bash"># member_add_by_etcdctl.sh
# 新增集群
member_add_by_etcdctl() &#123;
  local new_member_name=$1
  local new_member_peer_url=$2
  local existing_member_client_urls=$3

  # 设置ETCDCTL_API版本，确保使用v3 API
  export ETCDCTL_API=3

  # 添加新成员到集群
  etcdctl --endpoints=&quot;$&#123;existing_member_client_urls&#125;&quot; \
    member add &quot;$&#123;new_member_name&#125;&quot; \
    --peer-urls=&quot;$&#123;new_member_peer_url&#125;&quot;

  # 检查命令执行的退出状态
  if [ $? -eq 0 ]; then
    echo &quot;Member $&#123;new_member_name&#125; successfully added to the cluster.&quot;
  else
    echo &quot;Failed to add member $&#123;new_member_name&#125; to the cluster.&quot;
    exit 1
  fi
&#125;

# member_id=&quot;node2&quot;
# member_url=&quot;http://192.168.122.35:2380&quot;
# access_endpoint_url=&quot;http://192.168.122.26:2379&quot;

# # 新增集群成员
# member_add &quot;node2&quot; &quot;http://192.168.122.35:2380&quot; &quot;http://192.168.122.26:2379&quot;
member_id=&quot;node3&quot;
member_url=&quot;http://192.168.122.237:2380&quot;
access_endpoint_url=&quot;http://192.168.122.26:2379&quot;

# 新增集群成员
member_add_by_etcdctl $&#123;member_id&#125; $&#123;member_url&#125; $&#123;access_endpoint_url&#125;
</code></pre>
<h2 id="卸载-etcd"><a href="#卸载-etcd" class="headerlink" title="卸载 etcd"></a>卸载 etcd</h2><pre><code class="bash"># uninstall_etcd.sh

#!/bin/bash

# 停止etcd服务
stop_etcd_service() &#123;
  echo &quot;Stopping etcd service...&quot;
  systemctl stop etcd
&#125;

# 禁用etcd服务
disable_etcd_service() &#123;
  echo &quot;Disabling etcd service...&quot;
  systemctl disable etcd
&#125;

# 删除etcd服务文件
remove_etcd_service_file() &#123;
  echo &quot;Removing etcd service file...&quot;
  rm -f /lib/systemd/system/etcd.service
&#125;

# 重新加载systemd守护进程
reload_systemd() &#123;
  echo &quot;Reloading systemd daemon...&quot;
  systemctl daemon-reload
&#125;

# 删除etcd二进制文件和数据目录
cleanup_etcd_files() &#123;
  local bin_dir=&quot;/opt/k8s/bin&quot;
  local data_dir=&quot;/opt/k8s/data&quot;
  local wal_dir=&quot;/opt/k8s/wal&quot;
  local work_dir=&quot;/opt/k8s/work&quot;

  echo &quot;Cleaning up etcd binary and data directories...&quot;
  rm -f &quot;$&#123;bin_dir&#125;/etcd&quot;
  rm -rf &quot;$data_dir&quot;
  rm -rf &quot;$wal_dir&quot;
  rm -rf &quot;$work_dir&quot;
&#125;

# 卸载etcd的主函数
uninstall_etcd() &#123;
  stop_etcd_service
  disable_etcd_service
  remove_etcd_service_file
  reload_systemd
  cleanup_etcd_files
  
  echo &quot;etcd has been successfully uninstalled.&quot;
&#125;

# 执行卸载
uninstall_etcd
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/etcd/" style="color: #00a596">etcd</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/cluster/" style="color: #03a9f4">cluster</a>
        </span>
        
    </div>
    <a href="/2024/03/27/mdstorage/domain/k8s/etcd%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    
    <a class="page-num" href="/page/12/">
        <i class="fa-solid fa-caret-left fa-fw"></i>
    </a>
    <a class="page-num" href="/">1</a>
    <span class="page-omit">...</span>
    
    <span class="current">13</span>
    
    <a class="page-num" href="/page/14">
        14
    </a>
    
    
    <a class="page-num" href="/page/15">
        15
    </a>
    
    
    <span class="page-omit">...</span>
    <a class="page-num" href="/page/28">28</a>
    
    
    <a class="page-num" href="/page/14/">
        <i class="fa-solid fa-caret-right fa-fw"></i>
    </a>
    
</div>

    </div>
    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name">xiaoy</div>
        <div class="description">
            <p>Description<br>…</p>

        </div>
        
        
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://argvchs.github.io">Argvchs</a>
            </div>
            
        </div>
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2024 - 2024 Xiaoy
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;xiaoy
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
</body>
</html>
