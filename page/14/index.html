
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Xiaoy</title>
    <meta name="author" content="xiaoy" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>XIAOY</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;XIAOY</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div
        id="home-background"
        ref="homeBackground"
        data-images="/images/background.jpg"
    ></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Xiaoy</h1>
                <h3>xiaoy blog</h3>
                <h5></h5>
            </div>
        </span>
    </div>
</div>
<div
    id="home-posts-wrap"
    ref="homePostsWrap"
    true
>
    <div id="home-posts">
        

<div class="post">
    <a href="/2024/03/27/mdstorage/domain/shell/case%E8%AF%AD%E6%B3%95/">
        <h2 class="post-title">case语法.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/domain/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                domain
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/27
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code class="bash">case 值 in
模式1)
    command1
    command2
    command3
    ;;
模式2）
    command1
    command2
    command3
    ;;
*)
    command1
    command2
    command3
    ;;
esac
</code></pre>
<pre><code class="bash">get_etcd() &#123;
  local option=$1
  local target_dir=$2
  local source_path_or_url=$3
  local http_user=$4 # 仅 remote 时需要
  local http_passwd=$5 # 仅 remote 时需要

  case &quot;$option&quot; in
    &quot;local&quot;)
      get_etcd_from_local &quot;$source_path_or_url&quot; &quot;$target_dir&quot;
      ;;
    &quot;remote&quot;)
      get_etcd_from_remote &quot;$target_dir&quot; &quot;$source_path_or_url&quot; &quot;$http_user&quot; &quot;$http_passwd&quot;
      ;;
    *)
      echo &quot;Invalid option: $option. Please choose &#39;local&#39; or &#39;remote&#39;.&quot;
      exit 1
      ;;
  esac
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/shell/" style="color: #03a9f4">shell</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/bash/" style="color: #ffa2c4">bash</a>
        </span>
        
    </div>
    <a href="/2024/03/27/mdstorage/domain/shell/case%E8%AF%AD%E6%B3%95/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/03/27/mdstorage/domain/ide/emacs/sudo-edit/">
        <h2 class="post-title">sudo-edit.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/domain/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                domain
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/27
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="sudo-edit-插件"><a href="#sudo-edit-插件" class="headerlink" title="sudo-edit 插件"></a>sudo-edit 插件</h2><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>以 sudo 打开本地文件</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>M-x package-install RET sudo-edit</code></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>打开文件 <code>M-x sudo-edit</code> 输入密码即可，如果不出现密码输入是正则匹配出问题，修改 init.el 配置，<code>(setq tramp-password-prompt-regexp &quot;^.*\\(\\(?:adgangskode\\|contrase\\(?:\\(?:ny\\|ñ\\)a\\)\\|decryption key\\|encryption key\\|geslo\\|h\\(?:\\(?:asł\\|esl\\)o\\)\\|iphasiwedi\\|jelszó\\|l\\(?:ozinka\\|ösenord\\)\\|m\\(?:ot de passe\\|ật khẩu\\)\\|p\\(?:a\\(?:rola\\|s\\(?:ahitza\\|s\\(?: phrase\\|code\\|ord\\|phrase\\|wor[dt]\\)\\|vorto\\)\\)\\|in\\)\\|s\\(?:alasana\\|enha\\|laptažodis\\)\\|wachtwoord\\|лозинка\\|пароль\\|ססמה\\|كلمة السر\\|गुप्तशब्द\\|शब्दकूट\\|গুপ্তশব্দ\\|পাসওয়ার্ড\\|ਪਾਸਵਰਡ\\|પાસવર્ડ\\|ପ୍ରବେଶ ସଙ୍କେତ\\|கடவுச்சொல்\\|సంకేతపదము\\|ಗುಪ್ತಪದ\\|അടയാളവാക്ക്\\|රහස්පදය\\|ពាក្យសម្ងាត់\\|パスワード\\|密[码碼]\\|암호\\)\\).*[:：]\0? *&quot;)</code></li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/plugin/" style="color: #00bcd4">plugin</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/emacs/" style="color: #ffa2c4">emacs</a>
        </span>
        
    </div>
    <a href="/2024/03/27/mdstorage/domain/ide/emacs/sudo-edit/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/03/27/mdstorage/domain/ide/emacs/%E6%89%93%E5%BC%80%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6/">
        <h2 class="post-title">打开远程文件.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/domain/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                domain
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/27
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><code>https://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html</code></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/emacs/" style="color: #03a9f4">emacs</a>
        </span>
        
    </div>
    <a href="/2024/03/27/mdstorage/domain/ide/emacs/%E6%89%93%E5%BC%80%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/03/22/mdstorage/domain/k8s/client-go%E8%BF%9E%E6%8E%A5apiserver/">
        <h2 class="post-title">client-go连接apiserver.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/domain/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                domain
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/22
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="token-连接"><a href="#token-连接" class="headerlink" title="token 连接"></a>token 连接</h2><h2 id="apiserver-静态-token-进行连接"><a href="#apiserver-静态-token-进行连接" class="headerlink" title="apiserver 静态 token 进行连接"></a>apiserver 静态 token 进行连接</h2><pre><code class="golang">import (
    &quot;context&quot;
    &quot;fmt&quot;
    metav1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;
    &quot;k8s.io/client-go/kubernetes&quot;
    &quot;k8s.io/client-go/rest&quot;
)

func Connect() &#123;
    config := &amp;rest.Config&#123;
        // 指定API服务器的地址
        Host: &quot;https://192.168.122.127:6443&quot;,
        // 指定用于身份验证的Bearer Token
        BearerToken: &quot;a1232123131231231231231231233112&quot;,   // cluster-admin token
        // 忽略SSL证书验证，仅在测试环境下使用
        TLSClientConfig: rest.TLSClientConfig&#123;Insecure: true&#125;,
    &#125;

    // 使用配置创建Kubernetes客户端
    clientset, err := kubernetes.NewForConfig(config)
    if err != nil &#123;
        panic(err)
    &#125;

    // 使用clientset进行操作，例如列出所有命名空间
    namespaces, err := clientset.CoreV1().Namespaces().List(context.TODO(), metav1.ListOptions&#123;&#125;)
    if err != nil &#123;
        panic(err)
    &#125;
    for _, ns := range namespaces.Items &#123;
        fmt.Println(ns.Name)
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/apiserver/" style="color: #00bcd4">apiserver</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/client-go/" style="color: #ff7d73">client-go</a>
        </span>
        
    </div>
    <a href="/2024/03/22/mdstorage/domain/k8s/client-go%E8%BF%9E%E6%8E%A5apiserver/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/03/22/mdstorage/domain/linux/%E5%BC%BA%E5%88%B6%E7%94%A8%E6%88%B7%E7%99%BB%E5%87%BA/">
        <h2 class="post-title">强制用户登出.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/domain/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                domain
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/22
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>rdp 时、用户不登出、rdp 远程无法建立</p>
<h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><pre><code class="bash">loginctl list-sessions

sudo loginctl terminate-session $SESSION_ID
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/linux/" style="color: #00bcd4">linux</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/desktop/" style="color: #03a9f4">desktop</a>
        </span>
        
    </div>
    <a href="/2024/03/22/mdstorage/domain/linux/%E5%BC%BA%E5%88%B6%E7%94%A8%E6%88%B7%E7%99%BB%E5%87%BA/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/03/20/mdstorage/project/cToRust/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/">
        <h2 class="post-title">软件说明文档.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/project/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                project
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/20
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="软件说明文档"><a href="#软件说明文档" class="headerlink" title="软件说明文档"></a>软件说明文档</h1><h2 id="软件名"><a href="#软件名" class="headerlink" title="软件名"></a>软件名</h2><p><code>cust</code> </p>
<p>C程序转换器</p>
<h2 id="功能摘要"><a href="#功能摘要" class="headerlink" title="功能摘要"></a>功能摘要</h2><ol>
<li>提供命令行工具将目标 C&#x2F;C++ 语言源码，转换为相应 Rust 语言代码</li>
</ol>
<h2 id="软件分类"><a href="#软件分类" class="headerlink" title="软件分类"></a>软件分类</h2><p>linux CLI 工具</p>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>C: 指 C&#x2F;C++ 语言，后面简化称为 C</p>
<p>src code: 源语言，指待转换的语言，本次的指 C</p>
<p>AST: 抽象语法树</p>
<p>IR: Intermediate Representation 中间表示，与语言无关，硬件无关，容易进行优化，多级表示，丰简由人，这适合在 C to Rust 应用中使用。</p>
<h2 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h2><p>对于如军工、医疗、航天、核能领域，需要一种运行效率、内存安全、稳定性方面有严格要求的语言进行应用程序实现，当已有的 C&#x2F;C++ 程序满足不了这些要求时，就需要将现有的 C&#x2F;C++ 程序、工具库转换为可用的 Rust 程序。<code>cust</code>即可适用于此场景。</p>
<h2 id="开源许可证类型"><a href="#开源许可证类型" class="headerlink" title="开源许可证类型"></a>开源许可证类型</h2><p>GPL v3</p>
<h2 id="作品概述"><a href="#作品概述" class="headerlink" title="作品概述"></a>作品概述</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul>
<li>目标：C&#x2F;C++ 程序转换为 Rust 程序</li>
</ul>
<h3 id="作品特点"><a href="#作品特点" class="headerlink" title="作品特点"></a>作品特点</h3><ul>
<li><p>结合编译原理和现有的 AI 大模型各自优势，将 C&#x2F;C++ 程序转换为可用的 Rust 程序</p>
</li>
<li><p>利用编译原理，src code （本次工具中为 C）转换 AST ， AST 再成与 IR （中间语言的形式），再将 IR 语言转换为 Rust 语言，这样做的好处是可以利用这一思路最大程度复用代码，如 src code -&gt;  IR 这部分代码可复用于转换为其他目标语言，而 IR  -&gt; Rust code 部分代码可复用到不同的 src code -&gt; Rust code。</p>
<p>同时，C to Rust 中采用 IR 的方式有诸多优势：</p>
<ul>
<li><strong>硬件无关</strong>：IR 设计成独立于任何特定的硬件或指令集架构（ISA），适用于多种硬件平台，也就是说转义出来的目标语言天然跨平台。</li>
<li><strong>容易进行优化</strong>：IR 通常设计得使得对代码进行分析和优化变得更加容易，开发路径也相对简单，易进行迭代开发。</li>
<li><strong>多级表示</strong>：可使用多级别的 IR，每个级别提供不同的抽象程度。</li>
</ul>
</li>
</ul>
<h3 id="运行环境和运行步骤"><a href="#运行环境和运行步骤" class="headerlink" title="运行环境和运行步骤"></a>运行环境和运行步骤</h3><h4 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h4><p>clang llvm 环境，支持 Linux ，不支持 windows</p>
<p>rust cargo 环境</p>
<h4 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h4><p>clang llvm 环境，支持 Linux ，不支持 windows</p>
<p>使用 ai 优化需要能连上通义的接口（外网）</p>
<h3 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h3><ul>
<li><p>完全使用语义解析进行 C To Rust 转换</p>
</li>
<li><p>采用语义解析 C To Rust、将上下文和结果输入到 AI 大模型进行语义检查和最后的优化。 </p>
</li>
<li><p>C 语言代码排错</p>
<ul>
<li><strong>语法错误</strong>：这是编程中最常见的错误类型，如缺少分号、括号不匹配、错误的关键字使用等。如果代码中存在语法错误，编译器将无法正确理解代码，从而无法继续编译过程。</li>
<li><strong>类型错误</strong>：类型错误发生在对变量或表达式进行了不允许或预期之外的操作时，例如将整数类型赋值给字符类型变量，或对字符串执行数学运算。</li>
<li><strong>声明和定义错误</strong>：包括变量或函数未声明、重复声明、缺少必要的头文件导入等。</li>
<li><strong>作用域问题</strong>：尝试访问仅在另一个作用域中定义的变量或函数时，会发生作用域错误。</li>
<li><strong>链接错误</strong>：如果代码中存在对未定义或未实现的外部函数或变量的引用，进行完整编译过程时会被识别为链接错误。</li>
<li><strong>警告</strong>：警告不会阻止代码的编译，但它们指出了可能导致运行时错误的代码实践，如可能的变量未初始化、未使用的变量、潜在的类型转换问题等</li>
<li><strong>内存访问错误</strong>：会静态检测到潜在的内存访问问题，如数组越界访问、解引用空指针等，尽管许多此类错误需要运行时检查来发现。</li>
<li><strong>优化建议</strong>：提出代码优化的建议，以改善性能或减少内存消耗，虽然这通常不会影响编译过程的成功与否。</li>
<li><strong>标准遵从性</strong>：会检查代码是否遵循了选定的 C 语言标准（如 C99、C11 等），包括对废弃特性的使用警告等。</li>
</ul>
</li>
<li><p>支持文件输入和字符串输入代码</p>
<ul>
<li><p>–file file_path 输入文件输入代码</p>
</li>
<li><p>–code “” 字符串输入代码</p>
<pre><code class="bash">./cust -c &quot;$(cat &lt;&lt;EOF
#include &lt;iostream&gt;
#include &lt;cstdarg&gt;

void print_values(int n, ...) &#123;
    va_list vl;
    va_start(vl, n);
    for (int i = 0; i &lt; n; i++) &#123;
        int value = va_arg(vl, int);
        std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; &quot;\\n&quot;;
    &#125;
    va_end(vl);
&#125;
int main() &#123;
    print_values(3, 10, 20, 30);
    return 0;
&#125;
EOF
)&quot;
</code></pre>
</li>
</ul>
</li>
<li><p>支持输出到 stdout 和文件</p>
</li>
<li><p>-o stdout | dst_file_path 输出定向到标准输出或目标文件中</p>
</li>
</ul>
<h3 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h3><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><pre><code class="mermaid">graph TB;
    符号表
    src[字符流]:::no_border
    an1[词法分析器]
    an2[语法分析]
    an3[语义分析]
    code_gen1[中间代码生成器]
    code_opt[语言无关代码优化器]
    code_gen2[代码生成器]
    code_gen3[机器相关代码优化器]
    dst[目标语言]:::no_border
    src --&gt; an1 --&gt;|符号流| an2 --&gt;|语法树| an3 --&gt;|语法树| code_gen1 --&gt;|中间表示形式| code_opt --&gt;|中间表示形式| code_gen2 --&gt;|目标机器语言| code_gen3 --&gt; dst
    
    
    classDef no_border fill:transparent, stroke:transparent ;
</code></pre>
<h5 id="解析对象和流程"><a href="#解析对象和流程" class="headerlink" title="解析对象和流程"></a>解析对象和流程</h5><pre><code class="mermaid">---
title: 解析对象和流程
---

graph TB;
    src[用户输入]:::no_border
    
    subgraph Cust[cust 程序]
        an1[获取用户输入 file is-ai-opt output]
        an2[检查C代码正确性]
        an3[语法、语义、词法分析]
        code_gen1[中间代码生成器]
        code_opt[中间代码优化器]
        code_gen2[Rust 代码生成器]
        code_gen3[Rust 代码优化器]
        code_opt2[ai 优化]
        dst[Rust 代码输出]:::no_border
    end
    src --&gt; an1 --&gt;|获取待解析的C代码| an2 --&gt;|待解析的C代码| an3 --&gt;|语法树 AST| code_gen1 --&gt;|中间表示形式 IR| code_opt --&gt;|中间表示形式 IR| code_gen2 --&gt;|Rust 语言| code_gen3 --&gt; dst
    an1 &amp; an2 &amp; an3 &amp; code_gen1 &amp; code_opt &amp; code_gen2 &amp; code_gen3 ---&gt; code_opt2 ---&gt; dst
    classDef no_border fill:transparent, stroke:transparent ;
</code></pre>
<h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><pre><code class="mermaid">sequenceDiagram
    participant UserInput as 用户输入
    participant CustProgram as cust 程序
    participant CCheck as 检查C代码正确性
    participant Analysis as 语法、语义、词法分析
    participant IRGen as 中间代码生成器
    participant IROpt as 中间代码优化器
    participant RustCodeGen as Rust 代码生成器
    participant RustOpt as Rust 代码优化器
    participant AIOpt as ai 优化
    participant RustOutput as Rust 代码输出

    UserInput-&gt;&gt;CustProgram: 获取用户输入
    CustProgram-&gt;&gt;CCheck: 获取待解析的C代码
    CCheck-&gt;&gt;Analysis: 待解析的C代码
    Analysis-&gt;&gt;IRGen: 语法树 AST
    IRGen-&gt;&gt;IROpt: 中间表示形式 IR
    IROpt-&gt;&gt;RustCodeGen: 中间表示形式 IR
    RustCodeGen-&gt;&gt;RustOpt: Rust 语言
    RustOpt-&gt;&gt;AIOpt: Rust 代码
    AIOpt-&gt;&gt;RustOutput: 优化后的Rust代码
</code></pre>
<h4 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h4><ul>
<li>字符输入</li>
</ul>
<p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/image-20240326225550130.png" alt="image-20240326225550130"></p>
<ul>
<li>代码文件输入</li>
</ul>
<p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/image-20240326225753595.png" alt="image-20240326225753595"></p>
<ul>
<li>输出<ul>
<li>代码检查</li>
<li>转换代码</li>
<li>AI 优化代码</li>
</ul>
</li>
</ul>
<p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/image-20240326225616707.png" alt="image-20240326225616707"></p>
<p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/image-20240326225824678.png" alt="image-20240326225824678"></p>
<h4 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h4><p><code>clang libclang llvm</code></p>
<p>Rust crate <code> clang clang-sys syn</code> </p>
<p>llvm IR</p>
<h4 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h4><ul>
<li>代码输入</li>
<li>clang-sys 词法、语法、语义解析</li>
<li>clang AST 建立</li>
<li>IR 结构生成器</li>
<li>Rust 翻译规则生成</li>
<li>Rust 代码生成</li>
<li>Rust 代码优化</li>
<li>AI 检查、优化</li>
</ul>
<h4 id="部署要求"><a href="#部署要求" class="headerlink" title="部署要求"></a>部署要求</h4><p>llvm clang 库安装</p>
<pre><code class="bash"># ubuntu22.04
sudo apt-get update
sudo apt-get install llvm clang
</code></pre>
<p>Rust cargo 基础开发环境、能访问外网拉取 crate。</p>
<p>如果使用 ai 优化功能，需要能连接通义千问。本项目代码中内置 api key</p>
<h2 id="问题、解决思路"><a href="#问题、解决思路" class="headerlink" title="问题、解决思路"></a>问题、解决思路</h2><ul>
<li>入参 int n … 语法翻译问题<ul>
<li>通过 <code>AST</code> 中解析出参数中是否有此语法，如果有，则在 IR 中做出记录，在 IR to Rust 中将其转换为 <code>Vec&lt;T&gt;</code> , 并在之后的 Function body 逻辑处理中，将 C 中对 n 的处理，转换为 Rust 对 Vec<T> n  的处理。在上下文中记录此函数声明和此参数上下文。</li>
</ul>
</li>
<li>获取 for 循环中的 condition 的 operator 思路<ul>
<li><strong>计算左操作数的偏移量（<code>left_offset</code>）</strong>：<ul>
<li>首先，获取左操作数实体（<code>entity.get_child(0)</code>），假设为二元操作的第一个子实体。</li>
<li>使用 <code>.map</code> 遍历左操作数的子实体（这里实际上只有一个），获取每个子实体的源代码范围（<code>get_range()</code>），然后对这个范围内的标记（<code>tokenize()</code>）进行计数（<code>.len()</code>），以确定左操作数占用了多少个标记。</li>
<li>通过 <code>.fold</code> 将这些标记数量累加起来，得到 <code>left_offset</code>，即左操作数结束的位置（以标记计数为单位）。</li>
</ul>
</li>
<li><strong>获取整个二元操作的标记</strong>：<ul>
<li>通过 <code>entity.get_range().and_then(|r| Some(r.tokenize()))</code> 获取表示整个二元操作的 <code>Entity</code> 的源代码范围，并将这个范围内的内容分割成标记。</li>
</ul>
</li>
<li><strong>提取操作符</strong>：<ul>
<li>使用左操作数的偏移量 <code>left_offset</code> 作为索引，从整个二元操作的标记列表中提取操作符。因为左操作数后面紧跟的标记应该就是操作符本身。</li>
</ul>
</li>
<li><strong>返回操作符的拼写</strong>：<ul>
<li>通过 <code>get_spelling()</code> 方法获取操作符标记的文本表示，然后将其作为 <code>Some</code> 值返回。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h3><ol>
<li><strong>创新性结合</strong>: 利用编译原理和现有的AI技术的优势，提供一个高效且可靠的C&#x2F;C++到Rust的代码转换工具。</li>
<li><strong>高度复用设计</strong>: 通过先将C代码转换为中间表示（IR），然后再将IR转换为Rust代码的策略，增强了代码的可复用性，同时也支持将IR转换为其他目标语言。</li>
<li><strong>硬件和平台无关</strong>: IR设计独立于任何特定的硬件或指令集，使得转换出来的Rust代码能够跨平台使用。</li>
<li><strong>易于优化</strong>: IR层面的设计便于代码分析和优化，有助于生成性能更高、内存使用更优的Rust代码。同时后期迭代可以有多级的IR，做到职责单一、程序便于维护迭代。</li>
<li><strong>支持广泛的错误排查和优化</strong>: 包括语法错误、类型错误、声明和定义错误、作用域问题、链接错误、内存访问错误等，以及提供代码优化建议。</li>
<li><strong>灵活的输入输出</strong>: 支持文件输入和字符串输入，以及输出到标准输出或文件，提高了工具的使用灵活性。</li>
<li><strong>开源许可</strong>: 采用GPL v3开源许可证，促进了社区的贡献和软件的持续改进。</li>
</ol>
<h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p><strong>我的演讲结束，谢谢大家，具体的实现可以看源码 和 演示视频</strong></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" style="color: #ffa2c4">软件说明</a>
        </span>
        
    </div>
    <a href="/2024/03/20/mdstorage/project/cToRust/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/03/19/mdstorage/domain/k8s/etcd%E5%92%8Capiserver%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/">
        <h2 class="post-title">etcd和apiserver生命周期管理.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/domain/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                domain
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/19
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="etcd-安装脚本"><a href="#etcd-安装脚本" class="headerlink" title="etcd 安装脚本"></a>etcd 安装脚本</h2><pre><code class="bash">set -ex


ftpserver=http://119.91.145.27:12800
mkdir -p /opt/k8s/wal /opt/k8s/data /opt/k8s/bin /opt/k8s/work

cat &lt;&lt; EOF &gt; /opt/k8s/work/etcd.conf
ETCD_OPTS=&quot;--name node1 \\
--max-request-bytes 10485760 \\
--data-dir /opt/k8s/data \\
--wal-dir /opt/k8s/wal \\
--advertise-client-urls http://127.0.0.1:2379 \\
--listen-client-urls http://127.0.0.1:2379 \\
--listen-peer-urls http://127.0.0.1:2380&quot;
EOF

cat &lt;&lt; EOF &gt; /lib/systemd/system/etcd.service
[Unit]
Description=Etcd For Kubernetes
Wants=network-online.target
After=network.target network-online.target

[Service]
EnvironmentFile=/opt/k8s/work/etcd.conf
ExecStart=/opt/k8s/bin/etcd $ETCD_OPTS
Restart=always

[Install]
WantedBy=multi-user.target
EOF

wget -P /opt/k8s/bin/ --http-user=team  --http-passwd=xdmybl $&#123;ftpserver&#125;/repo/kubernetes/etcd
chmod +x /opt/k8s/bin/etcd
systemctl daemon-reload
systemctl start etcd
</code></pre>
<h2 id="apiserver-安装脚本"><a href="#apiserver-安装脚本" class="headerlink" title="apiserver 安装脚本"></a>apiserver 安装脚本</h2><pre><code class="bash">#!/bin/bash

# 安装 apiserver 的脚本(包括 etcd 的安装)
# 单台机器架构 ( 单节点 etcd 单台 apiserver )

# 判断是否存在 etcd, 没有则安装
unit_name=etcd
if  systemctl list-unit-files | grep -q &quot;^$unit_name&quot; ; then
  echo &quot;$unit_name exists&quot;
else
  echo &quot;$unit_name does not exist&quot;
  ./install_etcd.sh
fi

# 假设 etcd 是监听 127.0.0.1:2379 2380

# 需要填apiserver 的监听地址
LOCALIP=127.0.0.1


#------------------------------------------------------------
# wget
ftp_server=http://119.91.145.27:12800

mkdir -p /opt/k8s &amp;&amp; cd /opt/k8s
wget --http-user=team  --http-passwd=xdmybl $&#123;ftp_server&#125;/kubernetes/kube-apiserver
wget --http-user=team  --http-passwd=xdmybl $&#123;ftp_server&#125;/kubernetes/kubectl
chmod +x kubectl &amp;&amp; chmod +x kube-apiserver
# 链接
ln -s $&#123;PWD&#125;/kubectl /usr/local/bin/
# 需要空格
cat &gt;&gt; /etc/profile &lt;&lt; EOF

alias k=&quot;kubectl&quot;

EOF
#------------------------------------------------------------

# 生成 证书
#------------------------------------------------------------
# 获取 cfssl 在 ./bin目录下
ftp_server=http://119.91.145.27:12800

mkdir -p /opt/k8s/work &amp;&amp; cd /opt/k8s
wget --http-user=team  --http-passwd=xdmybl  $&#123;ftp_server&#125;/kubernetes/cfssl/cfssl_linux-amd64
wget --http-user=team  --http-passwd=xdmybl  $&#123;ftp_server&#125;/kubernetes/cfssl/cfssljson_linux-amd64
mv cfssl_linux-amd64 cfssl &amp;&amp; chmod +x cfssl
mv cfssljson_linux-amd64 cfssljson &amp;&amp; chmod +x cfssljson
ln -s $&#123;PWD&#125;/cfssl /usr/local/bin
ln -s $&#123;PWD&#125;/cfssljson /usr/local/bin

# 创建 logs 目录
mkdir -p /opt/k8s/logs

cd work
# 需要
# ca-csr.json
# ca-config.json
# server-csr.json
# admin-csr.json 用于生成 kubectl admin 用户 kubeconfig

# 生成 ca-csr.json
cat &lt;&lt; EOF &gt;&gt; ca-csr.json
&#123;
  &quot;CN&quot;: &quot;kubernetes&quot;,
  &quot;hosts&quot;: [
    &quot;$LOCALIP&quot;,
    &quot;kubernetes&quot;,
    &quot;kubernetes.default&quot;,
    &quot;kubernetes.default.svc&quot;,
    &quot;kubernetes.default.svc.cluster&quot;,
    &quot;kubernetes.default.svc.cluster.local.&quot;
  ],
  &quot;key&quot;: &#123;
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  &#125;,
  &quot;names&quot;: [
    &#123;
      &quot;C&quot;: &quot;CN&quot;,
      &quot;ST&quot;: &quot;Shanghai&quot;,
      &quot;L&quot;: &quot;Shanghai&quot;,
      &quot;O&quot;: &quot;k8s&quot;,
      &quot;OU&quot;: &quot;System&quot;
    &#125;
  ]
&#125;
EOF

# ca-config.json
cat &lt;&lt; EOF &gt;&gt; ca-config.json
&#123;
  &quot;signing&quot;: &#123;
    &quot;default&quot;: &#123;
      &quot;expiry&quot;: &quot;87600h&quot;
    &#125;,
    &quot;profiles&quot;: &#123;
      &quot;kubernetes&quot;: &#123;
         &quot;expiry&quot;: &quot;87600h&quot;,
         &quot;usages&quot;: [
            &quot;signing&quot;,
            &quot;key encipherment&quot;,
            &quot;server auth&quot;,
            &quot;client auth&quot;
        ]
      &#125;
    &#125;
  &#125;
&#125;
EOF

cat &lt;&lt; EOF &gt; server-csr.json
&#123;
  &quot;CN&quot;: &quot;kubernetes&quot;,
  &quot;hosts&quot;: [
    &quot;$LOCALIP&quot;,
    &quot;kubernetes&quot;,
    &quot;kubernetes.default&quot;,
    &quot;kubernetes.default.svc&quot;,
    &quot;kubernetes.default.svc.cluster&quot;,
    &quot;kubernetes.default.svc.cluster.local.&quot;
  ],
  &quot;key&quot;: &#123;
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  &#125;,
  &quot;names&quot;: [
    &#123;
      &quot;C&quot;: &quot;CN&quot;,
      &quot;ST&quot;: &quot;Shanghai&quot;,
      &quot;L&quot;: &quot;Shanghai&quot;,
      &quot;O&quot;: &quot;k8s&quot;,
      &quot;OU&quot;: &quot;System&quot;
    &#125;
  ]
&#125;
EOF

cat &lt;&lt; EOF &gt; admin-csr.json
&#123;
  &quot;CN&quot;: &quot;admin&quot;,
  &quot;hosts&quot;: [
    &quot;$LOCALIP&quot;,
    &quot;kubernetes&quot;,
    &quot;kubernetes.default&quot;,
    &quot;kubernetes.default.svc&quot;,
    &quot;kubernetes.default.svc.cluster&quot;,
    &quot;kubernetes.default.svc.cluster.local.&quot;
  ],
  &quot;key&quot;: &#123;
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  &#125;,
  &quot;names&quot;: [
    &#123;
      &quot;C&quot;: &quot;CN&quot;,
      &quot;O&quot;: &quot;system:masters&quot;,
      &quot;OU&quot;: &quot;System&quot;,
      &quot;L&quot;: &quot;Shanghai&quot;,
      &quot;ST&quot;: &quot;Shanghai&quot;
    &#125;
  ]
&#125;
EOF

# 签发 ca
cfssl gencert -initca ca-csr.json | cfssljson -bare ca -
# 签发 apiserver 证书
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes server-csr.json | cfssljson -bare server
# 签发 admin 用户证书，绑定用户角色，供 kubectl KUBECONFIG 使用
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin

# token
cat &gt; token.csv &lt;&lt; EOF
c47ffb939f5ca36231d9e3121a252940,jane,1
a1232123131231231231231231233112,cluster-admin,2,system:masters
b4564546555565444564564544545645,admin,3,system:masters
EOF

# apiserver bootstrap
cat &lt;&lt; EOF &gt; kube-apiserver.conf
KUBE_APISERVER_OPTS=&quot;--logtostderr=false \\
--v=5 \\
--etcd-servers=http://127.0.0.1:2379 \\
--bind-address=$LOCALIP \\
--secure-port=6443 \\
--advertise-address=$LOCALIP \\
--allow-privileged=true \\
--enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,ResourceQuota,NodeRestriction \\
--authorization-mode=RBAC,Node \\
--enable-bootstrap-token-auth=true \\
--token-auth-file=/opt/k8s/work/token.csv \\
--service-node-port-range=30000-32767 \\
--kubelet-client-certificate=/opt/k8s/work/server.pem \\
--kubelet-client-key=/opt/k8s/work/server-key.pem \\
--tls-cert-file=/opt/k8s/work/server.pem  \\
--tls-private-key-file=/opt/k8s/work/server-key.pem \\
--client-ca-file=/opt/k8s/work/ca.pem \\
--service-account-key-file=/opt/k8s/work/ca-key.pem \\
--service-account-issuer=api \\
--service-account-signing-key-file=/opt/k8s/work/server-key.pem \\
--requestheader-client-ca-file=/opt/k8s/work/ca.pem \\
--proxy-client-cert-file=/opt/k8s/work/server.pem \\
--proxy-client-key-file=/opt/k8s/work/server-key.pem \\
--requestheader-allowed-names=kubernetes \\
--requestheader-extra-headers-prefix=X-Remote-Extra- \\
--requestheader-group-headers=X-Remote-Group \\
--requestheader-username-headers=X-Remote-User \\
--enable-aggregator-routing=true \\
--audit-log-maxage=30 \\
--audit-log-maxbackup=3 \\
--audit-log-maxsize=100 \\
--audit-log-path=/opt/k8s/logs/k8s-audit.log&quot;
EOF

#------------------------------------------------------------

# 生成 service
#------------------------------------------------------------
cat &lt;&lt; EOF &gt; /lib/systemd/system/kube-apiserver.service
[Unit]
Description=Kubernetes API Server
Documentation=https://github.com/kubernetes/kubernetes

[Service]
EnvironmentFile=/opt/k8s/work/kube-apiserver.conf
ExecStart=/opt/k8s/kube-apiserver \$KUBE_APISERVER_OPTS
Restart=on-failure

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl start kube-apiserver.service
#------------------------------------------------------------

# 生成 kubeconfig
#------------------------------------------------------------
mkdir -p /root/.kube/ &amp;&amp; cd /root/.kube
# 生成 kubectl 的 kubeconfig


kubectl config set-cluster kubernetes \
    --certificate-authority=/opt/k8s/work/ca.pem \
    --embed-certs=true \
    --server=https://$&#123;LOCALIP&#125;:6443 \
    --kubeconfig=config
    
kubectl config set-credentials cluster-admin \
    --client-certificate=/opt/k8s/work/admin.pem \
    --client-key=/opt/k8s/work/admin-key.pem \
    --embed-certs=true \
    --kubeconfig=config

kubectl config set-context default \
    --cluster=kubernetes \
    --user=cluster-admin \
    --kubeconfig=config

kubectl config use-context default --kubeconfig=config
kubectl get ns
#------------------------------------------------------------
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/apiserver/" style="color: #00a596">apiserver</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/etcd/" style="color: #03a9f4">etcd</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/kubernetes/" style="color: #ff7d73">kubernetes</a>
        </span>
        
    </div>
    <a href="/2024/03/19/mdstorage/domain/k8s/etcd%E5%92%8Capiserver%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/03/18/mdstorage/project/sr/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0%E5%90%8E%E7%AE%A1%E7%90%86%E9%9D%A2HA%E7%9B%B8%E5%85%B3/">
        <h2 class="post-title">通信链路改造后管理面HA相关.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/18
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h2><h3 id="引擎集群内信息同步"><a href="#引擎集群内信息同步" class="headerlink" title="引擎集群内信息同步"></a>引擎集群内信息同步</h3><h4 id="Host-机制"><a href="#Host-机制" class="headerlink" title="Host 机制"></a>Host 机制</h4><p>使用 <code>/etc/hosts</code> 对集群 host 进行维护</p>
<p>（安装时由引擎安装所填充）</p>
<pre><code>127.0.0.1 localhost

192.168.0.1 ouryun_m_node_1 ouryun_m 
192.168.0.2 ouryun_m_node_2 ouryun_m 
192.168.0.3 ouryun_m_node_3 ouryun_m 
</code></pre>
<p>kubernetes 的客户端会依据 ouryun_m 自动找到 Apiserver 服务端</p>
<h4 id="Etcd-集群机制"><a href="#Etcd-集群机制" class="headerlink" title="Etcd 集群机制"></a>Etcd 集群机制</h4><ul>
<li>etcd 通过 Hostname 进行集群组建</li>
<li>组建好的 etcd 集群会内部通信，保证集群内部数据一致性</li>
</ul>
<h4 id="Apiserver-机制"><a href="#Apiserver-机制" class="headerlink" title="Apiserver 机制"></a>Apiserver 机制</h4><ul>
<li>Apiserver 连接本地的 etcd，利用 etcd 的数据一致性保证 Apiserver 之间的数据一致</li>
<li>向引擎所有节点的组件提供服务，并提供认证鉴权</li>
<li>Apiserver 签发证书时不需要关注自己的 ip ，而是为多个 hostname 申请即可，提高了灵活性和可维护性（为后续引擎修改 ip 做铺垫）</li>
</ul>
<h4 id="引擎集群内部组件通过-Apiserver-进行组件间信息同步（operator-开发模型）"><a href="#引擎集群内部组件通过-Apiserver-进行组件间信息同步（operator-开发模型）" class="headerlink" title="引擎集群内部组件通过 Apiserver 进行组件间信息同步（operator 开发模型）"></a>引擎集群内部组件通过 Apiserver 进行组件间信息同步（operator 开发模型）</h4><p>Apiserver 的客户端 client-go 已提供通过 hostname 进行集群的服务发现机制，确保了客户端总是可以找到提供特定服务的 Apiserver。</p>
<pre><code class="mermaid">---
title: 通信链路改造后管理面HA相关
---
graph TB
    subgraph Sc[总控]
        sc_core[sc core]
        sc[sc]
    end

    subgraph Se
        subgraph M_Group[管理面集群]
            subgraph M_Node1[管理节点]
                webserver1[webserver]
                apiserver1[Apiserver]
                etcd1[Etcd]
                webserver1 --&gt;|127.0.0.1| apiserver1 --&gt;|127.0.0.1| etcd1
            end
            subgraph M_Node2[管理节点]
                webserver2[webserver]
                apiserver2[Apiserver]
                etcd2[Etcd]
                webserver2 --&gt;|127.0.0.1| apiserver2 --&gt;|127.0.0.1| etcd2
            end
            subgraph M_Node3[管理节点]
                webserver3[webserver]
                apiserver3[Apiserver]
                etcd3[Etcd]
                webserver3 --&gt;|127.0.0.1| apiserver3 --&gt;|127.0.0.1| etcd3
            end
            
            etcd1 &amp; etcd2 &lt;--&gt; etcd3
            etcd2 &lt;---&gt; etcd1
        end
        subgraph S_Group[调度节点集群]
            webserver4[webserver]
            webserver5[webserver]
        end
        subgraph W_Group[工作节点集群]
            webserver6[webserver]
            webserver7[webserver]
            webserver8[webserver]
        end
        webserver4 &amp; webserver5 &amp; webserver6 &amp; webserver7 &amp; webserver8 ---&gt;|host: ouryun_m| apiserver1
%%		webserver4 --&gt; webserver1
        
    end
    
    sc &lt;--&gt;sc_core
    webserver1 &amp; webserver2 &amp; webserver3 &amp; webserver4 &amp; webserver5 &amp; webserver6 &amp; webserver7 &amp; webserver8 ====&gt;|channel| sc_core
    
    style Sc fill:#87CEFA
    style Se fill:#708090
    
    linkStyle 9,10,11,12,13 stroke:#FFA07A,stroke-width:2px,color:green;
    linkStyle 6,7,8 stroke:#FFD700,stroke-width:3px,color:green;
    linkStyle 1,3,5 stroke:#32CD32,stroke-width:2px,color:yellow;
    linkStyle 14,15,16,17,18,19,20,21,22 stroke:#FF6347,stroke-width:8px,color:green;
</code></pre>
<h3 id="总控-引擎通信"><a href="#总控-引擎通信" class="headerlink" title="总控-引擎通信"></a>总控-引擎通信</h3><h4 id="总控-管理面通信"><a href="#总控-管理面通信" class="headerlink" title="总控-管理面通信"></a>总控-管理面通信</h4><h5 id="webserver-服务注册机制"><a href="#webserver-服务注册机制" class="headerlink" title="webserver 服务注册机制"></a>webserver 服务注册机制</h5><p>webserver 启动时会向 sc-core 注册本组件信息，其中包括本节点角色(M)、引擎序列号、引擎节点ID 等信息</p>
<h5 id="sc-core-负载均衡机制"><a href="#sc-core-负载均衡机制" class="headerlink" title="sc-core 负载均衡机制"></a>sc-core 负载均衡机制</h5><p>sc-core 在转发总控到引擎管理面流量时，指定对应引擎和节点角色，可以通过已注册的引擎的 webserver 负载均衡一个可用的引擎管理面中的 webserver 进行处理。</p>
<h4 id="总控-任意节点-webserver-通信"><a href="#总控-任意节点-webserver-通信" class="headerlink" title="总控-任意节点 webserver 通信"></a>总控-任意节点 webserver 通信</h4><p>sc-core 在转发总控到任意引擎节点时，指定对应引擎和节点ID，可以通过注册信息，转发到指定节点的 webserver 中进行处理。</p>
<h2 id="物理架构"><a href="#物理架构" class="headerlink" title="物理架构"></a>物理架构</h2><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><h3 id="引擎-webserver-sc-core-注册流程"><a href="#引擎-webserver-sc-core-注册流程" class="headerlink" title="引擎 webserver -&gt; sc-core 注册流程"></a>引擎 webserver -&gt; sc-core 注册流程</h3><h3 id="引擎安装-webserver-流程"><a href="#引擎安装-webserver-流程" class="headerlink" title="引擎安装 webserver 流程"></a>引擎安装 webserver 流程</h3><ul>
<li>修改 hosts</li>
<li>安装 webserver</li>
<li>配置启动参数</li>
<li>apiserver、etcd 安装逻辑</li>
</ul>
<h3 id="sc-向管理面-webserver-通信"><a href="#sc-向管理面-webserver-通信" class="headerlink" title="sc 向管理面 webserver 通信"></a>sc 向管理面 webserver 通信</h3><h3 id="调度节点、工作节点组件访问管理面组件"><a href="#调度节点、工作节点组件访问管理面组件" class="headerlink" title="调度节点、工作节点组件访问管理面组件"></a>调度节点、工作节点组件访问管理面组件</h3><h2 id="异常场景"><a href="#异常场景" class="headerlink" title="异常场景"></a>异常场景</h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF/" style="color: #00a596">通信链路</a>
        </span>
        
    </div>
    <a href="/2024/03/18/mdstorage/project/sr/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0%E5%90%8E%E7%AE%A1%E7%90%86%E9%9D%A2HA%E7%9B%B8%E5%85%B3/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/03/15/mdstorage/project/cToRust/cust%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/">
        <h2 class="post-title">cust相关问题和解决思路.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/project/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                project
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/15
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="C-调用标准库函数进行一系列操作"><a href="#C-调用标准库函数进行一系列操作" class="headerlink" title="C 调用标准库函数进行一系列操作"></a>C 调用标准库函数进行一系列操作</h2><h3 id="问题、解决思路"><a href="#问题、解决思路" class="headerlink" title="问题、解决思路"></a>问题、解决思路</h3><ul>
<li>入参 int n … 语法翻译问题<ul>
<li>通过 <code>AST</code> 中解析出参数中是否有此语法，如果有，则在 IR 中做出记录，在 IR to Rust 中将其转换为 <code>Vec&lt;T&gt;</code> , 并在之后的 Function body 逻辑处理中，将 C 中对 n 的处理，转换为 Rust 对 Vec<T> n  的处理。</li>
</ul>
</li>
<li>获取 for 循环中的 condition 的 operator 思路<ul>
<li><strong>计算左操作数的偏移量（<code>left_offset</code>）</strong>：<ul>
<li>首先，获取左操作数实体（<code>entity.get_child(0)</code>），假设为二元操作的第一个子实体。</li>
<li>使用 <code>.map</code> 遍历左操作数的子实体（这里实际上只有一个），获取每个子实体的源代码范围（<code>get_range()</code>），然后对这个范围内的标记（<code>tokenize()</code>）进行计数（<code>.len()</code>），以确定左操作数占用了多少个标记。</li>
<li>通过 <code>.fold</code> 将这些标记数量累加起来，得到 <code>left_offset</code>，即左操作数结束的位置（以标记计数为单位）。</li>
</ul>
</li>
<li><strong>获取整个二元操作的标记</strong>：<ul>
<li>通过 <code>entity.get_range().and_then(|r| Some(r.tokenize()))</code> 获取表示整个二元操作的 <code>Entity</code> 的源代码范围，并将这个范围内的内容分割成标记。</li>
</ul>
</li>
<li><strong>提取操作符</strong>：<ul>
<li>使用左操作数的偏移量 <code>left_offset</code> 作为索引，从整个二元操作的标记列表中提取操作符。因为左操作数后面紧跟的标记应该就是操作符本身。</li>
</ul>
</li>
<li><strong>返回操作符的拼写</strong>：<ul>
<li>通过 <code>get_spelling()</code> 方法获取操作符标记的文本表示，然后将其作为 <code>Some</code> 值返回。</li>
</ul>
</li>
</ul>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Rust/" style="color: #00a596">Rust</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #03a9f4">C</a>
        </span>
        
    </div>
    <a href="/2024/03/15/mdstorage/project/cToRust/cust%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/03/12/mdstorage/project/cToRust/cust%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99%E5%85%B3%E7%B3%BB/">
        <h2 class="post-title">cust转换规则关系.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/project/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                project
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/12
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>这个示例涉及到几个关键的编程概念在 C 和 Rust 之间的转换，包括函数定义、传入参数、循环控制、标准输入输出和主函数。让我们详细解析每个部分：</p>
<h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><h4 id="返回值类型"><a href="#返回值类型" class="headerlink" title="返回值类型"></a>返回值类型</h4><ul>
<li><strong>C</strong>: 使用 <code>void</code> 关键字表示没有返回值的函数。如 <code>void print_values(int n, ...)</code></li>
<li><strong>Rust</strong>: Rust 中没有返回值的函数隐式返回 <code>()</code>，这通常在函数签名中省略。如 <code>fn print_values(args: Vec&lt;i32&gt;)</code></li>
</ul>
<h3 id="传入参数"><a href="#传入参数" class="headerlink" title="传入参数"></a>传入参数</h3><h4 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h4><ul>
<li><strong>C</strong>: 使用 <code>...</code> 和配合 <code>va_list</code> 处理变长参数。</li>
<li><strong>Rust</strong>: Rust 不直接支持 C 风格的变长参数。可以使用 <code>Vec&lt;T&gt;</code> 或其他集合类型来处理不定数量的参数。</li>
</ul>
<h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><ul>
<li><strong>C</strong>: 通过初始化变量、条件和增量在 <code>for</code> 循环的括号内定义循环逻辑。</li>
<li><strong>Rust</strong>: Rust 的 <code>for</code> 循环与 C 不同，它用于遍历迭代器。在本例中，遍历一个 <code>Vec&lt;i32&gt;</code> 的每个元素。</li>
</ul>
<h3 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h3><h4 id="打印到控制台"><a href="#打印到控制台" class="headerlink" title="打印到控制台"></a>打印到控制台</h4><ul>
<li><strong>C</strong>: 使用 <code>printf</code> 函数进行格式化输出。</li>
<li><strong>Rust</strong>: 使用 <code>println!</code> 宏进行格式化输出。Rust 的宏提供了额外的类型安全性和方便的格式化选项。</li>
</ul>
<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><h4 id="主函数返回值"><a href="#主函数返回值" class="headerlink" title="主函数返回值"></a>主函数返回值</h4><ul>
<li><strong>C</strong>: <code>main</code> 函数返回 <code>int</code> 类型，<code>0</code> 通常表示成功。</li>
<li><strong>Rust</strong>: <code>main</code> 函数没有返回值，对于错误处理，可以使用 <code>Result</code> 类型，或者在异常情况下调用 <code>panic!</code> 宏。</li>
</ul>
<h3 id="示例代码解析"><a href="#示例代码解析" class="headerlink" title="示例代码解析"></a>示例代码解析</h3><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C 代码"></a>C 代码</h4><pre><code class="c">#include &lt;iostream&gt;
#include &lt;cstdarg&gt;

void print_values(int n, ...) &#123;
    va_list vl;
    va_start(vl, n);
    for (int i = 0; i &lt; n; i++) &#123;
        int value = va_arg(vl, int);
        std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; &quot;\n&quot;;
    &#125;
    va_end(vl);
&#125;

int main() &#123;
    print_values(3, 10, 20, 30);
    return 0;
&#125;
</code></pre>
<p>这段 C 代码定义了一个 <code>print_values</code> 函数，使用 C 语言的变长参数列表功能来接收并打印任意数量的整数值。</p>
<h4 id="Rust-转换"><a href="#Rust-转换" class="headerlink" title="Rust 转换"></a>Rust 转换</h4><pre><code class="rust">fn print_values(args: Vec&lt;i32&gt;) &#123;
    for value in args &#123;
        println!(&quot;Value: &#123;&#125;&quot;, value);
    &#125;
&#125;

fn main() &#123;
    print_values(vec![10, 20, 30]);
&#125;
</code></pre>
<p>在 Rust 中，由于不支持 C 风格的变长参数，所以采用 <code>Vec&lt;i32&gt;</code> 来代替。这种方式更安全、更符合 Rust 的设计理念。<code>print_values</code> 函数遍历整数向量，并使用 <code>println!</code> 宏打印每个值。</p>
<p>通过这种方式，我们不仅转换了代码，还提高了类型安全性，并利用了 Rust 强大的迭代器和宏系统。</p>
<h2 id="parse-str-quote-parse-quote"><a href="#parse-str-quote-parse-quote" class="headerlink" title="parse_str quote! parse_quote!"></a>parse_str quote! parse_quote!</h2><p><code>syn::parse_str</code>、<code>quote!</code> 和 <code>parse_quote!</code> 都是 Rust 编程中用于宏和代码生成的强大工具，它们在 <code>proc-macro</code> 开发和代码生成中扮演着不同的角色。下面是它们之间的主要区别和联系：</p>
<h3 id="syn-parse-str"><a href="#syn-parse-str" class="headerlink" title="syn::parse_str"></a><code>syn::parse_str</code></h3><ul>
<li><strong>用途</strong>：<code>syn::parse_str</code> 用于将字符串解析为 Rust 语法树节点。它是 <code>syn</code> 库提供的函数，可以解析任何合法的 Rust 代码字符串到指定的数据类型，如 <code>Expr</code>、<code>ItemFn</code>、<code>Type</code> 等。</li>
<li><strong>场景</strong>：当你有一个 Rust 代码的字符串表示，并且需要将这个字符串转换成一个可操作的语法树节点时，使用 <code>syn::parse_str</code>。这对于分析和转换代码特别有用。</li>
</ul>
<h3 id="quote"><a href="#quote" class="headerlink" title="quote!"></a><code>quote!</code></h3><ul>
<li><strong>用途</strong>：<code>quote!</code> 宏用于将 Rust 代码转换为 <code>TokenStream</code>。它是 <code>quote</code> crate 的一部分，能够让你以近乎正常的 Rust 语法编写代码片段，并将其转换为 <code>TokenStream</code>，这在宏的输出和代码生成时非常有用。</li>
<li><strong>场景</strong>：在编写宏或生成 Rust 代码时，使用 <code>quote!</code> 宏可以方便地生成代码。通过 <code>quote!</code>，你可以轻松地将变量插入到代码模板中，并生成编译器能够理解的 <code>TokenStream</code>。</li>
</ul>
<h3 id="parse-quote"><a href="#parse-quote" class="headerlink" title="parse_quote!"></a><code>parse_quote!</code></h3><ul>
<li><strong>用途</strong>：<code>parse_quote!</code> 宏结合了 <code>quote!</code> 和 <code>syn::parse</code> 的功能。它允许你编写 Rust 代码片段，并将其直接解析为指定的语法树节点类型，如 <code>Expr</code>、<code>Item</code> 等。</li>
<li><strong>场景</strong>：当你需要生成特定的语法树节点，并且这些节点需要在编译时进行进一步处理或分析时，<code>parse_quote!</code> 非常有用。它让你能够编写可读的 Rust 代码片段，并直接转换成可操作的语法树结构。</li>
</ul>
<h3 id="关系和使用建议"><a href="#关系和使用建议" class="headerlink" title="关系和使用建议"></a>关系和使用建议</h3><ul>
<li>使用 <code>quote!</code> 时，你是从 Rust 代码到 <code>TokenStream</code> 的转换过程中编写代码片段。</li>
<li>使用 <code>syn::parse_str</code> 或 <code>parse_quote!</code> 时，你是从字符串或 <code>TokenStream</code> 转换到具体的语法树节点。</li>
<li><code>quote!</code> 常用于宏的输出和代码生成，而 <code>syn::parse_str</code> 和 <code>parse_quote!</code> 常用于分析和转换这些生成的代码。</li>
<li><code>parse_quote!</code> 提供了一个方便的方式，结合了 <code>quote!</code> 生成代码和 <code>syn::parse</code> 解析代码的功能，使得从代码片段到语法树节点的转换更加直接和简洁。</li>
</ul>
<p>总之，根据你的具体需求选择合适的工具：如果你需要生成代码，使用 <code>quote!</code>；如果你需要将代码字符串转换为语法树节点进行分析或操作，使用 <code>syn::parse_str</code>；如果你希望编写代码片段并直接解析为语法树节点，使用 <code>parse_quote!</code>。</p>
<p>是的，在使用 <code>syn</code> 和 <code>quote</code> 库进行 Rust 宏编程和代码生成时，<code>syn</code> 的类型如 <code>Expr</code>、<code>Type</code> 等可以与 <code>TokenStream</code> 进行互相转换。这种转换能力是实现宏和代码生成逻辑中的核心功能，它允许开发者在 Rust 语法树节点和 <code>TokenStream</code> 之间自由转换，以便进行进一步的处理或生成代码。</p>
<h3 id="从-syn-类型到-TokenStream"><a href="#从-syn-类型到-TokenStream" class="headerlink" title="从 syn 类型到 TokenStream"></a>从 <code>syn</code> 类型到 <code>TokenStream</code></h3><p>当你有一个 <code>syn</code> 类型的实例（比如一个表达式 <code>Expr</code> 或一个类型 <code>Type</code>），你可以使用 <code>quote!</code> 宏将其转换为 <code>TokenStream</code>。<code>quote!</code> 宏能够接受 <code>syn</code> 类型的变量，并通过插值（<code>#var</code> 语法）将它们包含在生成的代码中。</p>
<pre><code class="rust">use syn::&#123;Expr, parse_str&#125;;
use quote::quote;
use proc_macro2::TokenStream;

// 假设有一个 syn 的 Expr
let expr: Expr = parse_str(&quot;42&quot;).unwrap();

// 使用 quote! 将 Expr 转换为 TokenStream
let tokens: TokenStream = quote! &#123;
    let value = #expr;
&#125;;
</code></pre>
<h3 id="从-TokenStream-到-syn-类型"><a href="#从-TokenStream-到-syn-类型" class="headerlink" title="从 TokenStream 到 syn 类型"></a>从 <code>TokenStream</code> 到 <code>syn</code> 类型</h3><p>反过来，如果你有一个 <code>TokenStream</code> 并希望将其解析为 <code>syn</code> 类型的语法树节点，你可以使用 <code>syn::parse</code> 函数或其变体（比如 <code>parse_str</code>，如果你是从字符串开始的）来实现。这通常在宏的输入处理过程中使用，宏接收的 <code>TokenStream</code> 需要被解析为具体的语法结构以便分析或修改。</p>
<pre><code class="rust">use syn::&#123;Expr, parse2&#125;;
use quote::quote;

// 创建一个 TokenStream
let tokens = quote! &#123; 42 &#125;;

// 将 TokenStream 解析为 syn 的 Expr
let expr: Expr = parse2(tokens).unwrap();
</code></pre>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>这种转换过程在编写宏和进行复杂的代码生成时非常有用，特别是需要对输入的 Rust 代码进行详细分析或需要生成特定的 Rust 代码片段时。</li>
<li>转换过程中可能会遇到错误，特别是从 <code>TokenStream</code> 解析到 <code>syn</code> 类型时，如果 <code>TokenStream</code> 中的代码不符合预期的 Rust 语法，<code>parse</code> 函数会返回一个错误。因此，错误处理是这一过程中不可或缺的部分。</li>
<li>使用 <code>quote!</code> 时保持代码的可读性和清晰性是很重要的，特别是当涉及到复杂的代码生成逻辑时。利用 <code>quote!</code> 宏的能力来插入变量和表达式，可以使生成的代码更加灵活和动态。</li>
</ul>
<p>结合 <code>syn</code> 和 <code>quote</code> 的能力，开发者可以在 Rust 宏和代码生成中实现复杂而强大的逻辑。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/cust/" style="color: #00bcd4">cust</a>
        </span>
        
    </div>
    <a href="/2024/03/12/mdstorage/project/cToRust/cust%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99%E5%85%B3%E7%B3%BB/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    
    <a class="page-num" href="/page/13/">
        <i class="fa-solid fa-caret-left fa-fw"></i>
    </a>
    <a class="page-num" href="/">1</a>
    <span class="page-omit">...</span>
    
    <span class="current">14</span>
    
    <a class="page-num" href="/page/15">
        15
    </a>
    
    
    <a class="page-num" href="/page/16">
        16
    </a>
    
    
    <span class="page-omit">...</span>
    <a class="page-num" href="/page/28">28</a>
    
    
    <a class="page-num" href="/page/15/">
        <i class="fa-solid fa-caret-right fa-fw"></i>
    </a>
    
</div>

    </div>
    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name">xiaoy</div>
        <div class="description">
            <p>Description<br>…</p>

        </div>
        
        
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://argvchs.github.io">Argvchs</a>
            </div>
            
        </div>
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2024 - 2024 Xiaoy
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;xiaoy
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
</body>
</html>
