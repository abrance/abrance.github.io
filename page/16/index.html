
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Xiaoy</title>
    <meta name="author" content="xiaoy" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>XIAOY</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;XIAOY</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div
        id="home-background"
        ref="homeBackground"
        data-images="/images/background.jpg"
    ></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Xiaoy</h1>
                <h3>xiaoy blog</h3>
                <h5></h5>
            </div>
        </span>
    </div>
</div>
<div
    id="home-posts-wrap"
    ref="homePostsWrap"
    true
>
    <div id="home-posts">
        

<div class="post">
    <a href="/2024/02/29/mdstorage/domain/C%E8%AF%AD%E8%A8%80/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B3%BB%E7%BB%9F%E8%AF%AD%E8%A8%80/">
        <h2 class="post-title">运行时系统语言.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/domain/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                domain
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/2/29
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="运行时系统语言"><a href="#运行时系统语言" class="headerlink" title="运行时系统语言"></a>运行时系统语言</h2><p>“有运行时的语言”（或具有运行时系统的语言）指的是那些在程序执行期间依赖于某种形式的运行时环境（Runtime Environment, RE）或运行时库（Runtime Library）的编程语言。这个运行时环境提供了一系列服务或功能，如内存管理（包括垃圾回收）、类型安全检查、异常处理、动态类型和反射等，从而支持程序的执行。</p>
<h3 id="运行时环境的作用"><a href="#运行时环境的作用" class="headerlink" title="运行时环境的作用"></a>运行时环境的作用</h3><p>运行时环境的主要作用包括但不限于：</p>
<ul>
<li><strong>内存管理</strong>：自动管理程序的内存分配和回收，例如通过垃圾回收机制减少内存泄漏。</li>
<li><strong>类型检查</strong>：动态语言通常在运行时执行类型检查，以确保类型安全。</li>
<li><strong>异常处理</strong>：处理程序执行中的异常情况，如运行时错误和异常捕获。</li>
<li><strong>动态特性支持</strong>：提供反射、动态绑定等动态特性，允许程序在运行时查询和修改类型信息。</li>
</ul>
<h3 id="有运行时与无运行时的语言"><a href="#有运行时与无运行时的语言" class="headerlink" title="有运行时与无运行时的语言"></a>有运行时与无运行时的语言</h3><ul>
<li><strong>有运行时的语言</strong>：如 Java、C#、Python、Ruby 和 JavaScript 等，它们依赖于虚拟机（如 JVM 和 .NET CLR）或解释器来执行程序。这些环境提供了丰富的运行时服务，使得开发者可以更加专注于业务逻辑的实现，而不是底层的资源管理。</li>
<li><strong>无运行时的语言</strong>：理论上，所有的编程语言在执行时都需要某种形式的运行时支持，但像 C 和 Rust 这样的语言被认为是“无运行时”或“几乎无运行时”的，因为它们不需要重量级的运行时环境。它们直接编译为机器码，运行时开销非常小，内存管理等责任主要由程序员手动管理。</li>
</ul>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>虽然“无运行时”这个词可能会让人误以为完全没有运行时支持，但实际上这些语言的标准库仍然提供了一定的运行时功能，只是相比那些“有运行时”的语言，这些功能更加基础和有限。例如，Rust 的运行时支持相对非常小，主要关注性能和内存安全，而避免了垃圾收集等运行时特性。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="color: #00bcd4">编程语言</a>
        </span>
        
    </div>
    <a href="/2024/02/29/mdstorage/domain/C%E8%AF%AD%E8%A8%80/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B3%BB%E7%BB%9F%E8%AF%AD%E8%A8%80/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/02/29/mdstorage/project/sr/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0sc%E3%80%81webserver%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0%E8%AE%BE%E8%AE%A1/">
        <h2 class="post-title">通信链路改造sc、webserver链路改造设计.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/2/29
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><h3 id="现状分析"><a href="#现状分析" class="headerlink" title="现状分析"></a>现状分析</h3><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><h3 id="困难点"><a href="#困难点" class="headerlink" title="困难点"></a>困难点</h3><h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><h2 id="异常场景"><a href="#异常场景" class="headerlink" title="异常场景"></a>异常场景</h2><h3 id="1-网络异常"><a href="#1-网络异常" class="headerlink" title="1. 网络异常"></a>1. 网络异常</h3><ul>
<li><strong>原因</strong>：客户端A&#x2F;B或sc-core网络不稳定，导致消息传输失败。</li>
<li><strong>解决方案</strong>：实现重试机制和超时控制，确保消息能够在网络恢复后成功传输。</li>
</ul>
<h3 id="2-客户端注册失败"><a href="#2-客户端注册失败" class="headerlink" title="2. 客户端注册失败"></a>2. 客户端注册失败</h3><ul>
<li><strong>原因</strong>：客户端信息错误、sc-core服务不可用或达到连接数上限。</li>
<li><strong>解决方案</strong>：检查客户端信息的正确性，确保sc-core服务运行正常，并考虑扩展服务能力以支持更多客户端。</li>
</ul>
<h3 id="3-消息转发失败"><a href="#3-消息转发失败" class="headerlink" title="3. 消息转发失败"></a>3. 消息转发失败</h3><ul>
<li><strong>原因</strong>：目标客户端不在线、sc-core内部错误或消息格式不兼容。</li>
<li><strong>解决方案</strong>：在sc-core中实现客户端在线状态检测，对内部错误进行异常捕获处理，并确保消息格式的统一和兼容性。</li>
</ul>
<h3 id="4-响应超时"><a href="#4-响应超时" class="headerlink" title="4. 响应超时"></a>4. 响应超时</h3><ul>
<li><strong>原因</strong>：B处理请求耗时过长或sc-core到B的网络延迟。</li>
<li><strong>解决方案</strong>：优化B处理逻辑的性能，提高响应速度，并在A端实现超时重试机制。</li>
</ul>
<h3 id="5-数据一致性问题"><a href="#5-数据一致性问题" class="headerlink" title="5. 数据一致性问题"></a>5. 数据一致性问题</h3><ul>
<li><strong>原因</strong>：在分布式环境下，客户端状态更新可能不同步。</li>
<li><strong>解决方案</strong>：实现客户端心跳机制，定期同步客户端状态，确保sc-core持有的客户端信息准确。</li>
</ul>
<h3 id="6-安全性问题"><a href="#6-安全性问题" class="headerlink" title="6. 安全性问题"></a>6. 安全性问题</h3><ul>
<li><strong>原因</strong>：传输数据未加密，存在被截获的风险。</li>
<li><strong>解决方案</strong>：使用TLS加密gRPC通信，确保数据传输的安全性。</li>
</ul>
<h3 id="7-资源竞争和泄漏"><a href="#7-资源竞争和泄漏" class="headerlink" title="7. 资源竞争和泄漏"></a>7. 资源竞争和泄漏</h3><ul>
<li><strong>原因</strong>：并发处理不当导致的资源竞争或未正确释放资源导致的内存泄漏。</li>
<li><strong>解决方案</strong>：使用锁或其他并发控制机制管理资源访问，确保goroutine安全；及时释放不再使用的资源，避免内存泄漏。</li>
</ul>
<h3 id="8-服务降级与熔断"><a href="#8-服务降级与熔断" class="headerlink" title="8. 服务降级与熔断"></a>8. 服务降级与熔断</h3><ul>
<li><strong>原因</strong>：sc-core负载过高，无法处理更多请求。</li>
<li><strong>解决方案</strong>：实现服务降级策略，在系统负载过高时，暂时拒绝非关键请求；使用熔断机制，防止系统完全不可用。</li>
</ul>
<h3 id="9-服务发现问题"><a href="#9-服务发现问题" class="headerlink" title="9. 服务发现问题"></a>9. 服务发现问题</h3><ul>
<li><strong>原因</strong>：客户端或服务端在动态环境下IP变化，导致无法正常通信。</li>
<li><strong>解决方案</strong>：引入服务注册与发现机制，客户端和服务端动态注册自己的地址信息，保证通信地址的实时更新。</li>
</ul>
<h1 id="项目概述-1"><a href="#项目概述-1" class="headerlink" title="项目概述"></a>项目概述</h1><h2 id="现状分析-1"><a href="#现状分析-1" class="headerlink" title="现状分析"></a>现状分析</h2><h3 id="总控、引擎、插件跨节点通信链路"><a href="#总控、引擎、插件跨节点通信链路" class="headerlink" title="总控、引擎、插件跨节点通信链路"></a>总控、引擎、插件跨节点通信链路</h3><pre><code class="mermaid">graph LR
    subgraph Sc[总控]
        sc
        sv[可视化 sv]
        installer-manager[引擎安装 manager]
    end
    
    subgraph Se[流量引擎]
        subgraph Sem[流量引擎 管理节点]
            installer-agent[引擎安装 agent]
            webserver[Webserver]
            admin_dam[admin Dam]
            apiserver[Apiserver]
            admin_ha[admin HA]
            nexus_m[Nexus]
            global_plugin_server[global-plugin-server]
        end

        subgraph Sew[流量引擎 工作节点]
            data_dam[data Dam]
            nexus_w[Nexus]
            envoy[Envoy]
        end
        
        subgraph Ses[流量引擎 调度节点]
            nexus_s[Nexus]
            data_ha[Data HA]
        end
    end
    
    installer-manager --&gt;|vip/nodeIP:8099|installer-agent
    installer-manager --&gt;|vip:6898|admin_ha
    sv --&gt;|vip:1234|admin_dam
    sv --&gt;|vip:8899|admin_dam
    sv --&gt;|vip:8299|webserver
    sc --&gt;|vip:8229|webserver	
    
    installer-agent --&gt;|nodeIP:8098|installer-manager
    data_dam --&gt;|nodeIp:4150|sv
    
    data_ha --&gt;|nodeIp:6443| apiserver
    webserver --&gt;|nodeIp:9001|data_dam
    webserver --&gt;|nodeIp:8000| nexus_m &amp; nexus_s &amp; nexus_w
    envoy --&gt;|vip:7878 7978| global_plugin_server
    
    %%installer-agent --&gt;|vip:6443|apiserver
</code></pre>
<p>结论： 可以看出来现有的通信链路有两个不符合设计要求的点 1. 通信建立连接方向为总控端到引擎端  2. 通信链路不规则，各个组件缺乏管制，随意建立链接。</p>
<p>缺点很明显，1 会导致与实际客户部署场景不吻合 2 会导致后期运维困难、系统维护困难、系统开发成本提高等。</p>
<h2 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h2><h3 id="改造后总控引擎通信链路（不算引擎内部）"><a href="#改造后总控引擎通信链路（不算引擎内部）" class="headerlink" title="改造后总控引擎通信链路（不算引擎内部）"></a>改造后总控引擎通信链路（不算引擎内部）</h3><pre><code class="mermaid">graph LR
    subgraph Sc[总控]
        sc[sc]
        core[core *:20111]
        sv[可视化 sv]
        installer-manager[引擎安装 manager]
    end
    
    subgraph Se[流量引擎]
        subgraph Sem[流量引擎 管理节点]
            %%installer-agent[引擎安装 agent]
            webserver[Webserver]
            admin_dam[admin Dam]
            apiserver[Apiserver]
            admin_ha[admin HA]
            nexus_m[Nexus]
            global_plugin_server[global-plugin-server]
        end

        subgraph Sew[流量引擎 工作节点]
            data_dam[data Dam]
            nexus_w[Nexus]
            envoy[Envoy]
        end
        
        subgraph Ses[流量引擎 调度节点]
            nexus_s[Nexus]
        end
    end
    
    %%installer-manager --&gt;|vip/nodeIP:8099|installer-agent
    %%installer-manager --&gt;|vip:6898|admin_ha
    %%sv --&gt;|vip:1234|admin_dam
    %%sv --&gt;|vip:8899|admin_dam
    %%sv --&gt;|vip:8299|webserver
    %%sc --&gt;|vip:8229|webserver	
    sc --&gt; core
    webserver --&gt; core

    sv --&gt; core
    %%admin_dam ---&gt; webserver
    admin_dam ---&gt; |*:29120| sv
    
    installer-manager --&gt; core
    %%admin_ha ---&gt; webserver
    %%installer-agent ---&gt; core
    
    installer-manager --&gt;|nodeIp:22 |Se
    %%installer-agent --&gt;|nodeIP:8098|installer-manager
    %%data_dam --&gt;|nodeIp:4150|sv
    %%data_dam --&gt;|nodeIp:9001|webserver
    %%webserver --&gt;|nodeIp:8000| nexus_m &amp; nexus_s &amp; nexus_w
    %%envoy --&gt;|vip:7878 7978| global_plugin_server
    %%installer-agent --&gt;|vip:6443|apiserver
</code></pre>
<h3 id="改造后总控引擎通信链路（算引擎内部）"><a href="#改造后总控引擎通信链路（算引擎内部）" class="headerlink" title="改造后总控引擎通信链路（算引擎内部）"></a>改造后总控引擎通信链路（算引擎内部）</h3><pre><code class="mermaid">graph LR
    subgraph Sc[总控]
        sc[sc]
        core[core *:20111]
        sv[可视化 sv]
        installer-manager[引擎安装 manager]
    end
    
    subgraph Se[流量引擎]
        subgraph Sem[流量引擎 管理节点]
            %%installer-agent[引擎安装 agent]
            webserver[Webserver]
            admin_dam[admin Dam]
            apiserver[Apiserver]
            admin_ha[admin HA]
            nexus_m[Nexus]
            global_plugin_server[global-plugin-server]
        end

        subgraph Sew[流量引擎 工作节点]
            data_dam[data Dam]
            nexus_w[Nexus]
            envoy[Envoy]
        end
        
        subgraph Ses[流量引擎 调度节点]
            nexus_s[Nexus]
            data_ha[Data HA]
        end
    end
    
    %%installer-manager --&gt;|vip/nodeIP:8099|installer-agent
    %%installer-manager --&gt;|vip:6898|admin_ha
    %%sv --&gt;|vip:1234|admin_dam
    %%sv --&gt;|vip:8899|admin_dam
    %%sv --&gt;|vip:8299|webserver
    %%sc --&gt;|vip:8229|webserver	
    sc --&gt; core
    webserver --&gt; core

    sv --&gt; core
    admin_dam ---&gt;|*:29120| sv
    
    installer-manager --&gt; core
    admin_ha ---&gt; webserver
    %%installer-agent ---&gt; core
    data_ha --&gt;|nodeIp:6443| apiserver
    %%installer-agent --&gt;|nodeIP:8098|installer-manager
    %%data_dam --&gt;|nodeIp:4150|sv
    %%data_dam --&gt;|nodeIp:9001|webserver
    webserver --&gt;|nodeIp:8000| nexus_m &amp; nexus_s &amp; nexus_w
    envoy --&gt;|vip:7878 7978| global_plugin_server
    installer-manager --&gt;|nodeIp:22 |Se
    %%installer-agent --&gt;|vip:6443|apiserver
    linkStyle 0,1 stroke-width:8px;    
</code></pre>
<h2 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h2><h3 id="建立连接反转"><a href="#建立连接反转" class="headerlink" title="建立连接反转"></a>建立连接反转</h3><p>（本次改动不涉及 可视化数据传输的流，这是考虑到可视化的数据流过大，经过一次转发消耗的资源比较大）</p>
<p>在 core 参与的框架中，完成组件之间通信有两步：</p>
<ol>
<li>与 core 建立通信</li>
<li>发送&#x2F;接收、处理请求</li>
</ol>
<p>图表标识</p>
<ul>
<li>红线表示需要完成 1 2 步编码</li>
<li>紫线表示不需要实现</li>
<li>橙色表示需要实现 2 步</li>
</ul>
<h4 id="sc-到-webserver"><a href="#sc-到-webserver" class="headerlink" title="sc 到 webserver"></a>sc 到 webserver</h4><pre><code class="mermaid">graph LR
    subgraph Sc[总控]
        subgraph ScApi[总控API]
            client[SCClient]

            subgraph Client
                conn_ctx[引擎连接管理]
                gw_obj[引擎服务搭建]
                node_ctx[引擎节点管理]
                auth_ctx[引擎授权管理]
                ha_ctx[调度策略管理]
            end

        end
        subgraph Core
            core_conn_ctx[各组件连接上下文管理]

            subgraph Stream
                Agent
            end
        end
    end
    
    subgraph Se
        router[Webserver]
        subgraph Router
        
            gw[网关、虚拟服务对象等接口]
            node_manage[引擎节点状态接口]
            auth_manage[引擎授权管理接口]
            ha_manage[调度策略管理接口]
        end
    end 
    
    router --&gt; Agent
    client --&gt; Agent
    router --&gt; Router
    client --&gt; Client &amp; core_conn_ctx
    
    linkStyle 0,1,2,3,4 stroke:red,stroke-width:8px,color:black;    
    
</code></pre>
<h2 id="多管理面节点主备切换场景–方案改造后流程图"><a href="#多管理面节点主备切换场景–方案改造后流程图" class="headerlink" title="多管理面节点主备切换场景–方案改造后流程图"></a>多管理面节点主备切换场景–方案改造后流程图</h2><p><img src="http://119.91.145.27:12799/api/public/dl/p8KdAUHH/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0%E5%A4%9A%E8%8A%82%E7%82%B9%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91.png" alt="通信链路改造多节点主备切换程序逻辑"> </p>
<h3 id="主备切换场景–异常情况"><a href="#主备切换场景–异常情况" class="headerlink" title="主备切换场景–异常情况"></a>主备切换场景–异常情况</h3><ul>
<li>HA 出现问题，主节点状态异常后未能及时完成主备切换操作</li>
<li>HA –&gt; webserver 这条链路出现问题，不能及时通知 webserver 主备切换信息，导致引擎失联，会在界面中显现</li>
<li>webserver –&gt; sc-core 被告之主备切换后未能主动连接 sc-core ，或是链路出现问题，同样表现为引擎失联</li>
<li>sc-core 不能正确处理 webserver 断线、新 webserver 重连场景，导致引擎链路出现问题，可能表现为引擎失联</li>
</ul>
<h2 id="通信链路规整"><a href="#通信链路规整" class="headerlink" title="通信链路规整"></a>通信链路规整</h2><p>todo</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF/" style="color: #00a596">通信链路</a>
        </span>
        
    </div>
    <a href="/2024/02/29/mdstorage/project/sr/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0/%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0sc%E3%80%81webserver%E9%93%BE%E8%B7%AF%E6%94%B9%E9%80%A0%E8%AE%BE%E8%AE%A1/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/02/28/mdstorage/project/cToRust/cToRust/">
        <h2 class="post-title">cToRust.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/project/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                project
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/2/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><pre><code>1 赛题背景
vivo蓝河操作系统是面向通用人工智能时代自研的下一代智慧操作系统，创新性地使用Rust语言编写操作系统，得益于vivo蓝心大模型的智慧赋能，实现了自主、可控、先进、安全的智慧解决方案。

C/C++代码编写的系统大约70%的严重安全漏洞和内存使用不当相关，而Rust语言一系列安全特性，可以在编译阶段发现内存相关安全漏洞，用Rust语言编写更安全的操作系统，已经成为行业趋势。国内自主研发的操作系统和自主可控的软件生态都还不成熟，通过代码转译技术，提升开发者对新操作系统的适配效率，促进国产操作系统软件生态发展成熟。

2 赛题介绍
本赛题要求参赛者设计并实现一个具有与蓝河系统/应用相关的代码转译能力的工具程序。可选方向有两个：

（1）底层代码转译：底层的C/C++代码转Rust代码工具。如给定C语言库，自动转译成Rust语言库。
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><code>https://topminisite.com/blog/tutorial-migrating-from-c-to-rust</code></p>
<h2 id="评分细则"><a href="#评分细则" class="headerlink" title="评分细则"></a>评分细则</h2><p>赛前准备了很多用例，到时候就根据程序跑过的用例数量多少来评分。</p>
<p>还有写下文档表明思路。</p>
<h2 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h2><p><code>https://github.com/abrance/cust</code></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Rust/" style="color: #00bcd4">Rust</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #ff7d73">C</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/vivo/" style="color: #00a596">vivo</a>
        </span>
        
    </div>
    <a href="/2024/02/28/mdstorage/project/cToRust/cToRust/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/02/28/mdstorage/project/cToRust/cust%E6%80%9D%E8%B7%AF/">
        <h2 class="post-title">cust思路.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/project/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                project
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/2/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><p>词法分析、语法分析、语义分析、代码生成</p>
<p>C 语言编译原理</p>
<pre><code class="mermaid">graph TB
    src:::no_border;
    prc4:::no_border;
    lib:::no_border;
    src[源程序] --&gt; process[预处理器] --&gt; |经过预处理的源程序| prc3[编译器] --&gt;|目标汇编程序| 汇编器 --&gt;|可重定位机器代码| linker[链接器/加载器] --&gt; prc4[目标机器代码]  
    lib[库文件 可重定向对象文件] --&gt; linker
    
    classDef no_border fill:transparent, stroke:transparent ;
</code></pre>
<pre><code class="mermaid">graph TB;
    符号表
    src[字符流]:::no_border
    an1[词法分析器]
    an2[语法分析]
    an3[语义分析]
    code_gen1[中间代码生成器]
    code_opt[机器无关代码优化器]
    code_gen2[代码生成器]
    code_gen3[机器相关代码优化器]
    dst[目标机器语言]:::no_border
    src --&gt; an1 --&gt;|符号流| an2 --&gt;|语法树| an3 --&gt;|语法树| code_gen1 --&gt;|中间表示形式| code_opt --&gt;|中间表示形式| code_gen2 --&gt;|目标机器语言| code_gen3 --&gt; dst
    
    
    classDef no_border fill:transparent, stroke:transparent ;
</code></pre>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li>C 词法分析</li>
<li>C 语法分析</li>
<li>C 语义分析</li>
<li>C to Rust 中间代码生成</li>
<li>Rust 代码生成器</li>
<li>Rust 代码优化器</li>
<li>Rust 语言代码</li>
</ul>
<h2 id="步骤设计和说明"><a href="#步骤设计和说明" class="headerlink" title="步骤设计和说明"></a>步骤设计和说明</h2><h3 id="1-C-词法分析"><a href="#1-C-词法分析" class="headerlink" title="1. C 词法分析"></a>1. C 词法分析</h3><ul>
<li><strong>目的</strong>：将源代码字符串分解成一系列的标记（tokens），这些标记代表语言的最小语法单位，如关键字、变量名、操作符等。</li>
<li><strong>在转换中的作用</strong>：这是解析 C 程序的第一步，为后续的语法分析准备标记流。</li>
</ul>
<h3 id="2-C-语法分析"><a href="#2-C-语法分析" class="headerlink" title="2. C 语法分析"></a>2. C 语法分析</h3><ul>
<li><strong>目的</strong>：根据 C 语言的语法规则分析标记流，构建出抽象语法树（AST）。AST 描述了程序的结构，展现了各个部分之间的关系。</li>
<li><strong>在转换中的作用</strong>：通过构建 AST，可以清晰地理解程序的结构，为后续的语义分析和转换提供基础。</li>
</ul>
<h3 id="3-C-语义分析"><a href="#3-C-语义分析" class="headerlink" title="3. C 语义分析"></a>3. C 语义分析</h3><ul>
<li><strong>目的</strong>：在语法分析的基础上进一步分析，包括类型检查、变量作用域确认、语义错误检测等。</li>
<li><strong>在转换中的作用</strong>：确保 C 程序在语义上是正确的，为转换成 Rust 代码提供准确的信息。</li>
</ul>
<h3 id="4-C-to-Rust-中间代码生成"><a href="#4-C-to-Rust-中间代码生成" class="headerlink" title="4. C to Rust 中间代码生成"></a>4. C to Rust 中间代码生成</h3><ul>
<li><strong>目的</strong>：将分析过的 C 程序（通常是 AST）转换为一种中间表示（IR），这种 IR 更接近于目标语言（在这里是 Rust）的结构。</li>
<li><strong>在转换中的作用</strong>：这一步是将 C 程序转换为 Rust 的关键，需要将 C 的特性映射到 Rust 的相应特性上，处理二者之间的差异。</li>
</ul>
<h3 id="5-Rust-代码生成器"><a href="#5-Rust-代码生成器" class="headerlink" title="5. Rust 代码生成器"></a>5. Rust 代码生成器</h3><ul>
<li><strong>目的</strong>：将中间代码转换为 Rust 源代码。这一步涉及到将中间表示中的结构、语句和表达式转换成 Rust 语言的对应项。</li>
<li><strong>在转换中的作用</strong>：生成可以由 Rust 编译器编译的源代码。</li>
</ul>
<h3 id="6-Rust-代码优化器"><a href="#6-Rust-代码优化器" class="headerlink" title="6. Rust 代码优化器"></a>6. Rust 代码优化器</h3><ul>
<li><strong>目的</strong>：对生成的 Rust 代码进行优化，提高代码的效率和性能。优化可以在多个层面进行，包括但不限于循环优化、死码删除、内联展开等。</li>
<li><strong>在转换中的作用</strong>：生成的 Rust 代码可能不是最优的，通过优化可以提高其运行时性能和资源利用率。</li>
</ul>
<h3 id="7-Rust-语言代码"><a href="#7-Rust-语言代码" class="headerlink" title="7. Rust 语言代码"></a>7. Rust 语言代码</h3><ul>
<li><strong>目的</strong>：最终产出的是经过优化的、可读性好的 Rust 代码，它应该保持了原始 C 程序的逻辑和功能，同时利用了 Rust 语言的安全和现代并发特性。</li>
<li><strong>在转换中的作用</strong>：这是转换流程的最终产物，一个可以编译和运行的 Rust 程序。</li>
</ul>
<h2 id="C-语法分析器"><a href="#C-语法分析器" class="headerlink" title="C 语法分析器"></a>C 语法分析器</h2><p>解决如何将 C 语言代码生成 AST</p>
<p>目前使用 clang 工具，解析为 AST 树，和各种符号在文件的范围。如果 clang 中可以直接获取到符号的语义的情况，则使用 clang 工具，如果不行，则取符号在文件的 location ，对其进行计算判断。（例如：for loop condition 对比操作）</p>
<h2 id="C-AST-to-Rust-AST"><a href="#C-AST-to-Rust-AST" class="headerlink" title="C AST to Rust AST"></a>C AST to Rust AST</h2><p>这里的 AST 不一定指由各自的编译器前端工具生成的 AST, 而是找到 C Rust 语义中联系程度、转换效率最高的一层，便于 AST to AST 的实现。</p>
<p>如何找到这一层，这一层的实现，即是这个方案最有挑战的部分，需要深入理解 C Rust 的语法和语义，设计一个足够通用且覆盖两门语言特性的 IR. </p>
<h2 id="Rust-AST-to-Rust-Code"><a href="#Rust-AST-to-Rust-Code" class="headerlink" title="Rust AST to Rust Code"></a>Rust AST to Rust Code</h2><pre><code>如何一步步将C项目迁移到Rust项目？ 将 C 项目迁移到 Rust 项目涉及几个步骤。以下是有关如何将 C 项目迁移到 Rust 项目的分步指南： 了解 Rust：开始迁移之前，请确保您充分了解 Rust 编程语言、其语法和功能。熟悉 Rust 概念，如所有权、借用和生命周期。 分析 C 项目：浏览 C 项目代码库并分析其结构、依赖项和功能。记下项目中使用的任何外部库、系统调用或复杂的 C 功能。 确定项目依赖关系：确定C项目中使用的依赖关系。检查 Rust 等效项或替代项是否可用于这些依赖项。 Rust 拥有丰富的生态系统，包含许多库和框架，因此很可能会有合适的替代方案可用。 设置新的 Rust 项目：使用 Cargo 构建系统创建新的 Rust 项目。 Cargo 提供了项目管理工具以及依赖管理。使用cargo new命令创建一个新项目：$cargonewproject_name 将代码转换为 Rust：通过了解每个 C 组件的逻辑和功能，开始将 C 代码转换为 Rust 代码。从一个简单的模块或文件开始，并将其转换为 Rust 等效项。使用 Rust 的类型系统、模式匹配和错误处理功能来增强代码的可读性和安全性。 处理内存管理：在C中，您需要使用malloc、free和其他函数手动管理内存。另一方面，Rust 通过其所有权模型和自动内存管理来处理内存安全。将 C 项目中的手动内存管理转换为 Rust 的所有权和借用系统。 重写复杂的组件：C 项目的某些部分可能需要用 Rust 进行更复杂的重写。分析这些组件并相应地规划它们的转换。利用 Rust 的功能（如结构、枚举、特征和模式匹配）以更惯用的方式重写这些组件。 将 Rust 与外部 C 代码集成：如果 C 项目与外部 C 库交互，可以使用 Rust 的外部函数接口 (FFI) 来弥合 Rust 和 C 之间的差距。Rust 通过使用 #[link] 属性提供与 C 的无缝互操作性和外部“C”函数。 测试和验证：在进行迁移时，定期测试和验证 Rust 代码。使用单元测试和集成测试来确保正确性并识别迁移过程中引入的任何问题。 优化和改进：初始转换完成后，您可以进一步优化和改进 Rust 代码库。利用 Rust 的性能特性，例如零成本抽象、并发模型和优化的运行时。 重构和清理：最后，重构代码库以确保它遵循 Rust 的最佳实践、习惯用法和风格约定。删除可能从 C 项目中遗留下来的任何冗余或不安全代码。 逐步集成：如果您的项目具有庞大的代码库或复杂的逻辑，那么将 Rust 代码逐步集成到现有的 C 项目中可能是有益的，仅首先替换关键组件。这种方法允许您逐步验证迁移并最大限度地降低与完全重写相关的风险。 通过以下步骤，您可以逐步有效地将C项目迁移到Rust项目，充分利用Rust的安全性、性能和并发特性。

Read more at: https://topminisite.com/blog/tutorial-migrating-from-c-to-rust
</code></pre>
<pre><code>与 C 相比，Rust 的异常处理方法是什么？ Rust 的异常处理方法与 C 不同，因为它没有像 C++ 那样传统的、基于运行时的异常。相反，Rust 使用一种更受控制的机制，称为“panics”来处理异常情况。 在 C 中，异常发生在运行时，可以使用 try-catch 块捕获和处理。然而，在 Rust 中，当程序遇到不可恢复的错误或违反假设（例如越界数组访问）时，就会触发恐慌。当发生恐慌时，Rust 会展开堆栈，运行每个函数的清理代码，直到到达捕获所有恐慌处理程序或程序终止。 Rust 的偏好是尽可能避免恐慌。相反，它鼓励使用 Result 类型来处理可恢复的错误。 Result 类型提供了一种显式传播和处理错误条件的方法，而不需要异常。通过要求开发人员明确地处理错误，Rust 强制执行更可预测的代码流和更好的错误处理实践。 如果开发人员想要捕获并处理 Rust 中的恐慌，他们可以使用 catch_unwind 函数来捕获展开恐慌。然而，在 Rust 中通常不鼓励这样做，因为恐慌是针对应该避免而不是处理的异常情况。

Read more at: https://topminisite.com/blog/tutorial-migrating-from-c-to-rust
</code></pre>
<pre><code> 与 C 相比，Rust 如何处理 I/O 操作？ 在 Rust 中，与 C 相比，处理 I/O 操作的方式更加安全和惯用。Rust 提供了许多抽象和模式来有效地处理 I/O 操作。以下是一些主要区别： 错误处理：Rust 广泛使用 Result 类型来处理 I/O 错误。 I/O 操作返回 Result 类型，指示成功或错误。另一方面，C 通常使用错误代码或异常来进行错误处理。由于缺乏标准化的错误处理模式，C 中的错误处理更容易出错。 安全和内存管理：Rust 通过其所有权和借用系统提供内存安全保证。 Rust 中的 I/O 操作在设计上是内存安全的，避免了许多常见的错误，如缓冲区溢出或释放后使用错误。在C中，需要手动内存管理，这使得在I/O操作期间更容易引入与内存相关的错误。 抽象和特征：Rust 为 I/O 操作提供更高级别的抽象，例如 std::io::Read、std::io::Write 和 std::io::Seek 特征。这些特征提供了处理不同类型 I/O 流的通用方法和模式。在 C 语言中，I/O 操作通常使用 fread() 和 fwrite() 等较低级函数执行。 C 为 I/O 操作提供的抽象接口较少，需要更多手动实现常见功能。 异步 I/O：Rust 通过 async 和 wait 关键字内置了对异步 I/O 的支持。异步 I/O 可以在处理 I/O 操作时实现更好的并发性和可扩展性。 C 本身不支持异步 I/O，实现类似的功能需要使用外部库或实现复杂的多线程。 总体而言，与 C 相比，Rust 的强类型系统、所有权模型和安全抽象使其更容易、更可靠、更高效地处理 I/O 操作。

Read more at: https://topminisite.com/blog/tutorial-migrating-from-c-to-rust
</code></pre>
<pre><code>Rust 迁移的推荐开发环境是什么？ Rust 迁移的推荐开发环境通常取决于个人喜好，但有一些许多开发人员认为富有成效的流行选项。这些包括： Visual Studio Code (VS Code)：一个轻量级、可定制的代码编辑器，具有广泛的 Rust 支持。它提供了各种扩展，例如 Rust Analyzer，提供 linting、自动完成、调试和其他有用的功能。 带有 Rust 插件的 IntelliJ IDEA：集成开发环境 (IDE)，具有代码分析、重构工具和对 Rust 的内置支持等强大功能。 JetBrains 提供了专门为 IDE 设计的 Rust 插件。 Sublime Text：一个跨平台文本编辑器，具有可用于 Rust 开发的充满活力的插件和包生态系统。 RustEnhanced 包在 Rust 开发人员中很受欢迎。 Emacs：一个高度可扩展的文本编辑器，通过 rust-mode、cargo 和 racer 等插件对 Rust 提供广泛支持。它提供了陡峭的学习曲线，但提供了显着的灵活性和定制性。 Atom：一个多功能且可定制的文本编辑器，能够使用 language-rust、racer 和 linter-rust 等包来增强 Rust 开发。

Read more at: https://topminisite.com/blog/tutorial-migrating-from-c-to-rust
</code></pre>
<h3 id="1-语法分析"><a href="#1-语法分析" class="headerlink" title="1. 语法分析"></a>1. <strong>语法分析</strong></h3><ul>
<li><strong>词法与语法分析器</strong>：开发或使用现有的词法分析器和语法分析器来解析 C 代码，生成抽象语法树（AST）。这是理解程序结构的基础。</li>
<li><strong>语言规范</strong>：深入理解 C 和 Rust 的语言规范，确保能够准确地解析和转换各种语法结构。</li>
</ul>
<h3 id="2-语义分析"><a href="#2-语义分析" class="headerlink" title="2. 语义分析"></a>2. <strong>语义分析</strong></h3><ul>
<li><strong>类型系统</strong>：处理 C 和 Rust 之间的类型系统差异，包括但不限于基本类型、结构体、联合体、枚举等的转换。</li>
<li><strong>内存模型</strong>：理解并转换不同的内存管理模型，包括指针操作、内存分配与释放等。</li>
</ul>
<h3 id="3-代码转换逻辑"><a href="#3-代码转换逻辑" class="headerlink" title="3. 代码转换逻辑"></a>3. <strong>代码转换逻辑</strong></h3><ul>
<li><strong>转换规则</strong>：开发一套详细的代码转换规则，这些规则需要涵盖从基本语法结构到复杂的控制流和数据结构的转换。</li>
<li><strong>自动化重构</strong>：实现代码的自动化重构，使转换后的 Rust 代码不仅语法正确，还要符合 Rust 的惯用法（idiomatic Rust）。</li>
</ul>
<h3 id="4-外部依赖和库函数"><a href="#4-外部依赖和库函数" class="headerlink" title="4. 外部依赖和库函数"></a>4. <strong>外部依赖和库函数</strong></h3><ul>
<li><strong>库函数映射</strong>：建立 C 标准库函数与 Rust 标准库或第三方 crates 的映射关系。</li>
<li><strong>系统调用和平台依赖</strong>：处理系统调用和特定平台依赖的代码，可能需要使用 Rust 的 <code>unsafe</code> 代码块。</li>
</ul>
<h3 id="5-错误处理和异常"><a href="#5-错误处理和异常" class="headerlink" title="5. 错误处理和异常"></a>5. <strong>错误处理和异常</strong></h3><ul>
<li><strong>错误转换</strong>：将 C 语言中的错误处理模式转换为 Rust 的 <code>Result</code> 和 <code>Option</code> 类型，以利用 Rust 的错误处理机制。</li>
<li><strong>异常安全</strong>：确保转换后的代码在面对异常时能够安全地释放资源，避免内存泄露。</li>
</ul>
<h3 id="6-测试和验证"><a href="#6-测试和验证" class="headerlink" title="6. 测试和验证"></a>6. <strong>测试和验证</strong></h3><ul>
<li><strong>自动化测试</strong>：为转换的代码自动生成测试用例，确保转换后的 Rust 代码的行为与原始 C 代码一致。</li>
<li><strong>回归测试</strong>：建立回归测试套件，用于验证代码转换工具的更新不会引入新的错误。</li>
</ul>
<h3 id="7-工具和库的选择"><a href="#7-工具和库的选择" class="headerlink" title="7. 工具和库的选择"></a>7. <strong>工具和库的选择</strong></h3><ul>
<li><strong>现有工具利用</strong>：调研并利用现有的工具和库，如使用 LLVM 的 Clang 前端进行 C 代码的解析，或寻找现有的 C 到 Rust 的转换工具作为参考。</li>
</ul>
<h3 id="8-用户界面和交互"><a href="#8-用户界面和交互" class="headerlink" title="8. 用户界面和交互"></a>8. <strong>用户界面和交互</strong></h3><ul>
<li><strong>易用性设计</strong>：如果工具面向非专业用户，考虑提供图形界面或命令行界面的友好交互设计，使用户能够轻松地配置转换选项和查看转换结果。</li>
</ul>
<h3 id="9-性能优化"><a href="#9-性能优化" class="headerlink" title="9. 性能优化"></a>9. <strong>性能优化</strong></h3><ul>
<li><strong>转换效率</strong>：优化代码转换过程的性能，确保工具可以高效处理大型代码库。</li>
</ul>
<h3 id="10-文档和社区支持"><a href="#10-文档和社区支持" class="headerlink" title="10. 文档和社区支持"></a>10. <strong>文档和社区支持</strong></h3><ul>
<li><strong>使用文档</strong>：提供详细的使用说明和最佳实践指南。</li>
<li><strong>社区交流</strong>：建立社区支持机制，收集用户反馈，持续改进工具。</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/c/" style="color: #00a596">c</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/rust/" style="color: #03a9f4">rust</a>
        </span>
        
    </div>
    <a href="/2024/02/28/mdstorage/project/cToRust/cust%E6%80%9D%E8%B7%AF/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/02/28/mdstorage/project/cToRust/rust%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">
        <h2 class="post-title">rust基本语法.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/project/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                project
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/2/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="Rust-语言概述"><a href="#Rust-语言概述" class="headerlink" title="Rust 语言概述"></a>Rust 语言概述</h2><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><pre><code class="rust"># integer
# i8 i16 i32 i64 i128 
# u8 u16 u32 u64 u128
let x : i8 = 2;

# f32 f64
let y : f64 = 2.0;

# true false
let z : bool = true;

# tup
let tup = (1, 2, 3);
let tup_a : (i32, f64, u8) = (500, 1.0, 2);

# 
</code></pre>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><pre><code class="rust"># print!
println!(&quot;&#123;&#125;&quot;, output);

# format!
let command = format!(&quot;clang -Xclang -ast-dump -fsyntax-only &#123;&#125;&quot;, f_path.to_string());
</code></pre>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><pre><code class="rust">fn func() &#123;
    // logic
&#125;

fn func(a: i8, b: i8) &#123;
    // param need type statement
&#125;

fn func(a: int) 
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Rust/" style="color: #00a596">Rust</a>
        </span>
        
    </div>
    <a href="/2024/02/28/mdstorage/project/cToRust/rust%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/02/27/mdstorage/domain/golang/golang%E7%BC%93%E5%AD%98%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/">
        <h2 class="post-title">golang缓存区溢出攻击.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/domain/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                domain
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/2/27
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ol>
<li><strong>缓冲区和内存管理</strong>：在计算机程序中，缓冲区是用来存储数据的临时内存区域。为了高效地管理内存，操作系统和程序会预先分配特定大小的内存给缓冲区。当程序运行时，它们会向这些缓冲区内写入数据。</li>
<li><strong>溢出原因</strong>：如果程序没有正确地检查写入缓冲区的数据量，就可能发生溢出。这意味着写入的数据超出了缓冲区的边界，覆盖了相邻的内存区域。这个问题尤其在使用如C和C++这类不自动管理内存的编程语言时频繁出现。</li>
<li><strong>攻击者的利用</strong>：攻击者可以利用缓冲区溢出漏洞来改变程序的执行流程。通过精心构造溢出数据，攻击者可以覆盖内存中的特定位置，比如返回地址，以此来执行恶意代码。这种技术可以用来绕过安全措施，获取系统访问权限。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><code>http://0xdabbad00.com/2015/04/12/looking_for_security_trouble_spots_in_go_code/</code></p>
<p><code>https://stackoverflow.com/questions/40262971/is-go-vulnerable-for-buffer-overflow</code></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>golang 如果不使用 unsafe 包，或使用 C 的库，否则不会受到缓存区溢出攻击的影响。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/security/" style="color: #00a596">security</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/golang/" style="color: #ffa2c4">golang</a>
        </span>
        
    </div>
    <a href="/2024/02/27/mdstorage/domain/golang/golang%E7%BC%93%E5%AD%98%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/02/27/mdstorage/domain/linux/Linux%E5%BA%94%E7%94%A8rootless%E5%8C%96%E6%95%B4%E7%90%86/">
        <h2 class="post-title">Linux应用rootless化整理.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/domain/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                domain
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/2/27
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>以一个应用为例，描述为一个应用不使用 root 用户在 <code>运行</code> 的生命周期需要进行的操作。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><code>Unix and Linux System Administration Handbook (Evi Nemeth, Garth Snyder, Trent R. Hein etc.) (Z-Library)</code></p>
<h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><h3 id="当软件系统允许使用sudo组用户运行时"><a href="#当软件系统允许使用sudo组用户运行时" class="headerlink" title="当软件系统允许使用sudo组用户运行时"></a>当软件系统允许使用<code>sudo</code>组用户运行时</h3><ul>
<li><strong>提权能力</strong>：确实，如果软件系统允许使用属于<code>sudo</code>组的用户运行，那么这些用户可以通过<code>sudo</code>命令暂时获得<code>root</code>用户的权限。这意味着他们可以执行通常需要<code>root</code>权限的操作，例如访问受保护的文件、修改系统设置、安装或卸载软件包等。</li>
<li><strong>安全和控制</strong>：虽然这种方法提供了很大的灵活性和方便性，但也带来了潜在的安全风险。因为<code>sudo</code>允许用户执行任何命令，所以必须谨慎配置<code>/etc/sudoers</code>文件，以限制用户可以执行的命令范围，遵循最小权限原则。</li>
</ul>
<h3 id="当软件系统不允许使用sudo组用户运行时"><a href="#当软件系统不允许使用sudo组用户运行时" class="headerlink" title="当软件系统不允许使用sudo组用户运行时"></a>当软件系统不允许使用<code>sudo</code>组用户运行时</h3><ul>
<li><strong>权限规划</strong>：在这种情况下，确实需要事先规划和整理软件系统运行所需的所有权限。这包括文件访问权限、网络端口使用权限、特定系统资源的访问等。</li>
<li><strong>安装时授权</strong>：在软件安装过程中，必须确保所有必要的资源和组件都被正确地授予给将要运行软件的用户账户。这可能包括设置文件和目录的所有权和权限、调整系统配置以允许非<code>root</code>用户访问特定的端口或服务等。</li>
<li><strong>无提权手段</strong>：使用非<code>sudo</code>组用户运行的应用确实没有再次提权的手段。这就要求软件的安装、配置和运行必须在不需要进一步提权的情况下进行。这种方法有助于提高系统的安全性，因为它限制了软件在系统上可能造成的影响范围。</li>
</ul>
<p><strong>创建系统用户需用更高权限</strong></p>
<pre><code class="bash"># 以创建用户 sysuser 为例，创建 sudo 组用户
sudo useradd -m sysuser 
sudo passwd sysuser  # 这里要输入密码
sudo usermod -aG sudo sysuser
</code></pre>
<pre><code class="bash"># 以创建用户 sysuser 为例，创建非 sudo 组用户
sudo useradd -m sysuser 
sudo passwd sysuser  # 这里要输入密码
</code></pre>
<h2 id="应用的文件访问"><a href="#应用的文件访问" class="headerlink" title="应用的文件访问"></a>应用的文件访问</h2><p>从文件归属和访问需求角度进行分类</p>
<h3 id="1-应用程序文件"><a href="#1-应用程序文件" class="headerlink" title="1. 应用程序文件"></a>1. 应用程序文件</h3><ul>
<li><strong>定义</strong>：这些是应用程序的核心文件，包括可执行文件、库文件等。</li>
<li><strong>归属</strong>：通常归属于 root 或特定的应用用户。</li>
<li><strong>访问需求</strong>：这些文件需要执行权限，但通常不需要写权限，以确保应用的完整性和安全性。</li>
</ul>
<h3 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2. 配置文件"></a>2. 配置文件</h3><ul>
<li><strong>定义</strong>：包含应用程序运行所需的配置信息的文件。</li>
<li><strong>归属</strong>：可能归属于 root、特定的应用用户或配置管理组。</li>
<li><strong>访问需求</strong>：在应用启动或配置更改时需要读取权限，少数情况下（如通过应用内部功能更新配置）可能需要写权限。</li>
</ul>
<h3 id="3-日志文件"><a href="#3-日志文件" class="headerlink" title="3. 日志文件"></a>3. 日志文件</h3><ul>
<li><strong>定义</strong>：应用程序运行时产生的日志信息存储文件。</li>
<li><strong>归属</strong>：通常归属于运行应用程序的用户或特定日志用户组。</li>
<li><strong>访问需求</strong>：需要写权限以记录运行时信息；对于日志审计和故障排查，需要读权限。</li>
</ul>
<h3 id="4-数据文件"><a href="#4-数据文件" class="headerlink" title="4. 数据文件"></a>4. 数据文件</h3><ul>
<li><strong>定义</strong>：应用程序用于存储数据的文件，如数据库文件、用户上传的文件等。</li>
<li><strong>归属</strong>：归属于特定的数据管理用户或组或应用程序用户。</li>
<li><strong>访问需求</strong>：根据应用功能，可能需要读、写、创建和删除权限。</li>
</ul>
<h3 id="5-临时文件"><a href="#5-临时文件" class="headerlink" title="5. 临时文件"></a>5. 临时文件</h3><ul>
<li><strong>定义</strong>：应用程序运行时临时创建的文件，用于处理数据、缓存等。</li>
<li><strong>归属</strong>：归属于运行应用程序的用户。</li>
<li><strong>访问需求</strong>：通常需要读写权限，运行完毕后可能需要删除权限。</li>
</ul>
<h3 id="6-外部设备和资源文件"><a href="#6-外部设备和资源文件" class="headerlink" title="6. 外部设备和资源文件"></a><del>6. 外部设备和资源文件</del></h3><ul>
<li><del><strong>定义</strong>：应用程序可能需要访问的外部设备（如USB设备）或网络资源（如通过网络共享访问的文件）。</del></li>
<li><del><strong>归属</strong>：这些文件的归属和权限由外部系统或网络协议定义。</del></li>
<li><del><strong>访问需求</strong>：根据外部资源的性质，可能需要特定的读写权限。</del></li>
</ul>
<h2 id="应用的网络管理"><a href="#应用的网络管理" class="headerlink" title="应用的网络管理"></a>应用的网络管理</h2><h2 id="应用的虚拟化权限管理"><a href="#应用的虚拟化权限管理" class="headerlink" title="应用的虚拟化权限管理"></a>应用的虚拟化权限管理</h2><h3 id="docker-相关"><a href="#docker-相关" class="headerlink" title="docker 相关"></a>docker 相关</h3><p><code>Unix and Linux System Administration Handbook</code> <code>Chapter 25 Containers</code>  Container in practice  中有一个例子讲述关于 docker 权限过高导致的风险以及如何管理有 docker 的 Linux 系统的权限分配方案</p>
<h2 id="未整理的提权操作"><a href="#未整理的提权操作" class="headerlink" title="未整理的提权操作"></a>未整理的提权操作</h2><ol>
<li><strong>安装或卸载软件包</strong>：在系统级别安装或卸载软件，特别是使用包管理器（如APT、YUM或Pacman）时。</li>
<li><strong>修改系统文件</strong>：编辑位于<code>/etc</code>、<code>/var</code>等目录下的配置文件。这些文件通常控制系统的启动、网络配置、安全策略等。</li>
<li><strong>管理用户和用户组</strong>：创建、修改或删除用户账户和用户组，以及修改用户权限。</li>
<li><strong>更改文件所有权</strong>：使用<code>chown</code>命令更改文件或目录的所有者，特别是当这些文件属于其他用户或系统用户时。</li>
<li><strong>配置网络设置</strong>：更改IP地址、路由表、防火墙规则等网络配置。</li>
<li><strong>管理系统服务</strong>：启动、停止、重启系统服务或守护进程，如Web服务器、数据库服务等。</li>
<li><strong>监听低编号端口</strong>：通常，只有<code>root</code>用户才能监听1024以下的端口，这些端口被认为是“特权”端口。</li>
<li><strong>分配受保护的硬件资源</strong>：例如，配置新的硬盘、分区和文件系统，或者直接访问某些硬件设备。</li>
<li><strong>设置系统时间和日期</strong>：更改系统的当前时间和日期，包括与网络时间协议（NTP）服务器的同步。</li>
<li><strong>访问日志文件</strong>：查看位于<code>/var/log</code>目录下的系统日志文件，这些文件通常包含重要的系统运行和安全信息。</li>
<li><strong>修改内核参数</strong>：使用<code>sysctl</code>或直接编辑<code>/proc/sys/</code>目录下的文件来调整内核运行时参数。</li>
<li><strong>配置定时任务</strong>：为系统级别的定时任务配置<code>cron</code>作业，需要编辑<code>/etc/crontab</code>文件或在<code>/etc/cron.*</code>目录下添加脚本。</li>
<li><strong>管理持久性存储设备</strong>：格式化和分区硬盘，管理逻辑卷（使用LVM），或者修改文件系统（如使用<code>fsck</code>命令检查和修复文件系统）。</li>
<li><strong>控制防火墙和安全设置</strong>：配置<code>iptables</code>或<code>firewalld</code>规则，管理SELinux或AppArmor安全策略。</li>
<li><strong>访问受限日志和数据文件</strong>：某些日志文件和数据文件因包含敏感信息而受到保护，只有<code>root</code>用户才能访问。</li>
<li><strong>管理虚拟化资源</strong>：创建和管理虚拟机或容器（如使用KVM、Docker等），通常需要更高权限来访问和分配硬件资源。</li>
<li><strong>备份和恢复操作</strong>：对系统文件进行备份和恢复时，尤其是使用工具直接访问原始设备或进行大范围文件系统操作。</li>
<li><strong>修改引导加载器配置</strong>：配置GRUB或其他引导加载器的设置，如更改启动参数或管理多重启动设置。</li>
<li><strong>加载或卸载内核模块</strong>：使用<code>modprobe</code>、<code>insmod</code>或<code>rmmod</code>命令加载或卸载内核模块。</li>
<li><strong>直接访问设备文件</strong>：通过<code>/dev</code>目录下的设备文件直接与硬件通信，比如进行磁盘I&#x2F;O操作或配置特定的硬件设备。</li>
</ol>
<p>网络相关</p>
<ol>
<li><strong>修改网络接口配置</strong>：配置或更改网络接口的IP地址、子网掩码、网关等参数，通常通过<code>ifconfig</code>（已经较少使用）或<code>ip</code>命令进行。</li>
<li><strong>配置路由表</strong>：添加或删除路由规则，管理系统的路由表，这对于定制网络流量的路径非常重要，可以使用<code>route</code>或<code>ip route</code>命令。</li>
<li><strong>配置和管理防火墙</strong>：设置或更改<code>iptables</code>、<code>nftables</code>或<code>firewalld</code>等防火墙工具的规则，以控制进出网络流量的允许或禁止。</li>
<li><strong>启动网络服务</strong>：在低于1024的端口启动网络服务，这些端口被认为是特权端口，很多基础网络服务（如HTTP、HTTPS、SSH）默认运行在这些端口上。</li>
<li><strong>配置端口转发和NAT（网络地址转换）</strong>：通过<code>iptables</code>或其他网络工具配置端口转发和NAT规则，这对于网络地址和端口的映射非常重要，特别是在多个网络之间进行通信时。</li>
<li><strong>监控和捕获网络流量</strong>：使用<code>tcpdump</code>、<code>wireshark</code>（在非图形界面环境中使用<code>tshark</code>）等工具监控和捕获网络接口上的流量，通常需要更高权限来访问网络接口。</li>
<li><strong>修改系统的网络设置</strong>：比如通过<code>sysctl</code>命令调整TCP&#x2F;IP栈的行为，例如改变IP转发、TCP窗口缩放等参数。</li>
<li><strong>管理VPN和其他隧道接口</strong>：设置和配置VPN连接或其他类型的网络隧道，如IPsec、OpenVPN或WireGuard等，这些操作需要访问网络配置和安全密钥。</li>
<li><strong>绑定到特权端口</strong>：除了启动网络服务外，直接绑定到1024以下的特权端口进行监听也需要更高的权限。</li>
<li><strong>配置动态主机配置协议（DHCP）</strong>：设置和管理DHCP服务器或客户端，为网络设备动态分配IP地址。</li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在如今虚拟化如此普及的今天，要么，应用都在容器中被隔离，要么，大厂商的软件都是独占机器的，机器和软件都是一家的，是否真的有收紧权限的必要性，是不是从找到漏洞的角度去做到安全更 “合理”。</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h3 id="最小权限原则"><a href="#最小权限原则" class="headerlink" title="最小权限原则"></a>最小权限原则</h3><ul>
<li><strong>安全最佳实践</strong>：即使在高度隔离的环境中，应用最小权限原则（Least Privilege Principle）仍然是安全最佳实践的核心。这个原则要求只授予完成特定任务所必需的最少权限，从而限制安全漏洞被利用的潜在影响。</li>
</ul>
<h3 id="容器与虚拟化环境的漏洞"><a href="#容器与虚拟化环境的漏洞" class="headerlink" title="容器与虚拟化环境的漏洞"></a>容器与虚拟化环境的漏洞</h3><ul>
<li><strong>隔离并非万无一失</strong>：虽然容器和虚拟机提供了隔离环境，但它们自身也可能包含漏洞，这些漏洞可能被利用来逃逸隔离或提升权限。例如，历史上曾经发现过多个容器逃逸漏洞。</li>
</ul>
<h3 id="内部威胁与配置错误"><a href="#内部威胁与配置错误" class="headerlink" title="内部威胁与配置错误"></a>内部威胁与配置错误</h3><ul>
<li><strong>内部威胁</strong>：过宽的权限设置不仅增加了外部攻击者的攻击面，也增加了内部威胁的风险。一个内部人员或恶意软件可能利用不必要的高权限来进行数据泄露、破坏或其他恶意行为。</li>
<li><strong>配置错误</strong>：权限设置过宽还可能导致配置错误，从而无意中暴露敏感数据或系统功能。随着环境变得更加复杂，这种风险也相应增加。</li>
</ul>
<h3 id="法规和合规性要求"><a href="#法规和合规性要求" class="headerlink" title="法规和合规性要求"></a>法规和合规性要求</h3><ul>
<li><strong>合规性要求</strong>：许多行业和国际标准（如GDPR、HIPAA、PCI DSS）对数据保护和访问控制有严格要求。实施严格的权限控制是满足这些要求的关键组成部分。</li>
</ul>
<h3 id="安全与漏洞发现的平衡"><a href="#安全与漏洞发现的平衡" class="headerlink" title="安全与漏洞发现的平衡"></a>安全与漏洞发现的平衡</h3><ul>
<li><strong>漏洞发现重要，但不是唯一解决方案</strong>：虽然发现并修补安全漏洞是提高软件安全性的重要手段，但仅依赖于漏洞发现并不足以全面保障安全。权限管理是构建深度防御策略（Defense in Depth）的一个重要方面，能够在漏洞被发现并利用之前提供额外的保护层。</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/linux/" style="color: #ff7d73">linux</a>
        </span>
        
    </div>
    <a href="/2024/02/27/mdstorage/domain/linux/Linux%E5%BA%94%E7%94%A8rootless%E5%8C%96%E6%95%B4%E7%90%86/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/02/27/mdstorage/resource/%E7%BF%BB%E8%AF%91%E5%B7%A5%E5%85%B7/%E8%8B%B1%E6%96%87%E4%B9%A6%E7%B1%8D%E7%BF%BB%E8%AF%91%E6%96%B9%E6%A1%88/">
        <h2 class="post-title">英文书籍翻译方案.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/resource/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                resource
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/2/27
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="沉浸式翻译"><a href="#沉浸式翻译" class="headerlink" title="沉浸式翻译"></a>沉浸式翻译</h3><p><code>https://immersivetranslate.com/docs/installation/</code></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/tool/" style="color: #03a9f4">tool</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/book/" style="color: #00bcd4">book</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/%E7%BF%BB%E8%AF%91/" style="color: #ffa2c4">翻译</a>
        </span>
        
    </div>
    <a href="/2024/02/27/mdstorage/resource/%E7%BF%BB%E8%AF%91%E5%B7%A5%E5%85%B7/%E8%8B%B1%E6%96%87%E4%B9%A6%E7%B1%8D%E7%BF%BB%E8%AF%91%E6%96%B9%E6%A1%88/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/02/21/mdstorage/resource/vpn/easyconnect/">
        <h2 class="post-title">easyconnect.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/resource/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                resource
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/2/21
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><code>https://github.com/docker-easyconnect/docker-easyconnect</code></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/vpn/" style="color: #00a596">vpn</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/easyconnect/" style="color: #ffa2c4">easyconnect</a>
        </span>
        
    </div>
    <a href="/2024/02/21/mdstorage/resource/vpn/easyconnect/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/02/18/mdstorage/domain/dart/flutter%E6%8A%80%E5%B7%A7/">
        <h2 class="post-title">flutter技巧.md</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/domain/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                domain
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/2/18
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="组件封装"><a href="#组件封装" class="headerlink" title="组件封装"></a>组件封装</h2><h3 id="封装-flutter-组件"><a href="#封装-flutter-组件" class="headerlink" title="封装 flutter 组件"></a>封装 flutter 组件</h3><h2 id="当出现两个-变量-同时决定页面展示时，使用同一个函数封装"><a href="#当出现两个-变量-同时决定页面展示时，使用同一个函数封装" class="headerlink" title="当出现两个 变量 同时决定页面展示时，使用同一个函数封装"></a>当出现两个 变量 同时决定页面展示时，使用同一个函数封装</h2><pre><code class="dart">var taskLs = [fakeTask, fakeSonTask, fakeSonSonTask, fakeSonTask2, fakeTask2];
TaskManifest? selectedManifest;

class TaskManager with ChangeNotifier &#123;
  List&lt;Task&gt; getTaskLs() &#123;
    return taskLs;
  &#125;

  bool createTaskOrUpdateManifest(&#123;Task? task, TaskManifest? manifest&#125;) &#123;
    if (manifest != null) &#123;
      selectedManifest = manifest;
      notifyListeners();
    &#125; else if (task != null) &#123;
      taskLs.add(task);
      notifyListeners();
    &#125; else &#123;
      print(&quot;unknown&quot;);
      return false;
    &#125;
    return true;
  &#125;

  List&lt;Task&gt; getRootTaskLs() &#123;
    print(&quot;---: $selectedManifest $&#123;selectedManifest?.name&#125;&quot;);
    var ls = &lt;Task&gt;[];

    for (final task in getTaskLs()) &#123;
      if (task.manifestId == selectedManifest?.id) &#123;
        if (task.isRoot == true) &#123;
          ls.add(task);
        &#125;
      &#125;
    &#125;
    getTaskLs().forEach((element) &#123;
      print(&quot;el: $element&quot;);&#125;
    );
    return ls;
  &#125;
&#125;
</code></pre>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="cast"><a href="#cast" class="headerlink" title="cast"></a>cast</h3><p>在Dart中，<code>cast</code>函数是一个非常有用的工具，它允许你将一个集合的元素类型转换为另一个类型。这在处理<code>dynamic</code>类型或不同类型之间的转换时尤其有用，但需要谨慎使用以避免运行时错误。下面是使用<code>cast</code>函数的一些最佳实践：</p>
<h4 id="1-明确知道元素类型时使用"><a href="#1-明确知道元素类型时使用" class="headerlink" title="1. 明确知道元素类型时使用"></a>1. 明确知道元素类型时使用</h4><p>只有当你确定集合中的所有元素都可以安全地被转换为目标类型时，才使用<code>cast</code>。这通常适用于你从动态类型（如从数据库、外部数据源或第三方库中获取的数据）转换到具体类型时。</p>
<h4 id="2-避免不必要的类型转换"><a href="#2-避免不必要的类型转换" class="headerlink" title="2. 避免不必要的类型转换"></a>2. 避免不必要的类型转换</h4><p>如果你能通过设计来确保数据的类型安全，那么尽量避免使用<code>cast</code>。比如，使用泛型集合来存储和传递具体类型的数据，这样可以让Dart的静态类型检查帮助你捕获类型错误。</p>
<h4 id="3-处理cast可能失败的情况"><a href="#3-处理cast可能失败的情况" class="headerlink" title="3. 处理cast可能失败的情况"></a>3. 处理<code>cast</code>可能失败的情况</h4><p>使用<code>cast</code>时，如果集合中有任何元素不能被转换为目标类型，都会抛出运行时异常。因此，使用<code>cast</code>时应该尽量确保转换的安全性，或者使用try-catch结构来处理可能的异常。</p>
<h4 id="4-优先使用类型安全的替代方案"><a href="#4-优先使用类型安全的替代方案" class="headerlink" title="4. 优先使用类型安全的替代方案"></a>4. 优先使用类型安全的替代方案</h4><p>在某些情况下，你可以通过映射（<code>.map()</code>）集合并手动转换每个元素来避免使用<code>cast</code>。这样做的好处是可以在转换每个元素时提供一个回退方案，比如：</p>
<pre><code class="dart">var list = &lt;dynamic&gt;[1, 2, 3];
var intList = list.map((e) =&gt; e as int).toList();
</code></pre>
<p>这种方法比<code>cast</code>更加类型安全，因为你可以控制转换的过程，并且在转换失败时捕获异常。</p>
<h4 id="5-谨慎使用cast改变集合的可变性"><a href="#5-谨慎使用cast改变集合的可变性" class="headerlink" title="5. 谨慎使用cast改变集合的可变性"></a>5. 谨慎使用<code>cast</code>改变集合的可变性</h4><p>当你对集合使用<code>cast</code>时，返回的是原始集合的一个视图，这意味着原始集合和转换后的集合在底层是相同的数据。对任一集合的修改都会影响另一个，但如果集合的类型不兼容，这种修改可能会引起问题。</p>
<h4 id="6-在混合类型数据流中使用"><a href="#6-在混合类型数据流中使用" class="headerlink" title="6. 在混合类型数据流中使用"></a>6. 在混合类型数据流中使用</h4><p>在处理混合类型的数据流时（比如一个列表包含了不同类型的对象），<code>cast</code>可以用来过滤出特定类型的对象集合，以便进行进一步处理。</p>
<pre><code>  List&lt;Task&gt; getTaskLs() &#123;
    // 直接返回Hive box中所有的Task对象
    if (taskBox != null) &#123;
      return taskBox!.values.cast&lt;Task&gt;().toList();
    &#125; else &#123;
      return [];
    &#125;
  &#125;
</code></pre>
<h2 id="as-类型转换"><a href="#as-类型转换" class="headerlink" title="as 类型转换"></a>as 类型转换</h2><p>在Dart语言中，<code>as</code>关键字用于类型转换，将一个对象显式地转换为另一个类型。尽管这是一个强大的功能，但如果不当使用，可能会导致运行时错误。以下是使用<code>as</code>进行类型转换的一些最佳实践：</p>
<h3 id="1-当你确定转换是安全的时使用"><a href="#1-当你确定转换是安全的时使用" class="headerlink" title="1. 当你确定转换是安全的时使用"></a>1. 当你确定转换是安全的时使用</h3><p>只在你确信对象可以被安全地转换为目标类型时使用<code>as</code>。这通常是在你通过某些方式（例如通过类型检查）已经验证了对象的类型后。</p>
<pre><code class="dart">if (object is TargetType) &#123;
  final targetTypeObject = object as TargetType;
&#125;
</code></pre>
<h3 id="2-优先使用类型测试运算符is"><a href="#2-优先使用类型测试运算符is" class="headerlink" title="2. 优先使用类型测试运算符is"></a>2. 优先使用类型测试运算符<code>is</code></h3><p>在尝试将一个对象转换为特定类型之前，先使用<code>is</code>运算符检查对象是否为目标类型。这可以避免在转换失败时抛出异常。</p>
<pre><code class="dart">if (object is TargetType) &#123;
  // 安全地使用object作为TargetType
&#125;
</code></pre>
<h3 id="3-避免不必要的as使用"><a href="#3-避免不必要的as使用" class="headerlink" title="3. 避免不必要的as使用"></a>3. 避免不必要的<code>as</code>使用</h3><p>如果Dart的类型推断能够正确识别对象的类型，就没有必要使用<code>as</code>进行显式转换。过度使用<code>as</code>可能会降低代码的可读性和维护性。</p>
<h3 id="4-在处理泛型时谨慎使用"><a href="#4-在处理泛型时谨慎使用" class="headerlink" title="4. 在处理泛型时谨慎使用"></a>4. 在处理泛型时谨慎使用</h3><p>当你与泛型类型打交道时，特别是当类型参数在运行时可能变化时，使用<code>as</code>进行类型转换需要格外小心。在这种情况下，确保转换是安全的，或者考虑使用更安全的替代方案。</p>
<h3 id="5-处理as转换可能失败的情况"><a href="#5-处理as转换可能失败的情况" class="headerlink" title="5. 处理as转换可能失败的情况"></a>5. 处理<code>as</code>转换可能失败的情况</h3><p>尽管通过<code>is</code>检查类型可以避免大多数问题，但在某些情况下，转换可能仍然失败。使用<code>as</code>时，考虑包含异常处理逻辑，特别是当处理外部数据或在你对数据源不完全确定时。</p>
<pre><code class="dart">try &#123;
  final targetTypeObject = object as TargetType;
&#125; catch (e) &#123;
  // 处理转换失败的情况
&#125;
</code></pre>
<h3 id="6-使用类型安全的集合操作"><a href="#6-使用类型安全的集合操作" class="headerlink" title="6. 使用类型安全的集合操作"></a>6. 使用类型安全的集合操作</h3><p>当从集合中获取元素时，如果你确信集合中的所有元素都属于一个特定类型，使用<code>as</code>进行转换可以使代码更简洁。但是，仍然推荐使用<code>is</code>进行检查，或者使用泛型来保证类型安全。</p>
<h3 id="7-避免将as用作隐藏逻辑错误的手段"><a href="#7-避免将as用作隐藏逻辑错误的手段" class="headerlink" title="7. 避免将as用作隐藏逻辑错误的手段"></a>7. 避免将<code>as</code>用作隐藏逻辑错误的手段</h3><p>错误地使用<code>as</code>可能会隐藏潜在的逻辑错误，导致难以调试的运行时异常。在使用<code>as</code>之前，仔细考虑是否有其他方式（如改进程序逻辑或使用更合适的类型）来解决问题。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><code>as</code>关键字是Dart中强大的类型转换工具，但应谨慎使用。始终确保转换的安全性，优先使用类型检查运算符<code>is</code>，并在适当的地方处理可能的异常，以编写更安全、更健壯的Dart代码。</p>
<h2 id="TaskContainerState-状态延迟刷新问题"><a href="#TaskContainerState-状态延迟刷新问题" class="headerlink" title="_TaskContainerState 状态延迟刷新问题"></a>_TaskContainerState 状态延迟刷新问题</h2><h3 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h3><p><code>TaskContainer</code> 组件下的  <code>_TaskContainerState build</code> 定义为</p>
<pre><code class="dart">Widget build(BuildContext context) &#123;
    // 初始状态 只有一个 SingleTaskP
    // 展开状态 有多个 SingleTaskP
    List&lt;Widget&gt; loadSonTaskContainerLs(Set set) &#123;
        if (_isFolded || !_haveSon) &#123;
            return [const SizedBox()];
        &#125; else &#123;
            // 获取所有下一层级的 task
            List&lt;TaskContainer&gt; ls = &lt;TaskContainer&gt;[];
            for (final id in set) &#123;
                ls.add(TaskContainer(indentTime: increaseIndentTime(widget.indentTime), task: taskDBRead.getTaskById(id)));
            &#125;
            return ls;
        &#125;
    &#125;

    return Consumer&lt;TaskUpdateModel&gt;(
        builder: (context, taskUpdateModel, child) &#123;
            final set = taskUpdateModel.getSonTaskIdLsFromParentId(widget.task!.id);

            _haveSon = set.isEmpty ? false : true;
            print(&quot;set: $&#123;set.length&#125; , haveson: $_haveSon, isFold: $_isFolded&quot;);
            //print(&quot;foldIconButton : $foldIconButton&quot;);
            return Row(
                crossAxisAlignment: CrossAxisAlignment.start, // 确保Row的子项从顶部开始对齐
                children: [
                    Container(
                        width: 48, // 或其他适当的值，确保足够容纳IconButton
                        child: _haveSon ? Container(
                            margin: const EdgeInsets.all(12),
                            child: IconButton(   // 这里之前写在 return 之前
                                onPressed: () &#123;
                                    setState(() &#123;
                                        _isFolded = !_isFolded;
                                    &#125;);
                                &#125;,
                                icon: Icon(
                                    _isFolded
                                    ? Icons.arrow_drop_down_rounded
                                    : Icons.arrow_right_rounded,
                                    size: 24,
                                ),
                            ))
                        : Container(),
                    ),
                    Expanded( // 使用Expanded来填充剩余空间
                        child: Column(
                            children: [
                                SingleTaskP(widget.indentTime, widget.task),
                                if (!_isFolded &amp;&amp; _haveSon) ...loadSonTaskContainerLs(set),
                            ],
                        ),
                    ),
                ],
            );
        &#125;
    );
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/dart/" style="color: #00bcd4">dart</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/flutter/" style="color: #03a9f4">flutter</a>
        </span>
        
    </div>
    <a href="/2024/02/18/mdstorage/domain/dart/flutter%E6%8A%80%E5%B7%A7/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    
    <a class="page-num" href="/page/15/">
        <i class="fa-solid fa-caret-left fa-fw"></i>
    </a>
    <a class="page-num" href="/">1</a>
    <span class="page-omit">...</span>
    
    <span class="current">16</span>
    
    <a class="page-num" href="/page/17">
        17
    </a>
    
    
    <a class="page-num" href="/page/18">
        18
    </a>
    
    
    <span class="page-omit">...</span>
    <a class="page-num" href="/page/28">28</a>
    
    
    <a class="page-num" href="/page/17/">
        <i class="fa-solid fa-caret-right fa-fw"></i>
    </a>
    
</div>

    </div>
    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name">xiaoy</div>
        <div class="description">
            <p>xiaoy<br>…</p>

        </div>
        
        
        <div class="friend-links">
            
            <div class="friend-link">
                <a href="https://abrance.github.io">Argvchs</a>
            </div>
            
        </div>
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2024 - 2024 Xiaoy
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;xiaoy
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
</body>
</html>
